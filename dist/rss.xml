<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Thrinisty&apos;s Blog</title><description>New One</description><link>https://thrinisty.github.io/</link><language>en</language><item><title>自学第二月份总结</title><link>https://thrinisty.github.io/posts/%E8%87%AA%E5%AD%A6%E7%AC%AC%E4%BA%8C%E6%9C%88%E4%BB%BD%E6%80%BB%E7%BB%93/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/%E8%87%AA%E5%AD%A6%E7%AC%AC%E4%BA%8C%E6%9C%88%E4%BB%BD%E6%80%BB%E7%BB%93/</guid><description>结束Java</description><pubDate>Thu, 01 May 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;自学第二月份总结&lt;/h1&gt;
&lt;p&gt;​	在学习Java后端开发的第二个月中，用10天的时间为Java语言基础收了个尾，结束了反射，多线程基础，IO流的学习&lt;/p&gt;
&lt;p&gt;​	学习完成Java部分的内容后又花了5天的时间回顾了MySQL数据库基础，巩固了一些数据库使用上的细节（存储引擎，事务，隔离级别等）。2天的时间完成了Java8一些新特性的学习，理解了Lambda表达式的使用，Stream API的概念以及使用方式，Optional类的学习&lt;/p&gt;
&lt;p&gt;​	之后又用了两天的时间完成JDBC的相关概念学习（SQL注入，连接池）学会了如何使用JDBC操作数据库，配置DBUtils，能够独立对于JDBC结合德鲁伊连接池，阿帕奇的Utils将SQL查询封装为Dao对象便于操作，用了两天的时间对于Redis有了一些初级的了解（数据结构，NoSQL，客户端），之后又花了一天半的时间完成了git版本控制工具的使用，能够结合远程代码托管平台（Github，Gitee），使用命令行或者IDEA集成开发环境，对于自己写的代码进行版本管理&lt;/p&gt;
&lt;p&gt;​	最后的8天稍微有些懈怠，由于课程安排有些紧凑，实际上满打满算的学习只有大概5天左右，完成了JavaWeb中的一部分学习：一些前端基础（html，CSS，JavaScript，jQuery），Web服务器（Tomcat），以及依赖管理工具Maven的基本使用，我对前端这部分的理解是在实际使用中搞清楚怎么用即可，没有花太多时间去像Java基础部分一样记录较为详细的笔记。&lt;/p&gt;
&lt;p&gt;​	五一假期打算过完生日后，抽出一天时间过一遍线代考试内容（5.10）另外两天看一下编译原理实验的作业和机器学习的大作业，假期之后再进行JavaWeb中Servlet的学习。&lt;/p&gt;
</content:encoded></item><item><title>Redis</title><link>https://thrinisty.github.io/posts/redis%E7%AC%94%E8%AE%B0java%E5%AE%A2%E6%88%B7%E7%AB%AF/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/redis%E7%AC%94%E8%AE%B0java%E5%AE%A2%E6%88%B7%E7%AB%AF/</guid><description>Java客户端，待学部分，等到Java框架学习完成后进行</description><pubDate>Thu, 24 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Redis笔记&lt;/h1&gt;
&lt;h2&gt;Jedis&lt;/h2&gt;
&lt;p&gt;我们学Redis最终还是要回到编码上，我们需要使用到Redis提供的客户端，推荐的有Jedis、lettuce、Redisson&lt;/p&gt;
&lt;p&gt;Jedis，以Redis命令作为方法名称，学习成本较低，简单实用，但是Jedis实例线程不安全，多线程环境下需要基于连接池来使用&lt;/p&gt;
&lt;p&gt;Lettuce，是基于Netty实现的，支持同步，异步，响应式编程方式，线程安全，支持Redis的哨兵模式，集群模式，管道模式&lt;/p&gt;
&lt;p&gt;Redisson，是基于Redis实现的分布式，可伸缩的Java数据结构集合，包含了Map、Queue、Lock、Semaphore、AtomicLong等强大功能&lt;/p&gt;
&lt;p&gt;而其中Spring Data Redis支持jedis和lettuce&lt;/p&gt;
&lt;h3&gt;Jedis使用&lt;/h3&gt;
&lt;p&gt;用Maven添加如下的依赖&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;redis.clients&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;jedis&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;5.2.0&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;4.13.2&amp;lt;/version&amp;gt;
        &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.junit.jupiter&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;junit-jupiter&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;5.8.1&amp;lt;/version&amp;gt;
        &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;全部配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
  &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

  &amp;lt;groupId&amp;gt;org.example&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;JedisTest&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
  &amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt;

  &amp;lt;name&amp;gt;JedisTest&amp;lt;/name&amp;gt;
  &amp;lt;url&amp;gt;http://maven.apache.org&amp;lt;/url&amp;gt;

  &amp;lt;properties&amp;gt;
    &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
  &amp;lt;/properties&amp;gt;

  &amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;redis.clients&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;jedis&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;5.2.0&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;4.13.2&amp;lt;/version&amp;gt;
      &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;

  &amp;lt;/dependencies&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;测试代码&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;package org.example;

public class Main {
    public static void main(String[] args) {
        JedisTest jedis = new JedisTest();
        jedis.setUP();
        jedis.testString();
        jedis.tearDown();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Iterator;
import java.util.Map;
import java.util.Set;

public class JedisTest {
    private Jedis jedis;

    public void setUP(){
        jedis = new Jedis(&quot;192.168.104.52&quot;, 6379);
        jedis.auth(&quot;654321&quot;);
        jedis.select(0);
    }

    public void testString() {
        jedis.hset(&quot;hash&quot;, &quot;test&quot;, &quot;value&quot;);
        Map&amp;lt;String, String&amp;gt; hash = jedis.hgetAll(&quot;hash&quot;);
        Set&amp;lt;Map.Entry&amp;lt;String, String&amp;gt;&amp;gt; entrySet = hash.entrySet();
        Iterator&amp;lt;Map.Entry&amp;lt;String, String&amp;gt;&amp;gt; iterator = entrySet.iterator();
        while(iterator.hasNext()) {
            Map.Entry&amp;lt;String, String&amp;gt; entry = iterator.next();
            System.out.println(entry.getKey() + &quot; &quot; + entry.getValue());
        }
    }

    public void tearDown() {
        if(jedis != null) {
            jedis.close();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;fieldString1 HelloWorld1
test value
fieldInt 1
fieldString HelloWorld
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，所有的jedis指令名称和参数都和redis中的对应，使用起来异常的方便，Hash数据结构中的hgetAll也使用HashMap的形式返回，方便用迭代器进行处理&lt;/p&gt;
&lt;h3&gt;Jedis连接池&lt;/h3&gt;
&lt;p&gt;Jedis本身是线程不安全的，而且频繁地创建和销毁连接会有性能上的损耗，推荐使用Jedis地连接池来替代Jedis地直接连接方式&lt;/p&gt;
&lt;p&gt;封装连接池类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class JedisConnectionFactory {
    private static final JedisPool jedisPool;

    static {
        JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();
        //设置最大连接数
        jedisPoolConfig.setMaxTotal(8);
        //设置最大空闲连接
        jedisPoolConfig.setMaxIdle(8);
        //设置最小空闲连接
        jedisPoolConfig.setMinIdle(8);
        //设置最长等待时间ms
        jedisPoolConfig.setMaxWait(Duration.ofMillis(2000));
        jedisPool = new JedisPool(jedisPoolConfig, &quot;192.168.104.52&quot;, 6379, 1000, &quot;654321&quot;);
    }
    //1000 是连接 Redis 服务器的超时时间（毫秒）

    public static Jedis getJedis() {
        return jedisPool.getResource();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public class Main {
    public static void main(String[] args) {
        Jedis jedis = JedisConnectionFactory.getJedis();
        jedis.set(&quot;key&quot;, &quot;value&quot;);
        String s = jedis.get(&quot;key&quot;);
        System.out.println(s);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;SpringDataRedis&lt;/h2&gt;
&lt;p&gt;SpringData是Spring中数据操作的模块，包含对于各种数据库的集成，其中对Redis的集成模块就是SpringDataRedis，总的来说包含了以下的功能&lt;/p&gt;
&lt;p&gt;1.提供了对不同Redis客户端的整合（Lettuce和Jedis）&lt;/p&gt;
&lt;p&gt;2.提供了RedisTemplate统一API操作Redis&lt;/p&gt;
&lt;p&gt;3.支持Redis的发布订阅模型&lt;/p&gt;
&lt;p&gt;4.支持Redis哨兵和Redis集群&lt;/p&gt;
&lt;p&gt;5.支持基于Lettuce的响应式编程&lt;/p&gt;
&lt;p&gt;6.支持基于JDK，JSON，字符串，Spring对象的数据序列化和反序列化&lt;/p&gt;
&lt;p&gt;7.支持基于Redis的JDKCollection实现&lt;/p&gt;
&lt;h3&gt;快速入门&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../images/131.png&quot; alt=&quot;131&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;问题解决&lt;/h3&gt;
&lt;p&gt;IDEA下创建项目SpringBoot发生如下问题，而没有Java更低版本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;项目 SDK &apos;1.8&apos; 不支持所选版本的 Java 17。请选择较低版本的 Java，或设置较高版本的 SDK
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以尝试替换源，选择更低版本Java&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;https://start.aliyun.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Maven获取依赖&lt;/p&gt;
&lt;p&gt;如果在使用Maven获取依赖项的时候用时太久可以尝试替换&lt;/p&gt;
&lt;p&gt;配置阿里云镜像&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;~/.m2/settings.xml&lt;/code&gt; 中添加：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;mirrors&amp;gt;
    &amp;lt;mirror&amp;gt;
        &amp;lt;id&amp;gt;aliyunmaven&amp;lt;/id&amp;gt;
        &amp;lt;url&amp;gt;https://maven.aliyun.com/repository/public&amp;lt;/url&amp;gt;
        &amp;lt;mirrorOf&amp;gt;central&amp;lt;/mirrorOf&amp;gt;
    &amp;lt;/mirror&amp;gt;
&amp;lt;/mirrors&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;感觉学到这里有点寸步难行，redis的各种相关配置，用到的SpringBoot，Maven之类，我都没有接触过，还是得回到Java的开发框架进行学习，Redis教程的进度先耽搁一下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@SpringBootTest
class RedisDataApplicationTests {

    @Autowired
    private RedisTemplate redisTemplate;
    @Test
    void testString() {
        redisTemplate.opsForValue().set(&quot;dataTest&quot;, &quot;李四&quot;);
        Object dataTest = redisTemplate.opsForValue().get(&quot;dataTest&quot;);
        System.out.println(dataTest);
    }

}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Redis</title><link>https://thrinisty.github.io/posts/redis%E7%AC%94%E8%AE%B0nosqlredis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/redis%E7%AC%94%E8%AE%B0nosqlredis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid><description>NoSQL，Redis数据结构</description><pubDate>Wed, 23 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Redis笔记&lt;/h1&gt;
&lt;p&gt;花了大概两天完成，Java8内容的学习，比预期的要上了短一些，本来打算按照学习计划先进行Java开发框架的学习，但是发现面试的时候Redis考点会更多一点，所以将Redis部分的学习提前，预定大概10天完成（黑马Redis教程）&lt;/p&gt;
&lt;p&gt;教程包括了：八种不同的数据结构，两个消息队列，四个相关的运维操作，Scrip脚本，事务操作&lt;/p&gt;
&lt;h2&gt;NoSQL&lt;/h2&gt;
&lt;p&gt;SQL是关系型数据库，而NoSQL是非关系型数据库&lt;/p&gt;
&lt;h3&gt;与SQL的区别&lt;/h3&gt;
&lt;h4&gt;结构化&lt;/h4&gt;
&lt;p&gt;SQL高度结构化，每个字段每个值都会有严格的要求，一般难以修改。而NoSQL是非结构化的，对于key没有严格要求，支持自定义，还可以键值类型，列类型，文档存储，Graph存储，相对SQL，结构便于修改&lt;/p&gt;
&lt;h4&gt;关联性&lt;/h4&gt;
&lt;p&gt;SQL有外键的约束，数据是相关联的，NoSQL没有关联（程序员手动维护）&lt;/p&gt;
&lt;h4&gt;SQL查询&lt;/h4&gt;
&lt;p&gt;只要是SQL都可以使用相同的查询语句查询，而NoSQL没有固定的语法格式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/124.png&quot; alt=&quot;124&quot; /&gt;&lt;/p&gt;
&lt;p&gt;每一个类型的数据查询方式不同&lt;/p&gt;
&lt;h4&gt;事务&lt;/h4&gt;
&lt;p&gt;SQL有事务满足ACID，而NoSQL只满足BASE&lt;/p&gt;
&lt;h4&gt;总结&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;../images/125.png&quot; alt=&quot;125&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;Redis&lt;/h2&gt;
&lt;h3&gt;基本介绍&lt;/h3&gt;
&lt;p&gt;Remote Dictionary Server 远程词典服务器，是一个基于内存的键值型NoSQL数据库，以下是Redis的基本特征&lt;/p&gt;
&lt;p&gt;键值型：value支持多种不同数据结构，功能丰富&lt;/p&gt;
&lt;p&gt;单线程：每个命令具备原子性（Redis 6可以多线程处理网络请求）&lt;/p&gt;
&lt;p&gt;高性能：低延迟，速度快（基于内存，IO多路复用，良好的编码【C语言编写】）&lt;/p&gt;
&lt;p&gt;持久化：内存以往是不持久化的，而Redis定期存入磁盘，支持持久化&lt;/p&gt;
&lt;p&gt;高可用：支持主从集群，分片集群&lt;/p&gt;
&lt;p&gt;语言支持：支持多种语言的客户端&lt;/p&gt;
&lt;h3&gt;常用命令&lt;/h3&gt;
&lt;p&gt;我们一般的redis数据库会配置在Linux环境下，之后可以使用Windows的GUI软件RESP来使用Linux下的数据库&lt;/p&gt;
&lt;p&gt;再Linux下装好redis后，可以使用如下的指令&lt;/p&gt;
&lt;p&gt;命令行客户端&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;redis-cli
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;服务端启动脚本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;redis-server
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;哨兵启动脚本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;redis-sentinel
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以在redis.conf中设置，允许访问的地址，密码，是否后台运行等&lt;/p&gt;
&lt;p&gt;再用如下的指令指定配置文件启动&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;redis-server redis.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;利用如下指令查找开启的进程&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ps -ef | grep redis
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;杀死对应端口的进程&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kill -9 2574
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用命令行客户端连接redis&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;redis-cli -a ******
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;连接成功后，ping和服务端交互&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ping
PONG
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还可以进行存取数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; set name jack
OK
127.0.0.1:6379&amp;gt; set age 21
OK
127.0.0.1:6379&amp;gt; get name
&quot;jack&quot;
127.0.0.1:6379&amp;gt; get age
&quot;21&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再windows宿主机使用如下指令连接（虚拟机网络适配器改为桥接连接模式）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;redis-cli -h 192.168.104.52 -p 6379 -a ******
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用GUI客户端连接&lt;/p&gt;
&lt;p&gt;网址链接： https://github.com/lework/RedisDesktopManager-Windows&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/126.png&quot; alt=&quot;126&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;Redis数据结构&lt;/h2&gt;
&lt;p&gt;Redis是一个键值对形式存储的数据库，key一般是String类型的，不过Value的类型非常多种多样&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/127.png&quot; alt=&quot;127&quot; /&gt;&lt;/p&gt;
&lt;p&gt;其中前五种是基本数据类型，后三种是特殊数据类型&lt;/p&gt;
&lt;p&gt;数据类型的具体使用详见 https://redis.io/docs/latest/commands&lt;/p&gt;
&lt;p&gt;如果在连接到redis下的客户端中可以使用如下指令获取帮助&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;help @数据类型
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例如查看String的相关指令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;help @String
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Key的层级格式&lt;/h3&gt;
&lt;p&gt;Redis没有类似MySQL中的Table概念，而所有的键值对都是存储在一起的，怎么区分不同类型的key？&lt;/p&gt;
&lt;p&gt;例如需要存储用户，商品信息到redis，一个用户的id是1，而另一个商品id也为1&lt;/p&gt;
&lt;p&gt;而为了解决这类的问题，redis引入了key的层级结构：Redis的key允许有多个单词形成层级结构，多个单词之间用：隔开，格式如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;项目名称:业务名称:类型:id
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;格式并非固定不变，可以根据需求删除或者添加词条&lt;/p&gt;
&lt;p&gt;user相关的key：com.user:1&lt;/p&gt;
&lt;p&gt;product相关的key：com.product:1&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/128.png&quot; alt=&quot;128&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;Redis通用命令&lt;/h3&gt;
&lt;p&gt;虽然有非常多的数据类型以及相关操作，但是其中也有一些通用的命令&lt;/p&gt;
&lt;h4&gt;KEYS&lt;/h4&gt;
&lt;p&gt;查看符合模板的所有key，不建议在Redis服务器端使用，会阻塞所有的其他指令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;KEYS pattern
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例如：返回所有的键值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;KEYS *
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;返回a开头的所有键值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;KEYS a*
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;DEL&lt;/h4&gt;
&lt;p&gt;删除一个指定的键值(例如age)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DEL age
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以删除多个&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DEL k1 k2 k3
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;MSET&lt;/h4&gt;
&lt;p&gt;批量插入键值对&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MSET k1 v1 k2 v2 k3 v3 k4 v4
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;EXISTS&lt;/h4&gt;
&lt;p&gt;判断是否存在键值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;EXISTS k4
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;EXPIRE&lt;/h4&gt;
&lt;p&gt;给一个key设置有效期，有效期到达时key会被删除&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;EXPIRE key second
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;EXPIRE name 5
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;TTL&lt;/h4&gt;
&lt;p&gt;查看一个键的有效期&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;TTL key
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中返回-1代表永久有效 -2为无效，其余为有效的秒数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;TTL k1
(integer) -1
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;String类型&lt;/h3&gt;
&lt;p&gt;是字符串类型，是Redis中最简单的存储类型，value是字符串，根据不同的格式又分为了三类：String 普通字符串  int 整数类型  float  浮点类型&lt;/p&gt;
&lt;p&gt;无论是哪一种格式存储，底层都是字节数组形式，只是编码方式不同，字符串类型的最大空间不可以超过512M&lt;/p&gt;
&lt;p&gt;以下是String类型常见的命令&lt;/p&gt;
&lt;h4&gt;SET&lt;/h4&gt;
&lt;p&gt;添加或者修改一个存在的String类型的键值对&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; set k1 123
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;GET&lt;/h4&gt;
&lt;p&gt;根据key获取String类型的value&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;get k1
&quot;123&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;MSET&lt;/h4&gt;
&lt;p&gt;批量添加多个String类型的的键值对&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MSET t1 1 t2 2 t3 3
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;MGET&lt;/h4&gt;
&lt;p&gt;根据多个key获取多个String类型的value&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MGET k1 k2 k3
1) &quot;v1&quot;
2) &quot;v2&quot;
3) &quot;v3&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;INCR&lt;/h4&gt;
&lt;p&gt;让一个整型的key自增1&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;get 1
&quot;23&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;INCR 1
(integer) 24
get 1
&quot;24&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;INCRBY&lt;/h4&gt;
&lt;p&gt;让一个整形的key自增并指定步长，例如incrby num 2让num自增2&lt;/p&gt;
&lt;p&gt;在INCR的基础上增加步长&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;INCRBY 1 4
(integer) 28
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;INCRBYFLOAT&lt;/h4&gt;
&lt;p&gt;让一个浮点类型的数字自增并指定步长&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;append 2 3.1415296
(integer) 9
get 2
&quot;3.1415296&quot;
INCRBYFLOAT 2 1.1
&quot;4.2415296&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;SETNX&lt;/h4&gt;
&lt;p&gt;添加一个String类型的键值对，前提是这个key不存在，否则不执行&lt;/p&gt;
&lt;p&gt;k1以及存在，不执行语句&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SETNX k1 1
(integer) 0
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;SETEX&lt;/h4&gt;
&lt;p&gt;添加一个String类型的键值对，并且指定有效期&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SETEX key seconds value
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置键3值12，持续30每秒&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SETEX 3 30 12
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者可以这么写&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;set 3 12 ex 30
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Hash类型&lt;/h3&gt;
&lt;p&gt;Hash类型，又称为散列，它的value是一个无序字典，类似于Java中的HashMap结构，String结构是将对象序列化为JSON字符串后存储，当需要修改某个字段的时候很不方便&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/129.png&quot; alt=&quot;129&quot; /&gt;&lt;/p&gt;
&lt;p&gt;而Hash结构可以将对象中的每个字段独立存储，可以针对单个字段作增删改查&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/130.png&quot; alt=&quot;130&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;HSET&lt;/h4&gt;
&lt;p&gt;添加或者修改hash类型key的field值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hset key field value
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;hset hash1 field value
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;HGET&lt;/h4&gt;
&lt;p&gt;获取一个hash类型的key的field值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HGET key field
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;hget hash1 field
&quot;value&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;HMSET&lt;/h4&gt;
&lt;p&gt;批量添加多个hash类型key的field值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HMSET hash1 field2 value2 field3 value3
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;HMGET&lt;/h4&gt;
&lt;p&gt;批量获取多个hash类型的key的field值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HMGET hash1 field field1 field2
1) &quot;value&quot;
2) &quot;value2&quot;
3) &quot;value2&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;HDEL&lt;/h4&gt;
&lt;p&gt;删除指定hash中的某个字段&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HDEL hash fieldString
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;HGETALL&lt;/h4&gt;
&lt;p&gt;获取一个hash类型的key中所有的field和value&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HGETALL hash1
1) &quot;field&quot;
2) &quot;value&quot;
3) &quot;field1&quot;
4) &quot;value2&quot;
5) &quot;field2&quot;
6) &quot;value2&quot;
7) &quot;field3&quot;
8) &quot;value3&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;HKEYS&lt;/h4&gt;
&lt;p&gt;获取一个hash类型的所有field&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HKEYS hash1
1) &quot;field&quot;
2) &quot;field1&quot;
3) &quot;field2&quot;
4) &quot;field3&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;HVALS&lt;/h4&gt;
&lt;p&gt;获取一个hash类型的所有value&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HVALS hash1
1) &quot;value&quot;
2) &quot;value2&quot;
3) &quot;value2&quot;
4) &quot;value3&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;HINCRBY&lt;/h4&gt;
&lt;p&gt;让一个hash类型key的字段值自增，并指定步长&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HSET hash fieldInt 1
(integer) 1
HINCRBY hash fieldInt 3
(integer) 4
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;HSETNX&lt;/h4&gt;
&lt;p&gt;添加一个hash类型key的field值，前提是field不存在，否则不执行（就是不允许修改存在的键的值）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HSETNX hash fieldString HelloWorld
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;List类型&lt;/h3&gt;
&lt;p&gt;对于List而言，可以使用该数据类型进行模拟栈：只需要入口和出口在同一边，如LPUSH+LPOP或者RPUSH+RPOP&lt;/p&gt;
&lt;p&gt;也可以模拟一个队列：需要入口和出口在不同边即可，如RPUSH+LPOP或者RPUSH+LPOP&lt;/p&gt;
&lt;p&gt;阻塞队列的模拟：入口出口不同边，取出采用BLPOP或者BRPOP&lt;/p&gt;
&lt;p&gt;基本介绍&lt;/p&gt;
&lt;p&gt;Redis中的List类型，和Java中的LinkedList类似，可以看作是一个双向链表的结构，既支持正向检索也可以支持反向检索&lt;/p&gt;
&lt;p&gt;特征：有序，元素可以重复，插入和删除较快，查询效率一般&lt;/p&gt;
&lt;p&gt;以下是List的常见命令&lt;/p&gt;
&lt;h4&gt;LPUSH&lt;/h4&gt;
&lt;p&gt;向列表左侧插入一个或者多个元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;LPUSH key element ...
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;LPUSH list a b c d e f g
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;LPOP&lt;/h4&gt;
&lt;p&gt;移除并返回列表左侧的第一个元素，没有则返回nil&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;LPOP key 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;LPOP list
&quot;g&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;RPUSH&lt;/h4&gt;
&lt;p&gt;向列表右侧插入一个或者多个元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;RPUSH list a b c d e f g h
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;RPOP&lt;/h4&gt;
&lt;p&gt;移除并返回列表右侧的第一个元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;RPOP list
&quot;h&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;LRANGE&lt;/h4&gt;
&lt;p&gt;返回一段角标范围内的所有元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;LRANGE key star end
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;LRANGE list 1 3
1) &quot;b&quot;
2) &quot;c&quot;
3) &quot;d&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;BLPOP与BRPOP&lt;/h4&gt;
&lt;p&gt;和LPOP，RPOP类似，只是在没有元素时等待指定时间，而不是返回nil&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;BLPOP list 60
1) &quot;list&quot;
2) &quot;target&quot;
(15.01s)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中list本来没有值，进入阻塞等待最多60s，新创建的客户端加入list 数据 target数据被读到&lt;/p&gt;
&lt;h3&gt;Set类型&lt;/h3&gt;
&lt;p&gt;Redis的Set结构和Java中的HashSet类似，可以看为是一个value为null的HashMap，因为是一个hash表，因此具备和HashSet类似的特征：无序，元素不可重复，查找快，支持交集、并集、差集的功能&lt;/p&gt;
&lt;p&gt;以下是Set类型常见的命令&lt;/p&gt;
&lt;h4&gt;SADD&lt;/h4&gt;
&lt;p&gt;向set中添加一个或者多个元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SADD key member ...
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;SADD set a b c d e f g
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;SREM&lt;/h4&gt;
&lt;p&gt;移除set中的指定元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SREM key member ...
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;SREM set a b c
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;SCARD&lt;/h4&gt;
&lt;p&gt;返回set中的元素个数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SCARD key
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;SCARD set
(integer) 4
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;SISMEMBER&lt;/h4&gt;
&lt;p&gt;判断一个元素是否存在于set中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SISMEMBER key member
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;SISMEMBER set g
(integer) 1
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;SMEMBERS&lt;/h4&gt;
&lt;p&gt;获取set中的所有元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SMEMBERS set
1) &quot;g&quot;
2) &quot;d&quot;
3) &quot;f&quot;
4) &quot;e&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;前置操作&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SADD set1 a b c d e f
SADD set2 a b
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;SINTER&lt;/h4&gt;
&lt;p&gt;求两个集合的交集&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SINTER set1 set2
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;1) &quot;b&quot;
2) &quot;a&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;SDIFF&lt;/h4&gt;
&lt;p&gt;求两个集合的差集&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SDIFF set1 set2
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;1) &quot;c&quot;
2) &quot;e&quot;
3) &quot;f&quot;
4) &quot;d&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;SUNION&lt;/h4&gt;
&lt;p&gt;求两个集合的并集&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SUNION set1 set2
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;1) &quot;b&quot;
2) &quot;a&quot;
3) &quot;d&quot;
4) &quot;c&quot;
5) &quot;e&quot;
6) &quot;f&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;SortedSet类型&lt;/h3&gt;
&lt;p&gt;Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但是底层数据结构差别巨大，SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层是一个跳表（Skip List）加上hash表&lt;/p&gt;
&lt;p&gt;以下是SortedSet的特征：可排序 元素不重复  查询速度快&lt;/p&gt;
&lt;p&gt;因为SortedSet的可排序性，经常用于实现排行榜等功能&lt;/p&gt;
&lt;p&gt;以下是Sorted的常见命令，所有排名默认为升序，降序在命令Z后加REV即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ZREVRANGE 
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;ZADD&lt;/h4&gt;
&lt;p&gt;添加一个或者多个元素到sorted set，如果与存在则更新其score值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ZADD key score member
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;ZADD sortedset 1 Hello
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;ZREM&lt;/h4&gt;
&lt;p&gt;删除sorted set中的一个元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ZREM key member
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;zrem sortedset HelloWorld
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;ZSCORE&lt;/h4&gt;
&lt;p&gt;获取sorted set中指定元素的score值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ZSCORE key member
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;ZSCORE sortedset Hello
&quot;1&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;ZRANK&lt;/h4&gt;
&lt;p&gt;获取sorted set中的指定元素排名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ZRANK key member
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;ZRANK sortedset Hello
(integer) 0
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;ZCARD&lt;/h4&gt;
&lt;p&gt;获取sorted set中的元素个数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ZCARD key
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;zcard sortedset
(integer) 2
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;ZCOUNT&lt;/h4&gt;
&lt;p&gt;统计指定范围内元素的个数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ZCOUNT key min max
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;ZCOUNT sortedset 2 5
(integer) 1
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;ZINCRBY&lt;/h4&gt;
&lt;p&gt;让sorted set 中指定score元素自增，指定步长&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ZINCRBY key increment member
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;ZINCRBY sortedset 4 1
&quot;22&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;ZRANGE&lt;/h4&gt;
&lt;p&gt;按照score排序后，获取指定排名范围内的元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ZRANGE key min max
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;ZRANGE sortedset 0 1
1) &quot;Hello&quot;
2) &quot;World&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;ZRANGEBYSCORE&lt;/h4&gt;
&lt;p&gt;按照score排序后，获取指定score范围内的元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ZRANGEBYSCORE key min max
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;ZRANGEBYSCORE sortedset 0 44
1) &quot;Hello&quot;
2) &quot;World&quot;
3) &quot;1&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;ZDIFF、ZINTER、ZUNION&lt;/h4&gt;
&lt;p&gt;求差集、交集、并集&lt;/p&gt;
&lt;p&gt;和Set类中的类似，不再过多叙述&lt;/p&gt;
</content:encoded></item><item><title>Java8笔记</title><link>https://thrinisty.github.io/posts/java8%E7%AC%94%E8%AE%B0lambda%E8%A1%A8%E8%BE%BE%E5%BC%8Fstream-apioptional/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java8%E7%AC%94%E8%AE%B0lambda%E8%A1%A8%E8%BE%BE%E5%BC%8Fstream-apioptional/</guid><description>Lambda表达式，函数式接口，Stream API，Optional</description><pubDate>Sun, 20 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Java8笔记&lt;/h1&gt;
&lt;p&gt;拖了一天，本来打算从昨天就开始Java8特性的学习。但是有门事多题难分少的编译原理实验课把自己搞得心烦，晚上就没有精力学习了。&lt;/p&gt;
&lt;p&gt;第二天还要体测，38度的高温，就隔这室外干站着，等半天跑1000米，跑前本来想着4分30以内及格就好，压着脚步跑，结果才4分37，还贼累，险些没给自己跑死。&lt;/p&gt;
&lt;p&gt;到了期中以后了，感觉时间也是慢慢的变得紧张了起来，还是尽量多学一会把，刚回宿舍躺了一小会，算是复活了，总而言之开始今天的学习吧&lt;/p&gt;
&lt;h2&gt;Java8&lt;/h2&gt;
&lt;p&gt;为什么要学习Java8？&lt;/p&gt;
&lt;p&gt;Java8是当今企业中开发最主流的稳定版本，这个版本中出现了很多的新特性，虽然考点不多，但是可以提升Java后端开发程序员的编程效率，值得学习&lt;/p&gt;
&lt;p&gt;相关知识有Lambda表达式、Stream API、Optional&lt;/p&gt;
&lt;p&gt;计划加上今天晚上，明天，后天，一共三天完成相关知识的学习&lt;/p&gt;
&lt;h2&gt;Lambda表达式&lt;/h2&gt;
&lt;p&gt;Lambda是一个匿名函数，我们可以把Lambda表达式理解为是一段可以传递的代码，使用它可以写出更为简洁灵活的代码，代码风格更加紧凑&lt;/p&gt;
&lt;h3&gt;代码示例&lt;/h3&gt;
&lt;p&gt;我们用一串代码举例子&lt;/p&gt;
&lt;p&gt;多线程接口Runnable，实现一个类，重写run方法，start调用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test01 {
    public static void main(String[] args) {
        Cat cat = new Cat();
        Thread thread = new Thread(cat);
        thread.start();
    }
}

class Cat implements Runnable {
    @Override
    public void run() {
        System.out.println(&quot;cat&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们就是用一次这个猫猫类，我们可以稍微用匿名内部类简写一点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test01 {
    public static void main(String[] args) {
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                System.out.println(&quot;cat&quot;);
            }
        };
        Thread thread = new Thread(runnable);
        thread.start();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来我们使用以下Lambda表达式来进行改造&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test01 {
    public static void main(String[] args) {
        Runnable runnable = () -&amp;gt; System.out.println(&quot;cat&quot;);
        Thread thread = new Thread(runnable);
        thread.start();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再举一个例子，比较类的实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test01 {
    public static void main(String[] args) {
        Comparator&amp;lt;Integer&amp;gt; comparator = new Comparator&amp;lt;Integer&amp;gt;() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return Integer.compare(o1, o2);
            }
        };
        System.out.println(comparator.compare(1,3));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lambda改造&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test01 {
    public static void main(String[] args) {
        Comparator&amp;lt;Integer&amp;gt; comparator = (Integer o1, Integer o2) -&amp;gt; Integer.compare(o1, o2);
        System.out.println(comparator.compare(1,3));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方法引用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test01 {
    public static void main(String[] args) {
        Comparator&amp;lt;Integer&amp;gt; comparator = Integer :: compare;
        System.out.println(comparator.compare(1,3));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以直接便捷的实现一个类的实例，如此方便，很人性化不是吗&lt;/p&gt;
&lt;p&gt;其中 -&amp;gt; 就是Lambda操作符，在实际操作中这么写非常的快速，而且很帅，很装&lt;/p&gt;
&lt;h3&gt;具体使用&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;使用说明&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(形参列表) -&amp;gt; 重写的抽象方法体
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;-&amp;gt; 左边Lambda形参列表（是接口中抽象方法的形参列表）&lt;/p&gt;
&lt;p&gt;-&amp;gt; 右边是Lambda体（是重写的抽象方法的方法体）&lt;/p&gt;
&lt;p&gt;Lambda表达式在Java中的本质是接口的实例（万事万物皆对象）&lt;/p&gt;
&lt;p&gt;Lambda表达式的使用，分为六种情况&lt;/p&gt;
&lt;p&gt;1.无参，无返回结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;() -&amp;gt; {重写方法体}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Runnable runnable = () -&amp;gt; System.out.println(&quot;cat&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.需要一个参数，没有返回值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(类型 名称) -&amp;gt; {重写方法体}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Consumer&amp;lt;String&amp;gt; con = (String s) -&amp;gt; {System.out.println(s);}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.数据类型可以省略，因为可以由编译器推断得出&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(名称) -&amp;gt; {重写方法体}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Consumer&amp;lt;String&amp;gt; con = (s) -&amp;gt; {System.out.println(s);}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.若Lambda只需要一个参数，参数小括号也可以省略&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;名称 -&amp;gt; {重写方法体}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Consumer&amp;lt;String&amp;gt; con = s -&amp;gt; {System.out.println(s);}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.Lambda需要两个或以上的参数，执行多条语句，有返回值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(类型 名称, 类型 名称, ...) -&amp;gt; {重写方法语句; return ...;}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Comparator&amp;lt;Integer&amp;gt; comparator = (Integer o1, Integer o2) -&amp;gt; {
    System.out.println(o1);
    System.out.println(o2);
    return Integer.compare(o1, o2);}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;6.当Lambda只有一条语句的时候，大括号可以省略，对return语句return也不用写&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(类型 名称, 类型 名称, ...) -&amp;gt; [return] 重写方法体;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Comparator&amp;lt;Integer&amp;gt; comparator = (Integer o1, Integer o2) -&amp;gt; Integer.compare(o1, o2);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lambda表达式的本质实际上是接口的实例，依赖于函数式接口的实现&lt;/p&gt;
&lt;h2&gt;函数式接口&lt;/h2&gt;
&lt;p&gt;如果一个接口中只有一个方法声明，那么这个接口就是函数式接口，可以使用Lambda表达式来进行代码优化（简化）&lt;/p&gt;
&lt;p&gt;接口一般用注解@FunctionalInterface来标示，只允许声明一个方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test01 {
    public static void main(String[] args) {
        Test test = (String o) -&amp;gt; {
            System.out.println(o);
        };
        test.write(&quot;Jerry&quot;);
    }
}

@FunctionalInterface
interface Test{
    void write(String str);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以匿名内部类实例的创建，都可以用Lambda表达式来创建，在java.utils.function包下定义了Java8的函数式接口&lt;/p&gt;
&lt;h3&gt;内置核心函数式接口&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函数式接口&lt;/th&gt;
&lt;th&gt;参数类型&lt;/th&gt;
&lt;th&gt;返回类型&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;消费型接口Consumer&amp;lt;T&amp;gt;&lt;/td&gt;
&lt;td&gt;T&lt;/td&gt;
&lt;td&gt;void&lt;/td&gt;
&lt;td&gt;方法void accept(T t)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;供给型接口Supplier&amp;lt;T&amp;gt;&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;T&lt;/td&gt;
&lt;td&gt;方法T get()&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;函数型接口Function&amp;lt;T,R&amp;gt;&lt;/td&gt;
&lt;td&gt;T&lt;/td&gt;
&lt;td&gt;R&lt;/td&gt;
&lt;td&gt;方法R apply(T t)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;断定型接口Predicate&amp;lt;T&amp;gt;&lt;/td&gt;
&lt;td&gt;T&lt;/td&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;方法boolean test(T t)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;Consumer&amp;lt;T&amp;gt;&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class Test01 {
    public static void main(String[] args) {
        Consumer&amp;lt;String&amp;gt; comsumer = (s) -&amp;gt; System.out.println(s);
        comsumer.accept(&quot;Jerry&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;Supplier&amp;lt;T&amp;gt;&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class Test01 {
    public static void main(String[] args) {
        Supplier&amp;lt;Integer&amp;gt; supplier = () -&amp;gt; new Integer(13);
        System.out.println(supplier.get());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;Function&amp;lt;T,R&amp;gt;&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class Test01 {
    public static void main(String[] args) {
        Function&amp;lt;Character, Integer&amp;gt; function = (s) -&amp;gt; new Integer(s);
        System.out.println(function.apply(&apos;a&apos;));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;Predicate&amp;lt;T&amp;gt;&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class Test01 {
    public static void main(String[] args) {
        Predicate&amp;lt;String&amp;gt; predicate = (s) -&amp;gt; {
            if (&quot;hello&quot;.equals(s)) {
                return true;
            }
            return false;
        };
        System.out.println(predicate.test(&quot;he&quot;));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;方法引用&lt;/h3&gt;
&lt;p&gt;当要传递给Lambda体的操作以及有实现的方法了，就可以使用方法引用&lt;/p&gt;
&lt;p&gt;要求：实现接口的抽象方法的参数列表和返回值的类型，必须和方法引用的参数列表和返回值保持一致&lt;/p&gt;
&lt;p&gt;格式：使用&quot;::&quot;将类与方法名隔开&lt;/p&gt;
&lt;p&gt;使用场景&lt;/p&gt;
&lt;p&gt;当接口中的抽象方法的形参列表和返回值与方法引用的方法的形参列表和返回值类型相同&lt;/p&gt;
&lt;h4&gt;情况一&lt;/h4&gt;
&lt;p&gt;对象::实例方法&lt;/p&gt;
&lt;p&gt;Consumer 中的 void accept(T t)&lt;/p&gt;
&lt;p&gt;PrintStream 中的 void println(T t)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test02 {
    public static void main(String[] args) {
        Consumer&amp;lt;String&amp;gt; consumer = str -&amp;gt; System.out.println(str);
        consumer.accept(&quot;Hello world&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;类对象为System.out 实例方法是println&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test02 {
    public static void main(String[] args) {
        Consumer&amp;lt;String&amp;gt; consumer = System.out :: println;
        consumer.accept(&quot;Hello world&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;情况二&lt;/h4&gt;
&lt;p&gt;类::静态方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test02 {
    public static void main(String[] args) {
        Comparator&amp;lt;Integer&amp;gt; comparator = (o1, o2) -&amp;gt; Integer.compare(o1, o2);
        System.out.println(comparator.compare(1,3));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public class Test01 {
    public static void main(String[] args) {
        Comparator&amp;lt;Integer&amp;gt; comparator = Integer :: compare;
        System.out.println(comparator.compare(1,3));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;情况三&lt;/h4&gt;
&lt;p&gt;类::实例方法&lt;/p&gt;
&lt;p&gt;前两种使用方式要求：接口中的抽象方法的形参列表和返回值与方法引用的方法的形参列表和返回值类型相同&lt;/p&gt;
&lt;p&gt;而第三种方式可以不严格要求如上的条件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test02 {
    public static void main(String[] args) {
        Comparator&amp;lt;String&amp;gt; comparator = (s1, s2) -&amp;gt; s1.compareTo(s2);
        System.out.println(comparator.compare(&quot;adf&quot;, &quot;dgb&quot;));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;改造为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test02 {
    public static void main(String[] args) {
        Comparator&amp;lt;String&amp;gt; comparator = String :: compareTo;
        System.out.println(comparator.compare(&quot;adf&quot;, &quot;dgb&quot;));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;构造器引用&lt;/h3&gt;
&lt;p&gt;和方法引用类似，函数式接口的抽象方法的形参类型和构造器的形参列表一致&lt;/p&gt;
&lt;p&gt;通过构造器引用可以简化接口返回对应类对象的使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test02 {
    public static void main(String[] args) {
        Supplier&amp;lt;Employee&amp;gt; emp = () -&amp;gt; new Employee();
        System.out.println(emp.get());
    }
}

class Employee {
    @Override
    public String toString() {
        return &quot;Employee&quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public class Test02 {
    public static void main(String[] args) {
        Supplier&amp;lt;Employee&amp;gt; emp = Employee :: new;
        System.out.println(emp.get());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再举一个例子&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test02 {
    public static void main(String[] args) {
        Function&amp;lt;Integer, Employee&amp;gt; emp = (id) -&amp;gt; new Employee(id);
        System.out.println(emp.apply(123));
    }
}

class Employee {
    private int id;

    public Employee(int id) {
        this.id = id;
    }

    @Override
    public String toString() {
        return &quot;Employee &quot; + id;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public class Test02 {
    public static void main(String[] args) {
        Function&amp;lt;Integer, Employee&amp;gt; emp = Employee :: new;
        System.out.println(emp.apply(123));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;数组引用&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;public class Test02 {
    public static void main(String[] args) {
        Function&amp;lt;Integer, String[]&amp;gt; emp = (id) -&amp;gt; new String[id];
        String[] arr = emp.apply(10);
        System.out.println(arr.length);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public class Test02 {
    public static void main(String[] args) {
        Function&amp;lt;Integer, String[]&amp;gt; emp = String[] :: new;
        String[] arr = emp.apply(10);
        System.out.println(arr.length);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Stream API&lt;/h2&gt;
&lt;h3&gt;前置知识&lt;/h3&gt;
&lt;p&gt;Stream API (java.util.stream)把真正的函数式编程风格引入到Java中，可以用Stream API写出高效、干净、简洁的代码&lt;/p&gt;
&lt;p&gt;Stream是Java8中处理集合的关键抽象概念，可以指定你希望对集合进行的操作，可以执行非常复杂的查找，过滤和映射数据操作，类似于SQL对数据库的操作（过滤，排序，映射，规约）&lt;/p&gt;
&lt;p&gt;Stream和Collection集合的区别：Collection是一种静态的内存数据结构，而Stream是有关计算的，前者主要面向内存（存储在内存），后者主要面向CPU（通过CPU计算）&lt;/p&gt;
&lt;h3&gt;注意要点&lt;/h3&gt;
&lt;p&gt;1.Stream自己不会存储元素&lt;/p&gt;
&lt;p&gt;2.Stream不会改变源对象，而会返回一个持有结果的Stream&lt;/p&gt;
&lt;p&gt;3.Stream操作是延迟执行的，意味着他们会等到需要结果的时候才会执行&lt;/p&gt;
&lt;p&gt;大体上分为三个步骤 1.创建流 2.中间操作 3.终止操作&lt;/p&gt;
&lt;h3&gt;Stream创建&lt;/h3&gt;
&lt;h4&gt;获取集合流对象&lt;/h4&gt;
&lt;p&gt;Java8中的Collection接口被扩展，提供两个获取流的方法&lt;/p&gt;
&lt;p&gt;default Stream&amp;lt;E&amp;gt; stream() : 返回一个顺序流&lt;/p&gt;
&lt;p&gt;default Stream&amp;lt;E&amp;gt; parallelStream() : 返回一个并行流&lt;/p&gt;
&lt;p&gt;我们现在有如下的ArrayList集合对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Stream1 {
    public static void main(String[] args) {
        List&amp;lt;Employee&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        Employee person1 = new Employee(&quot;黎明&quot;, 18);
        Employee person2 = new Employee(&quot;丽丽&quot;, 11);
        Employee person3 = new Employee(&quot;黎明&quot;, 18);
        list.add(person1);
        list.add(person2);
        list.add(person3);
        System.out.println(list.size());
    }
}

class Employee {
    String name;
    int age;

    public Employee(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过两个方法获取流&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Employee&amp;gt; stream = list.stream();
//获取顺序流（按照顺序取）
Stream&amp;lt;Employee&amp;gt; employeeStream = list.parallelStream();
//获取并行流（按照多个线程取值）
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;获取数组流对象&lt;/h4&gt;
&lt;p&gt;以下是一个数组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Stream1 {
    public static void main(String[] args) {
        Employee[] employee = new Employee[3];
        Employee person1 = new Employee(&quot;黎明&quot;, 18);
        Employee person2 = new Employee(&quot;丽丽&quot;, 11);
        Employee person3 = new Employee(&quot;黎明&quot;, 18);
        employee[0] = person1;
        employee[1] = person2;
        employee[2] = person3;
    }
}

class Employee {
    String name;
    int age;

    public Employee(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Employee&amp;gt; stream = Arrays.stream(employee);
//通过Arrays的静态方法调用stream创建流实例
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;静态方法创建流&lt;/h4&gt;
&lt;p&gt;用于直接用数据创建流&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Employee&amp;gt; stream = Stream.of(person1, person2, person3);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;无限流&lt;/p&gt;
&lt;p&gt;迭代&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Integer&amp;gt; limit = Stream.iterate(0, t -&amp;gt; t + 2).limit(10);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Stream.iterate(0, t -&amp;gt; t + 2).limit(10).forEach(System.out :: println);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;生成&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Double&amp;gt; limit = Stream.generate(Math::random).limit(10);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Stream.generate(Math :: random).limit(10).forEach(System.out :: println);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Stream中间操作&lt;/h3&gt;
&lt;h4&gt;筛选与切片&lt;/h4&gt;
&lt;h5&gt;filter 筛选流&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Employee&amp;gt; stream = list.stream();
Stream&amp;lt;Employee&amp;gt; employeeStream = stream.filter(e -&amp;gt; e.age &amp;gt; 11);
employeeStream.forEach(System.out :: println);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用filter传入一个判断的Predicate函数式接口，筛选出年龄大于11的Employee对象&lt;/p&gt;
&lt;p&gt;再用终结操作forEach输出结果，这也是一个方法引用&lt;/p&gt;
&lt;h5&gt;limit 截断流&lt;/h5&gt;
&lt;p&gt;只保留几个数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Employee&amp;gt; stream = list.stream();
Stream&amp;lt;Employee&amp;gt; employeeStream = stream.limit(2);
employeeStream.forEach(System.out :: println);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意这里一旦执行了forEach流就结束，不可以再使用中间操作&lt;/p&gt;
&lt;h5&gt;skip 跳过元素&lt;/h5&gt;
&lt;p&gt;跳过前面几个数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Employee&amp;gt; stream = list.stream();
Stream&amp;lt;Employee&amp;gt; employeeStream = stream.skip(1);
employeeStream.forEach(System.out :: println);
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;distinct 筛选&lt;/h5&gt;
&lt;p&gt;和数据库筛选一样，去重&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Employee&amp;gt; stream = list.stream();
Stream&amp;lt;Employee&amp;gt; employeeStream = stream.distinct();
employeeStream.forEach(System.out :: println);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;映射&lt;/h4&gt;
&lt;h5&gt;map(Function f)&lt;/h5&gt;
&lt;p&gt;接收一个函数作为参数将元素转化为其他形式提取信息（类比于add）&lt;/p&gt;
&lt;p&gt;将List中字符串大写&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;List&amp;lt;String&amp;gt; list = Arrays.asList(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;, &quot;dd&quot;);
Stream&amp;lt;String&amp;gt; stream = list.stream();
stream.map(str -&amp;gt; str.toUpperCase()).forEach(System.out :: println);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;过滤出名字长度大于2的名字（先用map取出name，再用filter过滤）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Employee&amp;gt; stream = list.stream();
stream.map(e -&amp;gt; e.name).filter(str -&amp;gt; str.length() &amp;gt; 2).forEach(System.out :: println);
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;flatMap(Function f)&lt;/h5&gt;
&lt;p&gt;将流中的每一个值都换成另一个流，再将所有的流连接成一个流（类比于addALL）&lt;/p&gt;
&lt;p&gt;和上面的map相比将每个元素取出，转换后再连接&lt;/p&gt;
&lt;p&gt;在对于集合里面嵌套集合的时候使用方便&lt;/p&gt;
&lt;h4&gt;排序&lt;/h4&gt;
&lt;h5&gt;sorted()&lt;/h5&gt;
&lt;p&gt;产生一个新流，其中按自然顺序排序（对于实现Comparable接口的对象可以使用）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Employee&amp;gt; stream = list.stream();
stream.sorted().forEach(System.out :: println);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;按照类中的接口方法排序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
public int compareTo(Object o) {
    Employee e = (Employee) o;
    return this.age - e.age;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;sorted(Comparator com)&lt;/h5&gt;
&lt;p&gt;产生一个新流，其中按比较器顺序排序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Employee&amp;gt; stream = list.stream();
stream.sorted(
        (e1, e2) -&amp;gt; {
            return e1.age - e2.age;
        }
).forEach(System.out :: println);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Stream终止操作&lt;/h3&gt;
&lt;h4&gt;匹配查找&lt;/h4&gt;
&lt;p&gt;allMatch&lt;/p&gt;
&lt;p&gt;检查是否匹配所有元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Employee&amp;gt; stream = list.stream();
boolean b = stream.allMatch(e -&amp;gt; e.age &amp;gt; 15);
System.out.println(b);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;anyMatch&lt;/p&gt;
&lt;p&gt;检查一个匹配&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Employee&amp;gt; stream = list.stream();
boolean b = stream.allMatch(e -&amp;gt; e.age &amp;gt; 15);
System.out.println(b);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;noneMatch&lt;/p&gt;
&lt;p&gt;检查是否没有匹配元素，例如是否有员工姓“尚”&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Employee&amp;gt; stream = list.stream();
boolean b = stream.noneMatch(e -&amp;gt; e.name.startsWith(&quot;尚&quot;));
System.out.println(b);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;findFirst&lt;/p&gt;
&lt;p&gt;返回第一个元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Employee&amp;gt; stream = list.stream();
Optional&amp;lt;Employee&amp;gt; first = stream.findFirst();
System.out.println(first);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;findAny&lt;/p&gt;
&lt;p&gt;返回任意一个元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Employee&amp;gt; stream = list.stream();
Optional&amp;lt;Employee&amp;gt; first = stream.findAny();
System.out.println(first);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;count&lt;/p&gt;
&lt;p&gt;求个数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Employee&amp;gt; stream = list.stream();
long count = stream.count();
System.out.println(count);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;min&lt;/p&gt;
&lt;p&gt;返回元素最小值（要求传入Comparator）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Employee&amp;gt; stream = list.stream();
Optional&amp;lt;Employee&amp;gt; min = stream.min(
        (e1, e2) -&amp;gt; {
            return e1.age - e2.age;
        }
);
System.out.println(min);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;max&lt;/p&gt;
&lt;p&gt;返回元素最大值（要求传入Comparator）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Optional&amp;lt;Employee&amp;gt; max = stream.max(
        (e1, e2) -&amp;gt; {
            return e1.age - e2.age;
        }
);
System.out.println(max);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;forEach&lt;/p&gt;
&lt;p&gt;内部迭代&lt;/p&gt;
&lt;p&gt;传入Consumer c，以下是经典的输出遍历&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Employee&amp;gt; stream = list.stream();
stream.forEach(System.out :: println);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;规约&lt;/h4&gt;
&lt;p&gt;reduce(T identity, BinaryOperator)&lt;/p&gt;
&lt;p&gt;可以将流中的元素反复结合起来，得到一个值，返回这个值&lt;/p&gt;
&lt;p&gt;计算1-10的和（其中0为初始值）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Stream1 {
    public static void main(String[] args) {
        List&amp;lt;Integer&amp;gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        Integer reduce = list.stream().reduce(0, (i1, i2) -&amp;gt; i1 + i2);
        //Integer reduce = list.stream().reduce(0, Integer::sum);
        System.out.println(reduce);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;reduce(BinaryOperator)&lt;/p&gt;
&lt;p&gt;计算所有员工年龄总和&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Employee&amp;gt; stream = list.stream();
Optional&amp;lt;Integer&amp;gt; reduce = stream.map(e -&amp;gt; e.age).reduce(Integer::sum);
System.out.println(reduce);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;收集&lt;/h4&gt;
&lt;p&gt;collect(Collector c)&lt;/p&gt;
&lt;p&gt;将流转换为其他形式，接收一个Collector接口的实现，用于给Stream中元素做汇总的方法&lt;/p&gt;
&lt;p&gt;放入List中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;List&amp;lt;Employee&amp;gt; collect = stream.sorted(
        (e1, e2) -&amp;gt; {
            return e1.age - e2.age;
        }
).collect(Collectors.toList());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;放入Set中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Set&amp;lt;Employee&amp;gt; collect = stream.sorted(
        (e1, e2) -&amp;gt; {
            return e1.age - e2.age;
        }
).collect(Collectors.toSet());
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Optional类&lt;/h2&gt;
&lt;h3&gt;基本介绍&lt;/h3&gt;
&lt;p&gt;之前在使用Stream API的时候使用到了Optional类来存储流输出的对象&lt;/p&gt;
&lt;p&gt;Optional&amp;lt;T&amp;gt;是一个容器类，他可以保存类型T的值，代表这个值存在，或者保存null，表示这个值不存在&lt;/p&gt;
&lt;p&gt;原本的null表示一个值不存在，现在Optional可以更好地表示这个概念，并避免空指针异常&lt;/p&gt;
&lt;p&gt;Optional类的Javadoc描述如下：这是一个可以为null的容器对象，如果值存在则isPresent()方法返回true，调用get()方法会返回该对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public final class Optional&amp;lt;T&amp;gt; {
    private static final Optional&amp;lt;?&amp;gt; EMPTY = new Optional&amp;lt;&amp;gt;();
    private final T value;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;相关方法&lt;/h3&gt;
&lt;h4&gt;创建方法&lt;/h4&gt;
&lt;p&gt;Optional.of(T t)&lt;/p&gt;
&lt;p&gt;创建一个Optional实例，t必须非空&lt;/p&gt;
&lt;p&gt;Optional.empty()&lt;/p&gt;
&lt;p&gt;创建一个空的Optional实例&lt;/p&gt;
&lt;p&gt;Optional.ofNullable(T t)&lt;/p&gt;
&lt;p&gt;创建一个Optional实例，t可以为空&lt;/p&gt;
&lt;h4&gt;判断包含&lt;/h4&gt;
&lt;p&gt;boolean isPresent()&lt;/p&gt;
&lt;p&gt;判断是否包含对象&lt;/p&gt;
&lt;p&gt;void isPresent(Consumer&amp;lt;? super T&amp;gt; consumer)&lt;/p&gt;
&lt;p&gt;如果包含对象，就执行Consumer接口的实现代码，并且将该值作为参数传递给它&lt;/p&gt;
&lt;h4&gt;获取对象&lt;/h4&gt;
&lt;p&gt;T get()&lt;/p&gt;
&lt;p&gt;如果调用对象包含值，则返回该值，否则抛出异常&lt;/p&gt;
&lt;p&gt;T orElse(T other)&lt;/p&gt;
&lt;p&gt;如果有值则将其返回，否则返回指定的other对象&lt;/p&gt;
&lt;p&gt;T orElseGet(Supplier&amp;lt;? extends T&amp;gt; other)&lt;/p&gt;
&lt;p&gt;如果有值则返回，否则调用Supplier接口实现提供的对象&lt;/p&gt;
&lt;p&gt;T orElse Throw(Supplier&amp;lt;? extends X exceptionSupplier&amp;gt;)&lt;/p&gt;
&lt;p&gt;如果有值则将其返回，否则抛出由Supplier接口实现提供的异常&lt;/p&gt;
&lt;h3&gt;代码示例&lt;/h3&gt;
&lt;p&gt;在没有Optional类的时候，我们需要通过if判断语句判断对象不为空，再去调用方法，防止空指针异常，我们在学了Optional类后我们就可以用Optional去包装类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Optional&amp;lt;Employee&amp;gt; optional = Optional.of(new Employee(&quot;李&quot;, 10));
optional.orElse(new Employee(&quot;王&quot;, 10)).toString();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果没有数据，就用新创建的Employee，调用相关方法&lt;/p&gt;
&lt;p&gt;Optional其实在实际使用上没有多少的内容，主要是有一些底层框架上会使用到Optional来返回结果，懂得如何操作数据对象，看得懂相关操作即可。&lt;/p&gt;
</content:encoded></item><item><title>JDBC笔记</title><link>https://thrinisty.github.io/posts/jdbc%E7%AC%94%E8%AE%B0%E6%89%B9%E5%A4%84%E7%90%86%E8%BF%9E%E6%8E%A5%E6%B1%A0dbutilsbasicdao/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/jdbc%E7%AC%94%E8%AE%B0%E6%89%B9%E5%A4%84%E7%90%86%E8%BF%9E%E6%8E%A5%E6%B1%A0dbutilsbasicdao/</guid><description>批处理，连接池，DBUtils，BasicDao</description><pubDate>Fri, 18 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;JDBC笔记&lt;/h1&gt;
&lt;h2&gt;批处理&lt;/h2&gt;
&lt;h3&gt;基本介绍&lt;/h3&gt;
&lt;p&gt;1.当需要成批插入或者更新记录的时候，可以使用Java批处理，这一机制允许多条语句一次性提交给数据库批量处理，通常情况下比单独提交更有效率&lt;/p&gt;
&lt;p&gt;2.JDBC的批量处理语句包括了以下的方法&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方法名称&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;addBatch&lt;/td&gt;
&lt;td&gt;添加需要批量处理的SQL语句或者参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;executeBatch&lt;/td&gt;
&lt;td&gt;执行批量处理语句&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;clearBatch&lt;/td&gt;
&lt;td&gt;清空批处理包的语句&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;3.JDBC连接MySQL时，如果要使用批处理，需要在url中添加参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;?rewriteBatchedStatements=true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.批处理往往与PreparedStatement一起搭配使用，可以及减少编译次数又减少运行次数，效率大大提升&lt;/p&gt;
&lt;h3&gt;传统的添加方式&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;public class Test {
    @SuppressWarnings ({&quot;all&quot;})
    public static void main(String[] args) throws Exception{
        Connection connection = JDBCUtils.getConnection();
        String sql = &quot;insert into balance values (?,?,?)&quot;;
        PreparedStatement statement = connection.prepareStatement(sql);

        for (int i = 1; i &amp;lt; 1000; i++) {
            statement.setInt(1, i);
            statement.setString(2, &quot;TomCat&quot;);
            statement.setDouble(3, i * 2);
            statement.executeUpdate();
        }
        JDBCUtils.close(null, statement, connection);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;耗时还是挺久的大概6、7秒钟完成，感兴趣可以输出运行时间测试一下&lt;/p&gt;
&lt;h3&gt;批处理运行&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;public class Test {
    @SuppressWarnings ({&quot;all&quot;})
    public static void main(String[] args) throws Exception{
        Connection connection = JDBCUtils.getConnection();
        String sql = &quot;insert into balance values (?,?,?)&quot;;
        PreparedStatement statement = connection.prepareStatement(sql);

        for (int i = 1; i &amp;lt; 1000; i++) {
            statement.setInt(1, i);
            statement.setString(2, &quot;TomCat&quot;);
            statement.setDouble(3, i * 2);
            statement.addBatch();
            if((i + 1) % 1000 == 0) {
                statement.executeBatch();
                statement.clearBatch();
            }
        }
        JDBCUtils.close(null, statement, connection);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意在JDBCUtils工具类中的url添加相关参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;String url = agreement + &quot;//&quot; + address + &quot;:&quot; + port + &quot;/&quot; + dataBase + &quot;?rewriteBatchedStatements=true&quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运用批处理在处理大量的SQL语句的时候，速度相较于单条执行要快很多，大概的用时只需要1、2秒钟&lt;/p&gt;
&lt;h2&gt;连接池&lt;/h2&gt;
&lt;h3&gt;连接池的引入&lt;/h3&gt;
&lt;p&gt;在传统的连接方式中往往程序和数据库进行网络的连接是多次的，这张方式的连接数上限往往是有限制的，在太多的连接的时候和数据库连接取得Connection的时候会抛出Too many connection的异常，就算及时关闭连接，连接的时长也会很长&lt;/p&gt;
&lt;p&gt;问题分析&lt;/p&gt;
&lt;p&gt;1.传统的JDBC数据库连接使用DriverManager来获取，每一次向数据库建立连接的时候都要将Connection加载到内存中，再验证IP地址，用户名，密码（0.05-1s）。需要数据库链接的时候，就会向数据库要求一个，频繁的进行数据库连接操作将占用很多的系统资源，容易造成服务器崩溃&lt;/p&gt;
&lt;p&gt;2.每一次数据库连接，使用完后都得断开，如果程序出现异常未能关闭，将导致数据库内存泄漏，最终导致重启数据库&lt;/p&gt;
&lt;p&gt;3.传统获取连接的方式，不能控制创建的连接数量，如果连接过多，也可能导致内存泄漏，数据库崩溃&lt;/p&gt;
&lt;p&gt;4.解决传统开发中的数据库连接问题，可以采用数据库连接池技术（connection pool）&lt;/p&gt;
&lt;h3&gt;基本介绍&lt;/h3&gt;
&lt;p&gt;1.预先在缓冲池中放入一定数量的连接，当需要建立数据据库连接的时候，只需要从缓冲池中取出连接，使用完毕的时候再将连接放回缓冲池中即可&lt;/p&gt;
&lt;p&gt;2.数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用现有的数据库连接，而不是重新建立一个&lt;/p&gt;
&lt;p&gt;3.当应用程序向连接池请求的连接数超过最大连接数的时候，这些请求将被添加入等待队列&lt;/p&gt;
&lt;h3&gt;数据库连接池种类&lt;/h3&gt;
&lt;p&gt;1.JDBC的数据库连接池使用javax.sql.DataSource表示，DataSource是一个接口，通常由第三方来实现&lt;/p&gt;
&lt;p&gt;2.&lt;strong&gt;C3P0&lt;/strong&gt;数据库连接池，速度相对较慢，但是稳定性不错（hibernate，spring）&lt;/p&gt;
&lt;p&gt;3.DBCP数据库连接池，速度相比于C3P0较快，但是不稳定&lt;/p&gt;
&lt;p&gt;4.Proxool数据库连接处，有监控连接池状态的功能，稳定性较C3P0差一点&lt;/p&gt;
&lt;p&gt;5.BoneCP数据库连接池，速度快&lt;/p&gt;
&lt;p&gt;6.&lt;strong&gt;Druid&lt;/strong&gt;（德鲁伊）是由阿里提供的数据库连接池，集以上（C3P0、DBCP、Proxool）数据库优点于一体的数据库连接池&lt;/p&gt;
&lt;p&gt;C3P0和德鲁伊连接池是目前经常会使用的连接池，我们接下来使用的也是这两个&lt;/p&gt;
&lt;h3&gt;C3P0连接池&lt;/h3&gt;
&lt;p&gt;注意在连接池中的close不是指的是将连接断开，而是将连接放回到连接池中，供下一个getConnection使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void test01() throws Exception{
    ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource();
    String agreement = &quot;jdbc:mysql:&quot;;
    String address = &quot;localhost&quot;;
    String port = &quot;3306&quot;;
    String dataBase = &quot;jdbc&quot;;
    String url = agreement + &quot;//&quot; + address + &quot;:&quot; + port + &quot;/&quot; + dataBase;
    String user = &quot;root&quot;;
    String password = &quot;654321&quot;;
    String driver = &quot;com.mysql.cj.jdbc.Driver&quot;;

    //设置连接池基础信息
    comboPooledDataSource.setDriverClass(driver);
    comboPooledDataSource.setJdbcUrl(url);
    comboPooledDataSource.setUser(user);
    comboPooledDataSource.setPassword(password);

    //初始化连接数
    comboPooledDataSource.setInitialPoolSize(10);
    comboPooledDataSource.setMaxPoolSize(50);

    //从连接池中获取连接
    Connection connection = comboPooledDataSource.getConnection();
    connection.close();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果通过这种方式创建连接相比于JDBC的从DriverManager获取连接要快很多&lt;/p&gt;
&lt;p&gt;除此之外你还可以使用配置文件设置连接池的基础信息（在创建连接池对象的时候指定配置文件参数），感兴趣的可以下去了解&lt;/p&gt;
&lt;h3&gt;Druid连接池&lt;/h3&gt;
&lt;h4&gt;连接池基本配置&lt;/h4&gt;
&lt;p&gt;我们在使用Druid连接池的时候需要使用到配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 数据库连接配置
driverClassName=com.mysql.cj.jdbc.Driver
url=jdbc:mysql://localhost:3306/tableselect?useSSL=false&amp;amp;serverTimezone=UTC&amp;amp;characterEncoding=utf8
username=root
password=654321

# 连接池核心参数
initialSize=10
maxActive=50
minIdle=5
maxWait=60000
#maxWait指的是等待队列中最长的等待时间
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;连接池使用&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class Druid_ {
    public static void main(String[] args) throws Exception {
        testDruid();
    }

    public static void testDruid() throws Exception {
        Properties properties = new Properties();
        properties.load(new FileInputStream(&quot;src\\druid.properties&quot;));
        //创建连接池对象
        DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);
        //过去Connection连接
        Connection connection = dataSource.getConnection();
        connection.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Druid速度非常快，目前而言能用Druid尽量别用C3P0，除非要进行兼容&lt;/p&gt;
&lt;h4&gt;工具类封装&lt;/h4&gt;
&lt;p&gt;便于使用者使用，我们将德鲁伊连接池做成一个工具类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.utils;
import com.alibaba.druid.pool.DruidDataSourceFactory;
import javax.sql.DataSource;
import java.io.FileInputStream;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Properties;

public class JDBCUtilsDruid {
    private static DataSource ds;

    static {
        Properties properties = new Properties();
        try {
            properties.load(new FileInputStream(&quot;src\\druid.properties&quot;));
            ds = DruidDataSourceFactory.createDataSource(properties);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    public static Connection getConnection() {
        try {
            return ds.getConnection();
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    public static void close(ResultSet result, Statement statement, Connection connection) {
        try {
            if (result != null) {
                result.close();
            }
            if (statement != null) {
                statement.close();
            }
            if (connection != null) {
                connection.close();
            }
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用测试方法调用，这样做会方便很多&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void testUtils() {
    Connection connection = JDBCUtilsDruid.getConnection();
    JDBCUtilsDruid.close(null, null, connection);
    //这里用的是工具类的close方法
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再多说一嘴，其实这种情况下使用connection.close()方法关闭连接也没有问题，因为通过动态绑定机制，connection实际上调用的是德鲁伊的close方法。这个方法和通过DriverManager创建的连接调用的close方法有本质的区别，不会将链接关闭，而是将连接放回连接池中&lt;/p&gt;
&lt;h2&gt;DBUtils&lt;/h2&gt;
&lt;h3&gt;问题引出&lt;/h3&gt;
&lt;p&gt;当我们关闭connection后，resultSet结果集无法使用（二者相关联），而有的时候我们需要复用resultSet中的数据，关闭connection后任需要结果集&lt;/p&gt;
&lt;p&gt;resultSet不利于数据的管理，使用起来也不太方便，这个时候我们需要再Java程序中创建一个类（JavaBean）与数据库的记录做一个映射，再创建一个结果集记录封装在ArrayList&amp;lt;JavaBean&amp;gt;下，每一个集合元素对应一条记录&lt;/p&gt;
&lt;p&gt;这样的话我们使用类来获取数据就会方便一些，而且生命期更加持久，可以在不用的时候再将ArrayList集合对象释放（以上的思路可以去自己实现，以下是一个Apache提供的一个工具类，相比于自己写的更加完善方便）&lt;/p&gt;
&lt;h3&gt;commons-dbutils&lt;/h3&gt;
&lt;h4&gt;基本介绍&lt;/h4&gt;
&lt;p&gt;commons-dbutils是Apache组织提供的一个开源JDBC工具类库，它是对JDBC的封装，使用dbutils可以极大地简化JDBC编码的工作量&lt;/p&gt;
&lt;h4&gt;DBUtils类&lt;/h4&gt;
&lt;p&gt;1.QueryRunner类：该类封装了SQL的执行，是线程安全的，可以实现增删改查，批处理&lt;/p&gt;
&lt;p&gt;2.ResultSetHandler接口：该接口用于处理ResultSet，将数据按要求转化为另一种形式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/123.png&quot; alt=&quot;123&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;构造返回记录类型&lt;/h4&gt;
&lt;p&gt;要使这个自动映射正常工作，&lt;code&gt;Balance&lt;/code&gt;类需要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是一个标准的JavaBean（有无参构造函数）&lt;/li&gt;
&lt;li&gt;有与数据库列名对应的属性&lt;/li&gt;
&lt;li&gt;有这些属性的setter方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;构造一个Balance接收返回结果的类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Balance {
    private int id;
    private String name;
    private String money;
    public Balance(){}

    @Override
    public String toString() {
        return id + &quot; &quot; + name + &quot; &quot; + money;
    }

    public void setId(int id) {
        this.id = id;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setMoney(String money) {
        this.money = money;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;查询结果&lt;/h4&gt;
&lt;p&gt;利用QueryRunner对象查询数据库返回结果&lt;/p&gt;
&lt;p&gt;返回单条单列的记录（返回一个Object对象）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Druid_ {
    public static void main(String[] args) throws Exception {
        Connection connection = JDBCUtilsDruid.getConnection();
        QueryRunner queryRunner = new QueryRunner();
        //通过使用queryRunner就可以查询数据库，返回结果
        String sql = &quot;select `name` from balance where id = ?;&quot;;
        String name = (String) queryRunner.query(connection, sql, new ScalarHandler(), 100);
        System.out.println(name);
        connection.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;返回单条记录（返回一个对应的Balance对象）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Druid_ {
    public static void main(String[] args) throws Exception {
        Connection connection = JDBCUtilsDruid.getConnection();
        QueryRunner queryRunner = new QueryRunner();
        //通过使用queryRunner就可以查询数据库，返回结果
        String sql = &quot;select * from balance where id = ?;&quot;;
        Balance balance = queryRunner.query(connection, sql, new BeanHandler&amp;lt;&amp;gt;(Balance.class), 100);
        System.out.println(balance);
        connection.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;返回多条结果（返回一个存放了Balance对象的ArrayList）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Druid_ {
    public static void main(String[] args) throws Exception {
        Connection connection = JDBCUtilsDruid.getConnection();
        QueryRunner queryRunner = new QueryRunner();
        //通过使用queryRunner就可以查询数据库，返回结果
        String sql = &quot;select * from balance where id = ? or id = ?;&quot;;
        List&amp;lt;Balance&amp;gt; list = queryRunner.query(connection, sql, new BeanListHandler&amp;lt;&amp;gt;(Balance.class), 100, 200);
        //这里的100和200是可变参数，代表填入的替换？的内容
        Iterator&amp;lt;Balance&amp;gt; iterator = list.iterator();
        while(iterator.hasNext()) {
            Balance balance = iterator.next();
            System.out.println(balance);
        }
        connection.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果步入源码中我们可以发现在query方法执行获取ArrayList结果集的过程中用到的Statement和ResultSet就已经被关闭&lt;/p&gt;
&lt;p&gt;而返回的结果类型取决于第三个参数的类型，其中result返回结果底层运用到了泛型来确定result的返回类型（更具不同的参数类型有不同的处理逻辑）&lt;/p&gt;
&lt;h4&gt;增删改&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class Druid_ {
    public static void main(String[] args) throws Exception {
        Connection connection = JDBCUtilsDruid.getConnection();
        QueryRunner queryRunner = new QueryRunner();
        //通过使用queryRunner就可以查询数据库，返回结果
        String sql = &quot;insert into balance values (300, &apos;Tom&apos;, 4000), (400, &apos;King&apos;, 5000);&quot;;
        int update = queryRunner.update(connection, sql);
        System.out.println(update);
        connection.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public class Druid_ {
    public static void main(String[] args) throws Exception {
        Connection connection = JDBCUtilsDruid.getConnection();
        QueryRunner queryRunner = new QueryRunner();
        //通过使用queryRunner就可以查询数据库，返回结果
        String sql = &quot;delete from balance;&quot;;
        int update = queryRunner.update(connection, sql);
        System.out.println(update);
        connection.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public class Druid_ {
    public static void main(String[] args) throws Exception {
        Connection connection = JDBCUtilsDruid.getConnection();
        QueryRunner queryRunner = new QueryRunner();
        //通过使用queryRunner就可以查询数据库，返回结果
        String sql = &quot;update balance set name = &apos;Cat&apos;&quot;;
        int update = queryRunner.update(connection, sql);
        //返回的结果是受影响的行数
        System.out.println(update);//2
        connection.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;BasicDao&lt;/h2&gt;
&lt;h3&gt;问题引出&lt;/h3&gt;
&lt;p&gt;1.SQL语句是固定的，不可以通过参数传入，使用起来不灵活&lt;/p&gt;
&lt;p&gt;2.对于select操作，返回类型不确定，需要使用到泛型&lt;/p&gt;
&lt;p&gt;3.对于很多表而言，业务负责不可能单靠一个Java类完成&lt;/p&gt;
&lt;h3&gt;Dao&lt;/h3&gt;
&lt;p&gt;data access object 数据访问对象&lt;/p&gt;
&lt;p&gt;我们对于每一个表都会有相应的操作，我们可以将这一些操作的共有部分提到BasicDao中，这样做可以简化代码，维护可读性&lt;/p&gt;
&lt;p&gt;1.这样的通用类我们称为BasicDao，是专门和数据库交互的，即完成数据库的增删改查操作&lt;/p&gt;
&lt;p&gt;2.再BasicDao的基础上，实现一张表对应一个Dao，可以更好的完成功能&lt;/p&gt;
&lt;p&gt;接下来我们就通过代码实际实现Dao&lt;/p&gt;
&lt;h3&gt;Dao实现&lt;/h3&gt;
&lt;p&gt;设计com.dao&lt;/p&gt;
&lt;h4&gt;com.dao.utils&lt;/h4&gt;
&lt;p&gt;工具类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class JDBCUtilsDruid {
    private static DataSource ds;

    static {
        Properties properties = new Properties();
        try {
            properties.load(new FileInputStream(&quot;src\\druid.properties&quot;));
            ds = DruidDataSourceFactory.createDataSource(properties);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    public static Connection getConnection() {
        try {
            return ds.getConnection();
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    public static void close(ResultSet result, Statement statement, Connection connection) {
        try {
            if (result != null) {
                result.close();
            }
            if (statement != null) {
                statement.close();
            }
            if (connection != null) {
                connection.close();
            }
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;com.dao.domain&lt;/h4&gt;
&lt;p&gt;javabean&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Balance {
    private int id;
    private String name;
    private String money;
    public Balance(){}

    @Override
    public String toString() {
        return id + &quot; &quot; + name + &quot; &quot; + money;
    }

    public void setId(int id) {
        this.id = id;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setMoney(String money) {
        this.money = money;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;com.dao.dao&lt;/h4&gt;
&lt;p&gt;存放BasicDao&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class BasicDao&amp;lt;T&amp;gt; {//使用泛型指定具体类型
    private QueryRunner qr = new QueryRunner();

    //开发通用的dml方法，针对任意的表
    public int update(String sql, Object... parameters) {
        Connection connection = null;
        try {
            connection = JDBCUtilsDruid.getConnection();
            return qr.update(connection, sql, parameters);
            //返回受影响的行数，执行语句
        } catch (Exception e) {
            throw new RuntimeException(e);
        } finally {
            JDBCUtilsDruid.close(null, null, connection);
        }
    }

    //返回对个查询对象
    public List&amp;lt;T&amp;gt; queryMulti(String sql, Class&amp;lt;T&amp;gt; cls, Object... parameters) {
        Connection connection = null;
        try {
            connection = JDBCUtilsDruid.getConnection();
            return qr.query(connection, sql, new BeanListHandler&amp;lt;T&amp;gt;(cls), parameters);
        } catch (Exception e) {
            throw new RuntimeException(e);
        } finally {
            JDBCUtilsDruid.close(null, null, connection);
        }
    }

    //返回查询单行结果
    public T querySingle(String sql, Class&amp;lt;T&amp;gt; cls, Object... parameters) {
        Connection connection = null;
        try {
            connection = JDBCUtilsDruid.getConnection();
            return qr.query(connection, sql, new BeanHandler&amp;lt;T&amp;gt;(cls), parameters);
        } catch (Exception e) {
            throw new RuntimeException(e);
        } finally {
            JDBCUtilsDruid.close(null, null, connection);
        }
    }

    //查询单行单列的方法
    public Object queryScalar(String sql, Object... parameters) {
        Connection connection = null;
        try {
            connection = JDBCUtilsDruid.getConnection();
            return qr.query(connection, sql, new ScalarHandler(), parameters);
        } catch (Exception e) {
            throw new RuntimeException(e);
        } finally {
            JDBCUtilsDruid.close(null, null, connection);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来我们根据BasicDao来开发针对于balance表的Dao，制定了前面我们设计的BasicDao的泛型T为Balance类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class BalanceDao extends BasicDao&amp;lt;Balance&amp;gt;{
    //拥有BasicDao方法
    //除此之外还可以自定义其他的方法
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看出在没有特殊要求的情况下，我们只需要在继承的时候指定泛型类型即可创建出新的对应表Dao，非常的方便&lt;/p&gt;
&lt;h4&gt;com.dao.test&lt;/h4&gt;
&lt;p&gt;测试类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class TestDao {
    public static void main(String[] args) {
        BalanceDao balanceDao = new BalanceDao();

        String sql = &quot;select * from balance&quot;;
        List&amp;lt;Balance&amp;gt; balances = balanceDao.queryMulti(sql, Balance.class);
        for(Balance balance : balances) {
            System.out.println(balance);
        }

        sql = &quot;select * from balance where id = ?&quot;;
        Balance balance = balanceDao.querySingle(sql, Balance.class, 100);
        System.out.println(balance);

        sql = &quot;select name from balance where id = 100&quot;;
        String name =(String) balanceDao.queryScalar(sql);
        System.out.println(name);

        sql = &quot;insert into balance values (300, &apos;Tom&apos;, 4000), (400, &apos;King&apos;, 5000);&quot;;
        int update = balanceDao.update(sql);
        System.out.println(update);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看的出来还是非常方便的啊&lt;/p&gt;
&lt;h4&gt;补充&lt;/h4&gt;
&lt;p&gt;其实你要在方便一点（不想要传入Balance.class）的话还可以在BasicDao中用反射获取T类对象，将类对象传入&lt;/p&gt;
&lt;h1&gt;JDBC结语&lt;/h1&gt;
&lt;p&gt;两天的时间，学的还是挺快的，过了一遍代码，学会了使用方式，对于JDBC，连接池，DB工具，自建BasicDao有了初步的认识，对于底层的代码看了一眼，不算完全掌握&lt;/p&gt;
&lt;p&gt;反思了以下自己泛型的部分掌握还不足，决定回宿舍复习一下泛型相关的内容&lt;/p&gt;
&lt;p&gt;明天打算开始Java8特性的学习，计划三天完成，估计我的有一个面试在三天之后，面试结束再决定Java8后学哪一个开发框架，在此之前先准备下面试，背下八股之类的&lt;/p&gt;
</content:encoded></item><item><title>JDBC笔记</title><link>https://thrinisty.github.io/posts/jdbc%E7%AC%94%E8%AE%B0%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%89%A7%E8%A1%8C%E5%AF%B9%E8%B1%A1sql%E6%B3%A8%E5%85%A5%E5%B0%81%E8%A3%85%E4%BA%8B%E5%8A%A1/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/jdbc%E7%AC%94%E8%AE%B0%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%89%A7%E8%A1%8C%E5%AF%B9%E8%B1%A1sql%E6%B3%A8%E5%85%A5%E5%B0%81%E8%A3%85%E4%BA%8B%E5%8A%A1/</guid><description>快速入门，执行对象，SQL注入，封装，事务</description><pubDate>Thu, 17 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;JDBC笔记&lt;/h1&gt;
&lt;h2&gt;JDBC&lt;/h2&gt;
&lt;p&gt;JDBC是JAVA程序操作数据库的一种技术，在绝大多数的框架中JDBC一般都被封装在了各式各样的框架之中，这些框架之后也会学习。但是掌握JDBC是如何连接数据库，操作数据库，返回数据库结果，使用数据库返回结果这也是一个后端开发者应该掌握的基础，掌握了之后对后续框架的理解也是一种帮助&lt;/p&gt;
&lt;p&gt;Java对于各大数据库厂商提供了一个连接操作的统一接口，其中定义的方法包括了连接、curd、关闭连接等。而数据库工资负责实现这一些接口，方便Java的开发者利用数据库接口去创建对应数据库实例的创建，再通过动态绑定机制调用数据库实现的相关方法，以下是一个代码示例方便理解（仅仅是模拟，不代表实际开发）&lt;/p&gt;
&lt;p&gt;Java数据库接口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface JdbcInterface {
    public Object getConnection();
    public void crud();
    public void close();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;数据库实现接口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class MysqlJdbcImpl implements JdbcInterface{
    @Override
    public Object getConnection() {
        System.out.println(&quot;连接数据库&quot;);
        return null;
    }

    @Override
    public void crud() {
        System.out.println(&quot;增删改查&quot;);
    }

    @Override
    public void close() {
        System.out.println(&quot;关闭数据库&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在实际操作的时候可以创建数据库的对象实例，再调用相关方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test {
    public static void main(String[] args) {
        JdbcInterface jdbc = new MysqlJdbcImpl();
        jdbc.getConnection();
        jdbc.crud();
        jdbc.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这也是接口编程的一个极大优势，无需要更改接口定义，只需要让各自的工具实现公开的接口，就可以完成调用&lt;/p&gt;
&lt;h2&gt;JDBC快速入门&lt;/h2&gt;
&lt;p&gt;其中我们要用到的有两个包，一个是 java.sql 另一个是 javax.sql&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/121.png&quot; alt=&quot;121&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/122.png&quot; alt=&quot;122&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;JDBC编写的步骤&lt;/h3&gt;
&lt;p&gt;1.注册驱动-加载Driver类&lt;/p&gt;
&lt;p&gt;2.获取连接-得到Connection&lt;/p&gt;
&lt;p&gt;3.执行增删改查-执行sql语句&lt;/p&gt;
&lt;p&gt;4.释放资源-关闭释放&lt;/p&gt;
&lt;h3&gt;程序示例&lt;/h3&gt;
&lt;p&gt;我们通过jdbc对dept表进行增删改查操作&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE dept ( 
`deptno` INT, 
`dname` VARCHAR ( 30 ), 
`loc` VARCHAR ( 30 ) 
);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;INSERT INTO dept
VALUES
	( 10, &apos;ACCOUNTING&apos;, &apos;NEW YORK&apos; ),
	( 20, &apos;RESEARCH&apos;, &apos;DALLAS&apos; ),
	( 30, &apos;SALES&apos;, &apos;CHICAGO&apos; ),
	( 40, &apos;OPERATIONS&apos;, &apos;BOSTON&apos; );
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们首先需要对于项目安装驱动详细内容见教程&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/pan_junbiao/article/details/86626741&lt;/p&gt;
&lt;p&gt;将得到的驱动添加到库中&lt;/p&gt;
&lt;p&gt;在引入包的时候注意版本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import com.mysql.cj.jdbc.Driver;  // MySQL 8.x
// 或
import com.mysql.jdbc.Driver;     // MySQL 5.x
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public class JDBC01 {
    public static void main(String[] args) throws SQLException {
        //将驱动文件添加入库
        //1.注册驱动-加载Driver类
        Driver driver = new Driver();

        //2.获取连接-得到Connection
        String agreement = &quot;jdbc:mysql:&quot;;
        String address = &quot;localhost&quot;;
        String port = &quot;3306&quot;;
        String dataBase = &quot;jdbc&quot;;
        String url = agreement + &quot;//&quot; + address + &quot;:&quot; + port + &quot;/&quot; + dataBase;
        //将用户密码放入properties
        Properties properties = new Properties();
        properties.setProperty(&quot;user&quot;, &quot;root&quot;);
        properties.setProperty(&quot;password&quot;, &quot;654321&quot;);
        Connection connect = driver.connect(url, properties);

        //3.执行增删改查-执行sql语句
        String sql = &quot;INSERT INTO dept VALUES (10,&apos;ACCOUNTING&apos;,&apos;NEW YORK&apos;);&quot;;
        //创建一个Statement对象
        Statement statement = connect.createStatement();
        int rows = statement.executeUpdate(sql);
        //返回生效的行数，这个时候返回1代表成功
        System.out.println(rows &amp;gt; 0 ? &quot;success&quot; : &quot;fail&quot;);

        //4.释放资源-关闭释放
        statement.close();
        connect.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看数据库发现数据库中成功的添加了相关数据&lt;/p&gt;
&lt;h4&gt;动态加载&lt;/h4&gt;
&lt;p&gt;其实上述的代码中的静态加载方式可以改进为利用反射动态链接，可以更加灵活&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Class&amp;lt;?&amp;gt; cls = Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);
Driver driver = (Driver)cls.newInstance();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而且通过动态加载，我们实际上可以不用创建Driver实例加载，因为静态代码块在类加载的时候，底层以及将Driver驱动已经帮我们加载好了&lt;/p&gt;
&lt;h4&gt;DriverManager&lt;/h4&gt;
&lt;p&gt;用DriverManager替代Manager，好处是不用Properties以及扩展性好一点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;String user = &quot;root&quot;;
String password = &quot;654321&quot;;
DriverManager.registerDriver(driver);
Connection connect = DriverManager.getConnection(url, user, password);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;综上所述，我们的代码可以更改为如下（推荐使用）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//1.注册驱动-加载Driver类
Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);

//2.获取连接-得到Connection
String agreement = &quot;jdbc:mysql:&quot;;
String address = &quot;localhost&quot;;
String port = &quot;3306&quot;;
String dataBase = &quot;jdbc&quot;;
String url = agreement + &quot;//&quot; + address + &quot;:&quot; + port + &quot;/&quot; + dataBase;

String user = &quot;root&quot;;
String password = &quot;654321&quot;;
Connection connect = DriverManager.getConnection(url, user, password);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;甚至在驱动更高级的版本（5.1.7）中你甚至可以不用Driver加载，但还是建议写上，避免多个驱动混用混乱&lt;/p&gt;
&lt;h4&gt;最终推荐的方案&lt;/h4&gt;
&lt;p&gt;我们除了使用动态加载驱动，用DriverManager管理连接，我们还可以将我们的连接数据库写的更加灵活一点，写一个配置文件，让程序从配置文件中读取连接对象，用户密码等&lt;/p&gt;
&lt;p&gt;配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;agreement=jdbc:mysql:
address=localhost
port=3306
dataBase=jdbc
user=root
password=654321
driver=com.mysql.cj.jdbc.Driver
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Java代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test {
    @SuppressWarnings ({&quot;all&quot;})
    public static void main(String[] args) throws Exception{
        Properties properties = new Properties();
        properties.load(new FileInputStream(&quot;src\\mysql.properties&quot;));
        String user = properties.getProperty(&quot;user&quot;);
        String password = properties.getProperty(&quot;password&quot;);
        String driver = properties.getProperty(&quot;driver&quot;);

        String agreement = properties.getProperty(&quot;agreement&quot;);
        String address = properties.getProperty(&quot;address&quot;);
        String port = properties.getProperty(&quot;port&quot;);
        String dataBase = properties.getProperty(&quot;dataBase&quot;);

        Class.forName(driver);
        String url = agreement + &quot;//&quot; + address + &quot;:&quot; + port + &quot;/&quot; + dataBase;
        Connection connection = DriverManager.getConnection(url, user, password);
        Statement statement = connection.createStatement();
        String sql = &quot;select deptno,dname,loc from dept&quot;;
        ResultSet resultSet = statement.executeQuery(sql);

        while(resultSet.next()) {
            int deptno = resultSet.getInt(1);
            String dname = resultSet.getString(2);
            String loc = resultSet.getString(3);
            System.out.println(deptno + &quot; &quot; + dname + &quot; &quot; + loc);
        }
        resultSet.close();
        statement.close();
        connection.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;结果集&lt;/h3&gt;
&lt;p&gt;我们在使用JDBC执行查询语句的时候需要用结果集ResultSet来存储返回的结果&lt;/p&gt;
&lt;p&gt;ResultSet表示数据库结果集数据表，通常由执行查询数据库的语句生成，ResultSet对象保持一个光标指向其当前行的数据行&lt;/p&gt;
&lt;p&gt;最初，光标只想第一行之前，next方法将光标指向下一行，并且在没有行的时候返回false，可以使用while循环来遍历结果集&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//3.执行增删改查-执行sql语句
//创建一个Statement对象
Statement statement = connect.createStatement();
String sql = &quot;select ename,job,deptno from emp&quot;;
//使用executeQuery返回结果集
ResultSet result = statement.executeQuery(sql);
//通过while循环输出结果集
while(result.next()) {
    String ename = result.getString(1);
    String job = result.getString(2);
    int deptno = result.getInt(3);
    System.out.println(ename + &quot;\t&quot; + job + &quot;\t&quot; + deptno);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SMITH	CLERK		20
ALLEN	SALESMAN	30
WARD	SALESMAN	30
JOOES	MANAGER		20
MARTIN	SALESMAN	30
BLAKE	MANAGER		30
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其实结果集的底层是一个ArrayList，包含了一个对象数组包含了各行的数据&lt;/p&gt;
&lt;h2&gt;执行对象&lt;/h2&gt;
&lt;h3&gt;基本介绍&lt;/h3&gt;
&lt;p&gt;1.Statement对象用于执行静态SQL语句并返回其生成的结果对象&lt;/p&gt;
&lt;p&gt;2.在建立连接后，需要对数据库进行访问，执行命令或者是SQL语句可以通过Statement PreparedStatement CallableStatement（依次继承前者）来完成&lt;/p&gt;
&lt;p&gt;3.Statement对象执行SQL语句，存在SQL注入风险&lt;/p&gt;
&lt;p&gt;4.SQL注入是利用某些系统没有对用户输入的数据进行充分的检查，在用户输入数据中注入非法的SQL语句段或者命令，以此恶意攻击数据库&lt;/p&gt;
&lt;p&gt;5.要防范SQL注入只要用PreparedStatement取代Statement即可&lt;/p&gt;
&lt;h3&gt;SQL注入&lt;/h3&gt;
&lt;p&gt;在历史中曾有运用SQL注入来攻破数据库的案例，例如如下是一个用户登陆的案例，我们需要使用用户名称以及用户密码来查找出用户用以登录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from admin where name = &apos;user&apos; and pwd = &apos;password&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中target用我们用户输入的内容替换，正常的情况中输入正确的用户以及密码即可找到对应的用户，但是通过SQL注入我们输入的用户密码如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;user = 1&apos; or
password = or &apos;1&apos; = &apos;1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将用户以及密码替换到数据库语句中就会发生以下情况&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from admin where name = &apos;1&apos; or&apos; and pwd = &apos;or &apos;1&apos; = &apos;1&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中&apos;1&apos; = &apos;1&apos;显然是满足条件的，以此我们得到了所有用户的记录，以下是一个代码示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;System.out.print(&quot;输入用户名称：&quot;);
String inputName = scanner.nextLine();
System.out.print(&quot;输入用户密码：&quot;);
String inputPwd = scanner.nextLine();
String sql = &quot;select id,name,pwd from admin where name = &apos;&quot; + inputName + &quot;&apos; and pwd = &apos;&quot; + inputPwd + &quot;&apos;;&quot;;
System.out.println(sql);
//使用executeQuery返回结果集
ResultSet result = statement.executeQuery(sql);
//通过while循环输出结果集
while(result.next()) {
    int id = result.getInt(1);
    String name = result.getString(2);
    String pwd = result.getString(3);

    System.out.println(id + &quot;\t&quot; + name + &quot;\t&quot; + pwd);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入用户名称：1&apos; or
输入用户密码：or &apos;1&apos; = &apos;1
select id,name,pwd from admin where name = &apos;1&apos; or&apos; and pwd = &apos;or &apos;1&apos; = &apos;1&apos;;
2	user1	password1
3	user2	password2
4	user3	password3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者你想要查看一个指定的用户（密码随意）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入用户名称：user2&apos; -- 
输入用户密码：123
select id,name,pwd from admin where name = &apos;user2&apos; -- &apos; and pwd = &apos;123&apos;;
3	user2	password2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是非常危险的，这个时候我们就需要使用到新的PreparedStatement对象来防止SQL注入的发生&lt;/p&gt;
&lt;h3&gt;PreparedStatement&lt;/h3&gt;
&lt;p&gt;1.PreparedStatement执行的SQL语句中的参数用?来表示，调用PreparedStatement对象的setXxx()方法来设置这些参数，setXxx()方法有两个参数，第一个参数是要设置的SQL语句中的参数的索引，从1开始，第二个是设置SQL语句中的参数值&lt;/p&gt;
&lt;p&gt;2.调用executeQuery() 返回ResultSet对象&lt;/p&gt;
&lt;p&gt;3.调用executeUpdate() 来执行增删改操作&lt;/p&gt;
&lt;p&gt;通过这样的对象我们不用+进行sql的拼接，减少语法错误的概率，还可以解决sql注入的问题，大大减少了编译的次数，效率较高&lt;/p&gt;
&lt;p&gt;具体使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Prepared {
    public static void main(String[] args) throws Exception{
        Properties properties = new Properties();
        properties.load(new FileInputStream(&quot;src\\mysql.properties&quot;));
        String user = properties.getProperty(&quot;user&quot;);
        String password = properties.getProperty(&quot;password&quot;);
        String driver = properties.getProperty(&quot;driver&quot;);

        String agreement = properties.getProperty(&quot;agreement&quot;);
        String address = properties.getProperty(&quot;address&quot;);
        String port = properties.getProperty(&quot;port&quot;);
        String dataBase = properties.getProperty(&quot;dataBase&quot;);

        Class.forName(driver);
        String url = agreement + &quot;//&quot; + address + &quot;:&quot; + port + &quot;/&quot; + dataBase;
        Connection connection = DriverManager.getConnection(url, user, password);

        String sql = &quot;select deptno,dname,loc from dept where deptno = ?&quot;;
        //其中的？代表占用符号
        PreparedStatement statement = connection.prepareStatement(sql);
        //PreparedStatement是Java提供的接口，具体的实现类看数据库厂商如何实现
        statement.setInt(1, 10);
        ResultSet resultSet = statement.executeQuery();
        //执行查询时不写sql，因为创建preparedstatement时使用sql创建
        while(resultSet.next()) {
            int deptno = resultSet.getInt(1);
            String dname = resultSet.getString(2);
            String loc = resultSet.getString(3);
            System.out.println(deptno + &quot; &quot; + dname + &quot; &quot; + loc);
        }
        resultSet.close();
        statement.close();
        connection.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;10 ACCOUNTING NEW YORK
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;三者对比&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;特性&lt;/th&gt;
&lt;th&gt;Statement&lt;/th&gt;
&lt;th&gt;PreparedStatement&lt;/th&gt;
&lt;th&gt;CallableStatement&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;SQL预编译&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;防SQL注入&lt;/td&gt;
&lt;td&gt;❌&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;参数化查询&lt;/td&gt;
&lt;td&gt;❌&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;调用存储过程&lt;/td&gt;
&lt;td&gt;❌&lt;/td&gt;
&lt;td&gt;❌&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;性能&lt;/td&gt;
&lt;td&gt;低&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;使用频率&lt;/td&gt;
&lt;td&gt;低&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;td&gt;中&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;JDBC封装&lt;/h2&gt;
&lt;p&gt;在jdbc操作中其实获取链接和释放操作都是我们会经常用到的，每一次都重写一遍其实非常的浪费时间，我们这个时候就有必要封装一个JDBC的工具模块来供自己调用&lt;/p&gt;
&lt;h3&gt;封装示例&lt;/h3&gt;
&lt;p&gt;以下是一个封装示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class JDBCUtils {
    //定义相关属性
    private static final String user;
    private static final String password;
    private static final String driver;
    private static final String agreement;
    private static final String address;
    private static final String port;
    private static final String dataBase;

    static {
        Properties properties = new Properties();
        try {
            properties.load(new FileInputStream(&quot;src\\mysql.properties&quot;));
            user = properties.getProperty(&quot;user&quot;);
            password = properties.getProperty(&quot;password&quot;);
            driver = properties.getProperty(&quot;driver&quot;);
            agreement = properties.getProperty(&quot;agreement&quot;);
            address = properties.getProperty(&quot;address&quot;);
            port = properties.getProperty(&quot;port&quot;);
            dataBase = properties.getProperty(&quot;dataBase&quot;);
            Class.forName(driver);
        } catch (Exception e) {
            //在实际开发中往往转为一个运行时异常抛出
            throw new RuntimeException(e);
            //调用者可以选择捕获异常或者默认处理
        }
    }

    public static Connection getConnection() {
        String url = agreement + &quot;//&quot; + address + &quot;:&quot; + port + &quot;/&quot; + dataBase;
        try {
            return DriverManager.getConnection(url, user, password);
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    public static void close(ResultSet result, Statement statement, Connection connection) {
        try {
            if(result != null) {
                result.close();
            }
            if(statement != null) {
                statement.close();
            }
            if(connection != null) {
                connection.close();
            }
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;测试代码&lt;/h3&gt;
&lt;p&gt;接下来我们用测试代码进行调用测试&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Prepared {
    public static void main(String[] args){

        Connection connection = JDBCUtils.getConnection();
        String sql = &quot;select deptno,dname,loc from dept where deptno = ?&quot;;
        PreparedStatement statement = null;
        ResultSet resultSet = null;
        try {
            statement = connection.prepareStatement(sql);
            statement.setInt(1, 10);
            resultSet = statement.executeQuery();
            while(resultSet.next()) {
                int deptno = resultSet.getInt(1);
                String dname = resultSet.getString(2);
                String loc = resultSet.getString(3);
                System.out.println(deptno + &quot; &quot; + dname + &quot; &quot; + loc);
            }
        } catch (SQLException e) {
            throw new RuntimeException(e);
        } finally {
            JDBCUtils.close(resultSet, statement, connection);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样相较于前文中的全部代码不光简单了很多，而且异常处理也非常的合理&lt;/p&gt;
&lt;h2&gt;JDBC事务&lt;/h2&gt;
&lt;h3&gt;基本介绍&lt;/h3&gt;
&lt;p&gt;1.JDBC程序中当一个Connection对象创建时，默认情况下是自动提交事务，每次执行一个SQL语句时如果执行成功，就会像数据库中自动提交事务，不可以回滚&lt;/p&gt;
&lt;p&gt;2.JDBC程序中为了让多个SQL语句作为一个整体执行，需要使用事务，这里是事务acid中的原子性&lt;/p&gt;
&lt;p&gt;3.调用Connection的setAutoCommit(false) 可以取消自动提交事务&lt;/p&gt;
&lt;p&gt;4.在所有的SQL语句都执行成功后，调用commit方法进行提交事务&lt;/p&gt;
&lt;p&gt;5.在其中某个操作失败或者出现异常的时候，调用rollback方法进行回滚事务&lt;/p&gt;
&lt;h3&gt;代码示例&lt;/h3&gt;
&lt;p&gt;以下代码完成了账户中转账的操作，但是假设在第二条SQL语句执行失败的情况下，异常被捕获第二条语句的转账没有收到，就会少了100块钱&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Prepared {
    public static void main(String[] args){

        Connection connection = JDBCUtils.getConnection();
        String sql1 = &quot;update balance set money = money - 100 where id = 1&quot;;
        String sql2 = &quot;update balance set money = money + 100 where id = 2&quot;;

        PreparedStatement statement = null;
        ResultSet resultSet = null;
        try {
            statement = connection.prepareStatement(sql1);
            int row = statement.executeUpdate();
            System.out.println(row &amp;gt; 0 ? &quot;success&quot; : &quot;fail&quot;);

            statement = connection.prepareStatement(sql2);
            row = statement.executeUpdate();
            System.out.println(row &amp;gt; 0 ? &quot;success&quot; : &quot;fail&quot;);
            
        } catch (SQLException e) {
            throw new RuntimeException(e);
        } finally {
            JDBCUtils.close(resultSet, statement, connection);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个时候我们就需要运用到事务来解决&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Prepared {
    public static void main(String[] args){

        Connection connection = JDBCUtils.getConnection();
        String sql1 = &quot;update balance set money = money - 100 where id = 1&quot;;
        String sql2 = &quot;update balance set money = money + 100 where id = 3&quot;;

        PreparedStatement statement = null;
        ResultSet resultSet = null;
        try {
            connection.setAutoCommit(false);//设置为不自动提交
            statement = connection.prepareStatement(sql1);
            int row = statement.executeUpdate();
            if(row &amp;lt;= 0) {
                throw new SQLException();
            }

            statement = connection.prepareStatement(sql2);
            row = statement.executeUpdate();
            if(row &amp;lt;= 0) {
                throw new SQLException();
            }
            connection.commit();//提交事务

        } catch (SQLException e) {
            //当发生执行SQL语句的时候，我们可以在异常处理回滚
            try {
                connection.rollback();
                //当没有存档点的情况下我们回滚到事务开始时，即设置自动提交的地方
            } catch (SQLException ex) {
                throw new RuntimeException(ex);
            }
            throw new RuntimeException(e);
        } finally {
            JDBCUtils.close(resultSet, statement, connection);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样的话，即使我们的第二条语句执行了一个不存在的用户3，用户1账户的钱也不会消失，注意当row=0时主动抛出异常，以便catch处理回滚&lt;/p&gt;
</content:encoded></item><item><title>关于 Git</title><link>https://thrinisty.github.io/posts/git%E7%AC%94%E8%AE%B0%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86%E6%9C%AC%E5%9C%B0%E5%BA%93%E5%88%86%E6%94%AF%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/git%E7%AC%94%E8%AE%B0%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86%E6%9C%AC%E5%9C%B0%E5%BA%93%E5%88%86%E6%94%AF%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/</guid><description>Git 学习笔记（加强版本）代码管理，本地库，分支，团队协作</description><pubDate>Wed, 16 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;GIT&lt;/h1&gt;
&lt;p&gt;Mysql基础部分内容结束，本来打算直接进入JDBC的学习，但是一来我有点小累，学不动Java了，二来我的编译原理课程需要使用到Git，实习的公司也要求熟练运用Git，所以就先看看这一个部分的知识，整理笔记并实际运用，预计今天（15号）一个晚自习和明天把这一块知识拿下（熟练使用Git、Github、GitLab、Gitee）&lt;/p&gt;
&lt;p&gt;之前的博客中我也介绍了一下Git大体是个什么玩意，但是使用的是VsCode链接到的Github，而我现在学Java改用IDEA了，又需要重新配置一下才可以方便使用。&lt;/p&gt;
&lt;p&gt;找的课程也就4~5个小时，就当过一遍教程了，对不了解的代码分支，分支合并学习一下，以下是该课程涉及的一些知识点（代码推送、代码拉取、代码克隆、IDEA集成Github、分支合并）&lt;/p&gt;
&lt;h2&gt;重要概念&lt;/h2&gt;
&lt;h3&gt;版本控制&lt;/h3&gt;
&lt;p&gt;版本控制是一种记录文件内容变化，以便将来查阅特定版本修订情况的系统&lt;/p&gt;
&lt;p&gt;其中最重要的就是可以记录文件修改历史，从而让用户能够查看历史版本，方便切换版本&lt;/p&gt;
&lt;p&gt;对于个人而言或许不太需要版本控制，但是如果一旦上升到公司集体，为了方便安全的对于代码进行修改（对于多个修改进行正确的合并），版本控制的使用就异常重要&lt;/p&gt;
&lt;h3&gt;分布式和集中式&lt;/h3&gt;
&lt;p&gt;对于早期的集中式管理系统，多个用户针对于中央服务器进行代码提交修改，这样做方便管理者来集中控制权限，但是如果中央服务器崩溃，项目就无法查看版本记录，而本地工作副本仅保存当前文件状态，无法形成有效的本地版本历史，而如今的分布式可以很好的解决这一点，通过拉取到本地，推送来统一进度，当中央发生故障的时候，任可以在自己的主机上做本地的版本控制&lt;/p&gt;
&lt;h3&gt;Git的工作机制&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../images/113.png&quot; alt=&quot;113&quot; /&gt;&lt;/p&gt;
&lt;p&gt;工作区：指的是本地存放代码的地方，也是直接编写代码的本地区域&lt;/p&gt;
&lt;p&gt;暂存区：是为了git识别，将工作区通过git add添加到的一个特定区域&lt;/p&gt;
&lt;p&gt;本地库：将暂存区的代码commit提交到本地库就会生成历史版本，无法删除记录（除非删除本地代码重新拉取云端的版本）&lt;/p&gt;
&lt;h3&gt;代码托管中心&lt;/h3&gt;
&lt;p&gt;代码托管中心是基于网络服务器的远程代码仓库，一般简单地称为远程库，在上述工作机制中，我们还可以把本地库运用push将本地库推送到远程库中，以下是一些常见的代码托管中心&lt;/p&gt;
&lt;p&gt;局域网 GitLab&lt;/p&gt;
&lt;p&gt;互联网 Github     Gitee 码云&lt;/p&gt;
&lt;h2&gt;本地库操作&lt;/h2&gt;
&lt;h3&gt;相关命令&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令名称&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;git config --global user.name 用户名称&lt;/td&gt;
&lt;td&gt;设置用户签名&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git config --global user.email 邮箱&lt;/td&gt;
&lt;td&gt;设置用户签名&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git init&lt;/td&gt;
&lt;td&gt;初始化本地库&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git status&lt;/td&gt;
&lt;td&gt;查看本地库状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git add 文件名&lt;/td&gt;
&lt;td&gt;添加到暂存区&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git commit -m &quot;日志信息&quot; 文件名&lt;/td&gt;
&lt;td&gt;提交到本地库&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git reflog&lt;/td&gt;
&lt;td&gt;查看历史记录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git reset --hard 版本号&lt;/td&gt;
&lt;td&gt;版本穿梭&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;Git操作&lt;/h3&gt;
&lt;h4&gt;设置用户签名&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;git config --global user.name thrinisty
git config --global user.email 714605471@qq.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;签名的作用是区分不同的操作者的身份，用户的签名信息在每一个版本的提交信息中能够看到，以确认本次提交是谁做的，Git首次安装必须要设置一下用户签名，否则无法提交代码&lt;/p&gt;
&lt;p&gt;注意，这里设置用户签名和将来登录Github的帐号没有任何的关系&lt;/p&gt;
&lt;h4&gt;初始化本地库&lt;/h4&gt;
&lt;p&gt;找到你要git提交的文件进入，输入以下指令创建空的git本地库&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git init
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;../images/114.png&quot; alt=&quot;114&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;查看本地库状态&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;git status
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;默认是在master分支下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;On branch master
No commits yet
Untracked files:
  (use &quot;git add &amp;lt;file&amp;gt;...&quot; to include in what will be committed)
        images/
        src/

nothing added to commit but untracked files present (use &quot;git add&quot; to track)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中的images和src还没有被添加到暂存区，没有被追踪&lt;/p&gt;
&lt;h4&gt;添加至暂存区&lt;/h4&gt;
&lt;p&gt;添加所有文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git add . 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;添加image文件夹&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git add image
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个时候我们也可以使用git status来查看新添加进入的文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/115.png&quot; alt=&quot;115&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;提交本地库&lt;/h4&gt;
&lt;p&gt;生成历史版本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git commit -m &quot;init commit&quot; [可选字段 默认提交所有暂存区中内容]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;../images/116.png&quot; alt=&quot;116&quot; /&gt;&lt;/p&gt;
&lt;p&gt;这个时候再次查看git本地库状态，看见所有在暂存区的内容被提交&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git status
On branch master
nothing to commit, working tree clean
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;查看版本信息&lt;/h4&gt;
&lt;p&gt;我们也可以通过一下的指令来查看版本信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git reflog
c3418c7 (HEAD -&amp;gt; master) HEAD@{0}: commit (initial): init commit
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;发现有一个提交过的版本名为init commit&lt;/p&gt;
&lt;p&gt;以下是一个更为详细的版本信息查看&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git log
commit c3418c789ad7bfb246a65f88f26f37764a011764 (HEAD -&amp;gt; master)
Author: thrinisty &amp;lt;714605471@qq.com&amp;gt;
Date:   Wed Apr 16 14:57:49 2025 +0800

	init commit
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;修改文件&lt;/h4&gt;
&lt;p&gt;修改文件之后我们需要将修改的文件再次添加到暂存区，以及提交到本地库&lt;/p&gt;
&lt;p&gt;例如我们在images文件夹下新增了一张图片&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git status
On branch master
Untracked files:
  (use &quot;git add &amp;lt;file&amp;gt;...&quot; to include in what will be committed)
        images/2.jpg

nothing added to commit but untracked files present (use &quot;git add&quot; to track)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们就需要重新将这张图片存储到到暂存区&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git status
On branch master
Changes to be committed:
  (use &quot;git restore --staged &amp;lt;file&amp;gt;...&quot; to unstage)
        new file:   images/2.jpg
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再重新提交到本地库，从而生成第二个版本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git commit -m &quot;New picture&quot;
[master 8c69e8c] New picture
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 images/2.jpg
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在我们再查看版本信息，就可以看到第二次提交&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git reflog
8c69e8c (HEAD -&amp;gt; master) HEAD@{0}: commit: New picture
c3418c7 HEAD@{1}: commit (initial): init commit
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;版本切换&lt;/h4&gt;
&lt;p&gt;Git切换版本，底层实际上就是移动的Head指针&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git reset --hard c3418c7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个时候我们的版本指针指向的就是第一次提交的版本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;c3418c7 (HEAD -&amp;gt; master) HEAD@{0}: reset: moving to c3418c7
8c69e8c HEAD@{1}: commit: New picture
c3418c7 (HEAD -&amp;gt; master) HEAD@{2}: commit (initial): init commit
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而我们添加的工作区中的第二次新添加的图片也会消失不见&lt;/p&gt;
&lt;p&gt;当然我们也可以版本穿梭回去&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git reset --hard 8c69e8c
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们工作区中的图片就会被添加回来&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/117.png&quot; alt=&quot;117&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;分支&lt;/h2&gt;
&lt;p&gt;在版本控制过程中，同时推进多个任务，为每个任务，我们就可以创建每个任务的单独分支。使用分支意味着程序员可以把自己的工作从开发主线上分离开来，开发自己分支的时候，不会影响到主线分支的运行&lt;/p&gt;
&lt;p&gt;而对于初学者而言，分支可以简单理解为副本，一个分支就是一个单独的副本（分支的底层的实现也是通过指针完成）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/118.png&quot; alt=&quot;118&quot; /&gt;&lt;/p&gt;
&lt;p&gt;分支优点：同时并行推进多个功能的开发，提高开发效率&lt;/p&gt;
&lt;p&gt;在各个分支的开发过程中，如果某一个分支开发失败，不会对其他分支有任何影响，失败的分支重新删除即可&lt;/p&gt;
&lt;h3&gt;分支相关指令&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令名称&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;git branch 分支名&lt;/td&gt;
&lt;td&gt;创建分支&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git branch -v&lt;/td&gt;
&lt;td&gt;查看分支&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git checkout 分支名&lt;/td&gt;
&lt;td&gt;切换分支&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git merge 分支名&lt;/td&gt;
&lt;td&gt;把指定的分支合并到当前分支上&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;基本使用&lt;/h3&gt;
&lt;p&gt;我们有的时候需要对于工作代码进行热修补，我们可以创建一个hot-fix分支，切换到分支，在分支上对于代码进行修改，完成之后切换到master分支下就可以使用git merge进行合并&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git branch hot-fix
git checkout hot-fix
相关的热修复
git checkout master
git merge hot-fix
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后的本地库状态&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git reflog
37195a2 (HEAD -&amp;gt; master, hot-fix) HEAD@{0}: merge hot-fix: Fast-forward
8c69e8c HEAD@{1}: checkout: moving from hot-fix to master
37195a2 (HEAD -&amp;gt; master, hot-fix) HEAD@{2}: commit: commit 1.jpg
8c69e8c HEAD@{3}: checkout: moving from master to hot-fix
8c69e8c HEAD@{4}: reset: moving to 8c69e8c
c3418c7 HEAD@{5}: reset: moving to c3418c7
8c69e8c HEAD@{6}: commit: New picture
c3418c7 HEAD@{7}: commit (initial): init commit
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;合并冲突&lt;/h3&gt;
&lt;p&gt;以上的例子是在master没有修改的情况下完成的合并，所以可以合并成功，在企业中我们在合并分支的时候往往遇到冲突&lt;/p&gt;
&lt;p&gt;合并分支的时候，两个分支在同一个文件的同一个位置有两套完全不同的修改，而Git无法替我们决定使用哪一个，必须要认为决定新代码内容&lt;/p&gt;
&lt;p&gt;例如我们在master中创建了一个1.txt 然后创建一个another分支，在两个分支下分别修改这个1.txt，分别提交，尝试在master中合并another，发现没有办法正常自动合并&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git merge another
Auto-merging 1.txt.txt
CONFLICT (content): Merge conflict in 1.txt.txt
Automatic merge failed; fix conflicts and then commit the result.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而用git status指令查看，发现了1.txt合并冲突&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;On branch master
You have unmerged paths.
  (fix conflicts and run &quot;git commit&quot;)
  (use &quot;git merge --abort&quot; to abort the merge)

Unmerged paths:
  (use &quot;git add &amp;lt;file&amp;gt;...&quot; to mark resolution)
        both modified:   1.txt.txt

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而打开冲突的文件，会发现git帮我们完成了冲突的标注&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEAD
master中的修改
=======
分支中的修改
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; another
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们需要手动合并&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;master中的修改
分支中的修改
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要重新添加提交&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git add .
git commit -m &quot;merge test&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;71460@thrinisty MINGW64 ~/多用户通讯系统 (master|MERGING)
$ git commit -m &quot;merge test&quot;
[master 0f34b4c] merge test

71460@thrinisty MINGW64 ~/多用户通讯系统 (master)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;发现两个分支合并成功，其实无论master还是another都是版本记录的指针，而所在的分支，其实是由Head决定的，所以创建分支的本质就是多创建一个指针，切换Head就是切换分支&lt;/p&gt;
&lt;h2&gt;团队协作&lt;/h2&gt;
&lt;p&gt;我们在实际开发的过程中不光有本地的仓库，还应该将代码同步到云端（代码托管平台）&lt;/p&gt;
&lt;p&gt;远程仓库命令&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令名称&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;git remote -v&lt;/td&gt;
&lt;td&gt;查看当前所有远程地址别名&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git remote add 别名 远程地址&lt;/td&gt;
&lt;td&gt;起一个别名&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git push 别名 分支&lt;/td&gt;
&lt;td&gt;推送本地分支上的内容到远程仓库&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git clone 远程地址&lt;/td&gt;
&lt;td&gt;将远程仓库的内容克隆到本地&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git pull 别名 远程分支名&lt;/td&gt;
&lt;td&gt;将远程仓库对于分支最新内容拉取与本地分支直接合并&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;远程仓库操作&lt;/h3&gt;
&lt;h4&gt;创建远程仓库&lt;/h4&gt;
&lt;p&gt;在github创建一个远程仓库名为Multi-user-communication-system（举例）&lt;/p&gt;
&lt;p&gt;其中 https://github.com/thrinisty/Multi-user-communication-system.git&lt;/p&gt;
&lt;p&gt;是我们的仓库链接，我们可以对于这个链接起一个别名system&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git remote add system 
https://github.com/thrinisty/Multi-user-communication-system.git
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;推送本地仓库到远程仓库&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;git push system master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个时候我们就将代码推送到了远程仓库&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/119.png&quot; alt=&quot;119&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;拉取代码&lt;/h4&gt;
&lt;p&gt;如果需要拉取云端的代码对本地的代码进行合并（请注意保持本地库的代码是最新的状态）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git pull system master
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;git pull system master
From https://github.com/thrinisty/Multi-user-communication-system
 * branch            master     -&amp;gt; FETCH_HEAD
Already up to date.
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;克隆仓库&lt;/h4&gt;
&lt;p&gt;如果没有本地库代码，我们还可以使用git clone完成项目的克隆，别名默认为origin&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone https://github.com/thrinisty/Multi-user-communication-system
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;团队内协作&lt;/h3&gt;
&lt;p&gt;在克隆的本地仓库可以用另外一个人的帐号，进行推送，但是需要赋予相关的权限，需要将这个人的账号添加进入团队&lt;/p&gt;
&lt;h4&gt;添加团队人员&lt;/h4&gt;
&lt;p&gt;在仓库的拥有者中仓库设置的Collaborators可以选取添加仓库的相关人员，而添加的相关人员就会有push代码的权限&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/120.png&quot; alt=&quot;120&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;团队成员修改提交&lt;/h4&gt;
&lt;p&gt;之后团队内成员可以拉取合并代码，并修改提交，参与到项目的研发中&lt;/p&gt;
&lt;h3&gt;跨团队协作&lt;/h3&gt;
&lt;p&gt;有的时候我们需要找一个外来人员更改代码，但是我们又不想要让这个外来人员进入团队，我们就需要跨团队协作&lt;/p&gt;
&lt;p&gt;这个时候外来人员可以通过项目链接选择使用fork看到代码，修改代码，提交修改，但是只是修改自己的本地仓库&lt;/p&gt;
&lt;p&gt;外来人员想要将修改的代码合并到对应的项目中可以使用pull request发送请求，而仓库的管理人员就可以审核申请，之后还可以查看修改，如果没有问题就可以确认合并。&lt;/p&gt;
&lt;h2&gt;IDEA集成&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Github&lt;/strong&gt;  &lt;strong&gt;Gitee&lt;/strong&gt;  &lt;strong&gt;GitLab&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这部分的内容照着尚硅谷的B站课程过一遍就好，一般都记得住，不会用的时候再去复习一下就好，用的多就会了，没必记录笔记&lt;/p&gt;
&lt;p&gt;在公司中代码保护非常的常见，之前我在讯飞得生产实习就有明确要求只准许使用公司内网连接，网络实时监控，不允许向网络上提交代码相关的内容&lt;/p&gt;
&lt;p&gt;而一个项目的开发中代码的保护也是很重要，这个时候就需要使用到GitLab自建代码托管平台，在局域网是进行代码管理&lt;/p&gt;
&lt;h2&gt;结语&lt;/h2&gt;
&lt;p&gt;Git到这里告一段落，明天开始JDBC的学习，计划两天完成，目的是掌握基础语法，JDBC大体结构，JDBC实战项目暂时不打算做了，得快点把概念和实际操作过熟练了，计划之后学完JDBC的高层框架（Mybatis）后实战运用，就不用底层的JDBC做项目了&lt;/p&gt;
</content:encoded></item><item><title>MySQL笔记</title><link>https://thrinisty.github.io/posts/mysql%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E4%B9%A0%E9%A2%98%E8%AF%BE/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/mysql%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E4%B9%A0%E9%A2%98%E8%AF%BE/</guid><description>习题练习</description><pubDate>Tue, 15 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;MySQL习题&lt;/h1&gt;
&lt;p&gt;我们系统的学完了MySQL相关知识，我们现在来用例题巩固一下我们的知识&lt;/p&gt;
&lt;h2&gt;练习一&lt;/h2&gt;
&lt;p&gt;1.显示所有部门的名称&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select deptno,dname from dept;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.显示所有雇员名以及全年收入（12*薪水 + 奖金）取名为年收入&lt;/p&gt;
&lt;p&gt;这里道题注意null+数字为空，需要使用判断语句处理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename, (sal*12 + if(comm is null,0,comm))
as&apos;年收入&apos; from emp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.显示工资超过2850雇员的姓名以及工资&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,sal from emp where sal &amp;gt; 2850;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.显示工资不再1500到2850之间雇员的姓名以及工资&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,sal from emp where sal &amp;gt; 2850 and sal &amp;lt; 1500;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.显示编号为7796的雇员名称以及所在部门编号&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,deptno from emp where empno=7796;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;6.显示部门在20，30中工资超过1500的雇员名以及工资&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,sal from emp where sal &amp;gt; 1500 
and deptno in(20,30);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;7.显示无管理者的雇员名称以及岗位&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,job from emp where mgr is null;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;8.显示在1991-2-1日到1991-5-1日之间雇佣的员工名，岗位以及雇佣日期，并以雇佣日期降序排序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,job,hiredate from emp 
where hiredate between 1991-02-01 
and 1991-05-01 
order by hiredate desc;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;练习二&lt;/h2&gt;
&lt;p&gt;1.选出部门30中的所有员工&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp where deptno = 30;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.列出所有CLERK的姓名，编号和部门编号&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename, empno, deptno from emp where job = &apos;CLERK&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.找出佣金高于平均薪水60%的员工&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename from emp 
where sal&amp;gt;(0.6*(select avg(sal) from emp));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.找出部门30中所有MANNAGER和部门20中所有CLERK的详细资料&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp 
where(deptno = 20 and job = &apos;CLERK&apos;) 
or (deptno = 30 and job = &apos;MANNAGER&apos;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp 
where deptno = 20 and job = &apos;CLERK&apos; 
union select * from emp 
where deptno = 30 and job = &apos;MANNAGER&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.查询20部门中既不是MANAGER又不是CLERK而薪水小于等于2000的所有员工&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp where deptno = 30 
and sal &amp;lt;= 2000 and (job &amp;lt;&amp;gt; &apos;MANAGER&apos; and job &amp;lt;&amp;gt; &apos;CLERK&apos;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;6.找出不收奖金或奖金低于100的员工&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp where comm is null or ifnull(comm,0)&amp;lt;100;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;7.找出每月倒数第三天受雇的员工&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp where last_day(hiredate) - 2 = hiredate;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;8.找出至今工作12年以上的员工&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp where date_add(hiredate, interval 12 year) &amp;lt; now();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;9.以首字母小写的方式显示所有员工的姓名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select concat(
lcase(substring(ename,1,1))
,substring(ename,2)) from emp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;10.显示名字长度为5的员工&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp where length(ename)=5;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;练习三&lt;/h2&gt;
&lt;p&gt;1.显示不带有R的员工姓名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp where ename not like &apos;%R%&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.显示所有员工姓名的前三个字符&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select left(ename,3) from emp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.显示所有的员工姓名，a用A替换&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select replace(ename,&apos;A&apos;,&apos;a&apos;) from emp;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;练习四&lt;/h2&gt;
&lt;p&gt;1.列出一个至少有一个员工的所有部门&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select distinct dname from dept,emp 
where dept.deptno = emp.deptno;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.列出薪水比smith多的所有员工&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp where sal &amp;gt; (select sal from emp where ename = &apos;SMITH&apos;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.列出受雇日期晚于其直接上级的所有员工&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select emy.* from emp as emy,emp as boss 
where emy.hiredate &amp;gt; boss.hiredate 
and emy.mgr = boss.empno;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.列出部门名称和这些部门的员工信息，同时列出没有员工的部门&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select dname,emp.* from dept left join emp 
on dept.deptno = emp.deptno;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.列出所有CLERK的姓名以及部门的名称&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select dname,emp.ename from dept left join emp 
on dept.deptno = emp.deptno where job = &apos;CLERK&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;6.列出最低薪水大于1500的各种工作&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select min(sal)as min_sal,job from emp 
group by job 
having min_sal &amp;gt; 1500;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;7.列出部门在SALES工作的员工名称&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename from emp,dept 
where emp.deptno = dept.deptno and dname = &apos;SALES&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;练习五&lt;/h2&gt;
&lt;p&gt;1.列出与SMITH从事相同工作的所有员工&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp 
where job = (select job from emp where ename = &apos;SMITH&apos;) 
and ename &amp;lt;&amp;gt; &apos;SMITH&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.列出薪水高于在部门30工作的所有员工的薪水的员工姓名和薪水&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,sal from emp where sal&amp;gt;all(select sal from emp where deptno = 30);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.列出在每个部门工作的员工数量，平均工资&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select dname,count(emp.deptno),avg(sal) from dept 
left join emp on dept.deptno = emp.deptno 
group by dname;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.列出所有部门的详细信息以及部门人数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select dept.*,temp.con from dept left join 
(select count(*) as con,deptno 
 from dept group by deptno)temp 
 on dept.deptno = temp.deptno;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.列出MANAGER的最低工资&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select min(sal) from emp where job = &apos;MANAGER&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;综合练习&lt;/h2&gt;
&lt;p&gt;设学校环境如下：一个系有若干个专业，每个专业一年只招一个班，每个班有若干个学生，先要建立于系、班级、学生数据库&lt;/p&gt;
&lt;p&gt;关系模式如下：&lt;/p&gt;
&lt;p&gt;班级class（班号classid，课程名subject，系名deptname，入学年份time，人数num）&lt;/p&gt;
&lt;p&gt;学生student（学号studentid，姓名name，年龄age，班号classid）&lt;/p&gt;
&lt;p&gt;系department（系号departmentid，系名deptname）&lt;/p&gt;
&lt;h3&gt;建表&lt;/h3&gt;
&lt;p&gt;定义每个表的主外码&lt;/p&gt;
&lt;p&gt;deptname唯一约束&lt;/p&gt;
&lt;p&gt;学生姓名不可以为空&lt;/p&gt;
&lt;p&gt;班级class&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create table class(
`classid` int primary key,
`subject` varchar(32),
`deptname` varchar(32),
`time` int,
`num` int
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;学生student&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create table student(
`studentid` int,
`name` varchar(32) not null default &apos;&apos;,
`age` int,
`classid` int,
primary key(`studentid`),
foreign key(`classid`) references class(classid)
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;系department&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create table department(
`departmentid` int primary key,
`deptname` varchar(32) unique not null
);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;插入数据&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;-- 插入系部数据
INSERT INTO department VALUES
(1, &apos;计算机科学系&apos;),
(2, &apos;电子工程系&apos;),
(3, &apos;机械工程系&apos;),
(4, &apos;外国语学院&apos;),
(5, &apos;经济管理学院&apos;);

-- 插入班级数据
INSERT INTO class VALUES
(101, &apos;数据结构&apos;, &apos;计算机科学系&apos;, 64, 45),
(102, &apos;数据库原理&apos;, &apos;计算机科学系&apos;, 48, 40),
(201, &apos;电路分析&apos;, &apos;电子工程系&apos;, 56, 38),
(202, &apos;数字电子技术&apos;, &apos;电子工程系&apos;, 48, 42),
(301, &apos;机械制图&apos;, &apos;机械工程系&apos;, 64, 36),
(401, &apos;英语语言学&apos;, &apos;外国语学院&apos;, 32, 28),
(501, &apos;微观经济学&apos;, &apos;经济管理学院&apos;, 48, 50);

-- 插入学生数据
INSERT INTO student VALUES
(1001, &apos;张三&apos;, 20, 101),
(1002, &apos;李四&apos;, 21, 101),
(1003, &apos;王五&apos;, 19, 102),
(1004, &apos;赵六&apos;, 20, 102),
(1005, &apos;钱七&apos;, 22, 201),
(1006, &apos;孙八&apos;, 20, 201),
(1007, &apos;周九&apos;, 21, 202),
(1008, &apos;吴十&apos;, 19, 301),
(1009, &apos;郑十一&apos;, 20, 401),
(1010, &apos;王十二&apos;, 21, 501);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;查询&lt;/h3&gt;
&lt;p&gt;完成如下查询&lt;/p&gt;
&lt;p&gt;1.找出所有姓李的学生&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from student where name like &apos;李%&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.列出开设超过一个课程的系的名称&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select deptname,count(*)as class_count 
from class group by deptname 
having class_count &amp;gt; 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+--------------+-------------+
| deptname     | class_count |
+--------------+-------------+
| 计算机科学系  |           2 |
| 电子工程系    |           2 |
+--------------+-------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.列出人数大于等于50，系的编号和名字&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select department.*,temp.sum_num from department,(select deptname,sum(num) as sum_num from class group by deptname having sum_num &amp;gt;= 50)temp where temp.deptname = department.deptname;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+--------------+--------------+---------+
| departmentid | deptname     | sum_num |
+--------------+--------------+---------+
|            2 | 电子工程系   | 80       |
|            5 | 经济管理学院 | 50       |
|            1 | 计算机科学系 | 85       |
+--------------+--------------+---------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;移除学生&lt;/h3&gt;
&lt;p&gt;我们现在需要移除一名张三学生，考虑的地方有以下两点，使张三所在班级的人数减一，再将张三从student表中移除，而这个过程我们要由事务来完成&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;start transaction;
update class set num = num-1 where classid = (select classid from student where name = &apos;张三&apos;);
delete from student where name = &apos;张三&apos;;
commit;
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>MySQL笔记</title><link>https://thrinisty.github.io/posts/mysql%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E7%B4%A2%E5%BC%95%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E8%A7%86%E5%9B%BE%E7%AE%A1%E7%90%86/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/mysql%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E7%B4%A2%E5%BC%95%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E8%A7%86%E5%9B%BE%E7%AE%A1%E7%90%86/</guid><description>索引，事务，隔离级别，存储引擎，视图，管理</description><pubDate>Mon, 14 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;MySQL&lt;/h1&gt;
&lt;h2&gt;自增长&lt;/h2&gt;
&lt;p&gt;我们再插入记录的时候有的时候需要有的数据从1开始自动增长，我们这个时候就要运用到自增长&lt;/p&gt;
&lt;p&gt;基本使用方式：在定义的时候设置auto_increment字段&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;字段名称 整形 primary key auto_increment
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;插入记录的时候填入null&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE dept ( 
`deptno` INT primary key auto_increment,
`dname` VARCHAR ( 30 ), 
`loc` VARCHAR ( 30 ) 
);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;insert into dept values(null, &apos;ddd&apos;, &apos;beijing&apos;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你需要自增需要从10开始，你也可以修改auto_increment设置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ALTER TABLE dept AUTO_INCREMENT = 10;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;插入数据的时候子增值字段也可以不使用null，而插入一个具体的值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;insert into dept values(50, &apos;ddd&apos;, &apos;beijing&apos;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;补充：设置自增步长&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-- 1. 首先设置全局自增步长
SET @@auto_increment_increment = 10;

-- 2. 然后修改表的自增值
ALTER TABLE dept AUTO_INCREMENT = 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;索引&lt;/h2&gt;
&lt;p&gt;索引可以在添加一定的代价后(占据更大大空间)，极大地增加查询（90%）的速度，而对于增删改（10%）会有一定的速率影响&lt;/p&gt;
&lt;h3&gt;基本使用方式&lt;/h3&gt;
&lt;p&gt;添加索引&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE [UNIQUE] INDEX 索引名称 on 表名(字段);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;alter table 表名 add index 索引名称(字段);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除索引&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;drop index 索引名称 on 表名;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除主键索引&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;alter table dept drop primary key;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;索引的类型&lt;/h3&gt;
&lt;p&gt;1.主键索引，主键自动的为主键添加索引（primary key）&lt;/p&gt;
&lt;p&gt;2.唯一索引（unique），在创建表的时候，添加为唯一索引&lt;/p&gt;
&lt;p&gt;3.普通索引（index）&lt;/p&gt;
&lt;p&gt;4.全文索引（fulltext）在实际使用的时候一般不使用自带的全文索引往往切换为Solr或者ElasticSearch&lt;/p&gt;
&lt;p&gt;显示来自于dept的索引&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;show index from dept;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;show keys from dept;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;show indexes from dept;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;练习&lt;/h3&gt;
&lt;p&gt;为以下的表格添加主键索引&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create table `order` (
`id` int,
`name` varchar(32),
`p_name` varchar(32),
`count` int
)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;alter table `order` add unique index id_index (id);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;create index id_index on `order`(id);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;创建索引规则&lt;/h3&gt;
&lt;p&gt;1.较为频繁作为查询条件字段应该创建索引&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;例如：一个学校中的学生id
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.唯一性太差的字段不适合单独创建索引，即使查询频繁&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;例如：学生的性别
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.更新非常频繁的字段不适合创建索引&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;例如：学生账号的登录次数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.不会出现在where子句中的字段不该创建索引&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;例如：学生信息表中的详细的家庭住址
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;事务&lt;/h2&gt;
&lt;h3&gt;什么是事务？&lt;/h3&gt;
&lt;p&gt;事务用于保证数据的一致性，它由一组相关的dml语句组成，改组的dml语句要么全部执行，要么全部失败，例如在转账的时候就需要使用事务来处理，以保证数据的一致性&lt;/p&gt;
&lt;p&gt;事务和锁&lt;/p&gt;
&lt;p&gt;当执行事务操作的时候，mysql会在表上加锁，防止其他用户修改表的数据，这对于用户而言非常重要&lt;/p&gt;
&lt;h3&gt;引用示例&lt;/h3&gt;
&lt;p&gt;我们现在有一个运用场景，有如下的一张表格代表两个用户的银行账户信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create table balance (
`id` int primary key,
`name` varchar(32),
`money` double
)

insert into balance values
(100,&apos;tom&apos;,3000.00),
(200,&apos;king&apos;,6000);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们现在有如下需求：&lt;/p&gt;
&lt;p&gt;将tom的100块钱转移到king的账户下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;update balance set money = money-100 where id=100;
update balance set money = money+100 where id=200;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是假如我们的数据库运行出现问题：第一条转账语句成功但是第二条失败，则tom转出的100块钱就凭空消失了，这个时候我们就需要运用到事务操作，将两条语句当为一个整体执行（要么全部执行成功，要么失败）&lt;/p&gt;
&lt;h3&gt;事务基本操作&lt;/h3&gt;
&lt;h4&gt;start transaction&lt;/h4&gt;
&lt;p&gt;开始一个事务&lt;/p&gt;
&lt;h4&gt;savepoint&lt;/h4&gt;
&lt;p&gt;保存点名--设置保存点&lt;/p&gt;
&lt;h4&gt;rollback to&lt;/h4&gt;
&lt;p&gt;保存点名--回退事务&lt;/p&gt;
&lt;h4&gt;rollback&lt;/h4&gt;
&lt;p&gt;回退全部的事务&lt;/p&gt;
&lt;h4&gt;commit&lt;/h4&gt;
&lt;p&gt;提交事务，所有的操作生效，不可以回退&lt;/p&gt;
&lt;p&gt;我们现在回到我们的实际案例上面&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;start transaction; --设置了事物的开始

savepoint a;  --保存点a
update balance set money = money-100 where id=100;--dml

savepoint b;  --保存点a
update balance set money = money+100 where id=200;--dml

ROLLBACK;  --回滚
commit;  --提交
select * from balance;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行这样一段代码的话，数据不会被更改，因为进行了回滚，如果删除回滚在进行提交，执行成功，tom的100元给到了king&lt;/p&gt;
&lt;p&gt;回退事务：当执行回退事物的时候，通过指定的保存点就可以回退到指定的点&lt;/p&gt;
&lt;p&gt;提交事务：使用commit进行提交，执行了commit后就会确认事务的变化，结束事务，删除保存点，释放锁，数据生效。当使用commit语句结束事务以后，其他的会话可以查看到事物变化后的新数据&lt;/p&gt;
&lt;h3&gt;注意事项&lt;/h3&gt;
&lt;p&gt;1.如果不开始事务，默认情况下，dml操作是自动提交的，不可以进行回滚&lt;/p&gt;
&lt;p&gt;2.如果开始一个事务，没有创建保存点，可以执行rollback操作，默认回滚到事务开始的状态&lt;/p&gt;
&lt;p&gt;3.可以在事务还没有提交的时候，创建多个保存点&lt;/p&gt;
&lt;p&gt;4.可以在事务还没有提交的时候，选择回退到哪个保存点&lt;/p&gt;
&lt;p&gt;5.mysql事务机制需要innodb存储引擎，myisam不可以使用事务机制&lt;/p&gt;
&lt;h3&gt;事务的acid特性&lt;/h3&gt;
&lt;p&gt;（atomicity）原子性：原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生&lt;/p&gt;
&lt;p&gt;（consistency）一致性：事务必须使数据库从一个一致性状态变换到另一个一致性状态&lt;/p&gt;
&lt;p&gt;（isolation）隔离性：事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离&lt;/p&gt;
&lt;p&gt;（durability）持久性：持久性是指一个事务一旦被提交，他对于数据库中的数据的改变就是永久的，接下来即使数据库发生故障可而不应该对其有任何的影响&lt;/p&gt;
&lt;h2&gt;隔离级别&lt;/h2&gt;
&lt;p&gt;脏读：当一个事务读取另一个事务尚未提交的修改时，产生脏读&lt;/p&gt;
&lt;p&gt;不可重复读：同一查询在同一事物中多次进行，由于其他提交事务所做的修改或者删除，每次返回结果不同的结果集，产生不可重复读&lt;/p&gt;
&lt;p&gt;幻读：同意查询在同一事物中多次进行，由于其他提交事务的插入操作，每次返回不同的结果集，产生了幻读&lt;/p&gt;
&lt;h3&gt;事务隔离表格&lt;/h3&gt;
&lt;p&gt;事务隔离级别：MySQL隔离级别定义了事物与事务之间的隔离程度&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;隔离级别&lt;/th&gt;
&lt;th&gt;丢失修改&lt;/th&gt;
&lt;th&gt;脏读&lt;/th&gt;
&lt;th&gt;不可重复读&lt;/th&gt;
&lt;th&gt;幻读&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;读未提交&lt;/td&gt;
&lt;td&gt;不会发生&lt;/td&gt;
&lt;td&gt;可能发生&lt;/td&gt;
&lt;td&gt;可能发生&lt;/td&gt;
&lt;td&gt;可能发生&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;读已提交&lt;/td&gt;
&lt;td&gt;不会发生&lt;/td&gt;
&lt;td&gt;不会发生&lt;/td&gt;
&lt;td&gt;可能发生&lt;/td&gt;
&lt;td&gt;可能发生&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;可重复读&lt;/td&gt;
&lt;td&gt;不会发生&lt;/td&gt;
&lt;td&gt;不会发生&lt;/td&gt;
&lt;td&gt;不会发生&lt;/td&gt;
&lt;td&gt;可能发生&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;可串行化&lt;/td&gt;
&lt;td&gt;不会发生&lt;/td&gt;
&lt;td&gt;不会发生&lt;/td&gt;
&lt;td&gt;不会发生&lt;/td&gt;
&lt;td&gt;不会发生&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;Mysql中解决幻读&lt;/h3&gt;
&lt;p&gt;Mysql中的默认隔离级别是可重复读，但是在使用innodb引擎的时候不会发生幻读，原因如下&lt;/p&gt;
&lt;p&gt;InnoDB 存储引擎通过多版本并发控制(MVCC, Multi-Version Concurrency Control)机制，在&quot;可重复读&quot;(Repeatable Read)隔离级别下有效解决了幻读问题。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;普通SELECT操作(快照读)
通过ReadView判断哪些版本对当前事务可见
总是读取事务开始时的一致性快照
其他事务的插入操作不会影响当前事务的查询结果

当前读操作
对于SELECT ... FOR UPDATE、UPDATE、DELETE等操作：
InnoDB会加Next-Key Lock(记录锁+间隙锁)
防止其他事务在查询范围内插入新记录
从而彻底解决幻读问题
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;START TRANSACTION;
SELECT * FROM t WHERE id &amp;gt; 1; -- 看到3,5
-- 此时事务B插入id=4并提交
SELECT * FROM t WHERE id &amp;gt; 1; -- 仍然只看到3,5(快照读)
SELECT * FROM t WHERE id &amp;gt; 1 FOR UPDATE; -- 会看到3,4,5(当前读)
COMMIT;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在可重复读隔离级别下，普通SELECT不会看到事务B插入的id=4，而加锁的SELECT会看到并锁定这些记录。&lt;/p&gt;
&lt;h3&gt;读已提交和可重复读&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;特性&lt;/th&gt;
&lt;th&gt;读已提交(Read Committed)&lt;/th&gt;
&lt;th&gt;可重复读(Repeatable Read)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;数据可见性规则&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;总是看到最新已提交的数据&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;看到事务开始时的数据快照&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;锁机制&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;语句级锁(执行完立即释放)&lt;/td&gt;
&lt;td&gt;事务级锁(保持到事务结束)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;不可重复读&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;可能发生&lt;/td&gt;
&lt;td&gt;不会发生&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;性能&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;较高&lt;/td&gt;
&lt;td&gt;中等&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;可重复读和可串行化&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;特性&lt;/th&gt;
&lt;th&gt;可重复读(Repeatable Read)&lt;/th&gt;
&lt;th&gt;可串行化(Serializable)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;并发控制原理&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;MVCC(多版本并发控制)为主&lt;/td&gt;
&lt;td&gt;严格的二阶段封锁协议&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;读取行为&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;快照读(非锁定读)&lt;/td&gt;
&lt;td&gt;所有读自动转为锁定读(S锁)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;写入行为&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;需要时加X锁&lt;/td&gt;
&lt;td&gt;总是加X锁&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;锁范围&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;仅锁定实际访问的行和间隙&lt;/td&gt;
&lt;td&gt;更大范围的锁(更保守)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;性能&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;高并发，读不阻塞写&lt;/td&gt;
&lt;td&gt;低并发，读写相互阻塞&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;常用代码&lt;/h3&gt;
&lt;h4&gt;查看隔离级别&lt;/h4&gt;
&lt;p&gt;可以通过以下代码查看数据库设置的隔离级别&lt;/p&gt;
&lt;p&gt;MySQL 5.7及之前版本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select @@tx_isolation;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;MySQL 8.0及之后版本&lt;/p&gt;
&lt;p&gt;查看系统当前隔离级别&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT @@transaction_isolation;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+-------------------------+
| @@transaction_isolation |
+-------------------------+
| REPEATABLE-READ         |
+-------------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可见Mysql的默认隔离级别为可重复读&lt;/p&gt;
&lt;h4&gt;设置隔离级别&lt;/h4&gt;
&lt;p&gt;设置当前会话隔离级别&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SET SESSION TRANSACTION ISOLATION LEVEL 隔离级别;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置系统当前隔离级别&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SET global TRANSACTION ISOLATION LEVEL 隔离级别;
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;读未提交&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;SET SESSION TRANSACTION ISOLATION LEVEL read uncommitted;
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;读已提交&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;SET SESSION TRANSACTION ISOLATION LEVEL read committed;
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;可重复读&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;SET SESSION TRANSACTION ISOLATION LEVEL repeatable read;
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;可串行化&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;SET SESSION TRANSACTION ISOLATION LEVEL serializable;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;存储引擎&lt;/h2&gt;
&lt;p&gt;1.MySQL的表类型由存储引擎决定，主要包括MYISAM，InnoDB，Memory&lt;/p&gt;
&lt;p&gt;2.MySQL数据表只要支持六种类型：CSV，Memory，ARCHIVE，MRG_MYISAM，MYISAM，InnoDB&lt;/p&gt;
&lt;p&gt;3.这两种存储又分为两种：一类是事务安全型，例如InnoDB，其余为第二类，称为非事务安全型&lt;/p&gt;
&lt;p&gt;在MySQL中可以使用如下的指令查看存储引擎&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SHOW ENGINES;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;引擎比较&lt;/h3&gt;
&lt;p&gt;接下来来比较InnoDB、Myisam、Memory、Archive之间的优缺点：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;特性&lt;/th&gt;
&lt;th&gt;InnoDB&lt;/th&gt;
&lt;th&gt;MyISAM&lt;/th&gt;
&lt;th&gt;Memory&lt;/th&gt;
&lt;th&gt;Archive&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;事务支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;锁定级别&lt;/td&gt;
&lt;td&gt;行级锁&lt;/td&gt;
&lt;td&gt;表锁&lt;/td&gt;
&lt;td&gt;表锁&lt;/td&gt;
&lt;td&gt;行锁(仅插入)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;外键支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;存储位置&lt;/td&gt;
&lt;td&gt;磁盘&lt;/td&gt;
&lt;td&gt;磁盘&lt;/td&gt;
&lt;td&gt;内存&lt;/td&gt;
&lt;td&gt;磁盘&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;压缩能力&lt;/td&gt;
&lt;td&gt;中等&lt;/td&gt;
&lt;td&gt;低&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;极高&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;崩溃恢复&lt;/td&gt;
&lt;td&gt;优秀&lt;/td&gt;
&lt;td&gt;差&lt;/td&gt;
&lt;td&gt;无(数据丢失)&lt;/td&gt;
&lt;td&gt;中等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;全文索引&lt;/td&gt;
&lt;td&gt;5.6+支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;适用场景&lt;/td&gt;
&lt;td&gt;高并发OLTP&lt;/td&gt;
&lt;td&gt;读密集型&lt;/td&gt;
&lt;td&gt;临时/缓存&lt;/td&gt;
&lt;td&gt;归档存储&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;小结&lt;/h3&gt;
&lt;p&gt;1.MyISAM不支持事务、也不支持外键、但是访问速度极快、对于事物完整性没有要求&lt;/p&gt;
&lt;p&gt;2.InnoDB存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全、但是相比于MyISAM存储引擎，InnoDB写的处理效率差一些并且会占用更多的从磁盘空间以保留数据和索引&lt;/p&gt;
&lt;p&gt;3.Memory存储引擎使用存在内存中的内容来创建表，每个Memory表只实际对应一个磁盘文件，该类型的表访问速度极快，因为数据是存放在内存中的，并且默认使用了Hash索引，但是MySQL服务关闭，表中的数据就会丢失，表的结构还在&lt;/p&gt;
&lt;h3&gt;使用案例&lt;/h3&gt;
&lt;p&gt;修改存储引擎&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;alter talble 表名 engine = 存储引擎;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;alter table balance engine = innodb;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建一个MyISAM存储引擎的表，无法使用事务&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create table balance (
`id` int primary key,
`name` varchar(32),
`money` double
) ENGINE MYISAM;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建一个Memory存储引擎的表，支持Hash索引，执行速度很快&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create table balance (
`id` int primary key,
`name` varchar(32),
`money` double
) ENGINE Memory;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;1.如果应用不需要事务，处理的只是基本的增删改查，那么MyISAM是绝佳的选择，速度快&lt;/p&gt;
&lt;p&gt;2.需要事务支持，就选择InnoDB&lt;/p&gt;
&lt;p&gt;3.Memory存储引擎将数据存在内存中，由于没有磁盘的IO等待，速度非常快，但数据不持久&lt;/p&gt;
&lt;h2&gt;视图&lt;/h2&gt;
&lt;p&gt;我们有的时候需要将表中的某几个字段显示使用（有权限需要，不能够每个人都使用select查询整一张表格），我们可以将这几个字段拿出来做成一个视图，还可以将视图的查看权限赋予某个用户&lt;/p&gt;
&lt;h3&gt;基本概念&lt;/h3&gt;
&lt;p&gt;视图是一个虚拟表，其内容由查询定义，同真实的表一样，视图包含列，数据来自于对应的真实表（基表）&lt;/p&gt;
&lt;p&gt;1.视图是根据基表（可以多个基表）来创建的，视图是虚拟的表&lt;/p&gt;
&lt;p&gt;2.视图也有列，数据来自于基表&lt;/p&gt;
&lt;p&gt;3.通过修改视图可以修改基表的数据&lt;/p&gt;
&lt;p&gt;4.基表的改变也会影响到视图的数据&lt;/p&gt;
&lt;h3&gt;基本使用&lt;/h3&gt;
&lt;p&gt;创建视图&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create view 视图名称 as select语句;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;更新视图&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;alter view 视图名称 as select语句;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;显示视图是如何创建的（select语句）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;show create view 视图名;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除视图&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;drop view 视图1,视图2...;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们要对于员工表创建一个名为emp_view的视图（数据包含empno,ename,job,deptno）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create view emp_view as 
select empno,ename,job,deptno from emp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们现在来查看一下这个视图&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp_view;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+-------+--------+----------+--------+
| empno | ename  | job      | deptno |
+-------+--------+----------+--------+
|  7396 | SMITH  | CLERK    |     20 |
|  7499 | ALLEN  | SALESMAN |     30 |
|  7596 | WARD   | SALESMAN |     30 |
|  7696 | JOOES  | MANAGER  |     20 |
|  7796 | MARTIN | SALESMAN |     30 |
|  7896 | BLAKE  | MANAGER  |     30 |
+-------+--------+----------+--------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除视图&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;drop view emp_view;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例题：针对emp，dept，salgrade 三张表格创建一个emp_view视图，可以显示雇员编号，雇员名称，雇员部门名称，薪水级别&lt;/p&gt;
&lt;p&gt;相关的select语句&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select empno,ename,dname,grade from emp, dept, salgrade 
where emp.deptno = dept.deptno
and sal between losal and hisal;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;制作视图&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create view emp_view as
select empno,ename,dname,grade from emp, dept, salgrade 
where emp.deptno = dept.deptno
and sal between losal and hisal;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;视图细节&lt;/h3&gt;
&lt;p&gt;1.创建视图后，到数据库看，对应的视图只有一个视图结构文件(视图名.frm)&lt;/p&gt;
&lt;p&gt;2.视图和基表的修改相互影响&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;update emp_view set deptno = 40 where ename=&apos;SMITH&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;update emp set deptno = 20 where ename=&apos;SMITH&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.视图中可以再次使用视图&lt;/p&gt;
&lt;h3&gt;使用场景&lt;/h3&gt;
&lt;p&gt;安全：一些数据表有着重要的信息，某些字段需要保密，不可以让用户直接看到，这个时候我们就可以创建一个视图，在这个视图中保留安全的字段，而不包含保密的字段&lt;/p&gt;
&lt;p&gt;性能：关系数据库常常会分表存储，使用外键建立这一些表的关系，这个时候，数据库查询通常会用到join连接，这么做不但麻烦，效率也比较低，如果建立一个视图，将相关表的字段组合在一起，就可以避免使用join查询数据&lt;/p&gt;
&lt;p&gt;灵活：如果系统中有一张旧的表，这张表由于设计的问题，即将被废弃，然而，很多表都是基于这一张表，不方便修改，这个时候就可以建立一张视图，视图中的数据直接映射到新建的表，这样就可以做很少的改动，也达到了升级数据表的目的&lt;/p&gt;
&lt;h2&gt;Mysql管理&lt;/h2&gt;
&lt;h3&gt;user表&lt;/h3&gt;
&lt;p&gt;mysql中的用户，都存储在系统数据库mysql中的user表&lt;/p&gt;
&lt;p&gt;其中有一些重要的字段&lt;/p&gt;
&lt;p&gt;host：允许登录的位置，localhost表示该用户只允许本机登录，也可以指定ip&lt;/p&gt;
&lt;p&gt;user：用户名称&lt;/p&gt;
&lt;p&gt;authentication_string：密码，通过mysql的password()函数加密后的密码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select host,user,authentication_string from user;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+-----------+------------------+------------------------------------------------------------------------+
| host      | user             | authentication_string                                                  |
+-----------+------------------+------------------------------------------------------------------------+
| localhost | mysql.infoschema | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED |
| localhost | mysql.session    | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED |
| localhost | mysql.sys        | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED |
| localhost | root             | $A$005$ xgY]U4ieS
8Q+#hB9QVmRfma9kzzSPEIJ1FgvgP7VMuobh4V.rZD0mc7FD  |
+-----------+------------------+------------------------------------------------------------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;用户管理&lt;/h3&gt;
&lt;p&gt;当做项目开发的时候，Mysql数据库管理人员可以根据不同的开发人员，赋给相应的Mysql操作权限，供人员使用&lt;/p&gt;
&lt;h4&gt;创建用户&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;create user &apos;thrinisty&apos; @&apos;localhost&apos; identified by &apos;123456&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;select host,user from user;
+-----------+------------------+
| host      | user             |
+-----------+------------------+
| localhost | mysql.infoschema |
| localhost | mysql.session    |
| localhost | mysql.sys        |
| localhost | root             |
| localhost | thrinisty        |
+-----------+------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们在Navicat中可以用新的用户连接数据库&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/111.png&quot; alt=&quot;111&quot; /&gt;&lt;/p&gt;
&lt;p&gt;可以看到我们新用户表和root用户的表不太一样&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/112.png&quot; alt=&quot;112&quot; /&gt;&lt;/p&gt;
&lt;p&gt;这是因为不同的数据库用户，登录到DBMS，根据相应的权限，可以操作的数据库，数据对象（表、视图、触发器）都不一样&lt;/p&gt;
&lt;h4&gt;删除用户&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;drop user &apos;用户名&apos; @&apos;允许登录的位置&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;修改密码&lt;/h4&gt;
&lt;p&gt;注意以下修改方式是5.7.5版本以下的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;set password = password(&apos;密码&apos;);--修改自身密码
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;set password for &apos;用户名&apos; @&apos;登录位置&apos; = password(&apos;密码&apos;);
--修改他人的密码，需要有用户密码的权限
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我用的8.0版本需要使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ALTER USER USER() IDENTIFIED BY &apos;654321&apos;;--修改自身密码
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;ALTER USER &apos;username&apos;@&apos;hostname&apos; IDENTIFIED BY &apos;654321&apos;;
--修改他人的密码，需要有用户密码的权限
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;权限管理&lt;/h3&gt;
&lt;p&gt;MySQL中有非常多的权限可以赋予用户，我们来使用以下常见的权限&lt;/p&gt;
&lt;h4&gt;常见的权限&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;全选&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;GRANT OPTION&lt;/td&gt;
&lt;td&gt;允许授予权限&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ALL PRIVIEGES&lt;/td&gt;
&lt;td&gt;设置除GRANT OPTTION之外的简单权限&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ALTER&lt;/td&gt;
&lt;td&gt;允许使用 ALTER TABLE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CREATE&lt;/td&gt;
&lt;td&gt;允许使用 CREATE TABLE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CREATE USER&lt;/td&gt;
&lt;td&gt;允许使用增删改用户、移除所有权限&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CREATE VIEW&lt;/td&gt;
&lt;td&gt;允许使用CREATE VIEW&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DELETE&lt;/td&gt;
&lt;td&gt;允许使用DELETE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DROP&lt;/td&gt;
&lt;td&gt;允许使用DROP TABLE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;INDEX&lt;/td&gt;
&lt;td&gt;允许创建删除索引&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;INSERT&lt;/td&gt;
&lt;td&gt;允许使用INSERT插入&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SELECT&lt;/td&gt;
&lt;td&gt;允许使用查询&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SHOW DATABASES&lt;/td&gt;
&lt;td&gt;允许显示所有数据库&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;USAGE&lt;/td&gt;
&lt;td&gt;无权限&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;基本语法&lt;/h4&gt;
&lt;p&gt;赋权指令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;grant 权限列表 on 库.对象名 to 
&apos;用户名&apos;@&apos;登录位置&apos; [identified by &apos;密码&apos;];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;回收权限&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;revoke 权限列表 on 库.对象名 from 
&apos;用户名&apos;@&apos;登录位置&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;刷新权限&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FLUSH PRIVILEGES;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;赋给thrinisty全部表全部对象的all权限&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;grant all on *.* to &apos;thrinisty&apos;@&apos;localhost&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;管理细节&lt;/h3&gt;
&lt;p&gt;1.在创建用户的时候，如果不指定host，则为%，表示所有ip都有链接的权限&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create user jack;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.在删除用户的时候，如果host不是%，需要明确指定‘用户’@‘host值’&lt;/p&gt;
</content:encoded></item><item><title>MySQL笔记</title><link>https://thrinisty.github.io/posts/mysql%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A2%9E%E5%BC%BA%E6%9F%A5%E8%AF%A2%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%E5%A4%96%E8%BF%9E%E6%8E%A5%E5%AD%90%E6%9F%A5%E8%AF%A2%E7%BA%A6%E6%9D%9F/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/mysql%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A2%9E%E5%BC%BA%E6%9F%A5%E8%AF%A2%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%E5%A4%96%E8%BF%9E%E6%8E%A5%E5%AD%90%E6%9F%A5%E8%AF%A2%E7%BA%A6%E6%9D%9F/</guid><description>增强查询，多表查询，外连接，子查询，约束</description><pubDate>Sun, 13 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;MySQL&lt;/h1&gt;
&lt;h2&gt;MySQL表查询&lt;/h2&gt;
&lt;p&gt;在实际开发的过程中，我们需要用到的查询不只有前面的简单查询，我们还需要学习一些更为符合实际的查询方式，如日期查询，多表查询等&lt;/p&gt;
&lt;h3&gt;相关表格&lt;/h3&gt;
&lt;p&gt;我们先来建立几个表格，填入响应数据&lt;/p&gt;
&lt;h4&gt;员工表emp&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE emp (
	`empno` INT,
	`ename` VARCHAR ( 30 ),
	`job` VARCHAR ( 20 ),
	`mgr` INT,
	`hiredate` DATE,
	`sal` DOUBLE,
	`comm` DOUBLE,
`deptno` INT 
);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;INSERT INTO emp
VALUES
	( 7396, &apos;SMITH&apos;, &apos;CLERK&apos;, 7902, &apos;1990-12-17&apos;, 800.00, NULL, 20 ),
	( 7499, &apos;ALLEN&apos;, &apos;SALESMAN&apos;, 7902, &apos;1991-02-20&apos;, 1600.00, 300.00, 30 ),
	( 7596, &apos;WARD&apos;, &apos;SALESMAN&apos;, 7896, &apos;1993-02-07&apos;, 1250.00, 500.00, 30 ),
	( 7696, &apos;JOOES&apos;, &apos;MANAGER&apos;, 7839, &apos;1980-02-01&apos;, 2975.00, NULL, 20 ),
	( 7796, &apos;MARTIN&apos;, &apos;SALESMAN&apos;, 7698, &apos;1999-04-17&apos;, 1250.00, 1400.00, 30 ),
	( 7896, &apos;BLAKE&apos;, &apos;MANAGER&apos;, 7839, &apos;1990-12-17&apos;, 2850.00, NULL, 30 );
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;工作部门表dept&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE dept ( 
`deptno` INT, 
`dname` VARCHAR ( 30 ), 
`loc` VARCHAR ( 30 ) 
);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;INSERT INTO dept
VALUES
	( 10, &apos;ACCOUNTING&apos;, &apos;NEW YORK&apos; ),
	( 20, &apos;RESEARCH&apos;, &apos;DALLAS&apos; ),
	( 30, &apos;SALES&apos;, &apos;CHICAGO&apos; ),
	( 40, &apos;OPERATIONS&apos;, &apos;BOSTON&apos; );
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;薪水表格salgrade&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE salgrade ( 
    `grade` INT, 
    `losal` DOUBLE, 
    `hisal` DOUBLE 
);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;INSERT INTO salgrade
VALUES
	( 1, 700.00, 1200.00 ),
	( 2, 1200.00, 1400.00 ),
	( 3, 1400.00, 3000.00 ),
	( 4, 3000.00, 9000.00 );
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;查询加强&lt;/h3&gt;
&lt;h4&gt;where筛选日期&lt;/h4&gt;
&lt;p&gt;查找1992.1.1后入职的员工&lt;/p&gt;
&lt;p&gt;需要至于格式01-01&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,hiredate from emp where hiredate &amp;gt; &apos;1992-01-01&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+--------+------------+
| ename  | hiredate   |
+--------+------------+
| WARD   | 1993-02-07 |
| MARTIN | 1999-04-17 |
+--------+------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;like模糊查询&lt;/h4&gt;
&lt;p&gt;​	%：表示0到多个任意字符&lt;/p&gt;
&lt;p&gt;​	_ ：表示单个任意字符&lt;/p&gt;
&lt;p&gt;如何显示首字符为s的员工共姓名和工资&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,sal from emp where ename like &apos;s%&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+-------+-----+
| ename | sal |
+-------+-----+
| SMITH | 800 |
+-------+-----+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如何显示第三个字符为大写o的所有员工姓名和工资&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,sal from emp where ename like &apos;__o%&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+-------+------+
| ename | sal  |
+-------+------+
| JOOES | 2975 |
+-------+------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;order by排序&lt;/h4&gt;
&lt;p&gt;从工资低到高显示员工&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp order by sal asc;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+-------+--------+----------+------+------------+------+------+--------+
| empno | ename  | job      | mgr  | hiredate   | sal  | comm | deptno |
+-------+--------+----------+------+------------+------+------+--------+
|  7396 | SMITH  | CLERK    | 7902 | 1990-12-17 |  800 | NULL |     20 |
|  7596 | WARD   | SALESMAN | 7902 | 1993-02-07 | 1250 |  500 |     30 |
|  7796 | MARTIN | SALESMAN | 7698 | 1999-04-17 | 1250 | 1400 |     30 |
|  7499 | ALLEN  | SALESMAN | 7902 | 1991-02-20 | 1600 |  300 |     30 |
|  7896 | BLAKE  | MANAGER  | 7839 | 1990-12-17 | 2850 | NULL |     30 |
|  7696 | JOOES  | MANAGER  | 7839 | 1980-02-01 | 2975 | NULL |     20 |
+-------+--------+----------+------+------------+------+------+--------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;按照部门编号升序，员工工资降序排序（中间用，隔开）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp order by deptno asc , sal desc;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+-------+--------+----------+------+------------+------+------+--------+
| empno | ename  | job      | mgr  | hiredate   | sal  | comm | deptno |
+-------+--------+----------+------+------------+------+------+--------+
|  7696 | JOOES  | MANAGER  | 7839 | 1980-02-01 | 2975 | NULL |     20 |
|  7396 | SMITH  | CLERK    | 7902 | 1990-12-17 |  800 | NULL |     20 |
|  7896 | BLAKE  | MANAGER  | 7839 | 1990-12-17 | 2850 | NULL |     30 |
|  7499 | ALLEN  | SALESMAN | 7902 | 1991-02-20 | 1600 |  300 |     30 |
|  7596 | WARD   | SALESMAN | 7902 | 1993-02-07 | 1250 |  500 |     30 |
|  7796 | MARTIN | SALESMAN | 7698 | 1999-04-17 | 1250 | 1400 |     30 |
+-------+--------+----------+------+------------+------+------+--------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;分页查询&lt;/h4&gt;
&lt;p&gt;在实际开发中我们数据量往往很大，我们会用到分页来进行查询，这里介绍一个关键字limit&lt;/p&gt;
&lt;p&gt;基本语法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ... limit start, rows
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;表示从start + 1 行开始取，取出rows行，例如上述的例子中，我们需要取出前5行结果使用如下的语句即可，从第1行开始取5行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp order by deptno asc , sal desc limit 0, 5;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们是实际中使用我们就可以运用limit限制每一次查询的范围&lt;/p&gt;
&lt;p&gt;要将一个大表范围若干个小表可以这么做&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp order by deptno asc , sal desc limit 0, 4;
select * from emp order by deptno asc , sal desc limit 4, 4;
select * from emp order by deptno asc , sal desc limit 8, 4;
...
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;group by分组&lt;/h4&gt;
&lt;p&gt;我们有如下的几个题目&lt;/p&gt;
&lt;p&gt;1.显示每种岗位的雇员总数，平均工资&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select count(*), avg(sal), job from emp group by job;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.显示雇员的总数，以及获得补助的雇员数&lt;/p&gt;
&lt;p&gt;这里输入comm，comm字段为空则不参与统计&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select count(*), count(comm) from emp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果我们扩展一下&lt;/p&gt;
&lt;p&gt;没有获得补助的员工&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select count(*), count(*)-count(comm) from emp;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;select count(*), count(if(comm is null, 1, null)) from emp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.显示管理者的总人数&lt;/p&gt;
&lt;p&gt;先count再去重&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select count(distinct mgr) from emp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.显示雇员工资的最大差值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select max(sal)-min(sal) from emp;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;多子句查询&lt;/h4&gt;
&lt;p&gt;顺序：如果一个select语句同时包含了group by，having，limit，order by，那么它们的顺序应该为：group by，having，order by，limit&lt;/p&gt;
&lt;p&gt;例如统计各个部门的平均工资，并且是大于1000的，按照平均工资从高到低排序，取出前两行记录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select avg(sal),deptno from emp 
group by deptno 
having avg(sal)&amp;gt;1000 
order by avg(sal) desc 
limit 0, 2;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其实更建议使用as重命名，可以增快速度&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select avg(sal) as asql, deptno from emp 
group by deptno 
having asql&amp;gt;1000 
order by asql desc 
limit 0, 2;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+----------+--------+
| avg(sal) | deptno |
+----------+--------+
|   1887.5 |     20 |
|   1737.5 |     30 |
+----------+--------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;多表查询&lt;/h3&gt;
&lt;p&gt;多表查询是指基于两个和两个以上的表的查询，在实际的应用中，查询单个表可能不能满足需求&lt;/p&gt;
&lt;p&gt;例如说显示雇员名，雇员工资，所在部门的名字，就需要员工表和工作部门表&lt;/p&gt;
&lt;h4&gt;多表笛卡尔集&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;select * from emp, dept;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可见笛卡尔集需要将两种表做笛卡尔积（在不加条件的结果非常夸张）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+-------+--------+----------+------+------------+------+------+--------+--------+------------+----------+
| empno | ename  | job      | mgr  | hiredate   | sal  | comm | deptno | deptno | dname      | loc      |
+-------+--------+----------+------+------------+------+------+--------+--------+------------+----------+
|  7396 | SMITH  | CLERK    | 7902 | 1990-12-17 |  800 | NULL |     20 |     40 | OPERATIONS | BOSTON   |
|  7396 | SMITH  | CLERK    | 7902 | 1990-12-17 |  800 | NULL |     20 |     30 | SALES      | CHICAGO  |
|  7396 | SMITH  | CLERK    | 7902 | 1990-12-17 |  800 | NULL |     20 |     20 | RESEARCH   | DALLAS   |
|  7396 | SMITH  | CLERK    | 7902 | 1990-12-17 |  800 | NULL |     20 |     10 | ACCOUNTING | NEW YORK |
|  7499 | ALLEN  | SALESMAN | 7902 | 1991-02-20 | 1600 |  300 |     30 |     40 | OPERATIONS | BOSTON   |
|  7499 | ALLEN  | SALESMAN | 7902 | 1991-02-20 | 1600 |  300 |     30 |     30 | SALES      | CHICAGO  |
|  7499 | ALLEN  | SALESMAN | 7902 | 1991-02-20 | 1600 |  300 |     30 |     20 | RESEARCH   | DALLAS   |
|  7499 | ALLEN  | SALESMAN | 7902 | 1991-02-20 | 1600 |  300 |     30 |     10 | ACCOUNTING | NEW YORK |
|  7596 | WARD   | SALESMAN | 7902 | 1993-02-07 | 1250 |  500 |     30 |     40 | OPERATIONS | BOSTON   |
|  7596 | WARD   | SALESMAN | 7902 | 1993-02-07 | 1250 |  500 |     30 |     30 | SALES      | CHICAGO  |
|  7596 | WARD   | SALESMAN | 7902 | 1993-02-07 | 1250 |  500 |     30 |     20 | RESEARCH   | DALLAS   |
|  7596 | WARD   | SALESMAN | 7902 | 1993-02-07 | 1250 |  500 |     30 |     10 | ACCOUNTING | NEW YORK |
|  7696 | JOOES  | MANAGER  | 7839 | 1980-02-01 | 2975 |  100 |     20 |     40 | OPERATIONS | BOSTON   |
|  7696 | JOOES  | MANAGER  | 7839 | 1980-02-01 | 2975 |  100 |     20 |     30 | SALES      | CHICAGO  |
|  7696 | JOOES  | MANAGER  | 7839 | 1980-02-01 | 2975 |  100 |     20 |     20 | RESEARCH   | DALLAS   |
|  7696 | JOOES  | MANAGER  | 7839 | 1980-02-01 | 2975 |  100 |     20 |     10 | ACCOUNTING | NEW YORK |
|  7796 | MARTIN | SALESMAN | 7698 | 1999-04-17 | 1250 | 1400 |     30 |     40 | OPERATIONS | BOSTON   |
|  7796 | MARTIN | SALESMAN | 7698 | 1999-04-17 | 1250 | 1400 |     30 |     30 | SALES      | CHICAGO  |
|  7796 | MARTIN | SALESMAN | 7698 | 1999-04-17 | 1250 | 1400 |     30 |     20 | RESEARCH   | DALLAS   |
|  7796 | MARTIN | SALESMAN | 7698 | 1999-04-17 | 1250 | 1400 |     30 |     10 | ACCOUNTING | NEW YORK |
|  7896 | BLAKE  | MANAGER  | 7839 | 1990-12-17 | 2850 | NULL |     30 |     40 | OPERATIONS | BOSTON   |
|  7896 | BLAKE  | MANAGER  | 7839 | 1990-12-17 | 2850 | NULL |     30 |     30 | SALES      | CHICAGO  |
|  7896 | BLAKE  | MANAGER  | 7839 | 1990-12-17 | 2850 | NULL |     30 |     20 | RESEARCH   | DALLAS   |
|  7896 | BLAKE  | MANAGER  | 7839 | 1990-12-17 | 2850 | NULL |     30 |     10 | ACCOUNTING | NEW YORK |
+-------+--------+----------+------+------------+------+------+--------+--------+------------+----------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当不加限制的情况下，两张表的查询规则：&lt;/p&gt;
&lt;p&gt;把第一张表的每一条记录和第二张表的每一条记录组合，返回结果是两张表的所有列，一共返回的记录数是第一张表的行数和第二张表的行数的乘积，而组成的表称为笛卡尔集&lt;/p&gt;
&lt;p&gt;我们需要使用where对于笛卡尔集进行过滤，需要进行分析&lt;/p&gt;
&lt;p&gt;当两张表的deptno编号相等的时候才是我们需要的结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp, dept where emp.deptno=dept.deptno;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+-------+--------+----------+------+------------+------+------+--------+--------+----------+---------+
| empno | ename  | job      | mgr  | hiredate   | sal  | comm | deptno | deptno | dname    | loc     |
+-------+--------+----------+------+------------+------+------+--------+--------+----------+---------+
|  7396 | SMITH  | CLERK    | 7902 | 1990-12-17 |  800 | NULL |     20 |     20 | RESEARCH | DALLAS  |
|  7499 | ALLEN  | SALESMAN | 7902 | 1991-02-20 | 1600 |  300 |     30 |     30 | SALES    | CHICAGO |
|  7596 | WARD   | SALESMAN | 7902 | 1993-02-07 | 1250 |  500 |     30 |     30 | SALES    | CHICAGO |
|  7696 | JOOES  | MANAGER  | 7839 | 1980-02-01 | 2975 |  100 |     20 |     20 | RESEARCH | DALLAS  |
|  7796 | MARTIN | SALESMAN | 7698 | 1999-04-17 | 1250 | 1400 |     30 |     30 | SALES    | CHICAGO |
|  7896 | BLAKE  | MANAGER  | 7839 | 1990-12-17 | 2850 | NULL |     30 |     30 | SALES    | CHICAGO |
+-------+--------+----------+------+------------+------+------+--------+--------+----------+---------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;笛卡尔例题&lt;/h4&gt;
&lt;p&gt;显示雇员名，雇员工资，所在部门的名字&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,sal,dname from emp, dept where emp.deptno=dept.deptno;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+--------+------+----------+
| ename  | sal  | dname    |
+--------+------+----------+
| SMITH  |  800 | RESEARCH |
| ALLEN  | 1600 | SALES    |
| WARD   | 1250 | SALES    |
| JOOES  | 2975 | RESEARCH |
| MARTIN | 1250 | SALES    |
| BLAKE  | 2850 | SALES    |
+--------+------+----------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而在选取重复列的时候，需要指定是哪一个表的列&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,sal,dname,emp.deptno from emp, dept where emp.deptno=dept.deptno;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+--------+------+----------+--------+
| ename  | sal  | dname    | deptno |
+--------+------+----------+--------+
| SMITH  |  800 | RESEARCH |     20 |
| ALLEN  | 1600 | SALES    |     30 |
| WARD   | 1250 | SALES    |     30 |
| JOOES  | 2975 | RESEARCH |     20 |
| MARTIN | 1250 | SALES    |     30 |
| BLAKE  | 2850 | SALES    |     30 |
+--------+------+----------+--------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;显示部门编号为20的部门名称，员工名，工资&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,sal,dname,emp.deptno 
from emp,dept 
where emp.deptno = dept.deptno 
and emp.deptno = 20;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+-------+------+----------+--------+
| ename | sal  | dname    | deptno |
+-------+------+----------+--------+
| SMITH |  800 | RESEARCH |     20 |
| JOOES | 2975 | RESEARCH |     20 |
+-------+------+----------+--------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;显示各个员工的姓名，工资，以及工资级别&lt;/p&gt;
&lt;p&gt;我们先选好需要的表格是emp表和salgrade表，我们这一道题的要点在于过滤条件该如何筛选&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,sal,grade from emp, salgrade;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+--------+------+-------+
| ename  | sal  | grade |
+--------+------+-------+
| SMITH  |  800 |     4 |
| SMITH  |  800 |     3 |
| SMITH  |  800 |     2 |
| SMITH  |  800 |     1 |
| ALLEN  | 1600 |     4 |
| ALLEN  | 1600 |     3 |
| ALLEN  | 1600 |     2 |
| ALLEN  | 1600 |     1 |
| WARD   | 1250 |     4 |
| WARD   | 1250 |     3 |
| WARD   | 1250 |     2 |
| WARD   | 1250 |     1 |
| JOOES  | 2975 |     4 |
| JOOES  | 2975 |     3 |
| JOOES  | 2975 |     2 |
| JOOES  | 2975 |     1 |
| MARTIN | 1250 |     4 |
| MARTIN | 1250 |     3 |
| MARTIN | 1250 |     2 |
| MARTIN | 1250 |     1 |
| BLAKE  | 2850 |     4 |
| BLAKE  | 2850 |     3 |
| BLAKE  | 2850 |     2 |
| BLAKE  | 2850 |     1 |
+--------+------+-------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运用between and语句即可完成，判断sal位于最高工资和最低工资之间即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,sal,grade from emp, salgrade 
where sal between losal and hisal;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+--------+------+-------+
| ename  | sal  | grade |
+--------+------+-------+
| SMITH  |  800 |     1 |
| ALLEN  | 1600 |     3 |
| WARD   | 1250 |     2 |
| JOOES  | 2975 |     3 |
| MARTIN | 1250 |     2 |
| BLAKE  | 2850 |     3 |
+--------+------+-------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;自连接&lt;/h4&gt;
&lt;p&gt;是指的是同一张表的连接查询&lt;/p&gt;
&lt;p&gt;显示公司员工和它上级的名字&lt;/p&gt;
&lt;p&gt;这个时候我们就需要使用到表的自连接，将员工和上级放在同一行中筛选完成（还需要有一个别名）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp empee, emp boss;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样就可以将同一张表连接起来，我们再去写过滤条件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select empee.ename,boss.ename  
from emp empee, emp boss 
where empee.mgr = boss.empno;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+-------+-------+
| ename | ename |
+-------+-------+
| WARD  | BLAKE |
+-------+-------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;子查询&lt;/h3&gt;
&lt;p&gt;子查询是指嵌入在其他sql语句中的select语句，也成为嵌套查询&lt;/p&gt;
&lt;p&gt;单行子查询：只返回一行数据的子查询语句&lt;/p&gt;
&lt;p&gt;多行子查询：返回多行数据的子查询语句（in）&lt;/p&gt;
&lt;p&gt;单行子查询例题&lt;/p&gt;
&lt;p&gt;如何显示于SMITH同一部门的所有员工&lt;/p&gt;
&lt;p&gt;我们首先需要得到SMITH的部门号，再通过部门号筛选&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select deptno from emp where ename = &apos;SMITH&apos;;//20
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;select * from emp where deptno = 20;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们可以把第一个查询嵌入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp 
where deptno = (
	select deptno 
    from emp 
    where ename = &apos;SMITH&apos;
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即可完成&lt;/p&gt;
&lt;p&gt;多行子查询例题&lt;/p&gt;
&lt;p&gt;查询和部门20的工作相同的雇员的名字、岗位、部门号，但是不包含20自己的&lt;/p&gt;
&lt;p&gt;第一步：查询20号部门有哪一些工作岗位（还需要去重）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select distinct job from emp where deptno = 20;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+---------+
| job     |
+---------+
| CLERK   |
| MANAGER |
+---------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二步：运用job的工作字段进行查询筛选&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,job,sal,deptno from emp 
where job in(&apos;CLERK&apos;,&apos;MANAGER&apos;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第三步：不包含20号部门&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,job,sal,deptno from emp 
where job in(&apos;CLERK&apos;,&apos;MANAGER&apos;) and deptno&amp;lt;&amp;gt;20;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;综合嵌套一下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,job,sal,deptno from emp 
where job in(
	select distinct job 
	from emp 
	where deptno = 20) 
and deptno&amp;lt;&amp;gt;20;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;子查询临时表&lt;/h4&gt;
&lt;p&gt;查询ecshop中各个类别中，价格最高的商品&lt;/p&gt;
&lt;p&gt;先得到各个类别中价格最高的商品&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select cat_id, max(shop_price) from ecsshop
group by cat_id;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们可以将这个表格和ecsshop表进行连接，在设置过滤条件即可完成要求&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ecshop.cat_id, ecshop.goods_name 
from ecshop,(
select cat_id, max(shop_price) as max_price
from ecshop
group by cat_id)temp
where ecshop.cat_id=temp.cat_id 
and ecshop.shop_price=temp.max_price;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;all和any操作符&lt;/h4&gt;
&lt;p&gt;all&lt;/p&gt;
&lt;p&gt;所有的字段都满足&lt;/p&gt;
&lt;p&gt;显示比部门30的所有员工的工资高的员工姓名、工资、部门号&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,sal,deptno from emp 
where sal&amp;gt;
all(
    select sal 
    from emp 
    where deptno = 30);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以运用max查询最大的薪水，再通过判断条件筛选&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,sal,deptno from emp 
where sal&amp;gt;
(select max(sal) 
 from emp 
 where deptno = 30);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;any&lt;/p&gt;
&lt;p&gt;有一个字段满足条件即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,sal,deptno from emp 
where sal&amp;gt;
any(
    select sal 
    from emp 
    where deptno = 30);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以改为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,sal,deptno from emp 
where sal&amp;gt;
(select min(sal) 
 from emp 
 where deptno = 30);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;多列子查询&lt;/h4&gt;
&lt;p&gt;多列子查询指的是查询返回多个列数据的子查询语句&lt;/p&gt;
&lt;p&gt;例如查询于SMITH部门，岗位完全相同的所有雇员&lt;/p&gt;
&lt;p&gt;第一步：查询SMITH所在的部门以及岗位&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select deptno,job from emp where ename=&apos;SMITH&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+--------+-------+
| deptno | job   |
+--------+-------+
|     20 | CLERK |
+--------+-------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二步：将上述的查询结果当作查询使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename, deptno, job from emp 
where deptno=20 
and job=&apos;CLERK&apos;
and ename&amp;lt;&amp;gt;&apos;SMITH&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;综合嵌套(运用（）来进行相应的字段匹配)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename, deptno, job from emp 
where (deptno, job) = (
	select deptno,job from emp 
    where ename=&apos;SMITH&apos;
)
and ename&amp;lt;&amp;gt;&apos;SMITH&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;相关例题&lt;/h4&gt;
&lt;p&gt;例题一：&lt;/p&gt;
&lt;p&gt;查找每个部门工资高于本部门平均工资人的资料&lt;/p&gt;
&lt;p&gt;第一步：查询部门的平均工资&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select deptno, avg(sal) from emp group by deptno;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二步：将查询的结果表和员工表进行拼接，再进行筛选&lt;/p&gt;
&lt;p&gt;(这里的emp.*代表选出emp表的所有字段)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select emp.* from emp,(
	select deptno, avg(sal)as avg_sal
	from emp group by deptno
)temp where emp.deptno=temp.deptno 
and emp.sal&amp;gt;temp.avg_sal;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例题二：&lt;/p&gt;
&lt;p&gt;查询每个部门工资最高的人的详细资料&lt;/p&gt;
&lt;p&gt;第一步：查询部门的最高工资&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select deptno, max(sal) from emp group by deptno;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二步：将查询的结果表和员工表进行拼接，再进行筛选&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select emp.* from emp,(
	select deptno, max(sal)as avg_sal
	from emp group by deptno
)temp where emp.deptno=temp.deptno 
and emp.sal=temp.avg_sal;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例题三：&lt;/p&gt;
&lt;p&gt;查询每个部门的信息（包括：部门名，编号，地址）和人员数量&lt;/p&gt;
&lt;p&gt;思路：我们的信息来自于dept表，而人员数量需要构建临时表格&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select count(*),deptno from emp group by deptno;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+----------+--------+
| count(*) | deptno |
+----------+--------+
|        2 |     20 |
|        4 |     30 |
+----------+--------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;和部门信息表格拼接&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select dept.*, countp 
from dept,(
	select deptno,count(*)as countp 
	from emp 
    group by deptno)temp 
where dept.deptno=temp.deptno;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+--------+----------+---------+--------+
| deptno | dname    | loc     | countp |
+--------+----------+---------+--------+
|     20 | RESEARCH | DALLAS  |      2 |
|     30 | SALES    | CHICAGO |      4 |
+--------+----------+---------+--------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;表复制&lt;/h3&gt;
&lt;h4&gt;自我复制数据&lt;/h4&gt;
&lt;p&gt;有的时候，为了对于某个sql语句进行效率测试，我们需要海量的数据，可以使用此法为表创建海量的数据&lt;/p&gt;
&lt;p&gt;例如创建这一张表&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create table my_table(	
	id int,
    `name` varchar(32),
	sal double,
	job varchar(32),
	deptno int
	);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们先将emp表中的内容复制到创建的新表中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;insert into my_table(id,`name`,sal,job,deptno)
select empno,ename,sal,job,deptno from emp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;自我复制：每一次都会将表中的内容复制添加到自己的表中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;insert into my_table
select * from my_table;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;去除表中的重复数据&lt;/h4&gt;
&lt;p&gt;可以通过like创建一个新表，格式和旧表一样&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create table table2 like table1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;思路：&lt;/p&gt;
&lt;p&gt;1.创建一张临时表mytemp,该表数据结构和my_table一样&lt;/p&gt;
&lt;p&gt;2.把my_temp的记录通过distinct关键字处理复制&lt;/p&gt;
&lt;p&gt;3.清除掉原先表my_table的记录&lt;/p&gt;
&lt;p&gt;4.将my_temp的记录复制到my_table&lt;/p&gt;
&lt;p&gt;5.drop删除临时表my_temp&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create table my_temp like my_table;

insert into my_temp
select distinct * from my_table;

delete from my_table;

insert into my_table
select * from my_temp;

drop table my_temp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者你直接删除原先的my_table表，再将my_temp表格更改名称为my_table&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rename table my_temp to my_table;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;合并查询&lt;/h3&gt;
&lt;h4&gt;union&lt;/h4&gt;
&lt;p&gt;在实际使用的时候，有的时候我们需要合并多个select语句查询到的结果，我们会用到union操作&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select... union select...;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例如我们查询职业名称为clerk和部门号为20的并集&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp where job=&apos;clerk&apos; 
union select * from emp where deptno=20;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;union all&lt;/h4&gt;
&lt;p&gt;如果你添加了all，则不会去除重复内容&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp where job=&apos;clerk&apos; 
union all select * from emp where deptno=20;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;外连接&lt;/h3&gt;
&lt;h4&gt;问题引出&lt;/h4&gt;
&lt;p&gt;还记得之前我们的多表查询嘛，我们在合并表的时候会求多表的笛卡尔集&lt;/p&gt;
&lt;p&gt;我们有一个要求如下：列出部门名称和这些部门的员工名称和工作，同时要求显示出那些没有员工的部门名&lt;/p&gt;
&lt;p&gt;我们如果用笛卡尔积的话查询结果如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select dname,ename,job 
from emp,dept 
where emp.deptno=dept.deptno;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+----------+--------+----------+
| dname    | ename  | job      |
+----------+--------+----------+
| RESEARCH | SMITH  | CLERK    |
| RESEARCH | JOOES  | MANAGER  |
| SALES    | ALLEN  | SALESMAN |
| SALES    | WARD   | SALESMAN |
| SALES    | MARTIN | SALESMAN |
| SALES    | BLAKE  | MANAGER  |
+----------+--------+----------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是事实上我们的部门中还有其他的部门没有显示出来&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+--------+------------+----------+
| deptno | dname      | loc      |
+--------+------------+----------+
|     10 | ACCOUNTING | NEW YORK |
|     20 | RESEARCH   | DALLAS   |
|     30 | SALES      | CHICAGO  |
|     40 | OPERATIONS | BOSTON   |
+--------+------------+----------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是因为员工表的部门号没有10、40无法匹配到部门表，我们要实现显示出那些没有员工的部门，我们需要外连接，我们创建如下的表作演示&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE stu (
`id` INT,
`name` VARCHAR ( 32 ));

INSERT INTO stu
VALUES
	( 1, &apos;Jack&apos; ),
	( 2, &apos;Tom&apos; ),
	( 3, &apos;Kity&apos; ),
	( 4, &apos;nono&apos; );
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE exam (
`id` INT,
`grade` INT);

INSERT INTO exam
VALUES
	( 1, 56 ),
	( 2, 76 ),
	( 11, 8 );
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用where条件筛选后&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from stu,exam where stu.id=exam.id;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+----+------+----+-------+
| id | name | id | grade |
+----+------+----+-------+
|  1 | Jack |  1 |    56 |
|  2 | Tom  |  2 |    76 |
+----+------+----+-------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可见是没有11号id和4号id的行记录的，因为id不是左右两表都有&lt;/p&gt;
&lt;h4&gt;左外连接&lt;/h4&gt;
&lt;p&gt;左侧的表完全显示（如果没有成绩也要显示姓名与id）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from stu left join exam on stu.id=exam.id;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+----+------+------+-------+
| id | name | id   | grade |
+----+------+------+-------+
|  1 | Jack |    1 |    56 |
|  2 | Tom  |    2 |    76 |
|  3 | Kity | NULL | NULL  |
|  4 | nono | NULL | NULL  |
+----+------+------+-------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;右外连接&lt;/h4&gt;
&lt;p&gt;又侧的表完全显示（如果没有姓名也要显示成绩与id）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from stu right join exam on stu.id=exam.id;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+------+------+----+-------+
| id   | name | id | grade |
+------+------+----+-------+
|    1 | Jack |  1 |    56 |
|    2 | Tom  |  2 |    76 |
| NULL | NULL | 11 |     8 |
+------+------+----+-------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;例题&lt;/h4&gt;
&lt;p&gt;回到我们的例题：列出部门名称和这些部门的员工名称和工作，同时要求显示出那些没有员工的部门名&lt;/p&gt;
&lt;p&gt;左外连接实现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select dept.deptno,dname,ename,job 
from dept left join emp 
on dept.deptno=emp.deptno; 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+--------+------------+--------+----------+
| deptno | dname      | ename  | job      |
+--------+------------+--------+----------+
|     10 | ACCOUNTING | NULL   | NULL     |
|     20 | RESEARCH   | JOOES  | MANAGER  |
|     20 | RESEARCH   | SMITH  | CLERK    |
|     30 | SALES      | BLAKE  | MANAGER  |
|     30 | SALES      | MARTIN | SALESMAN |
|     30 | SALES      | WARD   | SALESMAN |
|     30 | SALES      | ALLEN  | SALESMAN |
|     40 | OPERATIONS | NULL   | NULL     |
+--------+------------+--------+----------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;右外连接实现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select dept.deptno,dname,ename,job 
from emp right join dept 
on dept.deptno=emp.deptno; 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+--------+------------+--------+----------+
| deptno | dname      | ename  | job      |
+--------+------------+--------+----------+
|     10 | ACCOUNTING | NULL   | NULL     |
|     20 | RESEARCH   | JOOES  | MANAGER  |
|     20 | RESEARCH   | SMITH  | CLERK    |
|     30 | SALES      | BLAKE  | MANAGER  |
|     30 | SALES      | MARTIN | SALESMAN |
|     30 | SALES      | WARD   | SALESMAN |
|     30 | SALES      | ALLEN  | SALESMAN |
|     40 | OPERATIONS | NULL   | NULL     |
+--------+------------+--------+----------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;MySQL中的约束&lt;/h2&gt;
&lt;p&gt;何为约束？&lt;/p&gt;
&lt;p&gt;约束是用于确保数据库数据满足特定的商业规则，而再mysql中约束包括not null、unique、primary key、foreign key、check五种&lt;/p&gt;
&lt;h3&gt;primary key&lt;/h3&gt;
&lt;p&gt;primary key：用于唯一的标示表行的数据，当定义主键约束之后，该列不可以重复，以下是一个案例&lt;/p&gt;
&lt;p&gt;创建一个主键为id表，向其中插入数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE primary_test (
	`id` INT PRIMARY KEY,
	`name` VARCHAR ( 32 ),
	`email` VARCHAR ( 32 ) 
)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;insert into primary_test values
(1,&apos;jack&apos;,&apos;jack@qq.com&apos;),
(2,&apos;marry&apos;,&apos;marry@gmail.com&apos;),
(3,&apos;lory&apos;,&apos;lory@163.com&apos;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们现在加一条语句，id为1（之前加过id为1的记录）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;insert into primary_test values(1,&apos;jerry&apos;,&apos;jerry@qq.com&apos;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;报错&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; 1062 - Duplicate entry &apos;1&apos; for key &apos;primary_test.PRIMARY&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;主键的细节&lt;/p&gt;
&lt;p&gt;1.一张表最多只能有一个主键，但可以是复合主键&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE primary_test2 (
	`id` INT ,
	`name` VARCHAR ( 32 ),
	`email` VARCHAR ( 32 ) ,
	 primary key(`id`,`name`)
) ;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.主键的指定方式有两种，第一种是直接在字段名 类型后加上primary key，第二种是在表的定义最后加上primary key(列名)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE primary_test4 (
	`id` INT ,
	`name` VARCHAR ( 32 ),
	`email` VARCHAR ( 32 ) ,
	 primary key(`id`)
) ;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.使用desc可以查看主键情况&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+-------+-------------+------+-----+---------+-------+
| Field | Type        | Null | Key | Default | Extra |
+-------+-------------+------+-----+---------+-------+
| id    | int         | NO   | PRI | NULL    |       |
| name  | varchar(32) | YES  |     | NULL    |       |
| email | varchar(32) | YES  |     | NULL    |       |
+-------+-------------+------+-----+---------+-------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.主键不可以重复且不能为空&lt;/p&gt;
&lt;h3&gt;not null&lt;/h3&gt;
&lt;p&gt;非空约束，当列上定义了not null，那么插入数据的时候必须要提供数据&lt;/p&gt;
&lt;h3&gt;unique&lt;/h3&gt;
&lt;p&gt;唯一约束&lt;/p&gt;
&lt;p&gt;1.当定义了唯一约束的时候，该列的值不可以重复&lt;/p&gt;
&lt;p&gt;2.一张表可以有多个unique字段&lt;/p&gt;
&lt;p&gt;3.当unique没有添加非空约束，则unique字段可以有多个null&lt;/p&gt;
&lt;h3&gt;foreign key&lt;/h3&gt;
&lt;p&gt;外键&lt;/p&gt;
&lt;p&gt;用于定义主表和从表之间的关系：外键约束要定义在从表上，主表则必须要拥有主键约束或者是unique约束，当定义外键约束后，要求外键列数据必须要在主表的主键列存在或者是null&lt;/p&gt;
&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;p&gt;例如我们有一个学生表其中有id和class_id，还有一个班级表，有属性id，如果我们要求，每个学生所在的班级号class_id是存在于班级表的，就可以把class_id做成外键约束（班级表为主表，而学生表为从表）&lt;/p&gt;
&lt;p&gt;当我们插入一个学生它的班级编号不存在于班级表，则插入失败&lt;/p&gt;
&lt;p&gt;当我们学生表有一个学生他的班级编号存在班级表，则删除对应的班级表id会删除失败&lt;/p&gt;
&lt;p&gt;班级表（主表）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE my_class (
	`id` INT primary key,
	`name` VARCHAR ( 32 ),
	`add` VARCHAR ( 32 ) 
) ;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;学生表（从表）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE my_stu (
	`id` INT primary key,
	`name` VARCHAR (32) NOT NULL,
	`class_id` int,
	foreign key(class_id) references my_class(id)
) ;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;外键细节&lt;/p&gt;
&lt;p&gt;1.外键指向的表字段，要求为primary key或者是unique&lt;/p&gt;
&lt;p&gt;2.表的类型是innodb，这样的表才支持外键&lt;/p&gt;
&lt;p&gt;3.外键字段的类型要求和主键字段类型一致&lt;/p&gt;
&lt;p&gt;4.外键字段的值必须要求在主键字段中出现过，或者为null&lt;/p&gt;
&lt;p&gt;5.一旦建立主外键的关系，数据就不可以随意删除了&lt;/p&gt;
&lt;h3&gt;check&lt;/h3&gt;
&lt;p&gt;用于强制行数据必须满足条件，注意在mysql 5.7，这里插入不符合check的数据会成功（只是会提示）8.0是会生效的&lt;/p&gt;
&lt;p&gt;假设sal列上定义了check约束，并要求sql列值在1000-2000之间，性别为两个，那么如果插入的记录如果不满足相关条件就会提示报错&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE test (
	`id` INT primary key,
	`name` VARCHAR (32) NOT NULL,
	`sex` VARCHAR(10) CHECK (`sex` IN(&apos;man&apos;,&apos;woman&apos;)),
	`sal` double CHECK (`sal`&amp;gt;1000 and `sal`&amp;lt;2000)
) ;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;表设计&lt;/h3&gt;
&lt;p&gt;现有一个商店的数据库shop_database，记录客户以及其购物情况，有以下的三个表组成&lt;/p&gt;
&lt;p&gt;goods商品表：&lt;/p&gt;
&lt;p&gt;商品号goods_id  商品名称goods_name  价格price  商品类别category 供货商provider&lt;/p&gt;
&lt;p&gt;customer顾客表：&lt;/p&gt;
&lt;p&gt;客户号customer_id  姓名name  住址address  邮箱email  性别sex  身份证id&lt;/p&gt;
&lt;p&gt;purchase购买表：&lt;/p&gt;
&lt;p&gt;订单号order_id  客户号customer_id  商品号goods_id  购买数量nums&lt;/p&gt;
&lt;p&gt;要求如下：&lt;/p&gt;
&lt;p&gt;1.合理定义主键、外键&lt;/p&gt;
&lt;p&gt;2.客户姓名不可以为空值&lt;/p&gt;
&lt;p&gt;3.电子邮箱不可以为重复&lt;/p&gt;
&lt;p&gt;4.客户的性别约束‘男’|‘女’&lt;/p&gt;
&lt;p&gt;5.价格在1.0——9999.99之间&lt;/p&gt;
&lt;p&gt;goods&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create table goods(
goods_id int primary key,
goods_name varchar(30) not null default &apos;&apos;,
price decimal(10,2)not null 
    check(price between 1.0 and 9999.99),
category int not null default &apos;&apos;,
provider varchar(30)
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;customer&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create table customer(
customer_id int primary key,
name varchar(30) not null,
address varchar(30),
email varchar(30),
sex varchar(10) check(sex IN(&apos;男&apos;,&apos;女&apos;)),
id decimal(20,0) unique
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;purchase&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create table purchase(
order_id int primary key,
customer_id int not null,
goods_id int not null,
nums int,
FOREIGN key(customer_id) REFERENCES customer(customer_id),
FOREIGN key(goods_id) REFERENCES goods(goods_id)
);
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>MySQL笔记</title><link>https://thrinisty.github.io/posts/mysql%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E4%BF%AE%E6%94%B9%E8%A1%A8crud%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/mysql%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E4%BF%AE%E6%94%B9%E8%A1%A8crud%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</guid><description>修改表，CRUD，常用函数</description><pubDate>Fri, 11 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;MySQL笔记&lt;/h1&gt;
&lt;h2&gt;修改表&lt;/h2&gt;
&lt;p&gt;我们修改表可以通过图形化界面进行修改，这一般比较方便，但是有一些限制，例如需要批量修改，条件限制的情况，我们也需要学会通过指令来对于表进行操作&lt;/p&gt;
&lt;h3&gt;添加列&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;ALTER TABLE table_name ADD(column datatype [DEFAULT expr]
, column datatype [DEFAULT expr]...);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;修改列&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;ALTER TABLE table_name MODIFY(column datatype [DEFAULT expr]
, column datatype [DEFAULT expr]...);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;删除列&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;ALTER TABLE table_name DROP(column);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;重命名表&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;RENAME TABLE `oldTable` TO `newTable`;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;查看表结构&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;desc newtable;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+------------+-------------+------+-----+---------+-------+
| Field      | Type        | Null | Key | Default | Extra |
+------------+-------------+------+-----+---------+-------+
| id         | int         | YES  |     | NULL    |       |
| name       | varchar(20) | YES  |     | NULL    |       |
| sex        | char(1)     | YES  |     | NULL    |       |
| birthday   | date        | YES  |     | NULL    |       |
| entry_date | datetime    | YES  |     | NULL    |       |
| job        | varchar(20) | YES  |     | NULL    |       |
| Salary     | double      | YES  |     | NULL    |       |
| resume     | text        | YES  |     | NULL    |       |
+------------+-------------+------+-----+---------+-------+
8 rows in set (0.09 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;修改表字符集&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;ALTER TABLE table_name character set utf8;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;例题&lt;/h3&gt;
&lt;p&gt;1.在创建的员工表上增加一个image列，varchar类型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ALTER TABLE employ ADD `image` VARCHAR ( 30 );
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.修改job列，使其长度为60&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ALTER TABLE employ MODIFY `job` VARCHAR ( 60 );
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.删除sex列&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ALTER TABLE employ DROP `sex`;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.将表名更改为employee&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rename table employ to employee;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.修改表的字符集为utf8&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ALTER TABLE employee CHARACTER SET utf8;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;6.将列名name修改为user_name&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ALTER TABLE employee CHANGE `name` user_name VARCHAR(32); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们在修改列属性的时候可以加一些规则，例如不为空，默认为&apos;null&apos;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ALTER TABLE employee MODIFY `user_name` VARCHAR(32) NOT NULL DEFAULT &apos;null&apos;; 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;CRUD&lt;/h2&gt;
&lt;p&gt;create read update delete 增删改查&lt;/p&gt;
&lt;p&gt;我们在之前也曾用到过这一些语句，现在我们系统的来进行学习CRUD&lt;/p&gt;
&lt;h3&gt;Insert（增）&lt;/h3&gt;
&lt;h4&gt;基本使用&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;INSERT INTO table_name [(column, column, ...)] VALUES (value, value, ...)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例如&lt;/p&gt;
&lt;p&gt;创建一张商品表(id int , goods_name varchar(10), price double)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE goods(
`id` int,
`goods_name` varchar(10),
`price` double);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中添加两条数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;INSERT INTO goods VALUES (1, &apos;牙刷&apos;, 10.0);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;INSERT INTO goods (id, goods_name) VALUES (2, &apos;牙膏&apos;);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; select * from goods;

+----+------------+-------+
| id | goods_name | price |
+----+------------+-------+
|  1 | 牙刷       |    10 |
|  2 | 牙膏       | NULL  |
+----+------------+-------+
2 rows in set (0.08 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;注意细节&lt;/h4&gt;
&lt;p&gt;1.插入的数据应该与字段的数据类型相同&lt;/p&gt;
&lt;p&gt;2.数据的长度因该在列的规定范围内&lt;/p&gt;
&lt;p&gt;3.value中列出的数据位置必须于被加入的列的排列位置对应&lt;/p&gt;
&lt;p&gt;4.字符和日期类型数据需要包含在单引号中&lt;/p&gt;
&lt;p&gt;5.列允许插入空值（前期是字段不是NOT NULL）&lt;/p&gt;
&lt;p&gt;6.插入的记录可以有多条，在后续加（），（）即可&lt;/p&gt;
&lt;p&gt;7.如果是表中的所有字段添加数据的时候，可以不写字段名称&lt;/p&gt;
&lt;p&gt;8.默认值的使用，当不给某个字段值的时候，如果有默认值就会添加，否则填入null，如果NOT NULL则报错&lt;/p&gt;
&lt;h3&gt;Update（改）&lt;/h3&gt;
&lt;h4&gt;基本使用&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;UPDATE table_name SET col_name1 = expr1 [col_name2 = expr2] [WHERE where_definition]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以下是一个使用案例&lt;/p&gt;
&lt;p&gt;1.将所有的员工薪水修改为5000元&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;UPDATE employee SET Salary = 5000;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.将力宏的薪水修改为3000元&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;UPDATE employee SET Salary = 3000 WHERE `user_name`=&apos;力宏&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.将lory的薪水上调1000元&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;UPDATE employee SET Salary = Salary + 1000 WHERE `user_name`=&apos;lory&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;使用细节&lt;/h4&gt;
&lt;p&gt;1.UPDATE语法可以指定用新值更新原有表行中的各列&lt;/p&gt;
&lt;p&gt;2.SET子句指定要修改那些列和赋予的哪些值&lt;/p&gt;
&lt;p&gt;3.WHERE子句指定应该更新哪些行，如果没有，则更新所有的行&lt;/p&gt;
&lt;p&gt;4.如果需要修改多个字段，可以通过set 字段1= value，set 字段2= value...完成，例如如下代码，就顺便进行了id++&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;UPDATE employee SET Salary = Salary + 1000, id = id + 1 WHERE `user_name`=&apos;lory&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Delete（删）&lt;/h3&gt;
&lt;h4&gt;基本使用&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;DELETE FROM table_name [WHERE where_definition];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;案例&lt;/p&gt;
&lt;p&gt;1.删除用户名为力宏的记录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DELETE FROM employee WHERE `user_name`=&apos;力宏&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.删除表中的所有记录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DELETE FROM employee;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;使用细节&lt;/h4&gt;
&lt;p&gt;1.如果不加WHERE子句，就会删除表中所有的记录&lt;/p&gt;
&lt;p&gt;2.DELETE语句不可以删除某一列的值（可以使用update更新字段为null）&lt;/p&gt;
&lt;p&gt;3.使用DELETE语句尽可以删除表的记录，不可以删除表本身，需要使用DROP删除表&lt;/p&gt;
&lt;h3&gt;Select（查）&lt;/h3&gt;
&lt;p&gt;算是数据库的一个重点&lt;/p&gt;
&lt;h4&gt;基本使用&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;SELECT [DISTINCT] * | [column1, colum2, ...] FROM table_name [WHERE where_definition];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中DISTANCT可选，表示是否去除重复数据&lt;/p&gt;
&lt;p&gt;1.查询所有的员工&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from employee;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+----+-----------+------+--------+
| id | user_name | job  | Salary |
+----+-----------+------+--------+
|  1 | 李明      | NULL |   2000 |
|  1 | 李明      | NULL |   2000 |
|  2 | 王丽      | NULL |   2000 |
|  3 | 丽华      | NULL |  20003 |
|  4 | 李儒      | NULL |   2000 |
|  5 | 小明      | NULL |   2000 |
|  6 | lory      | NULL |  20003 |
+----+-----------+------+--------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.查询非重复的员工（每个字段都相同）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select distinct * from employee;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+----+-----------+------+--------+
| id | user_name | job  | Salary |
+----+-----------+------+--------+
|  1 | 李明      | NULL |   2000 |
|  2 | 王丽      | NULL |   2000 |
|  3 | 丽华      | NULL |  20003 |
|  4 | 李儒      | NULL |   2000 |
|  5 | 小明      | NULL |   2000 |
|  6 | lory      | NULL |  20003 |
+----+-----------+------+--------+
6 rows in set (0.07 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.SELECT语句可以进行一些运算&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT * | (column1 | expression, column2 | expression, ...)FROME table_name;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例如在查询科目成绩时可以指定查询的一列为其他的几列相加&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT (english + math + chinese) as `grades` from table_name;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.SELECT可以使用as语句取别名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT column_name as other_name from table_name;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;SELECT `user_name` as `name`, `Salary` as `money` FROM `employee`
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+------+-------+
| name | money |
+------+-------+
| 李明 |  2000 |
| 李明 |  2000 |
| 王丽 |  2000 |
| 丽华 | 20003 |
| 李儒 |  2000 |
| 小明 |  2000 |
| lory | 20003 |
+------+-------+
7 rows in set (0.07 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.和改删一样，SELECT一样可以运用WHERE过滤&lt;/p&gt;
&lt;p&gt;常见的运算符&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;运算符&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&amp;gt;  &amp;lt;  &amp;lt;=  &amp;gt;=  =  &amp;lt;&amp;gt;&lt;/td&gt;
&lt;td&gt;大于 小于 大于等于 小于等于 等于 不等于&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BETWEEN...AND...&lt;/td&gt;
&lt;td&gt;显示在某一区间内的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;IN(set)&lt;/td&gt;
&lt;td&gt;显示在in列表中的值，如in(100，200)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[NOT] LIKE &apos;张pattern&apos;&lt;/td&gt;
&lt;td&gt;模糊查询&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;IS NULL&lt;/td&gt;
&lt;td&gt;判断是否为空&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;and&lt;/td&gt;
&lt;td&gt;并&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;or&lt;/td&gt;
&lt;td&gt;或&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;not&lt;/td&gt;
&lt;td&gt;非&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;6.使用order by设置排序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT  * | [column1, colum2, ...] FROM table_name 
ORDER BY column1 asc|desc;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;排序的列可以是表中的列名，也可以select语句中指定的列名&lt;/p&gt;
&lt;p&gt;Asc升序 Desc降序&lt;/p&gt;
&lt;p&gt;ORDER BY 子句应该位于SELECT语句的末尾&lt;/p&gt;
&lt;p&gt;7.group by + having&lt;/p&gt;
&lt;p&gt;使用group by子句对列进行分组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT column1, colum2, ... FROM table_name 
group by column;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用having子句对分组后的结果过滤&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT column1, colum2, ... FROM table_name 
group by column1 having ...;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用案例&lt;/p&gt;
&lt;p&gt;1.显示每个部门的平均工资和最高工资&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT AVG(sal), MAX(sal), deptno FROM emp GROUP BY deptno;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.显示每个部门的每种岗位的平均工资和最低工资&lt;/p&gt;
&lt;p&gt;可以先显示每个部门的平均工资和最低工资&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT AVG(sal), MIN(sal), deptno FROM emp GROUP BY deptno;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还需要再添加一个分组的标准&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT AVG(sal), MIN(sal), deptno, job FROM emp GROUP BY deptno, job;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.显示平均工资低于2000的部门号和他的平均工资&lt;/p&gt;
&lt;p&gt;先显示各个部门的平均工资和部门号&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT AVG(sal), deptno FROM emp 
GROUP BY deptno;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后运用having进行过滤实现平均工资小于2000&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT AVG(sal) as avg_sal, deptno FROM emp 
GROUP BY deptno
HAVING avg_sal &amp;lt; 2000;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以下是SELECT使用例题：&lt;/p&gt;
&lt;p&gt;1.对数学成绩排序后输出[升序]&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT * FROM student ORDER BY `math` asc;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.对总分按照降序排序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT `name` , (`math`+`english`+`chinese`) as grade FROM student ORDER BY grade desc;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.对姓李的学生按照成绩排序输出[升序]&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT * FROM student WHERE `name` LIKE &apos;李%&apos; ORDER BY (`math`+`english`+`chinese`)  asc;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;例题&lt;/h4&gt;
&lt;p&gt;1.查询math大于60并且id大于90的学生成绩&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT * FROM student WHERE `math` &amp;gt; 60 and id &amp;gt; 90;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.查询英语成绩大于语文成绩的同学&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT * FROM student WHERE `math` &amp;gt; `chinese`;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.查询总分大于200分并且数学成绩小于语文成绩的韩姓同学&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT * FROM student WHERE (`math`+`chinese`+`english`)&amp;gt;200 and `math`&amp;lt;`chinese` and user_name LIKE &apos;韩%&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.查询英语成绩在80-90分的同学(闭区间)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT * FROM student WHERE `english` BETWEEN 80 AND 90;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.查询数学分数为89，90，91的同学&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT * FROM student WHERE `english` IN(89,90,91);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;重要的函数&lt;/h2&gt;
&lt;h3&gt;Count&lt;/h3&gt;
&lt;p&gt;统计函数&lt;/p&gt;
&lt;h4&gt;基本使用&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;SELECT COUNT(*) | COUNT(column) FROM table_name [WHERE where_definition];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;count(*)和count(column)区别&lt;/p&gt;
&lt;p&gt;count(*)返回满足条件记录的行数&lt;/p&gt;
&lt;p&gt;count(column)统计满足条件的某列有多少的，但排除对应列为null的情况&lt;/p&gt;
&lt;h4&gt;使用案例&lt;/h4&gt;
&lt;p&gt;1.统计班级里一共有几个学生&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select count(*) from student where `grade`
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+----------+
| count(*) |
+----------+
|        7 |
+----------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.统计总分大于300的学生个数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select count(*) from student where `grade` &amp;gt; 300;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+----------+
| count(*) |
+----------+
|        4 |
+----------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;SUM&lt;/h3&gt;
&lt;p&gt;合计函数&lt;/p&gt;
&lt;p&gt;Sum函数返回满足where条件的行的和---一般使用在数值列&lt;/p&gt;
&lt;h4&gt;基本使用&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;SELECT SUM(column) FROM table_name [WHERE where_definition];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;仅对数值起作用&lt;/p&gt;
&lt;h4&gt;使用案例&lt;/h4&gt;
&lt;p&gt;1.统计一个班数学总成绩&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT SUM(math) FROM student;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.统计一个班语文、英语、数学各科的总成绩&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT SUM(math),SUM(english),SUM(chinese) FROM student;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.统计一个班语文、英语、数学各科和的总成绩&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT SUM(math + english + chinese) FROM student;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.统计一个班级语文的平均分&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT SUM(chinese)/COUNT(*) FROM student;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者我们也可以使用AVG统计函数求平均值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT AVG(chinese) FROM student;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;AVG&lt;/h3&gt;
&lt;h4&gt;基本使用&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;SELECT AVG(column) FROM table_name [WHERE where_definition];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用案例如上，不再过多赘述&lt;/p&gt;
&lt;h3&gt;MAX/MIN&lt;/h3&gt;
&lt;p&gt;数值范围在统计中特别有用&lt;/p&gt;
&lt;h4&gt;基本使用&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;SELECT MAX/MIN(column) FROM table_name [WHERE where_definition];
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;使用案例&lt;/h4&gt;
&lt;p&gt;1.求班级最高分&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT MAX(math + english + chinese)，MIN(math + english + chinese) FROM student;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.求出班级数学最高分&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT MAX(math)，MIN(math) FROM student;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;字符串函数&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;字符串函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;CHARSET(str)&lt;/td&gt;
&lt;td&gt;返回字串字符集&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CONCAT(str2 [,...])&lt;/td&gt;
&lt;td&gt;连接字串&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;INSTR(string, substring)&lt;/td&gt;
&lt;td&gt;返回substring在string中出现的位置，没有则返回0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UCASE(str2)&lt;/td&gt;
&lt;td&gt;转为大写&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LCASE(str2)&lt;/td&gt;
&lt;td&gt;转为小写&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LEFT(str2, length)&lt;/td&gt;
&lt;td&gt;从str2中的左边起取length个字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LENGTH(string)&lt;/td&gt;
&lt;td&gt;string长度[按照字节]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;REPLACE(str, search_str, replace_str)&lt;/td&gt;
&lt;td&gt;在str中用字符串替换&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;STRCMP(str1,str2)&lt;/td&gt;
&lt;td&gt;逐个字符比较两个字符串大小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SUBSTRING(str, position [length])&lt;/td&gt;
&lt;td&gt;从str的position开始，取length个字符，不写则取完&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LTRIM(str2) RTRIM(str2)&lt;/td&gt;
&lt;td&gt;去除前端空格去除后端空格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;trim&lt;/td&gt;
&lt;td&gt;去除左右两边空格&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;基本使用&lt;/h4&gt;
&lt;p&gt;CHARSET(str)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT CHARSET(name) FROM emp;
//返回字符集（utf8）
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;CONCAT(str2 [,...])&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT CONCAT(name, &apos;job is&apos;, job) as name_job FROM emp;
//字符串拼接
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;INSTR(string, substring)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT INSTR(string, &apos;target&apos;) FROM DUAL;--其中DUAL是亚元表
//返回出现位置
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;UCASE(str2) LCASE(str2)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT UCASE(name) FROM emp;//转为大写
SELECT LCASE(name) FROM emp;//转为小写
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;LEFT(str2, length) RIGHT(str2, length)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT LEFT(name, 2) FROM emp;//从左取2个字符
SELECT RIGHT(name, 2) FROM emp;//从右取2个字符
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;LENGTH(string)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT LENGTH(name) FROM emp;//返回名字长度
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;REPLACE(str, search_str, replace_str)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT REPLACE(name, &apos;a&apos;, &apos;b&apos;) FROM emp;
//将名字中的a替换为b
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;STRCMP(str1,str2)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT STRCMP(str1,str2) FROM DUAL;
//比较字符串大小 小于返回-1 大于返回1 等于返回0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;SUBSTRING(str, position [length])&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT SUBSTRING(name, 1, 2) FROM emp;
//从第一个位置开始取两个字符
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;LTRIM(str2)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT LTRIM(&apos; 名字&apos;) FROM DUAL;//&apos;名字&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;例题&lt;/h4&gt;
&lt;p&gt;以首字母小写的方式显示所有员工emp表的名字&lt;/p&gt;
&lt;p&gt;取出第一个字符转为小写然后和后面的字符拼接&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT CONCAT(LCASE(LEFT(name, 1)),
SUBSTRING(name,2,LENGTH(name))) FROM emp;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;数学函数&lt;/h3&gt;
&lt;p&gt;有很多，我挑几个常用的&lt;/p&gt;
&lt;h4&gt;ABS(num)&lt;/h4&gt;
&lt;p&gt;绝对值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT ABS(-1) FROM DUAL;//1
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;CEILING(number)&lt;/h4&gt;
&lt;p&gt;向上取整，得到比number大的最小整数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT CEILING(1.34) FROM DUAL;//2
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;FLOOR(number)&lt;/h4&gt;
&lt;p&gt;向下取整，得到比number小的最大整数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT FLOOR(1.34) FROM DUAL;//1
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;RAND([seed])&lt;/h4&gt;
&lt;p&gt;随机数范围为[0,1,0]&lt;/p&gt;
&lt;p&gt;不加种子返回的数每次都不同&lt;/p&gt;
&lt;p&gt;种子指定后返回的数不变&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT RAND(6) FROM DUAL;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;日期相关函数&lt;/h3&gt;
&lt;p&gt;对于日期而言也有非常多的相关函数，有点小多，在这里不过多介绍，即查即用&lt;/p&gt;
&lt;h3&gt;加密函数于系统函数&lt;/h3&gt;
&lt;h4&gt;USER()&lt;/h4&gt;
&lt;p&gt;显示登录到mysql有哪些用户以及登陆的IP&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select user() from dual;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+----------------+
| user()         |
+----------------+
| root@localhost |
+----------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;DATABASE()&lt;/h4&gt;
&lt;p&gt;查询使用数据库名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select DATABASE() from dual;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+------------+
| DATABASE() |
+------------+
| dbtest     |
+------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;MD5(str)&lt;/h4&gt;
&lt;p&gt;为字符串计算出一个MD5 32的字符串，常用为用户密码加密(32位)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select MD5(&apos;密码&apos;) from dual;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+----------------------------------+
| MD5(&apos;密码&apos;)                      |
+----------------------------------+
| a8105204604a0b11e916f3879aae3b0b |
+----------------------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;UPDATE user SET `password`=MD5(654321);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;PASSWORD(str)&lt;/h4&gt;
&lt;p&gt;加密函数，是MySQL使用的加密方式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from mysql.user
//其中的$A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED就是加密后的密码
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;流程控制函数&lt;/h3&gt;
&lt;h4&gt;IF(expr1,expr2,expr3)&lt;/h4&gt;
&lt;p&gt;如果表达式1为真，返回expr2，否则返回expr3&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT IF(TRUE, &apos;BEIJING&apos;, &apos;SHANGHAI&apos;) FROM DUAL;//BEIJING
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;IFNULL(expr1,expr2)&lt;/h4&gt;
&lt;p&gt;如果表达式1为NULL，返回expr1，否则返回expr2&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT IFNULL(&apos;BEIJING&apos;, &apos;SHANGHAI&apos;) FROM DUAL;//BEIJING
SELECT IFNULL(&apos;NULL&apos;, &apos;SHANGHAI&apos;) FROM DUAL;//SHANGHAI
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;多分支函数&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;SELECT CASE 
WHEN expr1 THEN expr2 
WHEN expr3 THEN expr4 
ELSE expr5
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;SELECT CASE 
WHEN FALSE THEN expr2 
WHEN TRUE THEN expr4 
ELSE expr5 END
//返回expr2
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;例题&lt;/h4&gt;
&lt;p&gt;查询emp表，如果comm是null，就显示0.0&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT name, IF(comm IS NULL, 0.0, comm) FROM emp;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;SELECT name, IFNULL(comm, 0.0) FROM emp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果emp表的job是CLERK则显示职员，如果是MANAGER则显示经理，如果是SALESMAN就显示销售人员，其他正常显示&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT name, (
SELECT CASE 
WHEN job=&apos;CLERK&apos; THEN &apos;职员&apos; 
WHEN job=&apos;MANAGER&apos; THEN &apos;经理&apos; 
WHEN job=&apos;SALESMAN&apos; THEN &apos;销售人员&apos; 
ELSE job END) AS &apos;job&apos;
FROM emp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上就是MySQL的基本语句，查询的基础部分，和一些常见的函数，我们明天会进入增强查询（多表查询）&lt;/p&gt;
</content:encoded></item><item><title>MySQL笔记</title><link>https://thrinisty.github.io/posts/mysql%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/mysql%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D/</guid><description>基本使用，数据类型，备份恢复</description><pubDate>Thu, 10 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;MySQL&lt;/h1&gt;
&lt;p&gt;​	经过40天的Java学习，我系统性的学习了Java相关知识点，了解了各个知识点背后的源码逻辑，可以用Java语言实现各类算法，以及解决实际问题，独立的设计，编写相关项目。&lt;/p&gt;
&lt;p&gt;​	而从今天开始我将开始数据库的学习，预计5天完成MySQL数据库基本操作的学习，之后运用JDBC完成一个实战项目&lt;/p&gt;
&lt;p&gt;​	我在之前选修数据库课程的时候，只是停留在理论上，对于知识的理解也只是限于应付考试，为了更好的理解数据库以及更好的使用数据库，我决定再次回顾相关知识点，并且整理笔记&lt;/p&gt;
&lt;h2&gt;MySQL的基本使用&lt;/h2&gt;
&lt;p&gt;关于MySQL的安装我就不过多赘述，因为之前也安装过了，详见各大网站上的安装使用教程照着安装即可&lt;/p&gt;
&lt;h3&gt;MySQL启动服务&lt;/h3&gt;
&lt;p&gt;在我这里因为安装的时候设置为开机自动启用，所以不用执行该指令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;net start mysql
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同样的如果需要停止服务&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;net stop mysql
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以通过以下的指令查看数据库服务是否启用（root）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sc query MySQL80
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;显示MySQL80在运行状态&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SERVICE_NAME: MySQL80
        TYPE               : 10  WIN32_OWN_PROCESS
        STATE              : 4  RUNNING
                                (STOPPABLE, PAUSABLE, ACCEPTS_SHUTDOWN)
        WIN32_EXIT_CODE    : 0  (0x0)
        SERVICE_EXIT_CODE  : 0  (0x0)
        CHECKPOINT         : 0x0
        WAIT_HINT          : 0x0
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;MySQL数据库的本地连接&lt;/h3&gt;
&lt;p&gt;-h 表示连接的主机 localhost为本地主机&lt;/p&gt;
&lt;p&gt;-P 代表的是连接端口&lt;/p&gt;
&lt;p&gt;-u 代表的是登录用户名称&lt;/p&gt;
&lt;p&gt;-p654321 （输入登录密码，p后不加空格）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql -h localhost -P 3306 -u root -p654321
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果我们需要对于账户和密码进行修改我们可以在链接到数据库后，使用如下的指令对于账户的密码进行修改（654321）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;你的新密码&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其实我们的登录账户名称和账户密码也会被存放在数据库中，我们上述的指令就是对于存放密码的数据库表进行更改操作&lt;/p&gt;
&lt;h2&gt;数据库的三层结构&lt;/h2&gt;
&lt;p&gt;1.所谓安装Mysql数据库，就是在主机上安装一个数据管理系统（DBMS），这个管理程序可以创建多个数据库&lt;/p&gt;
&lt;p&gt;2.一个数据库中可以创建多个表，用以保存数据&lt;/p&gt;
&lt;p&gt;3.数据库管理系统，数据库，表之间的关系（三层结构）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/109.png&quot; alt=&quot;109&quot; /&gt;&lt;/p&gt;
&lt;p&gt;数据库和表本质上是文件，存放在内存中&lt;/p&gt;
&lt;p&gt;表中的一行称之为一条记录，而在Java中一条记录使用一个对象来表示&lt;/p&gt;
&lt;h1&gt;SQL语句分类&lt;/h1&gt;
&lt;p&gt;DDL：数据定义语句（create 表，库.......）&lt;/p&gt;
&lt;p&gt;DML：数据操作语句（增删改查）&lt;/p&gt;
&lt;p&gt;DQL：数据查询语句（select）&lt;/p&gt;
&lt;p&gt;DCL：数据控制语句（管理数据库：如grant revoke）&lt;/p&gt;
&lt;h2&gt;创建数据库&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;CREATE DATABASE [IF NOT EXISTS] db_name
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;例题&lt;/h3&gt;
&lt;p&gt;1.创建一个名为lory_db01的数据库&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create database lory_db01;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除数据库&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;drop database lory_db01;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.创建一个使用utf-8字符集的lory_db02的数据库&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create database lory_db02 character set utf8;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.创建一个使用utf-8字符集并带校对规则的lory_db03的数据库(区分大小写utf8_bin)默认不区分大小写&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create database lory_db03 character set utf8 collate utf8_bin;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;区分大小与否&lt;/h3&gt;
&lt;p&gt;不区分大小写的情况下使用查询语句&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; select * from students where name = &apos;b&apos;;
+----+------+
| id | name |
+----+------+
| B  | B    |
| d  | b    |
+----+------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;区分大小写的情况下（利用COLLARTE指定）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; SELECT * FROM students WHERE name COLLATE utf8mb4_bin = &apos;b&apos;;
+----+------+
| id | name |
+----+------+
| d  | b    |
+----+------+
1 row in set (0.04 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;查询数据库&lt;/h2&gt;
&lt;h3&gt;显示数据库语句&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;show databases;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; show databases;
+--------------------+
| Database           |
+--------------------+
| dbtest             |
| information_schema |
| mysql              |
| performance_schema |
| sakila             |
| student            |
| sys                |
| test               |
| world              |
+--------------------+
9 rows in set (0.06 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;显示数据库创建语句&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;show create database db_name;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; show create database student;

| Database | Create Database                       
| student  | CREATE DATABASE `student` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci */ /*!80016 DEFAULT ENCRYPTION=&apos;N&apos; */ |

1 row in set (0.05 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;数据库删除语句&lt;/h3&gt;
&lt;p&gt;[ ]中内容可选&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;drop database [IF EXISTS] db_name;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;备份与恢复&lt;/h2&gt;
&lt;p&gt;备份是实际工作中非常重要的部分，我们无论是要进行数据库转移还是损坏后的恢复，都需要使用到备份和恢复数据库&lt;/p&gt;
&lt;h3&gt;备份数据库相关指令&lt;/h3&gt;
&lt;h4&gt;备份&lt;/h4&gt;
&lt;p&gt;mysqldump&lt;/p&gt;
&lt;p&gt;(注意是在dos命令行中执行而不是数据库命令行界面)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysqldump -u root -p**** -B DB_1 DB_2 ... &amp;gt; File.sql
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;C:\Windows\System32&amp;gt; mysqldump -u root -p654321 -B dbtest &amp;gt; d:\\test.sql
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行后在对应的路径下有一个备份文件，文件中其中存放了一些SQL语句，通过重新执行这些语句我们就可以恢复数据库中的内容（还有一些其他的信息）&lt;/p&gt;
&lt;h4&gt;恢复&lt;/h4&gt;
&lt;p&gt;source&lt;/p&gt;
&lt;p&gt;(注意在数据库命令行中执行)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;source d:/test.sql;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然你也可以将sql备份文件中的SQL语句直接执行&lt;/p&gt;
&lt;h3&gt;备份数据库表&lt;/h3&gt;
&lt;h4&gt;备份&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;mysqldump -u root -p db_01 table_1 table_2 ... &amp;gt; File.sql
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;恢复&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;source d:/test.sql;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;创建数据库表&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;create table table_name
(
	fieldname1 datatype,
	fieldname2 datatype,
	fieldname3 datatype,
)character set 字符集 collate 校对规则 engine 存储引擎
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;field：指定列名  datatype：指定字段类型  character set：不指定则默认为所在数据库字符集	collate：如不指定默认为所在数据库校对规则 engine（讲解待定）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE student1 (
    id INT,
    name VARCHAR(255),
    password VARCHAR(255)
)
CHARACTER SET utf8mb4 
COLLATE utf8mb4_bin 
ENGINE=InnoDB;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;MySQL列类型&lt;/h1&gt;
&lt;h2&gt;类型总览&lt;/h2&gt;
&lt;h3&gt;数值类型&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;数据类型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;BIT(M)&lt;/td&gt;
&lt;td&gt;位类型，M指定位数（1-64）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TINYINY [UNSIGNED]&lt;/td&gt;
&lt;td&gt;占一个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SAMLLINT [UNSIGNED]&lt;/td&gt;
&lt;td&gt;占两个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MEDIUMINT [UNSIGNED]&lt;/td&gt;
&lt;td&gt;占三个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;INT [UNSIGENED]&lt;/td&gt;
&lt;td&gt;INT类型，占4个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BIGINT [UNSIGHNED]&lt;/td&gt;
&lt;td&gt;占8个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FLOAT [UNSIGHNED]&lt;/td&gt;
&lt;td&gt;浮点型占4个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DOUBLE [UNSIGHED]&lt;/td&gt;
&lt;td&gt;浮点型占8个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DECIMAL(M,D)&lt;/td&gt;
&lt;td&gt;定点数M指定长度，D表示小数点位数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;文本、二进制类型&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;数据类型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;CHAR(size) char(20)&lt;/td&gt;
&lt;td&gt;固定长度字符串，最大255&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;VARCHAR(size)&lt;/td&gt;
&lt;td&gt;可变长度字符串，0-65535&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BLOB LONGBLOB&lt;/td&gt;
&lt;td&gt;二进制数据 BLOB （2^16）LONGBLOB（2^32）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TEXT LONGTEXT&lt;/td&gt;
&lt;td&gt;文本Text （2^16）LONGTEXT（2^32）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;时间日日期类型&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;数据类型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;DATE/DATETIME/TimeStamp&lt;/td&gt;
&lt;td&gt;日期类型（YYYY-MM-DD）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;TimeStamp表示时间戳，可用于自定记录insert、updata操作的时间&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/110.png&quot; alt=&quot;110&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;Mysql常用数据类型&lt;/h2&gt;
&lt;p&gt;其中用的比较多的有以下几个&lt;/p&gt;
&lt;p&gt;int double decimal char varchar text datatime&lt;/p&gt;
&lt;p&gt;在实际使用的时候，在满足要求的情况下尽量用小的数据类型&lt;/p&gt;
&lt;h3&gt;整形&lt;/h3&gt;
&lt;h4&gt;TINYINT&lt;/h4&gt;
&lt;p&gt;以tinyint为例，支持-128~127，或者添加无符号参数支持0-255&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE test(id TINYINT);
CREATE TABLE test(id TINYINT unsigned);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;BIT&lt;/h4&gt;
&lt;p&gt;1.bit(m) m在1-64&lt;/p&gt;
&lt;p&gt;2.添加数据范围按照给定的位数确定，2的m次方&lt;/p&gt;
&lt;p&gt;3.显示的时候按照bit&lt;/p&gt;
&lt;p&gt;4.查询时任然可以按照数来查询&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE test01(id BIT(8));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;插入数据以位的形式存储显示&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;INSERT INTO test01 VALUES(13);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;00001101
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;浮点型&lt;/h3&gt;
&lt;h4&gt;DECIMAL&lt;/h4&gt;
&lt;p&gt;1.FLOAT/DOUBLE于JAVA一样，单精度浮点数以及双精度&lt;/p&gt;
&lt;p&gt;2.DECIMAL可以支持更加精确的小数位，M为小数位数总数，D是小数点后面的位数&lt;/p&gt;
&lt;p&gt;3.如果D为0，则没有小数点和小数部分，M最大为65，D最大为30，如果D省略，默认为0，若M省略，默认为10&lt;/p&gt;
&lt;p&gt;4.如果希望精度较高推荐使用decimal&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DECIMAL[M,D][UNSIGNED]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE test02(num1 DECIMAL(30,20), num2 FLOAT);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;INSERT INTO test02 VALUES(88.1324, 133);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;字符串&lt;/h3&gt;
&lt;h4&gt;CHAR(size)&lt;/h4&gt;
&lt;p&gt;固定长度字符串，最大为255字符&lt;/p&gt;
&lt;h4&gt;VARCHAR(size)&lt;/h4&gt;
&lt;p&gt;可变长度字符串，最大为65532字节（utf-8编码最大21844字符 1-3个字节用于记录大小）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE test03(num1 VARCHAR(21844), num2 CHAR(255));
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;INSERT INTO test03 VALUES(&apos;helloworld&apos;, &apos;你好&apos;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;子字符串使用细节&lt;/h4&gt;
&lt;p&gt;1.char(m)和.varchar(m) m表示的是字符数，无论中英文都最多放m个&lt;/p&gt;
&lt;p&gt;2.char(4)是固定长度，即使插入aa，也会占据4个字符的空间，而varchar(4)是变长，会按照实际占用的空间分配，除此之外还需要1-3个字节存放记录内容长度&lt;/p&gt;
&lt;p&gt;3.如何选择：如果数据是定长的，例如手机，邮编等就用char，如果是不确定的就用varchar，例如留言，文章等，而在查询速度的上而言char的速度快于varchar&lt;/p&gt;
&lt;p&gt;4.在存放文本的时候也可以使用Text数据类型（更利于空间使用例如英文占一个字节，而中文占用三个字节），可以将TEXT列视为VAECHAR列，注意TEXT不可以有默认值，大小为0-2的16次，还需要更多的时候可以选择MEDIUMTEXT 或者 LONGTEXT&lt;/p&gt;
&lt;h3&gt;日期类型&lt;/h3&gt;
&lt;h4&gt;基本使用&lt;/h4&gt;
&lt;p&gt;时间戳可以设置为更新时的当前时间，这里没有加&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE test04 ( birthday DATE, job_time DATETIME, login_time TIMESTAMP );
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;INSERT INTO test04(birthday, job_time) VALUES(&apos;2022-2-22&apos;, &apos;2022-2-22 10:10:10&apos;);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+------------+---------------------+------------+
| birthday   | job_time            | login_time |
+------------+---------------------+------------+
| 2022-02-22 | 2022-02-22 10:10:10 | NULL       |
+------------+---------------------+------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以下是一个自动更新的例子&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE test05 (
  birthday DATE,
  job_time DATETIME,
  login_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+------------+---------------------+---------------------+
| birthday   | job_time            | login_time          |
+------------+---------------------+---------------------+
| 2022-02-22 | 2022-02-22 10:10:10 | 2025-04-11 15:35:43 |
| 2022-02-22 | 2022-02-22 10:10:10 | 2025-04-11 15:35:44 |
| 2022-02-22 | 2022-02-22 10:10:10 | 2025-04-11 15:35:45 |
| 2022-02-22 | 2022-02-22 10:10:10 | 2025-04-11 15:35:45 |
+------------+---------------------+---------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;创建表例题&lt;/h3&gt;
&lt;p&gt;创建一个员工表，选取适当的数据类型&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;字段&lt;/th&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;id&lt;/td&gt;
&lt;td&gt;整形&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;name&lt;/td&gt;
&lt;td&gt;字符型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sex&lt;/td&gt;
&lt;td&gt;字符型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;birthday&lt;/td&gt;
&lt;td&gt;日期型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;entry_date&lt;/td&gt;
&lt;td&gt;日期型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;job&lt;/td&gt;
&lt;td&gt;字符型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Salary&lt;/td&gt;
&lt;td&gt;小数型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;resume&lt;/td&gt;
&lt;td&gt;文本型&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;创建表格&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE `empty`(
	id INT,
	`name` VARCHAR ( 20 ),
	sex CHAR ( 1 ),
	birthday DATE,
	entry_date DATETIME,
	job VARCHAR ( 20 ),
	Salary DOUBLE,
	`resume` TEXT 
);
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>自学第一月份总结</title><link>https://thrinisty.github.io/posts/%E8%87%AA%E5%AD%A6%E7%AC%AC%E4%B8%80%E6%9C%88%E4%BB%BD%E6%80%BB%E7%BB%93/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/%E8%87%AA%E5%AD%A6%E7%AC%AC%E4%B8%80%E6%9C%88%E4%BB%BD%E6%80%BB%E7%BB%93/</guid><description>收获多多</description><pubDate>Tue, 01 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;自学第一月份总结&lt;/h1&gt;
&lt;p&gt;​	还是过的挺快的，从三月初决定不再考研开始，我投入了大量的时间去巩固Java的基础，也刷了很少的一部分面试算法题目，回顾了一些来自于之前课堂上的知识，例如操作系统，计算机网络等。&lt;/p&gt;
&lt;p&gt;​	也是在这一个月中很幸运的收到了来自第一份正式的面试邀约，无论结果如何，都对我是一次很好的锻炼机会吧。我也明白，虽然自身能力目前还达不到找到工作的水准，但是我知道自己也是在不断地向前走的，回过来看一看我自己，相比刚来到大学的时候的青涩，不敢勇于表达而言，我在面试中可以较为完整的表达出来自自己的一些观点，有着自己的一些思考，算是不错的进步了。&lt;/p&gt;
&lt;p&gt;​	从计划而言，原先的Java30天速成的计划可能得向后延期了，因为我发现，除了我原先想的知识以外，还有很多实用的Java外知识等着我去学习，如MySQL数据库，SQL注入，JDBC，正规式等要学完这一些，得再加上15天的时间，哎，总之继续努力吧。&lt;/p&gt;
&lt;p&gt;​	在课余上，买了把吉他，天天都会把自己折磨的有点手疼，进步也是蛮快的，15天左右了，练了些基础上的内容，拿着变调夹也可以弹一些简单的安河桥之类的，晴天前奏（学会扫弦还不大可能）&lt;/p&gt;
&lt;p&gt;​	感觉还是非常充实的一个月，收获很大，也有按时吃早餐，但是早睡是不可能的，最起码得留点时间给辛苦一天自己玩。&lt;/p&gt;
</content:encoded></item><item><title>面试小结</title><link>https://thrinisty.github.io/posts/%E9%9D%A2%E8%AF%95%E5%B0%8F%E7%BB%93/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/%E9%9D%A2%E8%AF%95%E5%B0%8F%E7%BB%93/</guid><description>字节跳动面试总结</description><pubDate>Thu, 27 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;面试小结&lt;/h1&gt;
&lt;p&gt;这一次面试没有想象中的那么压力山大，面试官也没有去死咬着某个知识点去提问，而是通过投递的简历来提问，其中计算机操作系统相关的题目较多，而我有对计算机系统方面的线程进程问题又比较了解，在这个部分表现得还算过得去，但是在于存储的方面我确实没有一个很好的实践积累，回答的大多都是在理论上的知识点，还有设备IO方面，我知道的也不是很多，面试官看我不是很清楚也就没有深挖。计算机网络相关的基础没有问到，不知道是不是看我的简历上有一两个网络编程的经验就跳过了。&lt;/p&gt;
&lt;p&gt;缺少知识点：多线程相关的细节，Mysql，Redis，哈希表，红黑树&lt;/p&gt;
&lt;p&gt;面试除了基础知识的提问，还考察了在设计项目上的思路，例如操作系统上如何去降低一个响应的时间：我除了进程之外也懂得不多，我就回答的是可以优化进程调度的一个策略，例如调整时间片大小，在线程之下创建亚线程。内存我直接不管了，另外加多CPU支持并行，多的我面试的时候也没有想到。&lt;/p&gt;
&lt;p&gt;以下是AI生成的其他回答&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; I/O优化
异步I/O：用非阻塞I/O（如epoll、io_uring）替代同步阻塞调用。

缓冲和批处理：合并小I/O请求为大操作（如磁盘写合并）。

SSD/高速存储：替换机械硬盘，降低I/O延迟。

内核参数调优
调整调度器：如Linux的CFS（完全公平调度器）参数或改用实时调度策略（SCHED_FIFO）。

中断优化：启用中断负载均衡（irqbalance），或绑定中断到特定CPU。

亚线程/协程：将任务拆分为更轻量级的单元（如协程、用户态线程），减少阻塞。

CPU绑定（Affinity）：将关键进程绑定到特定CPU核心，避免缓存失效和迁移开销。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;网络相关场景题&lt;/h3&gt;
&lt;p&gt;还有在网络繁忙的时候该如何解决大量访问的问题，这里我回答的是一个限流，以下是常见的限流算法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;令牌桶（Token Bucket）：

固定速率生成令牌，请求需消耗令牌（突发流量允许一定峰值）。

实现工具：Nginx limit_req、Redis + Lua脚本。

漏桶（Leaky Bucket）：

请求以恒定速率处理（平滑流量，严格限制突发）。

固定窗口/滑动窗口计数：

统计单位时间内的请求数（如每分钟100次），滑动窗口更精确但开销略高。

自适应限流：

根据系统负载动态调整阈值（如CPU、队列长度），如Netflix的Hystrix。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以下是AI回答&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;流量整形与负载均衡
队列缓冲：用消息队列（Kafka、RabbitMQ）异步处理请求，削峰填谷。

负载均衡：

横向扩展：增加服务实例，通过LB（如Nginx、HAProxy）分发流量。

智能路由：根据服务器负载动态分配请求（如Least Connections算法）。

服务降级与熔断
降级：关闭非核心功能（如推荐服务），返回缓存或默认值。

熔断：当错误率超过阈值时，短暂拒绝请求（如Hystrix、Resilience4j）。

服务隔离：将关键服务与非关键服务分离（如线程池隔离）。

缓存优化
多级缓存：

客户端缓存 → CDN → 服务端缓存（Redis）→ 数据库缓存。

热点数据预加载：提前缓存高频访问数据（如秒杀商品库存）。

弹性伸缩与云原生方案
自动扩缩容：Kubernetes HPA、AWS Auto Scaling。

Serverless：突发流量由无服务函数（如AWS Lambda）处理。

协议与连接优化
长连接复用：减少TCP握手开销（如HTTP/2、gRPC）。

压缩数据：减小传输体积（如Gzip、Protobuf）。

快速失败：设置超时时间（如TCP SYN队列调优）。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;哈希表和红黑树&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;：&lt;em&gt;“哈希表和红黑树有什么区别？如何选择？”&lt;/em&gt;
&lt;strong&gt;回答模板&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;先对比核心特性&lt;/strong&gt;：
“哈希表基于哈希函数，理想情况下查询是&lt;code&gt;O(1)&lt;/code&gt;，但可能因冲突退化；红黑树是自平衡二叉搜索树，稳定在&lt;code&gt;O(log n)&lt;/code&gt;，且支持有序遍历。”&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提优缺点&lt;/strong&gt;：
“哈希表内存占用大但查询快，适合字典类场景；红黑树更省内存且有序，适合范围查询。”&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;举例应用&lt;/strong&gt;：
“比如Java的&lt;code&gt;HashMap&lt;/code&gt;用哈希表实现快速查找，而&lt;code&gt;TreeMap&lt;/code&gt;用红黑树保证键的有序性。”&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;哈希表如何解决冲突？&lt;/strong&gt;
→ 拉链法（链表+红黑树，如Java 8的&lt;code&gt;HashMap&lt;/code&gt;）、开放寻址法。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;红黑树 vs AVL树？&lt;/strong&gt;
→ 红黑树牺牲严格平衡性换取更少的旋转操作，适合频繁插入删除的场景。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;算法题目&lt;/h3&gt;
&lt;p&gt;有思路的，可惜没有写出来，以下是题目样例，具体的输入我想不起来了&lt;/p&gt;
&lt;p&gt;我理解的这是一种压缩的方式：&lt;/p&gt;
&lt;p&gt;例如字符串 ab[avv]{2}dd 代表的是 abavvavvdd，要求写一个算法输入字符串，输出对应的字符串，这一道题我的理解是将 [ 放入栈结构里面，记录右侧下表，遇到]时候弹栈，读取后面的循环次数（限制为2-9，不然更麻烦了），循环输出，但是这里有个重点是这样一个[ ] 是要求可以嵌套使用的，最后写出来的只能处理不嵌套的一种样式，以下是 AI生成的算法，学学看吧&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.algorithm;
import java.util.Stack;

public class Interview {
    public static void main(String[] args) {
        String s1 = &quot;ab[avv]{2}dd&quot;;
        System.out.println(decodeString(s1));  // 输出: abavvavvdd

        String s2 = &quot;a[b[c]{2}]{3}d&quot;;
        System.out.println(decodeString(s2));  // 输出: abccbccbccd
    }

    // 手动实现的字符串重复方法（兼容 Java 8）
    public static String repeat(String str, int times) {
        if (times &amp;lt;= 0) {
            return &quot;&quot;;
        }
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i &amp;lt; times; i++) {
            sb.append(str);
        }
        return sb.toString();
    }

    public static String decodeString(String s) {
        Stack&amp;lt;StringBuilder&amp;gt; strStack = new Stack&amp;lt;&amp;gt;();
        Stack&amp;lt;Integer&amp;gt; numStack = new Stack&amp;lt;&amp;gt;();
        StringBuilder currentStr = new StringBuilder();
        int i = 0;
        int n = s.length();

        while (i &amp;lt; n) {
            char c = s.charAt(i);
            if (c == &apos;[&apos;) {
                // 遇到 &apos;[&apos;, 压栈当前状态
                strStack.push(currentStr);
                currentStr = new StringBuilder();
                i++;
            } else if (c == &apos;]&apos;) {
                // 遇到 &apos;]&apos;, 准备读取 &apos;{n}&apos;
                i++;  // 跳过 &apos;]&apos;
                if (i &amp;lt; n &amp;amp;&amp;amp; s.charAt(i) == &apos;{&apos;) {
                    i++;  // 跳过 &apos;{&apos;
                    if (i &amp;lt; n &amp;amp;&amp;amp; Character.isDigit(s.charAt(i))) {
                        int repeatTimes = s.charAt(i) - &apos;0&apos;;
                        i++;  // 跳过数字
                        if (i &amp;lt; n &amp;amp;&amp;amp; s.charAt(i) == &apos;}&apos;) {
                            i++;  // 跳过 &apos;}&apos;
                        }
                        // 弹出栈顶状态并使用自定义的repeat方法
                        StringBuilder prevStr = strStack.pop();
                        String repeatedStr = repeat(currentStr.toString(), repeatTimes);  // 使用自定义repeat
                        prevStr.append(repeatedStr);
                        currentStr = prevStr;
                    }
                }
            } else {
                // 普通字符，直接追加
                currentStr.append(c);
                i++;
            }
        }

        return currentStr.toString();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其实看起来还是有点困难的，主要还是我Java还没有学习到字符串相关的常用类String那里，哎，慢慢学吧&lt;/p&gt;
</content:encoded></item><item><title>项目标准开发流程</title><link>https://thrinisty.github.io/posts/%E9%A1%B9%E7%9B%AE%E6%A0%87%E5%87%86%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/%E9%A1%B9%E7%9B%AE%E6%A0%87%E5%87%86%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/</guid><description>企业标准开发流程</description><pubDate>Mon, 17 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;项目开发流程&lt;/h1&gt;
&lt;p&gt;需求分析---设计阶段---编码实现---测试阶段---实施阶段&lt;/p&gt;
&lt;h2&gt;1.需求分析（需求分析师）&lt;/h2&gt;
&lt;p&gt;目的是产出一个需求分析报告，包含客户具体要求，项目功能&lt;/p&gt;
&lt;h2&gt;2.设计阶段（架构师/项目经理）&lt;/h2&gt;
&lt;p&gt;设计工作UML类图，流程图，模块设计，数据库，架构，原型开发 组建团队&lt;/p&gt;
&lt;h2&gt;3.实现阶段（程序员/码农）&lt;/h2&gt;
&lt;p&gt;完成架构师的模块功能，测试自己的模块&lt;/p&gt;
&lt;h2&gt;4.测试阶段（测试工程师）&lt;/h2&gt;
&lt;p&gt;单元测试，测试用例，白盒测试，黑盒测试，集成测试&lt;/p&gt;
&lt;h2&gt;5.实施阶段（实施工程师）&lt;/h2&gt;
&lt;p&gt;将项目部署到客户的平台，保证运行正常，要求对环境的部署能力要高&lt;/p&gt;
&lt;h2&gt;6.维护阶段（不固定人员）&lt;/h2&gt;
&lt;p&gt;Debug，项目升级，发现bug&lt;/p&gt;
</content:encoded></item><item><title>Linux</title><link>https://thrinisty.github.io/posts/linux%E4%B8%AD%E9%87%8D%E8%A6%81%E7%9A%84%E6%8C%87%E4%BB%A4/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/linux%E4%B8%AD%E9%87%8D%E8%A6%81%E7%9A%84%E6%8C%87%E4%BB%A4/</guid><description>linux常见指令，这个部分较为简易，后续或许回补充</description><pubDate>Wed, 19 Feb 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h3&gt;linux中的一些常用指令&lt;/h3&gt;
&lt;h4&gt;cd（change directory）更改目录&lt;/h4&gt;
&lt;p&gt;其中 / 是linux中的根目录， . 代表的是当前的目录， .. 表示上一层目录
大部分的情况下 ./ 可以省略 直接cd + 目录下的文件路径&lt;/p&gt;
&lt;p&gt;cd ||  cd ~进入家目录&lt;/p&gt;
&lt;p&gt;cd - 进入上一次的目录&lt;/p&gt;
&lt;h4&gt;ls（list）显示当前目录的文件&lt;/h4&gt;
&lt;p&gt;-l参数会显示各个类型属性&lt;/p&gt;
&lt;p&gt;-a还会显示额外的文件&lt;/p&gt;
&lt;p&gt;-al综合前两个&lt;/p&gt;
&lt;h4&gt;cp（copy）拷贝文件&lt;/h4&gt;
&lt;p&gt;cp + 拷贝源路径 + 目标路径&lt;/p&gt;
&lt;p&gt;-r 参数 递归地拷贝&lt;/p&gt;
&lt;h4&gt;mv（move to）剪切&lt;/h4&gt;
&lt;p&gt;用法与复制类似&lt;/p&gt;
&lt;p&gt;特殊用法（更改名字）&lt;/p&gt;
&lt;p&gt;mv + 目标原来的文件名 + 现在的文件名&lt;/p&gt;
&lt;h4&gt;chmod （change mode）修改文件权限&lt;/h4&gt;
&lt;p&gt;可以通过chmod 744 文件名 修改&lt;/p&gt;
&lt;p&gt;chmod u+x 文件&lt;/p&gt;
&lt;p&gt;chmod g-r  文件&lt;/p&gt;
&lt;p&gt;chmod o+r 文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/34.png&quot; alt=&quot;34&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;rm（remove）删除文件&lt;/h4&gt;
&lt;p&gt;-rf 强制删除参数&lt;/p&gt;
&lt;h4&gt;touch 创建文件&lt;/h4&gt;
&lt;p&gt;touch a b c&lt;/p&gt;
&lt;h4&gt;mkdir 创建文件夹&lt;/h4&gt;
&lt;h4&gt;tar 压缩&lt;/h4&gt;
&lt;p&gt;tar -zcf 压缩名字 需要压缩的文件文件&lt;/p&gt;
&lt;p&gt;tar -xzf 解压文件&lt;/p&gt;
&lt;p&gt;tar -zcf x.tar.gz a b c&lt;/p&gt;
&lt;h4&gt;find 查找文件&lt;/h4&gt;
&lt;p&gt;find 路径 -name &quot;文件名&quot;&lt;/p&gt;
&lt;h4&gt;grep 查找关键字&lt;/h4&gt;
&lt;p&gt;grep &quot;搜索关键字&quot; 路径 -r (递归)&lt;/p&gt;
</content:encoded></item><item><title>Vim</title><link>https://thrinisty.github.io/posts/vim%E5%85%A5%E9%97%A8/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/vim%E5%85%A5%E9%97%A8/</guid><description>Vim入门</description><pubDate>Tue, 18 Feb 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;VIM&lt;/h2&gt;
&lt;p&gt;vim stdio.h 如果有则进入如果没有则创建文件&lt;/p&gt;
&lt;h4&gt;三种模式&lt;/h4&gt;
&lt;h5&gt;命令模式（默认进入）&lt;/h5&gt;
&lt;p&gt;yy复制一行  10yy复制十行&lt;/p&gt;
&lt;p&gt;p粘贴&lt;/p&gt;
&lt;p&gt;dd剪切&lt;/p&gt;
&lt;p&gt;u撤销&lt;/p&gt;
&lt;p&gt;x删除一个字符&lt;/p&gt;
&lt;p&gt;shift g跳到最后一行&lt;/p&gt;
&lt;p&gt;gg回到第一行&lt;/p&gt;
&lt;p&gt;*用于查找&lt;/p&gt;
&lt;p&gt;shift z&lt;/p&gt;
&lt;h5&gt;插入模式（Insert编辑）&lt;/h5&gt;
&lt;p&gt;通过i或者a按键进入，esc退出并进入命令模式&lt;/p&gt;
&lt;h5&gt;底行模式（通过命令模式下进入）：&lt;/h5&gt;
&lt;p&gt;:w保存 q退出 wq保存退出 wq! 强制保存退出&lt;/p&gt;
&lt;p&gt;:10跳到10行&lt;/p&gt;
&lt;p&gt;：nohl消除高亮&lt;/p&gt;
&lt;p&gt;:set nonu 去除行号&lt;/p&gt;
&lt;p&gt;:set nu 加上行号&lt;/p&gt;
&lt;p&gt;:%s/old/new替换&lt;/p&gt;
&lt;p&gt;/进入底行模式用于查找&lt;/p&gt;
&lt;p&gt;如/main&lt;/p&gt;
</content:encoded></item><item><title>关于 Git</title><link>https://thrinisty.github.io/posts/%E5%85%B3%E4%BA%8Egit/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/%E5%85%B3%E4%BA%8Egit/</guid><description>Git 学习笔记</description><pubDate>Wed, 15 Jan 2025 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;git的功能相当于一个游戏的存档功能，可用以代码的管理，正确使用git即可提高编码的效率以及存储安全，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/30.png&quot; alt=&quot;30&quot; /&gt;&lt;/p&gt;
&lt;p&gt;在VScode之中可以通过GUI进行快速的配置与github的git链接，首先用默认的浏览器注册一个GitHub账号，保持账号的登陆状态，按照网络上的教程安装git（详细可参照各大博客上的相关教程）&lt;/p&gt;
&lt;p&gt;再次打开vscode即可在上图的位置看到打开文件夹以及克隆仓库的两个选项，我们选择创建一个文件夹，在文件夹下可以新建一个本地的git仓库，可以自行在仓库中添加一些内容，提交就等价于游戏中保存一个本地存档，而同步相当于提交本地的游戏数据到云端存储，而第一次存储到github中需要按照相关的步骤对本地的环境进行授权操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/31.png&quot; alt=&quot;31&quot; /&gt;&lt;/p&gt;
&lt;p&gt;以上是源代码的管理图，有着代码各个版本的说明以及修改内容介绍，蓝色的代表本地存档，而紫色的代表云存档，二者进度不一定相同，例如提交了本地仓库，但是没有同步至云端。&lt;/p&gt;
&lt;p&gt;在对应的仓库目录下，我们可以在终端使用git log指令查看日志，来检索git提交的版本信息 ，键入q来进行退出&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/32.png&quot; alt=&quot;32&quot; /&gt;&lt;/p&gt;
&lt;p&gt;上述我们通过了在本地的初始化建立git仓库，默认提交到了github中，当然我们也可以在GitHub中先建立仓库，然后再远程建立连接，我们先在源代码管理界面的右侧找到三个点...的选项，选择远程，添加远程库，如果你登陆了github账号的话即可自动查找github中的仓库，选取并在后续选择私有或者公有即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/33.png&quot; alt=&quot;33&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>虚拟机代理</title><link>https://thrinisty.github.io/posts/vmware%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BB%A3%E7%90%86/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/vmware%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BB%A3%E7%90%86/</guid><description>VMware虚拟机代理</description><pubDate>Fri, 15 Nov 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h3&gt;第一份正式的博客内容&lt;/h3&gt;
&lt;p&gt;这算是我写的第一份博客，大学时光已经过半，我也想在有限的时间里面留下点什么，希望这一篇推文可以帮助到你:happy:&lt;/p&gt;
&lt;h4&gt;序言&lt;/h4&gt;
&lt;p&gt;和大多数人一样，我在linux安装各种软件包的时候，想到的第一个方法应该是换源，换一个学术的源平台去下载各种各样的包或者软件之类的，但是有的时候镜像资源难免会出现一些缺漏，导致了没有办法正确的找到依赖，而通过代理的方式可以在linux虚拟机下安装各式各样的软件一劳永逸，接下来是我从网络上找寻到的一种方式&lt;/p&gt;
&lt;h4&gt;解决方式（需要主机拥有代理软件）&lt;/h4&gt;
&lt;h5&gt;第一种解决方式：用图形化界面手动设置&lt;/h5&gt;
&lt;p&gt;第一：设置虚拟机（我这里运用的是VMware虚拟机，Ubuntu版本为22.04）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/7.png&quot; alt=&quot;7&quot; /&gt;&lt;/p&gt;
&lt;p&gt;如图我们将其中的网络适配器网络连接方式更改成为NAT桥接模式，使虚拟机与宿主机共享同样的的IP地址&lt;/p&gt;
&lt;p&gt;第二：记录主机的IP地址&lt;/p&gt;
&lt;p&gt;在主机上打开终端，键入  ipconfig 查看，其中会打印出很多的网络配置信息，我们重点聚焦于主机的IP地址
&lt;img src=&quot;../images/4.png&quot; alt=&quot;4&quot; /&gt;&lt;/p&gt;
&lt;p&gt;其中以太网适配器中的IPv4是我们所需的，将其记录下来：192.168.9.1&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/6.png&quot; alt=&quot;6&quot; /&gt;&lt;/p&gt;
&lt;p&gt;第三：开启代理软件获取其端口号（以clash举例，多的我也没有）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/5.png&quot; alt=&quot;5&quot; /&gt;&lt;/p&gt;
&lt;p&gt;其中7890就是我们所需要的内容，将其记录下来&lt;/p&gt;
&lt;p&gt;第四：启动linux虚拟机设置并开启网络代理&lt;/p&gt;
&lt;p&gt;在网络代理设置中点击手动（默认为已禁用），此时不更改网络代理的数据的时候是无法正常上网的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/8.png&quot; alt=&quot;8&quot; /&gt;&lt;/p&gt;
&lt;p&gt;下一步为设置两个代理，以及Socks主机&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/9.png&quot; alt=&quot;9&quot; /&gt;&lt;/p&gt;
&lt;p&gt;其中前一个为IP地址：填入主机IP，后一个端口号填入代理端口，保存即可完成虚拟机共享主机代理的设置&lt;/p&gt;
&lt;p&gt;第五：验证代理是否成功&lt;/p&gt;
&lt;p&gt;发现可以正常访问学术网站，linux虚拟机代理成功，同时也可以解决rustc软件包安装失效的问题&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/10.png&quot; alt=&quot;10&quot; /&gt;&lt;/p&gt;
&lt;h5&gt;第二种解决方式：通过命令行配置代理&lt;/h5&gt;
&lt;p&gt;第一：配置代理&lt;/p&gt;
&lt;p&gt;在终端中输入以下指令（ip地址为你自己的，端口号为代理软件的，同第一种解决方式中的一样）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export https_proxy=http://192.168.9.1:7890
export http_proxy=http://192.168.9.1:7890
export ftp_proxy=http://192.168.9.1:7890
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二：配置生效&lt;/p&gt;
&lt;p&gt;安装完成后，我们可以重新打开一个终端来让之前设置的环境变量生效。&lt;/p&gt;
&lt;p&gt;我们也可以手动将环境变量设置应用到当前终端（非永久生效，仅限于当前终端），输入以下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;source $HOME/.cargo/env
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;结语&lt;/h4&gt;
&lt;p&gt;真诚地希望你的问题在这里得到解决，以上是我写的有关linux虚拟机代理的解决方法&lt;/p&gt;
</content:encoded></item><item><title>My First Post</title><link>https://thrinisty.github.io/posts/thrinisty/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/thrinisty/</guid><description>第一篇博客</description><pubDate>Fri, 15 Nov 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h4&gt;关于Thrinisty&lt;/h4&gt;
&lt;h5&gt;欢迎:happy:&lt;/h5&gt;
&lt;p&gt;欢迎来到我的博客网页，在这里我会不定期的更新一些实验中的思路，遇到的问题以及解决方案&lt;/p&gt;
&lt;h5&gt;关于名字&lt;/h5&gt;
&lt;p&gt;为什么要取thrinisty这样的名字，其实这个名字源自于我母亲大人的LOL账号名，又受制于自己起名水平:cry:，故直接将这个称号照搬作为了我的博客名称。&lt;/p&gt;
&lt;h5&gt;尾声&lt;/h5&gt;
&lt;p&gt;总而言之，还是欢迎你来到我的博客，希望你在这里可以找到你想要的东西！！:happy:&lt;/p&gt;
</content:encoded></item><item><title>Markdown Extended Features</title><link>https://thrinisty.github.io/posts/markdown-extended/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/markdown-extended/</guid><description>Read more about Markdown features in Fuwari</description><pubDate>Wed, 01 May 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;GitHub Repository Cards&lt;/h2&gt;
&lt;p&gt;You can add dynamic cards that link to GitHub repositories, on page load, the repository information is pulled from the GitHub API.&lt;/p&gt;
&lt;p&gt;::github{repo=&quot;Fabrizz/MMM-OnSpotify&quot;}&lt;/p&gt;
&lt;p&gt;Create a GitHub repository card with the code &lt;code&gt;::github{repo=&quot;&amp;lt;owner&amp;gt;/&amp;lt;repo&amp;gt;&quot;}&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;::github{repo=&quot;saicaca/fuwari&quot;}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Admonitions&lt;/h2&gt;
&lt;p&gt;Following types of admonitions are supported: &lt;code&gt;note&lt;/code&gt; &lt;code&gt;tip&lt;/code&gt; &lt;code&gt;important&lt;/code&gt; &lt;code&gt;warning&lt;/code&gt; &lt;code&gt;caution&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;:::note
Highlights information that users should take into account, even when skimming.
:::&lt;/p&gt;
&lt;p&gt;:::tip
Optional information to help a user be more successful.
:::&lt;/p&gt;
&lt;p&gt;:::important
Crucial information necessary for users to succeed.
:::&lt;/p&gt;
&lt;p&gt;:::warning
Critical content demanding immediate user attention due to potential risks.
:::&lt;/p&gt;
&lt;p&gt;:::caution
Negative potential consequences of an action.
:::&lt;/p&gt;
&lt;h3&gt;Basic Syntax&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;:::note
Highlights information that users should take into account, even when skimming.
:::

:::tip
Optional information to help a user be more successful.
:::
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Custom Titles&lt;/h3&gt;
&lt;p&gt;The title of the admonition can be customized.&lt;/p&gt;
&lt;p&gt;:::note[MY CUSTOM TITLE]
This is a note with a custom title.
:::&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::note[MY CUSTOM TITLE]
This is a note with a custom title.
:::
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;GitHub Syntax&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;[!TIP]
&lt;a href=&quot;https://github.com/orgs/community/discussions/16925&quot;&gt;The GitHub syntax&lt;/a&gt; is also supported.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; [!NOTE]
&amp;gt; The GitHub syntax is also supported.

&amp;gt; [!TIP]
&amp;gt; The GitHub syntax is also supported.
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Simple Guides for Fuwari</title><link>https://thrinisty.github.io/posts/guide/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/guide/</guid><description>How to use this blog template.</description><pubDate>Mon, 01 Apr 2024 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;Cover image source: &lt;a href=&quot;https://image.civitai.com/xG1nkqKTMzGDvpLrqFT7WA/208fc754-890d-4adb-9753-2c963332675d/width=2048/01651-1456859105-(colour_1.5),girl,_Blue,yellow,green,cyan,purple,red,pink,_best,8k,UHD,masterpiece,male%20focus,%201boy,gloves,%20ponytail,%20long%20hair,.jpeg&quot;&gt;Source&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This blog template is built with &lt;a href=&quot;https://astro.build/&quot;&gt;Astro&lt;/a&gt;. For the things that are not mentioned in this guide, you may find the answers in the &lt;a href=&quot;https://docs.astro.build/&quot;&gt;Astro Docs&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Front-matter of Posts&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;---
title: My First Blog Post
published: 2023-09-09
description: This is the first post of my new Astro blog.
image: ./cover.jpg
tags: [Foo, Bar]
category: Front-end
draft: false
---
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Attribute&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;title&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;The title of the post.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;published&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;The date the post was published.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;description&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;A short description of the post. Displayed on index page.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;image&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;The cover image path of the post.&amp;lt;br/&amp;gt;1. Start with &lt;code&gt;http://&lt;/code&gt; or &lt;code&gt;https://&lt;/code&gt;: Use web image&amp;lt;br/&amp;gt;2. Start with &lt;code&gt;/&lt;/code&gt;: For image in &lt;code&gt;public&lt;/code&gt; dir&amp;lt;br/&amp;gt;3. With none of the prefixes: Relative to the markdown file&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;tags&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;The tags of the post.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;category&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;The category of the post.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;draft&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;If this post is still a draft, which won&apos;t be displayed.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Where to Place the Post Files&lt;/h2&gt;
&lt;p&gt;Your post files should be placed in &lt;code&gt;src/content/posts/&lt;/code&gt; directory. You can also create sub-directories to better organize your posts and assets.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;src/content/posts/
├── post-1.md
└── post-2/
    ├── cover.png
    └── index.md
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Markdown Example</title><link>https://thrinisty.github.io/posts/markdown/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/markdown/</guid><description>A simple example of a Markdown blog post.</description><pubDate>Sun, 01 Oct 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;An h1 header&lt;/h1&gt;
&lt;p&gt;Paragraphs are separated by a blank line.&lt;/p&gt;
&lt;p&gt;2nd paragraph. &lt;em&gt;Italic&lt;/em&gt;, &lt;strong&gt;bold&lt;/strong&gt;, and &lt;code&gt;monospace&lt;/code&gt;. Itemized lists
look like:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;this one&lt;/li&gt;
&lt;li&gt;that one&lt;/li&gt;
&lt;li&gt;the other one&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Note that --- not considering the asterisk --- the actual text
content starts at 4-columns in.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Block quotes are
written like so.&lt;/p&gt;
&lt;p&gt;They can span multiple paragraphs,
if you like.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Use 3 dashes for an em-dash. Use 2 dashes for ranges (ex., &quot;it&apos;s all
in chapters 12--14&quot;). Three dots ... will be converted to an ellipsis.
Unicode is supported. ☺&lt;/p&gt;
&lt;h2&gt;An h2 header&lt;/h2&gt;
&lt;p&gt;Here&apos;s a numbered list:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;first item&lt;/li&gt;
&lt;li&gt;second item&lt;/li&gt;
&lt;li&gt;third item&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Note again how the actual text starts at 4 columns in (4 characters
from the left side). Here&apos;s a code sample:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Let me re-iterate ...
for i in 1 .. 10 { do-something(i) }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you probably guessed, indented 4 spaces. By the way, instead of
indenting the block, you can use delimited blocks, if you like:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;define foobar() {
    print &quot;Welcome to flavor country!&quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(which makes copying &amp;amp; pasting easier). You can optionally mark the
delimited block for Pandoc to syntax highlight it:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import time
# Quick, count to ten!
for i in range(10):
    # (but not *too* quick)
    time.sleep(0.5)
    print i
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;An h3 header&lt;/h3&gt;
&lt;p&gt;Now a nested list:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;First, get these ingredients:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;carrots&lt;/li&gt;
&lt;li&gt;celery&lt;/li&gt;
&lt;li&gt;lentils&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Boil some water.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Dump everything in the pot and follow
this algorithm:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; find wooden spoon
 uncover pot
 stir
 cover pot
 balance wooden spoon precariously on pot handle
 wait 10 minutes
 goto first step (or shut off burner when done)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Do not bump wooden spoon or it will fall.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Notice again how text always lines up on 4-space indents (including
that last line which continues item 3 above).&lt;/p&gt;
&lt;p&gt;Here&apos;s a link to &lt;a href=&quot;http://foo.bar&quot;&gt;a website&lt;/a&gt;, to a &lt;a href=&quot;local-doc.html&quot;&gt;local
doc&lt;/a&gt;, and to a &lt;a href=&quot;#an-h2-header&quot;&gt;section heading in the current
doc&lt;/a&gt;. Here&apos;s a footnote [^1].&lt;/p&gt;
&lt;p&gt;[^1]: Footnote text goes here.&lt;/p&gt;
&lt;p&gt;Tables can look like this:&lt;/p&gt;
&lt;p&gt;size material color&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;9 leather brown
10 hemp canvas natural
11 glass transparent&lt;/p&gt;
&lt;p&gt;Table: Shoes, their sizes, and what they&apos;re made of&lt;/p&gt;
&lt;p&gt;(The above is the caption for the table.) Pandoc also supports
multi-line tables:&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;keyword text&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;red Sunsets, apples, and
other red or reddish
things.&lt;/p&gt;
&lt;p&gt;green Leaves, grass, frogs
and other things it&apos;s
not easy being.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;A horizontal rule follows.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Here&apos;s a definition list:&lt;/p&gt;
&lt;p&gt;apples
: Good for making applesauce.
oranges
: Citrus!
tomatoes
: There&apos;s no &quot;e&quot; in tomatoe.&lt;/p&gt;
&lt;p&gt;Again, text is indented 4 spaces. (Put a blank line between each
term/definition pair to spread things out more.)&lt;/p&gt;
&lt;p&gt;Here&apos;s a &quot;line block&quot;:&lt;/p&gt;
&lt;p&gt;| Line one
| Line too
| Line tree&lt;/p&gt;
&lt;p&gt;and images can be specified like so:&lt;/p&gt;
&lt;p&gt;Inline math equations go in like so: $\omega = d\phi / dt$. Display
math should get its own line and be put in in double-dollarsigns:&lt;/p&gt;
&lt;p&gt;$$I = \int \rho R^{2} dV$$&lt;/p&gt;
&lt;p&gt;$$
\begin{equation*}
\pi
=3.1415926535
;8979323846;2643383279;5028841971;6939937510;5820974944
;5923078164;0628620899;8628034825;3421170679;\ldots
\end{equation*}
$$&lt;/p&gt;
&lt;p&gt;And note that you can backslash-escape any punctuation characters
which you wish to be displayed literally, ex.: `foo`, *bar*, etc.&lt;/p&gt;
</content:encoded></item><item><title>Include Video in the Posts</title><link>https://thrinisty.github.io/posts/video/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/video/</guid><description>This post demonstrates how to include embedded video in a blog post.</description><pubDate>Tue, 01 Aug 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Just copy the embed code from YouTube or other platforms, and paste it in the markdown file.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;---
title: Include Video in the Post
published: 2023-10-19
// ...
---

&amp;lt;iframe width=&quot;100%&quot; height=&quot;468&quot; src=&quot;https://www.youtube.com/embed/5gIf0_xpFPI?si=N1WTorLKL0uwLsU_&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allowfullscreen&amp;gt;&amp;lt;/iframe&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;YouTube&lt;/h2&gt;
&lt;p&gt;&amp;lt;iframe width=&quot;100%&quot; height=&quot;468&quot; src=&quot;https://www.youtube.com/embed/5gIf0_xpFPI?si=N1WTorLKL0uwLsU_&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share&quot; allowfullscreen&amp;gt;&amp;lt;/iframe&amp;gt;&lt;/p&gt;
&lt;h2&gt;Bilibili&lt;/h2&gt;
&lt;p&gt;&amp;lt;iframe width=&quot;100%&quot; height=&quot;468&quot; src=&quot;//player.bilibili.com/player.html?bvid=BV1fK4y1s7Qf&amp;amp;p=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&amp;gt; &amp;lt;/iframe&amp;gt;&lt;/p&gt;
</content:encoded></item></channel></rss>