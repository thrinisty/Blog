<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Thrinisty&apos;s Blog</title><description>New Blog</description><link>https://thrinisty.github.io/</link><language>zh_CN</language><item><title>自学第五月份总结</title><link>https://thrinisty.github.io/posts/%E8%87%AA%E5%AD%A6%E7%AC%AC%E4%BA%94%E6%9C%88%E4%BB%BD%E6%80%BB%E7%BB%93/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/%E8%87%AA%E5%AD%A6%E7%AC%AC%E4%BA%94%E6%9C%88%E4%BB%BD%E6%80%BB%E7%BB%93/</guid><description>Vue3的学习，公司项目实操</description><pubDate>Fri, 01 Aug 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;自学第五月份总结&lt;/h1&gt;
&lt;h2&gt;Spring框架学习&lt;/h2&gt;
&lt;p&gt;上一个月速成了一下SpringBoot中常用的相关开发注解，能够在不需要AI辅助的情况下进行后端项目的开发，这个月进入了实际的开发工作中也能够用到60%左右的上个月学习到的内容，Rest风格的API，Controller，Service等项目编写的规范，同一异常处理等等诸如此类。因为对于项目上还有一些速成课程中没有接触到的，在Spring方面还有一些点滴型的收获：AOP，配置文件中参数的统一配置，前端返回参数工具类（泛型的实际使用）&lt;/p&gt;
&lt;h2&gt;公司项目&lt;/h2&gt;
&lt;p&gt;导师分配给我的任务是根据Postgre中已有的固件数据，设计一个固件查询的前后端项目，在前端上采用的是Vue，后端是SpringBoot。&lt;/p&gt;
&lt;h3&gt;基础任务&lt;/h3&gt;
&lt;p&gt;前端方面，由于我没有接触过Vue项目的开发，没有前置知识，我花了2天的时间进行Vue知识的速成补充，再结合AI的辅助给把前端给应付下来了，只是第一次刚学习只是就立马实操项目，在前端项目的代码编写规范上就显得非常的稚嫩了，不过胜在能跑，🤭嘻嘻。&lt;/p&gt;
&lt;p&gt;数据库表方面用的是公司爬虫爬下来的数据，在一开始查询是先根据两表联查获取数据，但是即便是优化了SQL语句，由于数据量过大（七十万条*三百万条），数据库任然会出现内存溢出的情况，我有没有相关的权限去进行数据表更改优化，后面索性拜托导师来联系负责数据库的前辈添加了一下字段直接在单表查，其余的还用到了厂商聚合，文件类型聚合，和时间聚合(例如当天数据量，当月数据量等)&lt;/p&gt;
&lt;p&gt;后端上，使用到了Caffeine缓存将查询到的厂商聚合时间聚合结果进行缓存，并在前端结合数据设计，给前端用户较为直观的条件查询显示页面。此外固件查询支持了根据S3信息进行下载，通过数据表中的json格式数据，利用Gson工具进行解析获取objectName以及bucketName，生成下载链接，返回给前端重定向下载。&lt;/p&gt;
&lt;h3&gt;用户管理&lt;/h3&gt;
&lt;p&gt;在用户管理上，我先是直接在yaml配置文件中进行配置的用户列表，其中存储着用户信息，账号密码，登录的时候提供相关的API进行登录，设置Session。&lt;/p&gt;
&lt;p&gt;后面导师要求使用公司统一的Datacon单点登录统一认证，给我付了权限创建相关的MySQL表格，目前我创建的有用户信息表格，共享文件表格，下载日志表格，因为是使用两张表还用到了一个dynamic的工具，利用DS注解进行多数据库的配置。信息的获取根据统一认证的平台返回的ticket进行，再进行用户的注册，这里和负责统一认证的前辈对接，再结合导师提供的工具类也是吧这个部分完成了。&lt;/p&gt;
&lt;p&gt;对于通过单点登录的用户，我还使用到了AOP部分的知识进行下载次数的限制，下载日志的存储，并用到了SpringBoot提供的定时任务每天凌晨自动的恢复每个用户的下载次数。&lt;/p&gt;
&lt;p&gt;如何处理原来的登录方式呢？我想了下，索性把之前的认证方式改为了登录的管理员后门，兼容了一下两种方式。&lt;/p&gt;
&lt;h3&gt;共享文件板块的开发&lt;/h3&gt;
&lt;p&gt;目前还在开发，基础的部分已经完成，支持文件的上传，在后端本地进行文件的存储，并在MySQL数据库中记录相应的存储路径，支持文件的下载，在前端通过可视化的方式调用api，根据id获取到文件字节数组，设置响应头将数据传回给前端。后面开发可能还得搞个批量上传的小界面出来。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;经过公司的项目开发，我SpringBoot的使用已经上手，快要丢掉的知识也逐渐被取回，看着项目随着时间一点一点壮大，git提交数量慢慢增多。看着提交的一个接着一个的版本，还是蛮有成就感的。&lt;/p&gt;
&lt;p&gt;项目在单点登录前在邢老师的帮助下，已经上线，但是服务器上的单点认证还暂时用不了，推测是公司内网访问单点登录服务平台（阿里云服务器）进行ticket消费的时候会出现DNS域名解析失败的问题，最近公司的网络也不太好，邢老师后面打算让我把后端单独部署到一台公网服务器上（目前部署还是前后端部署在同一个服务器上），来解决上述问题。&lt;/p&gt;
&lt;p&gt;第五个月的学习，评价为最有收获的一集！！&lt;/p&gt;
</content:encoded></item><item><title>SpringAI笔记（MCPClient）</title><link>https://thrinisty.github.io/posts/springai%E7%AC%94%E8%AE%B0%E6%A8%A1%E6%9D%BF---%E5%89%AF%E6%9C%AC/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/springai%E7%AC%94%E8%AE%B0%E6%A8%A1%E6%9D%BF---%E5%89%AF%E6%9C%AC/</guid><pubDate>Fri, 11 Jul 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;SpringAI笔记&lt;/h1&gt;
&lt;h2&gt;MCP Client&lt;/h2&gt;
</content:encoded></item><item><title>Vue3笔记（Pinia，组件通信）</title><link>https://thrinisty.github.io/posts/vue3%E7%AC%94%E8%AE%B0pinia/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/vue3%E7%AC%94%E8%AE%B0pinia/</guid><description>Vue Pinia，组件通信</description><pubDate>Wed, 09 Jul 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Vue3笔记&lt;/h1&gt;
&lt;p&gt;今天应该可以把Vue结束&lt;/p&gt;
&lt;h2&gt;Pinia&lt;/h2&gt;
&lt;h3&gt;环境准备&lt;/h3&gt;
&lt;p&gt;集中式状态（数据）管理&lt;/p&gt;
&lt;p&gt;把所有需要集中管理的数据放在同一个位置&lt;/p&gt;
&lt;p&gt;通过以下指令安装pinia&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm i pinia
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在main.js中引入Pinia&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import &apos;./assets/main.css&apos;

import { createApp } from &apos;vue&apos;
import App from &apos;./App.vue&apos;
//引入Pinia
import {createPinia} from &quot;pinia&quot;;
//创建Pinia
const app = createApp(App);
const pinia = createPinia()
app.use(createPinia())
app.mount(&apos;#app&apos;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们先准备两个组件&lt;/p&gt;
&lt;p&gt;其中sum的值会在其他组件中使用到，我们从count.ts中获取数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup lang=&quot;ts&quot;&amp;gt;
import {reactive, ref} from &quot;vue&quot;;
  import axios from &quot;axios&quot;
  const count = ref(4)
  const talkList = reactive([
    {id:1, title:&apos;:我没什么事儿，就想听听你的声音&apos;},
    {id:2, title:&apos;您好，您有新的恋爱订单，请及时收取我&apos;},
    {id:3, title:&apos;我们，是我遇见的最美好的字眼&apos;},
  ])
  async function addTalk(){
    const response = await axios.post(&apos;https://api.uomg.com/api/rand.qinghua?format=json&apos;);
    const obj = {id:count.value, title:response.data.content};
    count.value++
    talkList.push(obj);
  }
&amp;lt;/script&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;button @click=&quot;addTalk&quot;&amp;gt;获取语句&amp;lt;/button&amp;gt;
    &amp;lt;ul&amp;gt;
      &amp;lt;li v-for=&quot;talk in talkList&quot; :key=&quot;talk.id&quot;&amp;gt;{{talk.id}}:{{talk.title}}&amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;style scoped&amp;gt;

&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup lang=&quot;ts&quot;&amp;gt;
import {ref} from &quot;vue&quot;;
const sum = ref(10)
const n = ref(1)
function addSum(){
  sum.value += n.value
}
function subSum(){
  sum.value -= n.value
}
&amp;lt;/script&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;当前sum为：{{sum}}&amp;lt;/div&amp;gt;&amp;lt;br/&amp;gt;
  &amp;lt;select v-model.number=&quot;n&quot;&amp;gt;
    &amp;lt;option value=&quot;1&quot;&amp;gt;1&amp;lt;/option&amp;gt;
    &amp;lt;option value=&quot;2&quot;&amp;gt;2&amp;lt;/option&amp;gt;
    &amp;lt;option value=&quot;3&quot;&amp;gt;3&amp;lt;/option&amp;gt;
  &amp;lt;/select&amp;gt;&amp;lt;br/&amp;gt;
  &amp;lt;button @click=&quot;addSum&quot;&amp;gt;加n&amp;lt;/button&amp;gt;
  &amp;lt;button @click=&quot;subSum&quot;&amp;gt;减n&amp;lt;/button&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;style scoped&amp;gt;

&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;更改数据&lt;/h3&gt;
&lt;p&gt;第一种更改数据的方式&lt;/p&gt;
&lt;p&gt;更改为从全局的/store/count中获取sum值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import {defineStore} from &quot;pinia&quot;;
export const useSumStore = defineStore(&apos;sum&apos;,{
    state(){
        return {
            sum:60
        }
    }
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意在解构的时候保持响应式，通过toRefs实现（其实storeToRefs会更好一点）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup lang=&quot;ts&quot;&amp;gt;
import {ref, toRefs} from &quot;vue&quot;;
import {useSumStore} from &apos;@/store/count&apos;

const sumStore = useSumStore();
const {sum} = toRefs(sumStore);
const n = ref(1)
function addSum(){
  sum.value += n.value
}
function subSum(){
  sum.value -= n.value
}
&amp;lt;/script&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;当前sum为：{{sumStore.sum}}&amp;lt;/div&amp;gt;&amp;lt;br/&amp;gt;
  &amp;lt;select v-model.number=&quot;n&quot;&amp;gt;
    &amp;lt;option value=&quot;1&quot;&amp;gt;1&amp;lt;/option&amp;gt;
    &amp;lt;option value=&quot;2&quot;&amp;gt;2&amp;lt;/option&amp;gt;
    &amp;lt;option value=&quot;3&quot;&amp;gt;3&amp;lt;/option&amp;gt;
  &amp;lt;/select&amp;gt;&amp;lt;br/&amp;gt;
  &amp;lt;button @click=&quot;addSum&quot;&amp;gt;加n&amp;lt;/button&amp;gt;
  &amp;lt;button @click=&quot;subSum&quot;&amp;gt;减n&amp;lt;/button&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;style scoped&amp;gt;

&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;talk&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import {defineStore} from &quot;pinia&quot;;
import {reactive} from &quot;vue&quot;;
export const useTalkStore = defineStore(&apos;talks&apos;,{
    state(){
        return {
            talkList:[
                {id:1, title:&apos;:我没什么事儿，就想听听你的声音&apos;},
                {id:2, title:&apos;您好，您有新的恋爱订单，请及时收取我&apos;},
                {id:3, title:&apos;我们，是我遇见的最美好的字眼&apos;},
            ]
        }
    }
})
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;import {useTalkStore} from &quot;@/store/loveTalk&quot;;
const talkStore = useTalkStore();
const {talkList} = toRefs(talkStore);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二种更改数据的方式&lt;/p&gt;
&lt;p&gt;在ts中添加acions，并在页面组件中调用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import {defineStore} from &quot;pinia&quot;;
export const useSumStore = defineStore(&apos;sum&apos;,{
    actions: {
      increment(value) {
          this.sum += value;
      }
    },
    state(){
        return {
            sum:60
        }
    }
})
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;const sumStore = useSumStore();
const n = ref(1)
//通过action进行修改
function addSum(){
  sumStore.increment(n.value)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第三种方式&lt;/p&gt;
&lt;p&gt;通过sumStore修改数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function subSum(){
  sumStore.sum -= n.value
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;土味情话改造&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使得将请求的方法数据在全局中存储，页面更加聚焦于前端展示的实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import {defineStore} from &quot;pinia&quot;;
import {reactive} from &quot;vue&quot;;
import axios from &quot;axios&quot;;
export const useTalkStore = defineStore(&apos;talks&apos;,{
    actions: {
        async loadTalks() {
            const response = await axios.get(&apos;https://api.uomg.com/api/rand.qinghua?format=json&apos;);
            const obj = {id:this.count, title:response.data.content};
            this.count++
            console.log(obj)
            this.talkList.push(obj);
        }
    },
    state(){
        return {
            talkList:[
                {id:1, title:&apos;:我没什么事儿，就想听听你的声音&apos;},
                {id:2, title:&apos;您好，您有新的恋爱订单，请及时收取我&apos;},
                {id:3, title:&apos;我们，是我遇见的最美好的字眼&apos;},
            ],
            count: 4
        }
    }
})
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup lang=&quot;ts&quot;&amp;gt;
  import {useTalkStore} from &quot;@/store/loveTalk&quot;;
  const talkStore = useTalkStore();

  function addTalk(){
    talkStore.loadTalks()
  }
&amp;lt;/script&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;button @click=&quot;addTalk&quot;&amp;gt;获取语句&amp;lt;/button&amp;gt;
    &amp;lt;ul&amp;gt;
      &amp;lt;li v-for=&quot;talk in talkStore.talkList&quot; :key=&quot;talk.id&quot;&amp;gt;{{talk.id}}:{{talk.title}}&amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;style scoped&amp;gt;

&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;组合式写法&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;import { defineStore } from &quot;pinia&quot;;
import { ref } from &quot;vue&quot;;

export const useSumStore = defineStore(&apos;sum&apos;, () =&amp;gt; {
    // 使用 ref/reactive 定义状态
    const sum = ref(60);

    // 定义 actions（普通函数）
    function increment(value: number) {
        sum.value += value;
    }

    // 返回 state 和 actions
    return {
        sum,
        increment,
    };
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;和Hooks有些相似，但是使用场景不同&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;特性&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Pinia Setup Store&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Vue Composables (Hooks)&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;设计目的&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;管理全局状态（State Management）&lt;/td&gt;
&lt;td&gt;逻辑复用（Logic Reusability）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;作用域&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;全局共享状态（所有组件共用同一个Store实例）&lt;/td&gt;
&lt;td&gt;可局部使用（每个组件实例有自己的状态）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;响应式机制&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;自动与 Pinia 响应式系统集成&lt;/td&gt;
&lt;td&gt;依赖 Vue 的 &lt;code&gt;ref&lt;/code&gt;/&lt;code&gt;reactive&lt;/code&gt;/&lt;code&gt;computed&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;生命周期&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;长期存在（除非手动清理）&lt;/td&gt;
&lt;td&gt;随组件销毁自动清理&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;典型用途&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;存储登录状态、主题配置、全局业务数据&lt;/td&gt;
&lt;td&gt;封装可复用的逻辑（如表单校验、API请求）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;组件通信&lt;/h2&gt;
&lt;p&gt;有很多的方式，这里用mitt实现&lt;/p&gt;
&lt;p&gt;在emitter.ts创建mitt&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import mitt from &apos;mitt&apos;
const emitter = mitt()
export default emitter
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在main.ts中引用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import {createApp} from &apos;vue&apos;
import App from &apos;./App.vue&apos;
import router from &apos;./router&apos;
import emitter from &apos;@/utils/emitter.ts&apos;
createApp(App).use(router).mount(&apos;#app&apos;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;发送消息方&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import emitter from &apos;@/utils/emitter.ts&apos;
const message = ref(&quot;来自父亲的消息&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;button @click=&quot;emitter.emit(&apos;Message&apos;, message)&quot;&amp;gt;发送消息&amp;lt;/button&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接收消息方&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import emitter from &apos;@/utils/emitter.ts&apos;
const message = ref(&quot;&quot;)
emitter.on(&apos;Message&apos;, (value:string)=&amp;gt;{
  message.value = value
})
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;h2&amp;gt;父组件消息:{{message}}&amp;lt;/h2&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Vue3笔记（监视，自定义钩子，路由）</title><link>https://thrinisty.github.io/posts/vue3%E7%AC%94%E8%AE%B0%E7%9B%91%E8%A7%86%E8%87%AA%E5%AE%9A%E4%B9%89%E9%92%A9%E5%AD%90%E8%B7%AF%E7%94%B1/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/vue3%E7%AC%94%E8%AE%B0%E7%9B%91%E8%A7%86%E8%87%AA%E5%AE%9A%E4%B9%89%E9%92%A9%E5%AD%90%E8%B7%AF%E7%94%B1/</guid><description>监视，ref属性，接口，props，自定义钩子，路由配置</description><pubDate>Tue, 08 Jul 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Vue3笔记&lt;/h1&gt;
&lt;h2&gt;watch&lt;/h2&gt;
&lt;p&gt;用于监视数据，在特定条件下执行逻辑&lt;/p&gt;
&lt;p&gt;可以监视四种情况&lt;/p&gt;
&lt;p&gt;:::note&lt;/p&gt;
&lt;p&gt;1.ref定义的数据&lt;/p&gt;
&lt;p&gt;2.reactive定义的数据&lt;/p&gt;
&lt;p&gt;3.函数返回一个值（getter函数）&lt;/p&gt;
&lt;p&gt;4.一个包含上述内容的数组&lt;/p&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;h3&gt;情况一&lt;/h3&gt;
&lt;p&gt;watch监视ref定义的基本类型数据&lt;/p&gt;
&lt;p&gt;定义变量存储watch再次调用可以终止监听&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup lang=&quot;ts&quot;&amp;gt;
import { ref, watch } from &apos;vue&apos;
const sum = ref(0)
function culSum() {
  sum.value += 1
}
const myWatch = watch(sum, (newVal, oldVal) =&amp;gt; {
  console.log(newVal, oldVal)
  if (newVal &amp;gt;= 8) {
    myWatch()
  }
})
&amp;lt;/script&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;h2&amp;gt;当前sum值：{{ sum }}&amp;lt;/h2&amp;gt;
    &amp;lt;button @click=&quot;culSum&quot;&amp;gt;加一&amp;lt;/button&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;style scoped&amp;gt;&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;情况二&lt;/h3&gt;
&lt;p&gt;监视ref定义的对象类型数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup lang=&quot;ts&quot;&amp;gt;
import { ref, watch } from &apos;vue&apos;
const person = ref({
  name: &apos;张三&apos;,
  age: 25,
})
function addAge() {
  person.value.age += 1
}
function changeName() {
  person.value.name += &quot;~&quot;
}
function change() {
  person.value = {
    name: &apos;李四&apos;,
    age: 20,
  }
}
//监视的是person对象，属性变化不会被监视，地址变化才会触发
watch(person, (newVal, oldVal) =&amp;gt; {
  console.log(&quot;监视对象变化&quot;,newVal, oldVal)
})

&amp;lt;/script&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;h2&amp;gt;姓名：{{ person.name }}&amp;lt;/h2&amp;gt;
    &amp;lt;h2&amp;gt;姓名：{{ person.age }}&amp;lt;/h2&amp;gt;
    &amp;lt;button @click=&quot;addAge&quot;&amp;gt;年龄加一&amp;lt;/button&amp;gt;
    &amp;lt;button @click=&quot;changeName&quot;&amp;gt;更改名字&amp;lt;/button&amp;gt;
    &amp;lt;button @click=&quot;change&quot;&amp;gt;换人&amp;lt;/button&amp;gt;

  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;style scoped&amp;gt;&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果需要监视内部属性的变化可以加一个参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//监视的是person对象，以及属性的变化
watch(person, (newVal, oldVal) =&amp;gt; {
  console.log(&quot;监视对象变化&quot;,newVal, oldVal)
},{deep:true})
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;情况三&lt;/h3&gt;
&lt;p&gt;watch reactive定义的对象数据&lt;/p&gt;
&lt;p&gt;默认开启deep:true深度监视，而且关不掉&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup lang=&quot;ts&quot;&amp;gt;
import { reactive, watch } from &apos;vue&apos;
const person = reactive({
  name: &apos;张三&apos;,
  age: 25,
})
function addAge() {
  person.age += 1
}
function changeName() {
  person.name += &quot;~&quot;
}
function change() {
  Object.assign(person,{
    name: &apos;李四&apos;,
    age: 20,
  })
}
//监视的是person对象，属性变化不会被监视，地址变化才会触发
watch(person, (newVal, oldVal) =&amp;gt; {
  console.log(&quot;监视对象变化&quot;,newVal, oldVal)
})

&amp;lt;/script&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;h2&amp;gt;姓名：{{ person.name }}&amp;lt;/h2&amp;gt;
    &amp;lt;h2&amp;gt;姓名：{{ person.age }}&amp;lt;/h2&amp;gt;
    &amp;lt;button @click=&quot;addAge&quot;&amp;gt;年龄加一&amp;lt;/button&amp;gt;
    &amp;lt;button @click=&quot;changeName&quot;&amp;gt;更改名字&amp;lt;/button&amp;gt;
    &amp;lt;button @click=&quot;change&quot;&amp;gt;换人&amp;lt;/button&amp;gt;

  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;style scoped&amp;gt;&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;情况四&lt;/h3&gt;
&lt;p&gt;监视对象中的单个对象&lt;/p&gt;
&lt;p&gt;传入getter函数即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const person = reactive({
  name: &apos;张三&apos;,
  age: 25,
})
function addAge() {
  person.age += 1
}
function changeName() {
  person.name += &quot;~&quot;
}
function change() {
  Object.assign(person,{
    name: &apos;李四&apos;,
    age: 20,
  })
}


//监视对象中的单个属性变化
function getPersonName() {
  return person.name
}

watch(getPersonName, (newName) =&amp;gt; {
  console.log(&quot;监视对象发生改变&quot;,newName)
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以写为箭头函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;watch(()=&amp;gt;{return person.name}, (newName) =&amp;gt; {
  console.log(&quot;监视对象发生改变&quot;,newName)
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;情况五&lt;/h3&gt;
&lt;p&gt;监视上述多个数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//监视对象中的多个属性变化，返回一个getter方法数组
watch([()=&amp;gt;person.name,()=&amp;gt;person.age], (newName) =&amp;gt; {
  console.log(&quot;监视对象发生改变&quot;,newName)
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;watchEffect&lt;/h3&gt;
&lt;p&gt;他会立即运行一个函数，同时响应式的追踪其依赖，并在依赖更改的时候重新执行该函数&lt;/p&gt;
&lt;p&gt;一个实际使用场景&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup lang=&quot;ts&quot;&amp;gt;
import { ref, watch } from &apos;vue&apos;
const temp = ref(10)
const height = ref(0)
function addTemp() {
  temp.value += 10
}
function addHeight(){
  height.value += 10
}
const warnWatch = watch([temp,height], (value) =&amp;gt; {
  console.log(value)
  const [newTemp, newHeight] = value
  if(newTemp &amp;gt;= 60 || newHeight &amp;gt;= 80) {
    console.log(&quot;发送请求&quot;)
    warnWatch();
  }
})
&amp;lt;/script&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;h2&amp;gt;当前水温{{temp}} 水位{{height}}&amp;lt;/h2&amp;gt;
    &amp;lt;button @click=&quot;addTemp&quot;&amp;gt;点我温度加一&amp;lt;/button&amp;gt;
    &amp;lt;button @click=&quot;addHeight&quot;&amp;gt;点我高度加一&amp;lt;/button&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;style scoped&amp;gt;&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用watchEffect优化&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;watchEffect(()=&amp;gt;{
  if(temp.value &amp;gt;= 60 || height.value &amp;gt;= 80){
    console.log(temp.value, height.value)
  }
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;标签的ref属性&lt;/h2&gt;
&lt;p&gt;作用是用于注册模板引用&lt;/p&gt;
&lt;p&gt;用在普通的标签上获取到的是dom节点&lt;/p&gt;
&lt;p&gt;用在组件标签上，获取的是组建的实例对象&lt;/p&gt;
&lt;p&gt;使用场景&lt;/p&gt;
&lt;p&gt;通过ref的容器可以区分不同页面中的同名容器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup lang=&quot;ts&quot;&amp;gt;
import { ref } from &apos;vue&apos;
function showLog(){
  console.log(h2.value);
}
//创建一个h2，用于存储ref标记的内容
const h2 = ref()
&amp;lt;/script&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;h1&amp;gt;中国&amp;lt;/h1&amp;gt;
    &amp;lt;h2 ref=&quot;h2&quot;&amp;gt;北京&amp;lt;/h2&amp;gt;
    &amp;lt;h3&amp;gt;海淀区&amp;lt;/h3&amp;gt;
    &amp;lt;button @click=&quot;showLog&quot;&amp;gt;点我输出h2元素&amp;lt;/button&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;style scoped&amp;gt;&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;接口&lt;/h2&gt;
&lt;p&gt;在和后端通信的时候需要使用到&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export interface PersonInter {
  id: string;
  name: string;
  age: number;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;import { type PersonInter } from &apos;@/types&apos;

const person: PersonInter = {
  id: &apos;ast_sdf&apos;,
  name: &apos;李四&apos;,
  age: 10,
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;泛型对数组中的每一个元素进行接口约束&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const personList: Array&amp;lt;PersonInter&amp;gt; = [
  {
    id: &apos;ast_sdf&apos;,
    name: &apos;李四&apos;,
    age: 10,
  },
  {
    id: &apos;ast_sdf&apos;,
    name: &apos;李四&apos;,
    age: 10,
  },
  {
    id: &apos;ast_sdf&apos;,
    name: &apos;李四&apos;,
    age: 10,
  },
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过自定义类型也可以实现数组的约束&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export type Persons = Array&amp;lt;PersonInter&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样也行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import { type Persons } from &apos;@/types&apos;

const personList: Persons = [
  {
    id: &apos;ast_sdf&apos;,
    name: &apos;李四&apos;,
    age: 10,
  },
  {
    id: &apos;ast_sdf&apos;,
    name: &apos;李四&apos;,
    age: 10,
  },
  {
    id: &apos;ast_sdf&apos;,
    name: &apos;李四&apos;,
    age: 10,
  },
]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;props&lt;/h2&gt;
&lt;p&gt;通过props可以进行组件之间参数的传递&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup lang=&quot;ts&quot;&amp;gt;
import TestComponent from &apos;@/components/TestComponent.vue&apos;
import { reactive } from &apos;vue&apos;
import { type Persons } from &apos;@/types&apos;
const personList = reactive&amp;lt;Persons&amp;gt;([
  { id: &apos;asd&apos;, name: &apos;李四&apos;, age: 19 },
  { id: &apos;as&apos;, name: &apos;张三&apos;, age: 19 },
  { id: &apos;a&apos;, name: &apos;王五&apos;, age: 19 },
])
&amp;lt;/script&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;TestComponent a=&quot;App参数&quot; :list=&quot;personList&quot; /&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;style scoped&amp;gt;
.person {
  width: 100px;
  height: 100px;
  background-color: #2e5aae;
}
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;被使用的模块可以使用传递的参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup lang=&quot;ts&quot;&amp;gt;
import { defineProps } from &apos;vue&apos;

const props = defineProps([&apos;a&apos;, &apos;list&apos;])
&amp;lt;/script&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;h2&amp;gt;{{ props.a }}&amp;lt;/h2&amp;gt;
    &amp;lt;ul&amp;gt;
      &amp;lt;li v-for=&quot;person in list&quot; :key=&quot;person.id&quot;&amp;gt;{{ person.name }}&amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;style scoped&amp;gt;&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;自定义Hooks&lt;/h2&gt;
&lt;p&gt;以下组件完成了一个按钮实现sum自增，另一个访问网站提供图片打印&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup lang=&quot;ts&quot;&amp;gt;
import axios from &apos;axios&apos;
import { reactive, ref } from &apos;vue&apos;
const sum = ref(0)
const url = &apos;https://picsum.photos/200/300&apos;
const photos = reactive([url])


function add() {
  sum.value += 1
}
async function getPhoto(){
  try {
    const result = await axios.get(url)
    photos.push(url)
  } catch (error) {
    alert(error)
  }
}
&amp;lt;/script&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;h2&amp;gt;{{ sum }}&amp;lt;/h2&amp;gt;
    &amp;lt;button @click=&quot;add&quot;&amp;gt;点我加一&amp;lt;/button&amp;gt;
    &amp;lt;hr /&amp;gt;
    &amp;lt;img v-for=&quot;(photo, index) in photos&quot; :src=&quot;photo&quot; :key=&quot;index&quot; /&amp;gt;
    &amp;lt;button @click=&quot;getPhoto&quot;&amp;gt;再来一张&amp;lt;/button&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;style scoped&amp;gt;
img {
  height: 150px;
  margin-right: 10px;
}
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;缺点是变量和方法没有按照功能区分，可以通过自定义Hooks增加可读性&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import { ref } from &apos;vue&apos;

export default function(){
  const sum = ref(0)
  function add() {
    sum.value += 1
  }
  return {sum,add}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;import axios from &apos;axios&apos;
import { reactive } from &apos;vue&apos;
const url = &apos;https://picsum.photos/200/300&apos;
const photos = reactive([url])

export default function() {
  async function getPhoto(){
    try {
      const result = await axios.get(url)
      photos.push(url)
    } catch (error) {
      alert(error)
    }
  }
  //向外提供对象
  return{photos,getPhoto}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在需要用到钩子的组件中解构取出钩子返回对象以及方法即可使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup lang=&quot;ts&quot;&amp;gt;
import useSum from &apos;@/hooks/useSum.ts&apos;
import usePhotos from &apos;@/hooks/usePhotos.ts&apos;
const {sum, add} = useSum()
const {photos, getPhoto} = usePhotos()
&amp;lt;/script&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;h2&amp;gt;{{ sum }}&amp;lt;/h2&amp;gt;
    &amp;lt;button @click=&quot;add&quot;&amp;gt;点我加一&amp;lt;/button&amp;gt;
    &amp;lt;hr /&amp;gt;
    &amp;lt;img v-for=&quot;(photo, index) in photos&quot; :src=&quot;photo&quot; :key=&quot;index&quot; /&amp;gt;
    &amp;lt;button @click=&quot;getPhoto&quot;&amp;gt;再来一张&amp;lt;/button&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;style scoped&amp;gt;
img {
  height: 150px;
  margin-right: 10px;
}
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;路由&lt;/h2&gt;
&lt;p&gt;router&lt;/p&gt;
&lt;h3&gt;基本使用&lt;/h3&gt;
&lt;p&gt;1.确认导航区，展示区&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup lang=&quot;ts&quot;&amp;gt;

&amp;lt;/script&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;div class=&quot;app&quot;&amp;gt;
    &amp;lt;h2&amp;gt;Vue路由测试&amp;lt;/h2&amp;gt;
    &amp;lt;div class=&quot;navigate&quot;&amp;gt;
      &amp;lt;a href=&quot;/&quot;&amp;gt;首页&amp;lt;/a&amp;gt;
      &amp;lt;a href=&quot;/&quot;&amp;gt;新闻&amp;lt;/a&amp;gt;
      &amp;lt;a href=&quot;/&quot;&amp;gt;关于&amp;lt;/a&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;main-context&quot;&amp;gt;
      展示区域
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;style scoped&amp;gt;
    &amp;lt;!--省略css样式--&amp;gt;
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.安装路由器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm i vue-router
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.指定路由规则&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//创建路由器，并暴露其
//引入createRouter
import { createRouter, createWebHistory } from &apos;vue-router&apos;
import Home from &apos;@/components/Home.vue&apos;
import About from &apos;@/components/About.vue&apos;
import News from &apos;@/components/News.vue&apos;
//创建路由器
const router = createRouter({
  history: createWebHistory(),
  routes:[
    {
      path:&apos;/home&apos;,
      component:Home
    },
    {
      path:&apos;/about&apos;,
      component:About
    },
    {
      path:&apos;/news&apos;,
      component:News
    },
  ]
})
//暴露路由
export default router
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.形成对应的组件&lt;/p&gt;
&lt;p&gt;省略组件&lt;/p&gt;
&lt;p&gt;在App.vue中引入RouterView，在展示区域通过RouterView进行组建的替换&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;RouterView /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup lang=&quot;ts&quot;&amp;gt;
  import {RouterView} from &apos;vue-router&apos;
&amp;lt;/script&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;div class=&quot;app&quot;&amp;gt;
    &amp;lt;h2&amp;gt;Vue路由测试&amp;lt;/h2&amp;gt;
    &amp;lt;div class=&quot;navigate&quot;&amp;gt;
&amp;lt;!--      &amp;lt;a href=&quot;/home&quot;&amp;gt;首页&amp;lt;/a&amp;gt;--&amp;gt;
&amp;lt;!--      &amp;lt;a href=&quot;/news&quot;&amp;gt;新闻&amp;lt;/a&amp;gt;--&amp;gt;
&amp;lt;!--      &amp;lt;a href=&quot;/about&quot;&amp;gt;关于&amp;lt;/a&amp;gt;--&amp;gt;
      &amp;lt;RouterLink to=&quot;/home&quot;&amp;gt;首页&amp;lt;/RouterLink&amp;gt;
      &amp;lt;RouterLink to=&quot;/news&quot;&amp;gt;新闻&amp;lt;/RouterLink&amp;gt;
      &amp;lt;RouterLink to=&quot;/about&quot;&amp;gt;关于&amp;lt;/RouterLink&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;main-context&quot;&amp;gt;
      &amp;lt;RouterView /&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;style scoped&amp;gt;
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;嵌套路由&lt;/h3&gt;
&lt;p&gt;有的时候我们需要在一个组件的展示区中嵌套一个展示区，这个时候我们就会需要使用到嵌套路由&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  path:&apos;/news&apos;,
  component:News,
  children:[
    {
      path:&apos;detail&apos;,
      component:Detail
    },
  ]
},
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意在使用RouterLink的时候to指定news下的detail&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;div&amp;gt;News&amp;lt;/div&amp;gt;
    &amp;lt;ul&amp;gt;
      &amp;lt;li v-for=&quot;news in newsList&quot; :key=&quot;news.id&quot;&amp;gt;
        &amp;lt;RouterLink to=&quot;/news/detail&quot;&amp;gt;{{news.title}}&amp;lt;/RouterLink&amp;gt;
      &amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
    &amp;lt;div class=&quot;news-content&quot;&amp;gt;
      &amp;lt;RouterView&amp;gt;&amp;lt;/RouterView&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个时候，我们没有传入新闻的id，还不能把具体的内容加载到页面中，需要从News页面点击传入的的参数加载不同的内容&lt;/p&gt;
&lt;h3&gt;Query参数传递&lt;/h3&gt;
&lt;p&gt;通过query进行参数传递，方式类似于get请求&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;div&amp;gt;News&amp;lt;/div&amp;gt;
    &amp;lt;ul&amp;gt;
      &amp;lt;li v-for=&quot;news in newsList&quot; :key=&quot;news.id&quot;&amp;gt;
        &amp;lt;RouterLink :to=&quot;`/news/detail?id=${news.id}&amp;amp;title=${news.title}&amp;amp;content=${news.content}`&quot;&amp;gt;{{news.title}}&amp;lt;/RouterLink&amp;gt;
      &amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
    &amp;lt;div class=&quot;news-content&quot;&amp;gt;
      &amp;lt;RouterView&amp;gt;&amp;lt;/RouterView&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以下这样的写法也是可以的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;div&amp;gt;News&amp;lt;/div&amp;gt;
    &amp;lt;ul&amp;gt;
      &amp;lt;li v-for=&quot;news in newsList&quot; :key=&quot;news.id&quot;&amp;gt;
&amp;lt;!--        &amp;lt;RouterLink :to=&quot;`/news/detail?id=${news.id}&amp;amp;title=${news.title}&amp;amp;content=${news.content}`&quot;&amp;gt;{{news.title}}&amp;lt;/RouterLink&amp;gt;--&amp;gt;
        &amp;lt;RouterLink
          :to=&quot;{
          path:&apos;/news/detail&apos;,
          query:{
            id:news.id,
            title:news.title,
            content:news.content
          }
          }&quot;
        &amp;gt;
          {{news.title}}
        &amp;lt;/RouterLink&amp;gt;
      &amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
    &amp;lt;div class=&quot;news-content&quot;&amp;gt;
      &amp;lt;RouterView&amp;gt;&amp;lt;/RouterView&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Detai页面通过引入useRoute进行参数的接收&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup lang=&quot;ts&quot;&amp;gt;
import { useRoute } from &apos;vue-router&apos;
const route = useRoute();
console.log(route)
&amp;lt;/script&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;ul class=&quot;news-context&quot;&amp;gt;
    &amp;lt;li&amp;gt;编号：{{route.query.id}}&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;标题：{{route.query.title}}&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;内容：{{route.query.content}}&amp;lt;/li&amp;gt;
  &amp;lt;/ul&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;style scoped&amp;gt;

&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;params参数&lt;/h3&gt;
&lt;p&gt;在路由中参数提前占位&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  path:&apos;/news&apos;,
  component:News,
  children:[
    {
      path:&apos;detail/:id/:title/:content&apos;,
      component:Detail
    },
  ]
},
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;news页面传递参数写为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;div&amp;gt;News&amp;lt;/div&amp;gt;
    &amp;lt;ul&amp;gt;
      &amp;lt;li v-for=&quot;news in newsList&quot; :key=&quot;news.id&quot;&amp;gt;
        &amp;lt;RouterLink :to=&apos;`/news/detail/${news.id}/${news.title}/${news.content}`&apos;&amp;gt;
          {{ news.title }}
        &amp;lt;/RouterLink&amp;gt;
      &amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
    &amp;lt;div class=&quot;news-content&quot;&amp;gt;
      &amp;lt;RouterView&amp;gt;&amp;lt;/RouterView&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;detail页面route对象取params对象，获取params参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup lang=&quot;ts&quot;&amp;gt;
import { useRoute } from &quot;vue-router&quot;;
const route = useRoute();
console.log(route);
&amp;lt;/script&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;ul class=&quot;news-context&quot;&amp;gt;
    &amp;lt;li&amp;gt;编号：{{route.params.id}}&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;标题：{{route.params.title}}&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;内容：{{route.params.content}}&amp;lt;/li&amp;gt;
  &amp;lt;/ul&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;style scoped&amp;gt;

&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;props配置&lt;/h3&gt;
&lt;p&gt;路由规则的props配置&lt;/p&gt;
&lt;p&gt;在路由下打开props配置，当在News页面中使用到Detail组建的时候，就会在组建标签中附带上对应的占位参数（params）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;children:[
  {
    path:&apos;detail/:id/:title/:content&apos;,
    component:Detail,
    props:true
  },
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Detail中通过defineProps直接用即可，非常方便&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup lang=&quot;ts&quot;&amp;gt;
defineProps([&apos;id&apos;, &apos;title&apos;, &apos;content&apos;])
&amp;lt;/script&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;ul class=&quot;news-context&quot;&amp;gt;
    &amp;lt;li&amp;gt;编号：{{id}}&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;标题：{{title}}&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;内容：{{content}}&amp;lt;/li&amp;gt;
  &amp;lt;/ul&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;style scoped&amp;gt;

&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;replace属性&lt;/h3&gt;
&lt;p&gt;浏览器跳转页面有push和replace两种模式&lt;/p&gt;
&lt;p&gt;默认的是push模式，这种模式回形成历史记录，方便回顾历史跳回&lt;/p&gt;
&lt;p&gt;如果需要修改为replace模式，在对应的路由跳转标签上加入replace即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;RouterLink replace to=&quot;/home&quot;&amp;gt;首页&amp;lt;/RouterLink&amp;gt;
&amp;lt;RouterLink replace to=&quot;/news&quot;&amp;gt;新闻&amp;lt;/RouterLink&amp;gt;
&amp;lt;RouterLink replace to=&quot;/about&quot;&amp;gt;关于&amp;lt;/RouterLink&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;编程式导航&lt;/h3&gt;
&lt;p&gt;脱离RouterLink实现路由跳转，在实际编程中编程式导航使用多余路由&lt;/p&gt;
&lt;p&gt;如下是一个挂载三秒主页后完成页面跳转的示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup lang=&quot;ts&quot;&amp;gt;
import {onMounted} from &apos;vue&apos;
import {useRouter} from &apos;vue-router&apos;
const router = useRouter()
onMounted(() =&amp;gt; {
  setTimeout(() =&amp;gt; {
    //编写代码实现跳转
    router.push(&apos;/news&apos;)
  },3000)
})
&amp;lt;/script&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    Home
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;style scoped&amp;gt;

&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;重定向&lt;/h3&gt;
&lt;p&gt;访问/路径时重定向至/home路径&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;routes:[
  {
    path:&apos;/&apos;,
    redirect:&apos;/home&apos;
  },
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Vue3笔记（入门使用，setup，响应式数据，计算属性）</title><link>https://thrinisty.github.io/posts/vue3%E7%AC%94%E8%AE%B0%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8setup%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/vue3%E7%AC%94%E8%AE%B0%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8setup%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/</guid><description>Vue的入门使用，setup，响应式数据（ref、reactive），计算属性</description><pubDate>Mon, 07 Jul 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Vue3笔记&lt;/h1&gt;
&lt;h2&gt;快速入门&lt;/h2&gt;
&lt;p&gt;通过如下指令快速创建vite项目&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm create vue@latest
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过如下指令安装npm指定的相关依赖&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;main.ts&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import &apos;./assets/main.css&apos;

import { createApp } from &apos;vue&apos;
import App from &apos;./App.vue&apos;

createApp(App).mount(&apos;#app&apos;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;createApp是创建应用&lt;/p&gt;
&lt;p&gt;App是组件（根），写的后续vue组件都是安装到App上&lt;/p&gt;
&lt;p&gt;mount在对应的id挂在，这个app在index.html中&lt;/p&gt;
&lt;p&gt;以下是选项式编写的vue&lt;/p&gt;
&lt;p&gt;App.vue&lt;/p&gt;
&lt;p&gt;在App中导入并注册Person组件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script lang=&quot;ts&quot;&amp;gt;
import Person from &apos;./components/Person.vue&apos;
export default {
  name: &apos;App&apos;,
  components: { Person },
}
&amp;lt;/script&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;div class=&quot;app&quot;&amp;gt;
    &amp;lt;h1&amp;gt;Hello World&amp;lt;/h1&amp;gt;
    &amp;lt;Person /&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;style scoped&amp;gt;
.person {
  width: 100px;
  height: 100px;
  background-color: #2e5aae;
}
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Person组件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script lang=&quot;ts&quot;&amp;gt;
export default {
  data() {
    return {
      name: &apos;张三&apos;,
      age: 18,
      gender: &apos;男&apos;,
    }
  },
  methods: {
    showSex() {
      alert(this.gender)
    },
    changeName() {
      this.name = &apos;李四&apos;
    },
    changeAge() {
      this.age = this.age + 1;
    },
  },
}
&amp;lt;/script&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;div class=&quot;person&quot;&amp;gt;
    &amp;lt;h2&amp;gt;姓名:{{ name }}&amp;lt;/h2&amp;gt;
    &amp;lt;h2&amp;gt;年龄:{{ age }}&amp;lt;/h2&amp;gt;
    &amp;lt;button @click=&quot;showSex&quot;&amp;gt;查看性别&amp;lt;/button&amp;gt;
    &amp;lt;button @click=&quot;changeName&quot;&amp;gt;修改名字&amp;lt;/button&amp;gt;
    &amp;lt;button @click=&quot;changeAge&quot;&amp;gt;修改年龄&amp;lt;/button&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;style scoped&amp;gt;
.person {
  width: 300px;
  height: 100px;
  background-color: #265bc3;
}
&amp;lt;/style&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;setup&lt;/h2&gt;
&lt;p&gt;以下是组件式的vue编程&lt;/p&gt;
&lt;p&gt;setup是Vue3中的一个新的配置项，值是一个函数，组件中用到的所有的数据、方法、计算属性、监视等等均配置在setup中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script lang=&quot;ts&quot;&amp;gt;
export default {
  setup(){
    let name = &apos;张三&apos;
    let age = 18
    const sex = &apos;男&apos;
    //方法
    const showSex = () =&amp;gt; {
      alert(sex)
    }
    const changeName = () =&amp;gt; {
      console.log(&apos;修改姓名&apos;)
      name = &apos;李四&apos;
    }
    const changeAge = () =&amp;gt; {
      age = 20
    }
    return {name,age,sex,showSex,changeName,changeAge}
  }
}
&amp;lt;/script&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;div class=&quot;person&quot;&amp;gt;
    &amp;lt;h2&amp;gt;姓名:{{ name }}&amp;lt;/h2&amp;gt;
    &amp;lt;h2&amp;gt;年龄:{{ age }}&amp;lt;/h2&amp;gt;
    &amp;lt;button @click=&quot;showSex&quot;&amp;gt;查看性别&amp;lt;/button&amp;gt;
    &amp;lt;button @click=&quot;changeName&quot;&amp;gt;修改名字&amp;lt;/button&amp;gt;
    &amp;lt;button @click=&quot;changeAge&quot;&amp;gt;修改年龄&amp;lt;/button&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;style scoped&amp;gt;
.person {
  width: 300px;
  height: 100px;
  background-color: #265bc3;
}
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里的变量不是响应式的，通过按钮更新的数据不会更改回页面的数据&lt;/p&gt;
&lt;p&gt;setup的返回值就是将数据交出去，或者可以使用箭头函数将结果返回给页面，可以直接返回函数渲染&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;return ()=&amp;gt;&apos;可以&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过setup语法糖简化写法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup lang=&quot;ts&quot;&amp;gt;
let name = &apos;张三&apos;
let age = 18
const sex = &apos;男&apos;
//方法
const showSex = () =&amp;gt; {
  alert(sex)
}
const changeName = () =&amp;gt; {
  console.log(&apos;修改姓名&apos;)
  name = &apos;李四&apos;
}
const changeAge = () =&amp;gt; {
  age = 20
}
&amp;lt;/script&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;h2&amp;gt;姓名:{{ name }}&amp;lt;/h2&amp;gt;
    &amp;lt;h2&amp;gt;年龄:{{ age }}&amp;lt;/h2&amp;gt;
    &amp;lt;button @click=&quot;showSex&quot;&amp;gt;查看性别&amp;lt;/button&amp;gt;
    &amp;lt;button @click=&quot;changeName&quot;&amp;gt;修改名字&amp;lt;/button&amp;gt;
    &amp;lt;button @click=&quot;changeAge&quot;&amp;gt;修改年龄&amp;lt;/button&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;style scoped&amp;gt;&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;响应式数据&lt;/h2&gt;
&lt;h3&gt;基本类型&lt;/h3&gt;
&lt;p&gt;使用ref&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup lang=&quot;ts&quot;&amp;gt;
import { ref } from &apos;vue&apos;

const name = ref(&apos;张三&apos;)
const age = ref(18)
const sex = &apos;男&apos;
//方法
const showSex = () =&amp;gt; {
  alert(sex)
}
const changeName = () =&amp;gt; {
  console.log(&apos;修改姓名&apos;)
  name.value = &apos;李四&apos;
}
const changeAge = () =&amp;gt; {
  age.value = 20
}
&amp;lt;/script&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;h2&amp;gt;姓名:{{ name }}&amp;lt;/h2&amp;gt;
    &amp;lt;h2&amp;gt;年龄:{{ age }}&amp;lt;/h2&amp;gt;
    &amp;lt;button @click=&quot;showSex&quot;&amp;gt;查看性别&amp;lt;/button&amp;gt;
    &amp;lt;button @click=&quot;changeName&quot;&amp;gt;修改名字&amp;lt;/button&amp;gt;
    &amp;lt;button @click=&quot;changeAge&quot;&amp;gt;修改年龄&amp;lt;/button&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;style scoped&amp;gt;&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;对象类型&lt;/h3&gt;
&lt;p&gt;使用reactive&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup lang=&quot;ts&quot;&amp;gt;
import { reactive } from &apos;vue&apos;
const car = reactive({
  brand: &apos;奔驰&apos;,
  price: 1000000,
})
const games = reactive([
  { id: 1, name: &apos;英雄联盟&apos; },
  { id: 2, name: &apos;绝地求生&apos; },
])
function changePrice() {
  car.price += 100000
}
function changeName() {
  games[0].name = &apos;王者荣耀&apos;
}
&amp;lt;/script&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;h1&amp;gt;汽车品牌：{{ car.brand }}&amp;lt;/h1&amp;gt;
    &amp;lt;h1&amp;gt;汽车价格：{{ car.price }}&amp;lt;/h1&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;button @click=&quot;changePrice&quot;&amp;gt;修改汽车价格&amp;lt;/button&amp;gt;
  &amp;lt;ul&amp;gt;
    &amp;lt;li v-for=&quot;game in games&quot; :key=&quot;game.name&quot;&amp;gt;{{ game.name }}&amp;lt;/li&amp;gt;
  &amp;lt;/ul&amp;gt;
  &amp;lt;button @click=&quot;changeName&quot;&amp;gt;修改名字&amp;lt;/button&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;style scoped&amp;gt;&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;事实上ref也可以定义响应式对象数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup lang=&quot;ts&quot;&amp;gt;
import { reactive, ref } from &apos;vue&apos;
const car = reactive({
  brand: &apos;奔驰&apos;,
  price: 1000000,
})
const games = ref([
  { id: 1, name: &apos;英雄联盟&apos; },
  { id: 2, name: &apos;绝地求生&apos; },
])
function changePrice() {
  car.price += 100000
}
function changeName() {
  games.value[0].name = &apos;王者荣耀&apos;
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方法实现上games取出value使用即可&lt;/p&gt;
&lt;p&gt;如果需要通过json格式的数据修改对象内容完成响应式&lt;/p&gt;
&lt;p&gt;需要使用到Object.assign脚本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const car = reactive({
  brand: &apos;奔驰&apos;,
  price: 1000000,
})
function changeCar() {
  // car.brand = &apos;宝马&apos;
  // car.price = 2000000
  Object.assign(car, { brand: &apos;宝马&apos;, price: 2000000 })
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果是ref响应，可以使用value直接替换&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function changeCar() {
  // car.brand = &apos;宝马&apos;
  // car.price = 2000000
  //
  car.value = {
    brand: &apos;宝马&apos;,
    price: 2000000,
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;toRefs使用&lt;/h3&gt;
&lt;p&gt;通过toRefs使得新建的变量为ref响应式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const car = reactive({
  brand: &apos;奔驰&apos;,
  price: 1000000,
})
const {brand, price} = toRefs(car)

function changeCar() {
  brand.value = &apos;宝马&apos;
  price.value = 2000000
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;toRef&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;const name = toRef(car, &apos;brand&apos;)

function changeName() {
  name.value += &quot;~&quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;计算属性&lt;/h2&gt;
&lt;p&gt;相比较于方法调用而言，计算属性存在缓存，效率更高&lt;/p&gt;
&lt;p&gt;这里的计算属性fullName只读，不可以修改&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup lang=&quot;ts&quot;&amp;gt;
import { ref, computed} from &apos;vue&apos;
const firstName = ref(&apos;张&apos;)
const lastName = ref(&apos;三&apos;)

const fullName = computed(()=&amp;gt;{
  return firstName.value + lastName.value
  //在这里可以写具体的逻辑代码
  //计算属性中属性发生变化就重新计算
})

&amp;lt;/script&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    姓：&amp;lt;input type=&quot;text&quot; v-model=&quot;firstName&quot; /&amp;gt;&amp;lt;br /&amp;gt;
    名：&amp;lt;input type=&quot;text&quot; v-model=&quot;lastName&quot; /&amp;gt;&amp;lt;br /&amp;gt;
    全名：&amp;lt;span&amp;gt;{{fullName}}&amp;lt;/span&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;style scoped&amp;gt;&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要修改为可写可以使用如下写法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const fullName = computed({
  get(){
    return firstName.value + lastName.value
  },
  set(val){
    console.log(&quot;set&quot;,val)
  }
})

function changeFullName() {
  fullName.value = &quot;testName&quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要是想要让全名更新两个前名后名可以使用set中val接收修改的参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup lang=&quot;ts&quot;&amp;gt;
import { ref, computed} from &apos;vue&apos;
const firstName = ref(&apos;张&apos;)
const lastName = ref(&apos;三&apos;)
const fullName = computed({
  get(){
    return firstName.value + &quot;-&quot; + lastName.value
  },
  set(val){
    const nameArr = val.split(&quot;-&quot;)
    firstName.value = nameArr[0]
    lastName.value = nameArr[1]
  }
})

function changeFullName() {
  fullName.value = &quot;li-si&quot;
}

&amp;lt;/script&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    姓：&amp;lt;input type=&quot;text&quot; v-model=&quot;firstName&quot; /&amp;gt;&amp;lt;br /&amp;gt;
    名：&amp;lt;input type=&quot;text&quot; v-model=&quot;lastName&quot; /&amp;gt;&amp;lt;br /&amp;gt;
    全名：&amp;lt;span&amp;gt;{{fullName}}&amp;lt;/span&amp;gt;
    &amp;lt;button @click=&quot;changeFullName&quot;&amp;gt;修改全名为li-si&amp;lt;/button&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;style scoped&amp;gt;&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>用户中心项目笔记（用户管理）</title><link>https://thrinisty.github.io/posts/%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/</guid><description>用户中心</description><pubDate>Sat, 05 Jul 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;用户中心笔记&lt;/h1&gt;
&lt;h2&gt;查找删除&lt;/h2&gt;
&lt;p&gt;Controller&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@GetMapping(&quot;/search&quot;)
public List&amp;lt;User&amp;gt; searchUser(String username) {
    return userService.searchUser(username);
}

@PostMapping(&quot;/delete&quot;)
public boolean deleteUser(long id) {
    return userService.deleteUser(id);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Service&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private static final String USER_LOGIN_STATE = &quot;userLoginState&quot;;

@Override
public boolean deleteUser(long id) {
    if(id &amp;lt; 0) {
        return false;
    }
    return this.removeById(id);
    //这里的removeById会自动转换为逻辑删除将isDelete设置为1
}

@Override
public List&amp;lt;User&amp;gt; searchUser(String username) {
    QueryWrapper&amp;lt;User&amp;gt; queryWrapper = new QueryWrapper&amp;lt;&amp;gt;();
    queryWrapper.eq(&quot;username&quot;, username);
    List&amp;lt;User&amp;gt; users = this.list(queryWrapper);
    if (users.isEmpty()) {
        log.info(&quot;查询不到指定用户名&quot;);
    }
    for (User user : users) {
        user.setUserPassword(null);
    }
    return users;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再增加一个权限字段role判断是否为管理员&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
public boolean deleteUser(long id, HttpServletRequest request) {
    if(id &amp;lt; 0) {
        return false;
    }
    User user = (User) request.getSession().getAttribute(USER_LOGIN_STATE);
    if(user == null || user.getRole() != 1) {
        log.info(&quot;权限不足用户尝试删除数据&quot;);
        return false;
    }
    return this.removeById(id);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;用户注销&lt;/h2&gt;
&lt;p&gt;service&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
public boolean userLogout(HttpServletRequest request) {
    if(request == null){
        log.info(&quot;注销失败&quot;);
        return false;
    }
    HttpSession session = request.getSession();
    session.removeAttribute(USER_LOGIN_STATE);
    return true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;controller&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@PostMapping(&quot;/logout&quot;)
public boolean logout(HttpServletRequest request) {
    if(request == null){
        return false;
    }
    return userService.userLogout(request);
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>用户中心项目笔记（Vue）</title><link>https://thrinisty.github.io/posts/%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0vue%E5%89%8D%E7%AB%AF/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0vue%E5%89%8D%E7%AB%AF/</guid><description>用户中心Vue前端</description><pubDate>Fri, 04 Jul 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;用户中心笔记&lt;/h1&gt;
&lt;h2&gt;相关软件安装&lt;/h2&gt;
&lt;p&gt;node JS下载&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;PS C:\Users\71460\Desktop&amp;gt; node -v
v22.11.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Vue CLI&lt;/p&gt;
&lt;p&gt;使用以下任一指令安装脚手架&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install -g @vue/cli
# OR
yarn global add @vue/cli
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;验证安装成功&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;PS C:\Users\71460\Desktop&amp;gt; vue --version
@vue/cli 5.0.8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在对应文件cmd窗口&lt;/p&gt;
&lt;p&gt;使用如下指令创建对应的vue工程&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vue create user-center-frontend-vue
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Ant Design Vue&lt;/h2&gt;
&lt;p&gt;使用npm安装组件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm i --save ant-design-vue@4.x
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;全局引入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import { createApp } from &apos;vue&apos;;
import Antd from &apos;ant-design-vue&apos;;
import App from &apos;./App&apos;;
import &apos;ant-design-vue/dist/reset.css&apos;;

const app = createApp(App);

app.use(Antd).mount(&apos;#app&apos;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在main.ts中融合一下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import { createApp } from &quot;vue&quot;;
import App from &quot;./App.vue&quot;;
import router from &quot;./router&quot;;
import Antd from &quot;ant-design-vue&quot;;
import &quot;ant-design-vue/dist/reset.css&quot;;

createApp(App).use(Antd).use(router).mount(&quot;#app&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;代码风格&lt;/h2&gt;
&lt;p&gt;组合式API&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup&amp;gt;
import { ref, onMounted } from &apos;vue&apos;

// 响应式状态
const count = ref(0)

// 用来修改状态、触发更新的函数
function increment() {
  count.value++
}

// 生命周期钩子
onMounted(() =&amp;gt; {
  console.log(`The initial count is ${count.value}.`)
})
&amp;lt;/script&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;button @click=&quot;increment&quot;&amp;gt;Count is: {{ count }}&amp;lt;/button&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;页面布局&lt;/h2&gt;
&lt;p&gt;通过一个BasicLayout页面，使其他的页面引用其实现各个网页模板不发送改变&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div id=&quot;BasicLayout&quot;&amp;gt;
    &amp;lt;a-layout&amp;gt;
      &amp;lt;a-layout-header :style=&quot;headerStyle&quot;&amp;gt;Header&amp;lt;/a-layout-header&amp;gt;
      &amp;lt;a-layout-content class=&quot;content&quot; :style=&quot;contentStyle&quot;&amp;gt;
        &amp;lt;router-view /&amp;gt;
      &amp;lt;/a-layout-content&amp;gt;
      &amp;lt;a-layout-footer class=&quot;footer&quot; :style=&quot;footerStyle&quot;&amp;gt;
        &amp;lt;a href=&quot;https://thrinisty.github.io/Blog/&quot; target=&quot;_blank&quot;&amp;gt;
          thrinisty博客网址
        &amp;lt;/a&amp;gt;
      &amp;lt;/a-layout-footer&amp;gt;
    &amp;lt;/a-layout&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script setup lang=&quot;ts&quot;&amp;gt;&amp;lt;/script&amp;gt;

&amp;lt;style scoped&amp;gt;
#BasicLayout .footer {
  background-color: #96ebf4;
  text-align: center;
  position: fixed;
  left: 0;
  right: 0;
  bottom: 0;
  padding: 16px;
}

#BasicLayout .content {
  padding: 20px;
  margin-bottom: 20px;
  background: linear-gradient(to right, #cae8ec 0%, #70d9ea 80%);
}
&amp;lt;/style&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在其他的页面中引入这个BasicLayout基础布局&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;BasicLayout&amp;gt;&amp;lt;/BasicLayout&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;style&amp;gt;&amp;lt;/style&amp;gt;
&amp;lt;script setup lang=&quot;ts&quot;&amp;gt;
import BasicLayout from &quot;@/loayouts/BasicLayout.vue&quot;;
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;全局导航菜单&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div id=&quot;GlobalHeader&quot;&amp;gt;
    &amp;lt;a-row :wrap=&quot;false&quot;&amp;gt;
      &amp;lt;a-col flex=&quot;200px&quot;&amp;gt;
        &amp;lt;div class=&quot;header-container&quot;&amp;gt;
          &amp;lt;div class=&quot;title&quot;&amp;gt;用户论坛&amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;&amp;lt;/a-col
      &amp;gt;
      &amp;lt;a-col flex=&quot;auto&quot;
        &amp;gt;&amp;lt;a-menu
          v-model:selectedKeys=&quot;current&quot;
          mode=&quot;horizontal&quot;
          :items=&quot;items&quot;
      /&amp;gt;&amp;lt;/a-col&amp;gt;
      &amp;lt;a-col flex=&quot;80px&quot;
        &amp;gt;&amp;lt;div class=&quot;user-login-status&quot;&amp;gt;
          &amp;lt;a-button type=&quot;primary&quot; href=&quot;/user/login&quot;&amp;gt;Login&amp;lt;/a-button&amp;gt;
        &amp;lt;/div&amp;gt;&amp;lt;/a-col
      &amp;gt;
    &amp;lt;/a-row&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script lang=&quot;ts&quot; setup&amp;gt;
import { h, ref } from &quot;vue&quot;;
import {
  MailOutlined,
  AppstoreOutlined,
  SettingOutlined,
} from &quot;@ant-design/icons-vue&quot;;
import { MenuProps } from &quot;ant-design-vue&quot;;
const current = ref&amp;lt;string[]&amp;gt;([&quot;mail&quot;]);
const items = ref&amp;lt;MenuProps[&quot;items&quot;]&amp;gt;([
  {
    key: &quot;mail&quot;,
    icon: () =&amp;gt; h(MailOutlined),
    label: &quot;论坛&quot;,
    title: &quot;论坛&quot;,
  },
  {
    key: &quot;app&quot;,
    icon: () =&amp;gt; h(AppstoreOutlined),
    label: &quot;推文&quot;,
    title: &quot;推文&quot;,
  },
  {
    key: &quot;sub1&quot;,
    icon: () =&amp;gt; h(SettingOutlined),
    label: &quot;关注博主&quot;,
    title: &quot;关注博主&quot;,
    children: [
      {
        type: &quot;group&quot;,
        label: &quot;Item 1&quot;,
        children: [
          {
            label: &quot;Option 1&quot;,
            key: &quot;setting:1&quot;,
          },
          {
            label: &quot;Option 2&quot;,
            key: &quot;setting:2&quot;,
          },
        ],
      },
      {
        type: &quot;group&quot;,
        label: &quot;Item 2&quot;,
        children: [
          {
            label: &quot;Option 3&quot;,
            key: &quot;setting:3&quot;,
          },
          {
            label: &quot;Option 4&quot;,
            key: &quot;setting:4&quot;,
          },
        ],
      },
    ],
  },
  {
    key: &quot;alipay&quot;,
    icon: () =&amp;gt; h(SettingOutlined),
    label: h(
      &quot;a&quot;,
      { href: &quot;https://thrinisty.github.io/Blog/&quot;, target: &quot;_blank&quot; },
      &quot;主页链接&quot;
    ),
    title: &quot;返回主页&quot;,
  },
]);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在BasicLayout的header里引入全局导航的设置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;a-layout-header class=&quot;header&quot; :style=&quot;headerStyle&quot;&amp;gt;
  &amp;lt;GlobalHeader /&amp;gt;
&amp;lt;/a-layout-header&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在a-col标签中通过@click=&quot;doMenuClick&quot;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;a-col flex=&quot;auto&quot;
  &amp;gt;&amp;lt;a-menu
    v-model:selectedKeys=&quot;current&quot;
    mode=&quot;horizontal&quot;
    :items=&quot;items&quot;
    @click=&quot;doMenuClick&quot;
/&amp;gt;&amp;lt;/a-col&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;const doMenuClick = ({ key }: { key: string }) =&amp;gt; {
  router.push({
    path: &quot;/&quot; + key,
  });
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样我们选取水平菜单的时候就会请求对应key的路径，在全局路由进行配置即可轻松实现页面的切换&lt;/p&gt;
&lt;h2&gt;与后端交互数据&lt;/h2&gt;
&lt;h3&gt;全局自定义请求&lt;/h3&gt;
&lt;p&gt;编写请求配置文件request.ts  包括全局接口请求地址，超时时间，自定义请求响应拦截器等&lt;/p&gt;
&lt;p&gt;运用场景：需要对接口的通用响应进行统一处理，例如从response中取出data；或者根据code去集中处理错误，这样不用在每个接口请求中都去写相同的逻辑&lt;/p&gt;
&lt;p&gt;也可以在全局响应拦截器中读取结果中的data，并校验code是否合法，如果是未登录状态，则自动登录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const myAxios = axios.create({
  baseURL: &quot;https://localhost:8080&quot;,
  timeout: 10000,
  withCredentials: true,
});

// 添加请求拦截器
myAxios.interceptors.request.use(
  function (config) {
    // 在发送请求之前做些什么
    console.log(config);
    const { data } = config;
    console.log(data);
    return config;
  },
  function (error) {
    // 对请求错误做些什么
    return Promise.reject(error);
  }
);

// 添加响应拦截器
myAxios.interceptors.response.use(
  function (response) {
    // 2xx 范围内的状态码都会触发该函数。
    // 对响应数据做点什么
    return response;
  },
  function (error) {
    // 超出 2xx 范围的状态码都会触发该函数。
    // 对响应错误做点什么
    return Promise.reject(error);
  }
);

export default myAxios;
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>用户中心项目笔记（MyBatisPlus，注册，登录，记录状态）</title><link>https://thrinisty.github.io/posts/%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0mybatisplus%E6%B3%A8%E5%86%8C%E7%99%BB%E5%BD%95%E8%AE%B0%E5%BD%95%E7%8A%B6%E6%80%81/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0mybatisplus%E6%B3%A8%E5%86%8C%E7%99%BB%E5%BD%95%E8%AE%B0%E5%BD%95%E7%8A%B6%E6%80%81/</guid><description>用户中心项目后端开发，SpringBoot整合</description><pubDate>Thu, 03 Jul 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;用户中心开发笔记&lt;/h1&gt;
&lt;h2&gt;MyBatisPlus&lt;/h2&gt;
&lt;p&gt;引入相关依赖&lt;/p&gt;
&lt;p&gt;mybatisPlus依赖&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.baomidou&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mybatis-plus-boot-starter&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.5.12&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;lombok依赖，用于自动生成get set toString方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;
    &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;spring:
  application:
    name: user-center
  datasource:
    driver-class-name: com.mysql.jdbc.Driver
    url: jdbc:mysql://localhost:3306/usermanager
    username: root
    password: 654321
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Bean对象的设置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Data
@TableName(&quot;`user`&quot;)
public class User {
    private Long id;
    private String name;
    private Integer age;
    private String email;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建UserMapper的接口，继承于BaseMapper&amp;lt;User&amp;gt;，这个父类接口中存在很多现成的SQL操作方法供以使用，使得我们不需要手动写SQL语句&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface UserMapper extends BaseMapper&amp;lt;User&amp;gt; {

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在引导类中使用MapperScan扫描UserMapper&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@SpringBootApplication
@MapperScan(&quot;com.nwpu.backend.mapper&quot;)
public class BackendApplication {
    public static void main(String[] args) {
       SpringApplication.run(BackendApplication.class, args);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试程序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DROP TABLE IF EXISTS `user`;

CREATE TABLE `user`
(
    id BIGINT NOT NULL COMMENT &apos;主键ID&apos;,
    name VARCHAR(30) NULL DEFAULT NULL COMMENT &apos;姓名&apos;,
    age INT NULL DEFAULT NULL COMMENT &apos;年龄&apos;,
    email VARCHAR(50) NULL DEFAULT NULL COMMENT &apos;邮箱&apos;,
    PRIMARY KEY (id)
);

DELETE FROM `user`;

INSERT INTO `user` (id, name, age, email) VALUES
(1, &apos;Jone&apos;, 18, &apos;test1@baomidou.com&apos;),
(2, &apos;Jack&apos;, 20, &apos;test2@baomidou.com&apos;),
(3, &apos;Tom&apos;, 28, &apos;test3@baomidou.com&apos;),
(4, &apos;Sandy&apos;, 21, &apos;test4@baomidou.com&apos;),
(5, &apos;Billie&apos;, 24, &apos;test5@baomidou.com&apos;);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;@Test
void testUserMapper() {
    List&amp;lt;User&amp;gt; users = userMapper.selectList(null);
    for (User user : users) {
       System.out.println(user);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;User(id=1, name=Jone, age=18, email=test1@baomidou.com)
User(id=1, name=Jone, age=18, email=test1@baomidou.com)
User(id=2, name=Jack, age=20, email=test2@baomidou.com)
User(id=3, name=Tom, age=28, email=test3@baomidou.com)
User(id=4, name=Sandy, age=21, email=test4@baomidou.com)
User(id=5, name=Billie, age=24, email=test5@baomidou.com)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;数据库表格设计&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE `usermanager`.`user`  (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT &apos;用户ID&apos;,
  `username` varchar(100) NULL COMMENT &apos;用户名称&apos;,
  `user_account` varchar(255) NULL COMMENT &apos;用户账号&apos;,
  `avatar_url` varchar(255) NULL COMMENT &apos;用户头像地址&apos;,
  `gender` tinyint NULL COMMENT &apos;用户性别&apos;,
  `user_password` varchar(255) NOT NULL COMMENT &apos;用户密码&apos;,
  `phone` varchar(255) NULL COMMENT &apos;用户电话&apos;,
  `email` varchar(255) NULL COMMENT &apos;用户邮箱&apos;,
  `user_status` tinyint ZEROFILL NULL COMMENT &apos;用户状态&apos;,
  `createtime` datetime DEFAULT CURRENT_TIMESTAMP	NULL COMMENT &apos;创建时间&apos;,
  `updatetime` datetime DEFAULT CURRENT_TIMESTAMP NULL on update CURRENT_TIMESTAMP COMMENT &apos;更新时间&apos;,
  `is_delete` tinyint ZEROFILL NULL COMMENT &apos;是否删除&apos;,
  PRIMARY KEY (`id`)
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;User对象创建&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Data
public class User implements Serializable {
    private Long id;
    private String username;
    private String userAccount;
    private String avatarUrl;
    private Integer gender;
    private String userPassword;
    private String phone;
    private String email;
    private Integer userStatus;
    private Date createtime;
    private Date updatetime;
    private Integer isDelete;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;注册逻辑实现&lt;/h2&gt;
&lt;p&gt;1.用户在前端输入账户密码，以及校验码&lt;/p&gt;
&lt;p&gt;2.校验账户密码：&lt;/p&gt;
&lt;p&gt;​	账户不少于4位&lt;/p&gt;
&lt;p&gt;​	密码不小于8位&lt;/p&gt;
&lt;p&gt;​	账户不能重复&lt;/p&gt;
&lt;p&gt;3.对密码进行加密（密码不能直接存入到数据库）&lt;/p&gt;
&lt;p&gt;4.向用户数据库插入数据&lt;/p&gt;
&lt;p&gt;设置User业务层的接口，extends IService&amp;lt;User&amp;gt;是预设了一些常用的方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface UserService extends IService&amp;lt;User&amp;gt; {

    /**
     * 用户注册
     * @param userAccount 用户账号
     * @param userPassword 用户密码
     * @param checkPassword 确认密码
     * @return 新用户ID
     */
    long userRegister(String userAccount, String userPassword, String checkPassword);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实现上，继承于ServiceImpl&amp;lt;UserMapper, User&amp;gt; 可以默认实现预设的逻辑&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;M&lt;/code&gt;（Mapper 类型）&lt;/strong&gt;：指定操作数据库的 Mapper 接口（这里是 &lt;code&gt;UserMapper&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;T&lt;/code&gt;（实体类型）&lt;/strong&gt;：指定数据库对应的实体类（这里是 &lt;code&gt;User&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;@Service
public class UserServiceImpl extends ServiceImpl&amp;lt;UserMapper, User&amp;gt; implements UserService {
    @Override
    public long userRegister(String userAccount, String userPassword, String checkPassword) {
        return 0;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里我们为了方便引入一个commons-lang3依赖&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.commons&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;commons-lang3&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.17.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;密码加密，这里引入一个加密相关的依赖&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.security&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-security-crypto&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;工具类的封装&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class PasswordUtils {
    private static final BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();
    // 加密密码
    public static String encrypt(String rawPassword) {
        return encoder.encode(rawPassword);
    }
    // 校验密码
    public static boolean matches(String rawPassword, String encodedPassword) {
        return encoder.matches(rawPassword, encodedPassword);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试一下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void testEncode() {
    String password = &quot;feierling&quot;;
    String encodePwd = PasswordUtils.encrypt(password);
    System.out.println(encodePwd);
    System.out.println(PasswordUtils.matches(&quot;feierling&quot;, encodePwd));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;$2a$10$c31FHZvkQNmUb5K3qByys.aw8igBVHC7nRkg1Rb2dmK9//PIa9QIi
true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;:::warning&lt;/p&gt;
&lt;p&gt;在 &lt;strong&gt;BCrypt&lt;/strong&gt; 加密算法中，&lt;strong&gt;即使相同的密码，每次加密后的哈希值也会不同&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;p&gt;注册代码实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
public long userRegister(String userAccount, String userPassword, String checkPassword) {
    //使用工具类传入参数列表，都不为空
    if (StringUtils.isAnyBlank(userAccount, userPassword, checkPassword)) {
        return -1;//不能为空
    }
    if (userAccount.length() &amp;lt; 4) {
        return -2;//账户不能小于4
    }
    if (userPassword.length() &amp;lt; 8 || checkPassword.length() &amp;lt; 8) {
        return -3;//密码不能小于8
    }
    QueryWrapper&amp;lt;User&amp;gt; queryWrapper = new QueryWrapper&amp;lt;&amp;gt;();
    queryWrapper.eq(&quot;user_account&quot;, userAccount);
    long count = this.count(queryWrapper);
    if (count &amp;gt; 0) {
        return -4;//不能用相同的账户
    }
    Pattern pattern = Pattern.compile(&quot;[^a-zA-Z0-9\\u4e00-\\u9fa5]&quot;);
    if (pattern.matcher(userAccount).find()) {
        return -5;//账户名不能为特殊字符
    }
    if (!userPassword.equals(checkPassword)){
        return -6;//密码不相同
    }

    //加密
    String encodePwd = PasswordUtils.encrypt(userPassword);
    User user = new User();
    user.setUserAccount(userAccount);
    user.setUserPassword(encodePwd);

    //向数据库中插入数据
    boolean saveResult = this.save(user);
    if (!saveResult) {
        return -7;//插入失败
    }
    return user.getId();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;登录逻辑实现&lt;/h2&gt;
&lt;p&gt;接收参数：用户账户名称，密码&lt;/p&gt;
&lt;p&gt;请求类型：POST&lt;/p&gt;
&lt;p&gt;请求体：JSON格式&lt;/p&gt;
&lt;p&gt;返回值：用户信息（脱敏）&lt;/p&gt;
&lt;h3&gt;逻辑&lt;/h3&gt;
&lt;p&gt;校验账户密码是否合法&lt;/p&gt;
&lt;p&gt;账户是否在数据库中存在&lt;/p&gt;
&lt;p&gt;将用户态记录，将其存到服务器上（Session、Cookie）&lt;/p&gt;
&lt;p&gt;返回用户信息&lt;/p&gt;
&lt;h3&gt;代码实现&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;@Override
public User userLogin(String userAccount, String userPassword) {
    //使用工具类传入参数列表，都不为空
    if (StringUtils.isAnyBlank(userAccount, userPassword)) {
        return null;//账户密码不能为空
    }
    if (userAccount.length() &amp;lt; 4) {
        return null;//账户不能小于4
    }
    if (userPassword.length() &amp;lt; 8) {
        return null;//密码不能小于8
    }

    Pattern pattern = Pattern.compile(&quot;[^a-zA-Z0-9\\u4e00-\\u9fa5]&quot;);
    if (pattern.matcher(userAccount).find()) {
        return null;//账户名不能为特殊字符
    }

    QueryWrapper&amp;lt;User&amp;gt; queryWrapper = new QueryWrapper&amp;lt;&amp;gt;();
    queryWrapper.eq(&quot;user_account&quot;, userAccount);
    User user = this.getOne(queryWrapper);
    if (user == null) {
        return null;//用户不存在
    }
    Boolean isPasswordValid = PasswordUtils.matches(userPassword, user.getUserPassword());
    if (!isPasswordValid) {
        return null;//密码不正确
    }

    user.setUserPassword(null);//信息脱敏
    return user;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;记录用户登录状态&lt;/h2&gt;
&lt;p&gt;连接服务器后，得到一个session状态，返回给前端&lt;/p&gt;
&lt;p&gt;登陆成功后，得到了登陆成功的session，并且给该session设置一些值，返回给前端一个设置cookie的“命令”&lt;/p&gt;
&lt;p&gt;前端接收到后端的命令后，设置cookie，保存到浏览器内&lt;/p&gt;
&lt;p&gt;前端再次请求后端的时候，在请求头中带上cookie去请求&lt;/p&gt;
&lt;p&gt;后端拿到前端传过来的cookie，找到对应的session&lt;/p&gt;
&lt;p&gt;后端从session中可以取出基于该session存储的变量（用户的登录信息，登录名称）&lt;/p&gt;
&lt;h2&gt;Controller&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;@RestController
@RequestMapping(&quot;/user&quot;)
public class UserController {

    @Autowired
    private UserService userService;

    @PostMapping(&quot;/register&quot;)
    public Long userRegister(@RequestBody UserRegisterRequest userRegisterRequest) {
        if(userRegisterRequest == null) {
            return null;
        }
        String userAccount = userRegisterRequest.getUserAccount();
        String userPassword = userRegisterRequest.getUserPassword();
        String checkPassword = userRegisterRequest.getCheckPassword();
        return userService.userRegister(userAccount, userPassword, checkPassword);
    }

    @PostMapping(&quot;/login&quot;)
    public User userLogin(@RequestBody UserLoginRequest userLoginRequest, HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) {
        if(userLoginRequest == null) {
            return null;
        }
        String userAccount = userLoginRequest.getUserAccount();
        String userPassword = userLoginRequest.getUserPassword();
        return userService.userLogin(userAccount, userPassword, httpServletRequest);
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>用户中心项目笔记（）</title><link>https://thrinisty.github.io/posts/%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0%E6%A8%A1%E6%9D%BF/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0%E6%A8%A1%E6%9D%BF/</guid><description>用户中心</description><pubDate>Tue, 01 Jul 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;用户中心笔记&lt;/h1&gt;
</content:encoded></item><item><title>自学第四月份总结</title><link>https://thrinisty.github.io/posts/%E8%87%AA%E5%AD%A6%E7%AC%AC%E5%9B%9B%E6%9C%88%E4%BB%BD%E6%80%BB%E7%BB%93/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/%E8%87%AA%E5%AD%A6%E7%AC%AC%E5%9B%9B%E6%9C%88%E4%BB%BD%E6%80%BB%E7%BB%93/</guid><description>LeetCode继续刷题，Spring学习完成，Spring MVC、Spring Boot、Spring AI初步上手</description><pubDate>Tue, 01 Jul 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;自学第四月份总结&lt;/h1&gt;
&lt;h2&gt;关于LeetCode刷题&lt;/h2&gt;
&lt;p&gt;在六月份的上旬和中旬还是有在继续刷题，加上之前的积累总计有63道了，但是到公司之后每天需要学习新的知识点就没有把刷题的习惯继续保留下去了，我觉得基本的底子搭起来了，之后准备每天抽时间回顾一下，使得自己不至于忘了，等实习完毕后把剩余的37道也给完成&lt;/p&gt;
&lt;h2&gt;Spring框架学习&lt;/h2&gt;
&lt;h3&gt;Spring&lt;/h3&gt;
&lt;p&gt;了解了代理模式以及其代码实现，能够自己手写出代理类，也可以自动生成代理类。学习了AOP相关知识，明白了面向切面在实际中的运用，而对于Spring事务而言，学会怎样使用。&lt;/p&gt;
&lt;h3&gt;MyBatis&lt;/h3&gt;
&lt;p&gt;学了一半，还没有学完，目前能够使用Spring Boot整合基本CRUD使用&lt;/p&gt;
&lt;h3&gt;Spring MVC&lt;/h3&gt;
&lt;p&gt;学习了通过注解的方式代替传统Web xml的配置，也不用使用Servlet进行路径的映射，了解通过json的格式进行前后端数据的交互，学习了REST风格的编程响应，RestController的使用，尝试整合了一下SSM的使用，拦截器的使用&lt;/p&gt;
&lt;h3&gt;SpringBoot&lt;/h3&gt;
&lt;p&gt;很方便啊，相比较于SSM的直接使用，SpringBoot自动整合了一些相关的依赖，不易出现版本问题，能够快速的搭建出一个简易的项目框架出来，通过application配置文件进行相关参数的设置，了解了yaml格式的使用。&lt;/p&gt;
&lt;p&gt;通过SpringBoot整合其他框架非常的好用，得益于Spring Boot的对象创建机制，可以轻松通过pom依赖的引用，和Autowired注解实现相关功能，也了解了一些项目部署和监控的机制&lt;/p&gt;
&lt;h3&gt;Spring AI&lt;/h3&gt;
&lt;p&gt;了解了一些入门的使用，通过外界大模型进行数据的交互，Spring AI将大模型的交互封装的非常好用，调用就完了，了解了提示词的相关运用，Function Calling的运用场景，MCP服务器的编写，了解了记忆对话的实现方式，模型对话内容返回为Bean对象的方式&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;总的来说这个月学到的东西还是很多来着，Spring部分结束了，LeetCode也是继续再刷，MyBatis、SpringMVC、SpringBoot学会了常见的使用（速成），之后等忙完了也许会再次回顾补补基础之类的？Spring AI的初步使用，现在官方的文档还不是很全不太好学习。南京很热啊，每天实习上下班通勤难受死了，回到公寓基本也是啥也不想干，周末放空大脑好好娱乐，不过好在确实能够接触到工作的环境，和前辈们交流交流了解一下工作的相关知识&lt;/p&gt;
&lt;p&gt;负责的老师也派活下来了，拓展一个论坛的功能，要求前后端完成，所以Vue的学习也要提上日程了，算是个绝佳的练手机会吧&lt;/p&gt;
</content:encoded></item><item><title>SpringAI笔记（MCPService，上下文对话，内容封装）</title><link>https://thrinisty.github.io/posts/springai%E7%AC%94%E8%AE%B0mcpservice%E4%B8%8A%E4%B8%8B%E6%96%87%E5%AF%B9%E8%AF%9D%E5%86%85%E5%AE%B9%E5%B0%81%E8%A3%85/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/springai%E7%AC%94%E8%AE%B0mcpservice%E4%B8%8A%E4%B8%8B%E6%96%87%E5%AF%B9%E8%AF%9D%E5%86%85%E5%AE%B9%E5%B0%81%E8%A3%85/</guid><description>MCPService 上下文对话，内容封装</description><pubDate>Mon, 30 Jun 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;SpringAI笔记&lt;/h1&gt;
&lt;h2&gt;MCP&lt;/h2&gt;
&lt;p&gt;模型上下文协议&lt;/p&gt;
&lt;p&gt;是一种标准化协议，使 AI 模型能以结构化方式与外部工具及资源交互。它支持多种传输机制，以适应不同环境的灵活性需求。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/215.jpg&quot; alt=&quot;215&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://modelcontextprotocol.io/sdk/java&quot;&gt;MCP Java SDK&lt;/a&gt; 提供 MCP 的 Java 实现，支持通过同步和异步通信模式与 AI 模型及工具进行标准化交互。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring AI MCP&lt;/strong&gt; 通过集成 Spring Boot 扩展了 MCP Java SDK，同时提供 &lt;a href=&quot;https://springdoc.cn/spring-ai/api/mcp/mcp-client-boot-starter-docs.html&quot;&gt;客户端&lt;/a&gt; 和 &lt;a href=&quot;https://springdoc.cn/spring-ai/api/mcp/mcp-server-boot-starter-docs.html&quot;&gt;服务端&lt;/a&gt; Starter。使用 &lt;a href=&quot;https://start.springboot.io/&quot;&gt;Spring Initializer&lt;/a&gt;可快速构建支持 MCP 的 AI 应用。&lt;/p&gt;
&lt;h2&gt;MCPService&lt;/h2&gt;
&lt;h3&gt;引入相关依赖&lt;/h3&gt;
&lt;p&gt;引入仓库依赖&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;repositories&amp;gt;
    &amp;lt;repository&amp;gt;
       &amp;lt;id&amp;gt;spring-snapshots&amp;lt;/id&amp;gt;
       &amp;lt;name&amp;gt;Spring Snapshots&amp;lt;/name&amp;gt;
       &amp;lt;url&amp;gt;https://repo.spring.io/snapshot&amp;lt;/url&amp;gt;
       &amp;lt;releases&amp;gt;
          &amp;lt;enabled&amp;gt;false&amp;lt;/enabled&amp;gt;
       &amp;lt;/releases&amp;gt;
    &amp;lt;/repository&amp;gt;
    &amp;lt;repository&amp;gt;
       &amp;lt;name&amp;gt;Central Portal Snapshots&amp;lt;/name&amp;gt;
       &amp;lt;id&amp;gt;central-portal-snapshots&amp;lt;/id&amp;gt;
       &amp;lt;url&amp;gt;https://central.sonatype.com/repository/maven-snapshots/&amp;lt;/url&amp;gt;
       &amp;lt;releases&amp;gt;
          &amp;lt;enabled&amp;gt;false&amp;lt;/enabled&amp;gt;
       &amp;lt;/releases&amp;gt;
       &amp;lt;snapshots&amp;gt;
          &amp;lt;enabled&amp;gt;true&amp;lt;/enabled&amp;gt;
       &amp;lt;/snapshots&amp;gt;
    &amp;lt;/repository&amp;gt;
&amp;lt;/repositories&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;引入MCP Service相关依赖&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.ai&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-ai-starter-mcp-server-webmvc&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependencyManagement&amp;gt;
    &amp;lt;dependencies&amp;gt;
       &amp;lt;dependency&amp;gt;
          &amp;lt;groupId&amp;gt;org.springframework.ai&amp;lt;/groupId&amp;gt;
          &amp;lt;artifactId&amp;gt;spring-ai-bom&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;1.0.0-SNAPSHOT&amp;lt;/version&amp;gt;
          &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;
          &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt;
       &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
&amp;lt;/dependencyManagement&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Tool注解表示MCP服务方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Service
public class WeatherService {
    @Tool(description = &quot;根据城市名称获取天气&quot;)
    public String getWeather(@ToolParam(description = &quot;城市名称&quot;) String cityName) {
        if(cityName == null) {
            return &quot;城市名称不能为空&quot;;
        }
        if(&quot;北京&quot;.equals(cityName)) {
            return &quot;北京今天天气：晴，气温25°C，空气质量良&quot;;
        }
        if(&quot;上海&quot;.equals(cityName)) {
            return &quot;上海今天天气：阴，气温28°C，湿度65%&quot;;
        }
        return &quot;暂不支持该城市查询，当前可查询：北京、上海&quot;;
    }

    @Tool(description = &quot;查询城市今天适合的运动&quot;)
    public String action(@ToolParam(description = &quot;城市名称&quot;) String cityName) {
        if(&quot;北京&quot;.equals(cityName)) {
            return &quot;北京今天天气：空气质量良，适合出门运动&quot;;
        }
        if(&quot;上海&quot;.equals(cityName)) {
            return &quot;上海今天天气：阴，适合室内学习&quot;;
        }
        return &quot;暂不支持该城市查询，当前可查询：北京、上海&quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用Bean注解注册ToolCallbackProvider&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Configuration
public class MCPServiceConfig {
    @Bean
    public ToolCallbackProvider weatherTools(WeatherService weatherService) {
        return MethodToolCallbackProvider.builder().toolObjects(weatherService).build();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注册的服务&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/214.png&quot; alt=&quot;214&quot; /&gt;&lt;/p&gt;
&lt;p&gt;查询结果调用注册的MCP方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/213.png&quot; alt=&quot;213&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;记忆对话&lt;/h2&gt;
&lt;p&gt;上下文对话的作用就是让AI具有记忆力，在快速入门和流式对话中，我们是通过一种单一的输入输出方式进行调用的，这种调用方式无法让AI具有记忆力&lt;/p&gt;
&lt;p&gt;ChatGPT上下文对话的实现原理较为简单，本质上其实就是将不同角色的聊天信息依次存储在一个队列中发送给ChatGPT即可，然后ChatGPT会根据整个聊天信息对回复内容进行判断。在OpenAI提供的接口中，每条信息的角色总共分为三类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SystemMessage：系统限制信息，这种信息在对话中的权重很大，AI会优先依据SystemMessage里的内容进行回复；&lt;/li&gt;
&lt;li&gt;UserMessage：用户信息&lt;/li&gt;
&lt;li&gt;AssistantMessage：AI回复信息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果我们需要实现上下文对话，就只需要使用一个List存储这些Message对象，并将这些Message对象一并发送给AI，AI拿到这些Message后，会根据Message里的内容进行回复。&lt;/p&gt;
&lt;p&gt;:::warning&lt;/p&gt;
&lt;p&gt;不过，根据OpenAI的计费规则，&lt;strong&gt;你的消息队列越长，单次问询需要的费用就会越高&lt;/strong&gt;，因此我们需要对这个消息列表的长度进行限制。&lt;/p&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private final List&amp;lt;Message&amp;gt; messageHistory = new ArrayList&amp;lt;&amp;gt;(); // 历史消息列表
private static final int MAX_HISTORY = 10; // 保留最近10条消息

@GetMapping(&quot;/chat&quot;)
public String chat(@RequestParam String prompt) {
    // 1. 添加用户消息到历史
    messageHistory.add(new UserMessage(prompt));
    // 2. 修剪历史（固定窗口算法）
    if (messageHistory.size() &amp;gt; MAX_HISTORY) {
        messageHistory.remove(0); // 移除最旧的消息
    }
    // 3. 调用模型生成回复
    AssistantMessage assistantMessage = chatModel.call(new Prompt(messageHistory))
            .getResult()
            .getOutput();
    // 4. 添加AI回复到历史
    messageHistory.add(assistantMessage);
    return assistantMessage.getContent();
}
// 清空历史（可选）
@PostMapping(&quot;/clear&quot;)
public String clear() {
    messageHistory.clear();
    return &quot;对话历史已重置&quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;首次提问&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;你的名字是Marry，请你记住，以后回复我的时候带上你的名字
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;好的，我记住了！以后每次回复你时，我都会带上名字的。 ——Marry
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第二次提问&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;你的名字是什么
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;我的名字是 **Marry**！很高兴为你服务～ ——Marry
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第三次提问&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;我对你的第一条信息的要求是什么
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;你第一条信息的要求是： **“请你记住，以后回复我的时候带上你的名字（Marry）”。** 所以我会在每次回复的结尾标注 **——Marry**，像这样哦～ （注：发现之前的拼写差异了吗？你最初写的是“Marry”，但这次提问时写成了“Marry”，我会继续统一使用 **Marry** 的拼写，除非你另有指示 😊） ——Marry
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;请求清除历史&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;对话历史已重置
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;再次提问&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;你最初的第一条信息是：**“你好！”** 不过，如果你指的是对**我**（即你作为用户）的第一条信息的要求，通常并没有严格限制。你可以自由地输入任何问题、指令或话题，比如： - 提问（如“如何学习编程？”） - 请求帮助（如“请总结这篇文章”） - 直接对话（如“嗨，今天怎么样？”） 我的设计目标是灵活适应你的需求，所以无论是简单问候、具体问题，还是测试功能，都可以直接发送。唯一需要注意的是： 1. **避免违法/有害内容**（如暴力、隐私侵犯等）。 2. **清晰表达需求**（越具体，回答越精准）。 如果有特别格式或规则，你可以随时提出，我会配合！ 😊 需要我演示如何回答某类问题吗？
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实现了一定的上下文记忆要求&lt;/p&gt;
&lt;h2&gt;内容封装&lt;/h2&gt;
&lt;p&gt;将问答内容封装进入bean对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@GetMapping(&quot;/findBook&quot;)
public Book findBook(@RequestParam String bookName) throws Exception {
    String userText = &quot;&quot;&quot;
    请严格以如下JSON格式返回《%s》的信息：
    {
      &quot;name&quot;: &quot;书名&quot;,
      &quot;author&quot;: &quot;作者&quot;,
      &quot;price&quot;: 价格数字,
      &quot;description&quot;: &quot;简介&quot;
    }
    不要返回任何非JSON内容。
    &quot;&quot;&quot;.formatted(bookName);
    String jsonResponse = chatModel.call(new Prompt(new UserMessage(userText)))
            .getResult()
            .getOutput()
            .getContent();
    System.out.println(jsonResponse);
    // 使用Jackson解析JSON
    return new ObjectMapper().readValue(jsonResponse, Book.class);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;{
  &quot;name&quot;: &quot;1984&quot;,
  &quot;author&quot;: &quot;乔治·奥威尔&quot;,
  &quot;price&quot;: 35,
  &quot;description&quot;: &quot;《1984》是英国作家乔治·奥威尔创作的一部反乌托邦小说，描绘了一个极权主义社会中个人自由被彻底剥夺的恐怖景象。小说通过主人公温斯顿·史密斯的视角，展现了思想控制、历史篡改和无处不在的监控如何彻底改变人类的本质。&quot;
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>SpringAI笔记（聊天模型，函数调用，RAG）</title><link>https://thrinisty.github.io/posts/springai%E7%AC%94%E8%AE%B0%E8%81%8A%E5%A4%A9%E6%A8%A1%E5%9E%8B%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8rag/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/springai%E7%AC%94%E8%AE%B0%E8%81%8A%E5%A4%A9%E6%A8%A1%E5%9E%8B%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8rag/</guid><description>SpringAI聊天模型，函数调用，RAG</description><pubDate>Fri, 27 Jun 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;SpringAI笔记&lt;/h1&gt;
&lt;h2&gt;聊天模型&lt;/h2&gt;
&lt;p&gt;ChatClient接口：定义了一个与聊天服务交互的客户端，用于创建聊天客户端对象，设置请求规范，发起聊天请求，底层使用了ChatModel&lt;/p&gt;
&lt;p&gt;ChatModel接口：是核心，定义了与AI模型交互的基本方法，它继承自Model&amp;lt;Prompr,ChatResponse&amp;gt;，提供了两个重载的call方法&lt;/p&gt;
&lt;h3&gt;ChatClient&lt;/h3&gt;
&lt;h4&gt;初步使用&lt;/h4&gt;
&lt;p&gt;通过ChatClient调用大模型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@RestController
public class ChatController {
    private final ChatClient chatClient;

    public ChatController(ChatClient.Builder chatClientBuilder) {
        this.chatClient = chatClientBuilder.build();
    }

    @GetMapping(&quot;/chat&quot;)
    public String chat(@RequestParam(value = &quot;message&quot;, defaultValue = &quot;你是谁&quot;) String message) {
        String text = chatClient.prompt()//设置提示词
                .user(message)//输入用户输入内容
                .call()//调用模型
                .content();//返回字符串结果
        return text;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;设置提示词&lt;/h4&gt;
&lt;p&gt;角色预设，通过设置prompt提示词完成，可以设置一个Configuration配置文件在其中将一个ChatClient放入IoC容器，并通过builder.defaultSystem()设置提示词&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Configuration
public class AiConfig {
    @Bean
    public ChatClient chatClient(ChatClient.Builder builder) {
        return builder.defaultSystem(&quot;医生，看病&quot;).build();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;@RestController
public class ChatAIController {
    @Autowired
    private ChatClient chatClient;

    @GetMapping(&quot;/chatAI&quot;)
    public String chat(@RequestParam(value = &quot;message&quot;, defaultValue = &quot;你是谁&quot;) String message) {
        String text = chatClient.prompt()//设置提示词
                .user(message)//输入用户输入内容
                .call()//调用模型
                .content();//返回字符串结果
        return text;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;尝试重新调用，输出有所变化&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;我是DeepSeek Chat，一个由深度求索公司开发的AI助手！😊 虽然我不是真正的医生，但我可以为你提供一些健康相关的科普信息、常见症状的可能原因，或者帮助你理解医学术语。 如果你有具体的健康问题，建议尽快咨询专业医生或前往正规医疗机构就诊，以获得准确的诊断和治疗方案。你的健康很重要，千万别耽误哦！💖 有什么我可以帮你的吗？
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;输出优化&lt;/h4&gt;
&lt;p&gt;我们以上的回复是将所有的结果生成完毕后返回给客户端，我们在实际使用的时候往往采用流式响应stream，可以逐个字符输出&lt;/p&gt;
&lt;p&gt;:::note&lt;/p&gt;
&lt;p&gt;这里还需要将字符集设置为UTF-8的编码格式否则会出现乱码&lt;/p&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@GetMapping(value = &quot;/chatAIStream&quot;, produces = &quot;text/html;charset=UTF-8&quot;)
public Flux&amp;lt;String&amp;gt; chatStream(@RequestParam(value = &quot;message&quot;, defaultValue = &quot;你是谁&quot;) String message) {
    Flux&amp;lt;String&amp;gt; flux = chatClient.prompt()//设置提示词
            .user(message)//输入用户输入内容
            .stream()//调用模型
            .content();//返回字符串结果
    return flux;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;ChatModel&lt;/h3&gt;
&lt;h4&gt;初步使用&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;@RestController
public class ChatController {
    @Autowired
    private ChatModel chatModel;
    @GetMapping(&quot;/chatModel01&quot;)
    public String chatModel01(@RequestParam(value = &quot;message&quot;, defaultValue = &quot;你是谁&quot;) String message) {
        return chatModel.call(message);
    }

    @GetMapping(&quot;/chatModel02&quot;)
    public String chatModel02(@RequestParam(value = &quot;message&quot;, defaultValue = &quot;你是谁&quot;) String message) {
        ChatResponse chatResponse = chatModel.call(
                new Prompt(
                        message,
                        ChatOptions.builder()
                                .model(&quot;deepseek-chat&quot;)
                                .temperature(0.9)
                                .build()
                )
        );
        return chatResponse.getResult().getOutput().getContent();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;设置提示词&lt;/h4&gt;
&lt;p&gt;综合使用一下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@GetMapping(&quot;/prompt&quot;)
public String prompt(@RequestParam(&quot;name&quot;)
                         String name,
                     @RequestParam(&quot;voice&quot;)
                         String voice) {
    //设置用于输入信息
    String userText = &quot;推荐南京的至少三种美食&quot;;
    UserMessage userMessage = new UserMessage(userText);
    //设置系统提示信息
    String systemText = &quot;你是美食资讯助手，帮助查询美食，你的名字是{name}，&quot; +
            &quot;你应该用你的名字和{voice}的饮食习惯回复用户&quot;;
    SystemPromptTemplate systemPromptTemplate = new SystemPromptTemplate(systemText);
    //替换占位符
    Message systemMessage = systemPromptTemplate.createMessage(Map.of(&quot;name&quot;, name, &quot;voice&quot;, voice));
    //使用Prompt Template设置信息
    Prompt prompt = new Prompt(List.of(userMessage, systemMessage));
    //调用ChatModel方法
    ChatResponse chatResponse = chatModel.call(prompt);
    List&amp;lt;Generation&amp;gt; results = chatResponse.getResults();
    return results.stream().map(x-&amp;gt;x.getOutput().getContent()).collect(Collectors.joining(&quot;&quot;));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过封装用户传入的提示词我们可以实现个性化的回复&lt;/p&gt;
&lt;p&gt;http://localhost:8080/prompt?name=%E5%BC%A0%E4%B8%89&amp;amp;voice=%E5%A5%A2%E5%8D%8E&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;亲爱的美食爱好者，我是张三，很高兴为您推荐南京的奢华美食。作为一个对美食有着极高要求的鉴赏家，我为您精心挑选了以下三种最具代表性的南京美味： 1. 金陵盐水鸭 这道南京最负盛名的美食，选用优质瘦型鸭，经过24小时秘制卤水浸泡，肉质细嫩多汁，咸香适中。我特别推荐德基广场的&quot;金陵饭店&quot;，他们选用的是有机养殖的鸭子，配以30年陈酿的花雕酒腌制。 2. 鸭血粉丝汤 这道平民美食也能吃出奢华感。我常去老门东的&quot;回味鸭血粉丝&quot;，他们使用现杀现取的鸭血，配以熬制8小时的老鸭汤底，粉丝选用的是日本进口的葛粉，口感Q弹爽滑。 3. 蟹黄汤包 南京的汤包以蟹黄馅最为名贵。我最爱&quot;南京大牌档&quot;的蟹黄汤包，每只包子都包含一整只阳澄湖大闸蟹的蟹黄，皮薄如纸，汤汁鲜美。建议搭配30年的陈醋食用。 作为美食达人，我建议您可以选择在德基广场的&quot;江南灶&quot;一次性品尝这三道美食，他们家的摆盘和服务都达到了米其林水准。记得提前一周预约哦！ 您对这些美食感兴趣吗？我可以为您推荐更多南京的隐藏美食地图。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;函数调用&lt;/h2&gt;
&lt;p&gt;SpringAI函数调用（Function Calling）功能允许大模型在生成回答时触发预定义的外部函数，从而实现动态数据获取或业务逻辑操作（如查询数据库，调用API等）&lt;/p&gt;
&lt;p&gt;SpringAI帮我们规范了函数定义注册等过程，并在发起模型请求之前自动将函数注入到Prompt中，当模型决策再合适的时候去调用某个函数时，SpringAI完成函数调用动作，最终将函数执行结果与原始问题再一并发送给模型，模型根据新的输入决策下一步动作&lt;/p&gt;
&lt;p&gt;其中涉及到与大模型多次交互过程，一次函数调用就是一次完成的交互过程&lt;/p&gt;
&lt;h3&gt;使用步骤&lt;/h3&gt;
&lt;p&gt;1.定义函数：声明可供模型调用的函数（名称、描述、参数结构）&lt;/p&gt;
&lt;p&gt;2.模型交互：将函数信息和用户输入一起发送给模型，模型决定是否需要调用函数&lt;/p&gt;
&lt;p&gt;3.执行函数：解析模型的函数调用请求，执行对应的业务逻辑&lt;/p&gt;
&lt;p&gt;4.返回结果：将函数执行结果返回给模型，生成最终回答&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Configuration
public class CalculatorService {
    public record AddOperation(int a, int b) {

    }

    public record MulOperation(int a, int b) {

    }

    public record SuperOperation(int a, int b) {}

    @Bean
    @Description(&quot;加法运算&quot;)
    public Function&amp;lt;AddOperation,Integer&amp;gt; addOperation() {
        return request -&amp;gt; {
            return request.a + request.b;
        };
    }

    @Bean
    @Description(&quot;乘法运算&quot;)
    public Function&amp;lt;MulOperation,Integer&amp;gt; mulOperation() {
        return request -&amp;gt; {
            return request.a * request.b;
        };
    }

    @Bean
    @Description(&quot;特殊的运算&quot;)
    public Function&amp;lt;SuperOperation,Integer&amp;gt; superOperation() {
        return request -&amp;gt; {
            return request.a - request.b + 10;
        };
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编写Controller调用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@RestController
public class FunController {
    @Autowired
    private ChatClient chatClient;

    @Autowired
    private ChatModel chatModel;

    @GetMapping(value = &quot;/function&quot;)
    public String function01(@RequestParam(&quot;userMessage&quot;) String userMessage) {
        return ChatClient.builder(chatModel)
                .build().prompt()
                .system(&quot;你是计算器代理，支持了加法乘法操作，在提供加法运算和乘法运算之前获取两个数字，运算类型，请调用自定义函数执行加法运算乘法运算还有一个特殊运算，说中文&quot;)
                .user(userMessage)
                .functions(&quot;addOperation&quot;,&quot;mulOperation&quot;,&quot;superOperation&quot;)
                .call()
                .content();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;?userMessage=请为我计算数字8和数字70的特殊运算结果&lt;/p&gt;
&lt;p&gt;请求返回结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;数字8和数字70的特殊运算结果是：-52
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;RAG&lt;/h2&gt;
&lt;p&gt;检索增强生成，是一种结合了检索系统和生成模型的新型技术框架主要的目的如下&lt;/p&gt;
&lt;p&gt;1.利用外部知识库&lt;/p&gt;
&lt;p&gt;2.帮助大模型生成更加、准确、有依据、最新的回答&lt;/p&gt;
&lt;h3&gt;工作流程&lt;/h3&gt;
&lt;p&gt;1.用户输入问题&lt;/p&gt;
&lt;p&gt;2.问题向量化&lt;/p&gt;
&lt;p&gt;3.向量数据库检索&lt;/p&gt;
&lt;p&gt;4.构建上下文（含系统提示词）&lt;/p&gt;
&lt;p&gt;5.携带检索内容，调用大模型进行回答&lt;/p&gt;
&lt;p&gt;6.返回最终答案给用户&lt;/p&gt;
&lt;p&gt;这里DeepSeek似乎不支持Embedding，项目暂时没有跑起来&lt;/p&gt;
&lt;p&gt;先说一下大致思路&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.learn.ragtest.config;

import org.springframework.ai.chat.client.ChatClient;
import org.springframework.ai.document.Document;
import org.springframework.ai.embedding.EmbeddingModel;
import org.springframework.ai.vectorstore.SimpleVectorStore;
import org.springframework.ai.vectorstore.VectorStore;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.List;
import java.util.Vector;

@Configuration
public class RagConfig {
    @Bean
    ChatClient chatClient(ChatClient.Builder builder) {
        return builder.defaultSystem(&quot;你是Java开发专家，解决用户需求&quot;).build();
    }

    @Bean
    VectorStore vectorStore(EmbeddingModel embeddingModel) {
        SimpleVectorStore simpleVectorStore = SimpleVectorStore
                .builder(embeddingModel)
                .build();
        //生成说明文档
        List&amp;lt;Document&amp;gt; documents = List.of(
                new Document(&quot;产品说明：名称：Java开发语言&quot; +
                        &quot;相关描述：一种面向对象的开发语言&quot; +
                        &quot;特性：1.继承\n 2.封装\n 3.多态\n&quot;)
        );
        //向量化存储
        simpleVectorStore.add(documents);
        return simpleVectorStore;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;携带上下文检索内容提问大模型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Autowired
private ChatClient chatClient;

@Autowired
private VectorStore vectorStore;

@GetMapping(&quot;/rag&quot;)
public String rag(@RequestParam(&quot;message&quot;) String message) {
    String content = chatClient.prompt()
            .user(message)
            .advisors(new QuestionAnswerAdvisor(vectorStore))
            .call()
            .content();
    return content;
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>SpringAI笔记（基本概念，入门使用）</title><link>https://thrinisty.github.io/posts/springai%E7%AC%94%E8%AE%B0%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/springai%E7%AC%94%E8%AE%B0%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/</guid><description>Spring AI的基本概念，入门使用</description><pubDate>Thu, 26 Jun 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Spring AI笔记&lt;/h1&gt;
&lt;p&gt;Spring AI是一个AI工程领域的应用程序框架，提供了一个友好的API和开发AI应用的抽象，旨在简化AI大模型应用的开发工作&lt;/p&gt;
&lt;p&gt;对主流的AI大模型供应商提供了支持如OpenAI、DeepSeek、Ollama、Amazon&lt;/p&gt;
&lt;p&gt;还可以把AI大模型的输出映射到JavaBean中&lt;/p&gt;
&lt;h2&gt;基本概念&lt;/h2&gt;
&lt;h3&gt;Prompt&lt;/h3&gt;
&lt;p&gt;提示（Prompt）是引导人工智能模型产生特定输出的语言输入的基础&lt;/p&gt;
&lt;p&gt;对于熟悉 ChatGPT 的人来说，提示可能只是在对话框中输入并发送到 API 的文本。然而，它包含的内容远不止这些。在许多人工智能模型中，提示文本不仅仅是一个简单的字符串。&lt;/p&gt;
&lt;p&gt;ChatGPT 的 API 在一个提示中包含多个文本输入，每个文本输入都被分配了一个角色。例如，&lt;code&gt;system&lt;/code&gt; 角色会告诉模型如何操作，并为交互设置上下文。还有 &lt;code&gt;user&lt;/code&gt; 角色，通常是来自用户的输入。&lt;/p&gt;
&lt;h3&gt;提示模板&lt;/h3&gt;
&lt;p&gt;设计优质提示词的关键在于构建请求的上下文框架，并将部分通用描述替换为用户输入的具体参数值。&lt;/p&gt;
&lt;p&gt;该流程采用基于文本的传统模板引擎来实现提示词的创建与管理。为此，Spring AI 使用了开源库 &lt;a href=&quot;https://www.stringtemplate.org/&quot;&gt;StringTemplate&lt;/a&gt; 作为技术实现方案。&lt;/p&gt;
&lt;p&gt;例如，一个简单的提示词模板如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Tell me a {adjective} joke about {content}.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 Spring AI 中，提示词模板可类比 Spring MVC 架构中的 “View” 层。系统会提供一个模型对象（通常是 &lt;code&gt;java.util.Map&lt;/code&gt;）来填充模板中的占位符，最终 “渲染” 生成的字符串将作为传递给 AI 模型的提示内容。&lt;/p&gt;
&lt;h3&gt;结构化输出&lt;/h3&gt;
&lt;p&gt;AI 模型的输出传统上以 &lt;code&gt;java.lang.String&lt;/code&gt; 形式返回 — 即便要求生成 JSON 格式的答复。它可能是格式正确的 JSON，但本质仍是字符串而非 JSON 数据结构。要注意，在提示词中简单要求 “输出 JSON” 并不能百分百保证结果准确性。&lt;/p&gt;
&lt;p&gt;这一复杂性催生了一个专门领域：既要设计能生成预期输出的提示词，又需将返回的原始字符串转换为可供应用程序集成的数据结构。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://springdoc.cn/spring-ai/api/structured-output-converter.html#_structuredoutputconverter&quot;&gt;结构化输出&lt;/a&gt; 转换采用精心制作的提示，通常需要与模型进行多次交互才能实现所需的格式。&lt;/p&gt;
&lt;h3&gt;整合数据&lt;/h3&gt;
&lt;p&gt;现有三种技术可定制 AI 模型以整合你的数据：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;微调（Fine-Tuning）&lt;/strong&gt;：这项传统机器学习技术通过调整模型内部权重实现定制，但对 GPT 等大模型而言存在双重挑战 — 不仅需要专业机器学习知识，还因模型规模导致计算资源消耗极大。值得注意的是，部分模型可能根本不开放此功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;提示词填充（Prompt Stuffing）&lt;/strong&gt;：一种更实用的替代方案是将数据直接嵌入到提供给模型的提示词中。鉴于模型的 Token 限制，需要特定技术确保相关数据能适配上下文窗口。这种方法俗称 “提示词填充”。Spring AI 库能帮助你基于该技术（现多称为检索增强生成/RAG）实现解决方案。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://springdoc.cn/spring-ai/concepts.html#concept-fc&quot;&gt;工具调用（Tool Calling）&lt;/a&gt;&lt;/strong&gt;：该技术支持注册工具（用户自定义服务），将大语言模型与外部系统 API 连接。Spring AI 大幅简化了实现 &lt;a href=&quot;https://springdoc.cn/spring-ai/api/tools.html&quot;&gt;工具调用&lt;/a&gt; 所需的代码量。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;工具调用&lt;/h3&gt;
&lt;p&gt;大语言模型（LLM）在训练完成后即固化，导致知识陈旧，且无法直接访问或修改外部数据。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://springdoc.cn/spring-ai/api/tools.html&quot;&gt;工具调用机制（Tool Calling）&lt;/a&gt; 有效解决了这些局限。该功能允许你将自定义服务注册为工具，将大语言模型与外部系统 API 连接，使 LLM 能获取实时数据并委托这些系统执行数据处理操作。&lt;/p&gt;
&lt;p&gt;Spring AI 极大简化了支持工具调用所需的编码工作，自动处理工具调用的对话交互。你只需将工具定义为带有 &lt;code&gt;@Tool&lt;/code&gt; 注解的方法，并通过提示选项提供给模型即可调用。此外，单个提示中可定义和引用多个工具。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/211.jpg&quot; alt=&quot;211&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;入门使用&lt;/h2&gt;
&lt;p&gt;SpringAI整合DeepSeek作为示例，文档详见如下链接&lt;/p&gt;
&lt;p&gt;https://api-docs.deepseek.com/zh-cn/&lt;/p&gt;
&lt;p&gt;导入相关的pom依赖&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;3.5.3&amp;lt;/version&amp;gt;
        &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;
    &amp;lt;/parent&amp;gt;
    &amp;lt;groupId&amp;gt;com.learn&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;DeepSeek&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;name&amp;gt;DeepSeek&amp;lt;/name&amp;gt;
    &amp;lt;description&amp;gt;DeepSeek&amp;lt;/description&amp;gt;
    &amp;lt;url/&amp;gt;
    &amp;lt;licenses&amp;gt;
        &amp;lt;license/&amp;gt;
    &amp;lt;/licenses&amp;gt;
    &amp;lt;developers&amp;gt;
        &amp;lt;developer/&amp;gt;
    &amp;lt;/developers&amp;gt;
    &amp;lt;scm&amp;gt;
        &amp;lt;connection/&amp;gt;
        &amp;lt;developerConnection/&amp;gt;
        &amp;lt;tag/&amp;gt;
        &amp;lt;url/&amp;gt;
    &amp;lt;/scm&amp;gt;
    &amp;lt;properties&amp;gt;
        &amp;lt;java.version&amp;gt;17&amp;lt;/java.version&amp;gt;
    &amp;lt;/properties&amp;gt;

    &amp;lt;repositories&amp;gt;
        &amp;lt;repository&amp;gt;
            &amp;lt;id&amp;gt;spring-milestones&amp;lt;/id&amp;gt;
            &amp;lt;name&amp;gt;Spring Milestones&amp;lt;/name&amp;gt;
            &amp;lt;url&amp;gt;https://repo.spring.io/milestone&amp;lt;/url&amp;gt;
            &amp;lt;snapshots&amp;gt;
                &amp;lt;enabled&amp;gt;true&amp;lt;/enabled&amp;gt;
            &amp;lt;/snapshots&amp;gt;
        &amp;lt;/repository&amp;gt;
        &amp;lt;repository&amp;gt;
            &amp;lt;id&amp;gt;spring-snapshots&amp;lt;/id&amp;gt;
            &amp;lt;name&amp;gt;Spring Snapshots&amp;lt;/name&amp;gt;
            &amp;lt;url&amp;gt;https://repo.spring.io/snapshot&amp;lt;/url&amp;gt;
            &amp;lt;releases&amp;gt;
                &amp;lt;enabled&amp;gt;true&amp;lt;/enabled&amp;gt;
            &amp;lt;/releases&amp;gt;
        &amp;lt;/repository&amp;gt;
    &amp;lt;/repositories&amp;gt;


    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.ai&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-ai-openai-spring-boot-starter&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

    &amp;lt;dependencyManagement&amp;gt;
        &amp;lt;dependencies&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.ai&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-ai-bom&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;1.0.0-M5&amp;lt;/version&amp;gt;
                &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;
                &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt;
            &amp;lt;/dependency&amp;gt;
        &amp;lt;/dependencies&amp;gt;
    &amp;lt;/dependencyManagement&amp;gt;

    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;

&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;properties相关配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;spring.application.name=DeepSeek
server.port=8080
spring.ai.openai.api-key=sk-xxxxx
spring.ai.openai.base-url=https://api.deepseek.com
spring.ai.openai.chat.options.model=deepseek-chat
spring.ai.openai.chat.options.temperature=0.5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;建立一个Controller调用DeepSeek模型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@RestController
public class DeepSeekConroller {
    @Autowired
    private ChatModel chatModel;

    @GetMapping(&quot;/hello&quot;)
    public String generate(@RequestParam(value = &quot;message&quot;, defaultValue = &quot;hello&quot;)String message) {
        String result = chatModel.call(message);
        System.out.println(result);
        return result;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过ChatModel对象的call方法传入输入大模型的信息，将生成的字符串返回给用户&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Hello! 😊 How can I assist you today?
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;../images/212.png&quot; alt=&quot;212&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>SpringBoot笔记（原理分析，监控，项目部署）</title><link>https://thrinisty.github.io/posts/springboot%E7%AC%94%E8%AE%B0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/springboot%E7%AC%94%E8%AE%B0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/</guid><pubDate>Thu, 26 Jun 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;SpringBoot笔记&lt;/h1&gt;
&lt;p&gt;Spring高级部分包括以下三个部分&lt;/p&gt;
&lt;p&gt;SpringBoot原理分析  SpringBoot监控  SpringBoot项目部署&lt;/p&gt;
&lt;h2&gt;对象创建原理&lt;/h2&gt;
&lt;p&gt;导入pom创建IoC对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-data-redis&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在SpringBoot的引导类中，调用的run方法其实会返回一个context的实例对象，通过这个实例对象，我们可以用key从IoC容器中取出对应的Bean对象，我们导入了redis的pom坐标，context中就会存在这样的一个redisTemplate Bean对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@SpringBootApplication
public class Springboot008Application {
    public static void main(String[] args) {
       ConfigurableApplicationContext context = SpringApplication.run(Springboot008Application.class, args);
       Object redisTemplate = context.getBean(&quot;redisTemplate&quot;);
       System.out.println(redisTemplate);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;org.springframework.data.redis.core.RedisTemplate@27ffd9f8
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Condition&lt;/h3&gt;
&lt;p&gt;Condition是在Spring4.0增加条件判断功能，通过这个Condition功能可以实现选择性的创建Bean的操作&lt;/p&gt;
&lt;p&gt;使用步骤&lt;/p&gt;
&lt;p&gt;1.自定义类实现Condition接口&lt;/p&gt;
&lt;p&gt;2.重写matches方法，在其中进行逻辑判断&lt;/p&gt;
&lt;p&gt;3.在@Bean注解纳入管理的类上添加 @Conditional(自定义实现类.class)&lt;/p&gt;
&lt;p&gt;在config软件包下的UserConfig类中用@Bean将User纳入Bean容器的管理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Configuration
public class UserConfig {
    @Bean
    public User user() {
        return new User();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过context对象getBean一样可以获取到user对象&lt;/p&gt;
&lt;p&gt;接下来我们通过@Conditional(ClassCondition.class)指定一个实现Condition的ClassCondition类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Configuration
public class UserConfig {
    @Bean(name = &quot;user&quot;)
    @Conditional(ClassCondition.class)
    public User user() {
        return new User();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这个类中我们在matches方法返回false，这代表不进行user对象加入IoC容器进行管理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class ClassCondition implements Condition {
    @Override
    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
        return false;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们再次尝试获取user对象的时候就会发生报错，没有获取到user的bean对象，我们可以通过这个方法实现是否创建对应bean对象的逻辑&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;我们现在有一个要求，导入Jedis坐标后创建User的Bean对象，否则不纳入IoC管理，在没有获取到Jedis类的时候返回false，从而实现对应Bean的创建与否&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class ClassCondition implements Condition {
    @Override
    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
        boolean flag = true;
        try {
            Class.forName(&quot;redis.clients.jedis.Jedis&quot;);
        } catch (ClassNotFoundException e) {
            flag = false;
        }
        return flag;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将类对象用@Conditional注解配置到Bean的创建上&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Configuration
public class UserConfig {
    @Bean(name = &quot;user&quot;)
    @Conditional(ClassCondition.class)
    public User user() {
        return new User();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个时候只有导入了jedis坐标的时候才会创建user的Bean对象放入到IoC容器中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;redis.clients&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;jedis&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;matches(ConditionContext context, AnnotatedTypeMetadata metadata)方法&lt;/p&gt;
&lt;p&gt;通过context.getEnviroment可以获取environment对象从而获取配置值&lt;/p&gt;
&lt;p&gt;metadata是注解元对象，可以获取注解定义的属性值&lt;/p&gt;
&lt;p&gt;SpringBoot是通过类似这样的方式根据有无对应字节码，选择性创建Bean对象&lt;/p&gt;
&lt;p&gt;而SpringBoot提供的常用条件注解如下：&lt;/p&gt;
&lt;p&gt;ConditionalOnProperty：判断配置文件中有对应属性和值&lt;/p&gt;
&lt;p&gt;ConditionalOnClass：判断环境中有对应字节码文件&lt;/p&gt;
&lt;p&gt;ConditionalOnMissingBean：判断环境中没有对应Bean&lt;/p&gt;
&lt;h2&gt;切换内置Web服务器&lt;/h2&gt;
&lt;p&gt;SpringBoot的Web环境中默认使用Tomcat作为内置服务器，总共SpringBoot有4种内置服务器供选择，可以方便的进行环境下切换&lt;/p&gt;
&lt;p&gt;通过两步完成&lt;/p&gt;
&lt;p&gt;1.排除Tomcat依赖&lt;/p&gt;
&lt;p&gt;2.引入jetty依赖&lt;/p&gt;
&lt;h2&gt;Enable注解&lt;/h2&gt;
&lt;p&gt;Spring不可以直接获取其他工程中的Bean对象&lt;/p&gt;
&lt;p&gt;@ComponentScan的扫描范围是当前引导类所在的包以及其子包，所以无法加载到其他工程下的Bean对象，我们对于这种情况有两种解决方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.learn.springboot008.config;

@Configuration
public class UserConfig {
    @Bean(name = &quot;user&quot;)
    @Conditional(ClassCondition.class)
    public User user() {
        return new User();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第一种：用@ComponentScan注解扫描其他工程的对应配置软件包&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.learn.springboot009;
@SpringBootApplication
@ComponentScan(&quot;com.learn.springboot008.config&quot;)//扫描其他包
public class Springboot009Application {
    public static void main(String[] args) {
        ConfigurableApplicationContext context = SpringApplication.run(Springboot009Application.class, args);
        User user = context.getBean(&quot;user&quot;, User.class);
        System.out.println(user);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将其的Bean加入到IoC容器中即可，但是这种方案需要记住第三方包的软件包路径，不是非常方便&lt;/p&gt;
&lt;p&gt;第二种：使用@Import注解，被Import注解导入的类，都会被IoC容器创建并纳入管理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@SpringBootApplication
//@ComponentScan(&quot;com.learn.springboot008.config&quot;)
@Import(UserConfig.class)
public class Springboot009Application {
    public static void main(String[] args) {
        ConfigurableApplicationContext context = SpringApplication.run(Springboot009Application.class, args);
        User user = context.getBean(&quot;user&quot;, User.class);
        System.out.println(user);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第三种：在第三方对Import注解进行封装为EnableUser，在开发工程直接使用EnableUser注解&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.learn.springboot008.config;

import org.springframework.context.annotation.Import;

import java.lang.annotation.*;

@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Import(UserConfig.class)
public @interface EnableUser {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;@SpringBootApplication
//@ComponentScan(&quot;com.learn.springboot008.config&quot;)
//@Import(UserConfig.class)
@EnableUser
public class Springboot009Application {
    public static void main(String[] args) {
        ConfigurableApplicationContext context = SpringApplication.run(Springboot009Application.class, args);
        User user = context.getBean(&quot;user&quot;, User.class);
        System.out.println(user);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Import注解&lt;/h2&gt;
&lt;p&gt;@Enable底层依赖于@Import注解导入一些类，使用@Import导入的类会被Spring加载到IoC容器中，而@Import提供四种用法&lt;/p&gt;
&lt;p&gt;1.导入Bean&lt;/p&gt;
&lt;p&gt;:::warning&lt;/p&gt;
&lt;p&gt;Spring 默认会使用类的简单名称（首字母小写）作为 Bean 的名称，但在直接 &lt;code&gt;@Import&lt;/code&gt; 类的情况下，Bean 的名称实际上是全限定类名（fully qualified class name），而不是简单的 &quot;user&quot;&lt;/p&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;p&gt;或者也可以直接通过类获取User user = context.getBean(User.class);&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@SpringBootApplication
//@ComponentScan(&quot;com.learn.springboot008.config&quot;)
//@Import(UserConfig.class)
//@EnableUser
@Import(User.class)
public class Springboot009Application {
    public static void main(String[] args) {
        ConfigurableApplicationContext context = SpringApplication.run(Springboot009Application.class, args);
        User user = context.getBean(&quot;com.learn.springboot008.bean.User&quot; ,User.class);
        //User user = context.getBean(User.class);
        System.out.println(user);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.导入配置类&lt;/p&gt;
&lt;p&gt;UserConfig&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Configuration//这个注解也可以不加
public class UserConfig {
    @Bean(name = &quot;user&quot;)
    public User user() {
        return new User();
    }

    @Bean(name = &quot;student&quot;)
    public Student student() {
        return new Student();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在主工程种获取对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@SpringBootApplication
@Import(UserConfig.class)
public class Springboot009Application {
    public static void main(String[] args) {
        ConfigurableApplicationContext context = SpringApplication.run(Springboot009Application.class, args);
        User user = context.getBean(User.class);
        System.out.println(user);
        Student student = context.getBean(&quot;student&quot;, Student.class);
        System.out.println(student);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.导入ImportSelector实现类，一般用一加载配置文件中的类&lt;/p&gt;
&lt;p&gt;MyImportSelector，实现一个继承于ImportSelector的类，在selectImports方法中返回类的全限定类名的字符串&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class MyImportSelector implements ImportSelector {
    @Override
    public String[] selectImports(AnnotationMetadata importingClassMetadata) {
        return new String[]{&quot;com.learn.springboot008.bean.User&quot;, &quot;com.learn.springboot008.bean.Student&quot;};
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在主工程中的引导类用如下注解导入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Import(MyImportSelector.class)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.导入ImportBeanDefinitionRegistrar实现类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar {
    @Override
    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
        BeanDefinition beanDefinition = BeanDefinitionBuilder.rootBeanDefinition(User.class).getBeanDefinition();
        registry.registerBeanDefinition(&quot;user&quot;, beanDefinition);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;@Import(MyImportSelector.class)
public class Springboot009Application {
    public static void main(String[] args) {
        ConfigurableApplicationContext context = SpringApplication.run(Springboot009Application.class, args);
        User user = context.getBean(User.class);
        System.out.println(user);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;SpringBoot监听&lt;/h2&gt;
&lt;p&gt;SpringBoot的监听机制，其实就是对于java提供的监听机制的封装&lt;/p&gt;
&lt;p&gt;Java中的事件监听机制定义了以下几个角色：&lt;/p&gt;
&lt;p&gt;Event事件：继承于EvenObject类的对象&lt;/p&gt;
&lt;p&gt;Source事件源：任意对象Object&lt;/p&gt;
&lt;p&gt;Listener监听器：实现EventListener接口的对象&lt;/p&gt;
&lt;p&gt;SpringBoot在项目启动的时候，会对几个监听器进行回调，我们可以实现这些监听器接口，在项目启动时完成一些操作&lt;/p&gt;
&lt;p&gt;ApplicationContextInitializer、SpringApplicationRunListener、CommandLineRunner、ApplicationRunner&lt;/p&gt;
&lt;p&gt;后两种只需要实现接口注册到Spring容器中即可被使用&lt;/p&gt;
&lt;p&gt;CommandLineRunner、ApplicationRunner当项目启动后被执行，例如使用Redis的时候，将缓存进行预热&lt;/p&gt;
&lt;p&gt;其中的args是我们传递的参数，两个用一个即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Component
public class MyCommandLineRunner implements CommandLineRunner {
    @Override
    public void run(String... args) throws Exception {
        System.out.println(&quot;MyCommandLineRunner&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;@Component
public class MyApplicationRunner implements ApplicationRunner {
    @Override
    public void run(ApplicationArguments args) throws Exception {
        System.out.println(&quot;MyApplicationRunner&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;MyCommandLineRunner
MyApplicationRunner
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而前两种需要进行配置&lt;/p&gt;
&lt;p&gt;在META-INF/spring.factories配置&lt;/p&gt;
&lt;p&gt;ApplicationContextInitializer设置键为全限定类名，值为我们的实现类名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;org.springframework.context.ApplicationContextInitializer=com.learn.springboot010.listener.MyApplicationContextInitializer
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;MyApplicationContextInitializer
2025-06-26T11:38:42.231+08:00  INFO 24284 --- [springboot-010] [           main] c.l.s.Springboot010Application           : Starting Springboot010Application using Java 17.0.15 with PID 24284 ...
MyApplicationRunner
MyCommandLineRunner
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用于没有准备IoC容器的时候进行一些资源的检查&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;org.springframework.context.ApplicationContextInitializer=com.learn.springboot010.listener.MyApplicationContextInitializer
org.springframework.boot.SpringApplicationRunListener=com.learn.springboot010.listener.MySpringApplicationRunListener
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;starting 项目启动中...
environmentPrepared 环境对象开始准备...

  .   ____          _            __ _ _
 /\\ / ___&apos;_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | &apos;_ | &apos;_| | &apos;_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  &apos;  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/

 :: Spring Boot ::                (v3.5.3)

MyApplicationContextInitializer
contextPrepared 上下文对象开始准备...
2025-06-26T11:42:28.123+08:00  INFO 21740 --- [springboot-010] [           main] c.l.s.Springboot010Application           : Starting Springboot010Application using Java 17.0.15 with PID 21740 (C:\Users\71460\Desktop\Java\Spring\SpringBootLearn\springboot-010\target\classes started by 71460 in C:\Users\71460\Desktop\Java\Spring\SpringBootLearn)
2025-06-26T11:42:28.127+08:00  INFO 21740 --- [springboot-010] [           main] c.l.s.Springboot010Application           : No active profile set, falling back to 1 default profile: &quot;default&quot;
contextLoaded 上下文对象准备完毕
2025-06-26T11:42:28.877+08:00  INFO 21740 --- [springboot-010] [           main] c.l.s.Springboot010Application           : Started Springboot010Application in 1.434 seconds (process running for 2.271)
started 项目启动完毕
MyApplicationRunner
MyCommandLineRunner
ready 准备完成

&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;SpringBoot监控&lt;/h2&gt;
&lt;p&gt;SpringBoot自带监控功能Actuator，导入pom坐标即可使用&lt;/p&gt;
&lt;p&gt;可以检查SpringBoot运行状态，或者一些第三方的数据库的运行状态&lt;/p&gt;
&lt;p&gt;一般有info 和 health属性，还可以将监控的所有endpoint暴露出来&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;management.endpoint.health.show-details=always
management.endpoints.web.exposure.include=*
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有Spring Boot Admin开源项目用于管理监控SpringBoot应用程序&lt;/p&gt;
&lt;p&gt;其中涉及到了admin-server和admin-client&lt;/p&gt;
&lt;p&gt;admin-server&lt;/p&gt;
&lt;p&gt;1.创建admin-server模块&lt;/p&gt;
&lt;p&gt;2.导入admin-starter-server&lt;/p&gt;
&lt;p&gt;3在引导类上启动监控共功能@EnableAdminServer&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@EnableAdminServer
@SpringBootApplication
public class AdminServerApplication {

    public static void main(String[] args) {
       SpringApplication.run(AdminServerApplication.class, args);
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在配置中配置下端口9000&lt;/p&gt;
&lt;p&gt;admin-client&lt;/p&gt;
&lt;p&gt;1.创建admin-client模块&lt;/p&gt;
&lt;p&gt;2.导入admin-starter-client&lt;/p&gt;
&lt;p&gt;3.配置相关信息：server地址等&lt;/p&gt;
&lt;p&gt;4.启动server和client服务，访问server&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;spring.application.name=admin-client

spring.boot.admin.client.url=http://localhost:9000
management.endpoints.web.exposure.include=*
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;之后通过http://localhost:9000/ 访问server即可在网页中显示可视化信息&lt;/p&gt;
&lt;h2&gt;SpringBoot部署&lt;/h2&gt;
&lt;p&gt;SpringBoot项目开发完毕后支持两种方式部署到服务器中，jar包，或者war包&lt;/p&gt;
&lt;p&gt;之前我们尝试过打包为jar包，通过java指令启动，我们现在尝试打成war包&lt;/p&gt;
&lt;p&gt;在pom文件中引入war包的依赖&lt;/p&gt;
&lt;p&gt;在引导类中继承SpringBootServletInitializer，重写方法将引导类的类放入builder.sources()返回&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@SpringBootApplication
public class Springboot004Application extends SpringBootServletInitializer {

    public static void main(String[] args) {
        SpringApplication.run(Springboot004Application.class, args);
    }

    @Override
    protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) {
        return builder.sources(Springboot004Application.class);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将war包放入web-app启动Tomcat即可访问&lt;/p&gt;
</content:encoded></item><item><title>SpringBoot笔记（入门使用，配置，框架整合）</title><link>https://thrinisty.github.io/posts/springboot%E7%AC%94%E8%AE%B0%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/springboot%E7%AC%94%E8%AE%B0%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88/</guid><description>SpringBoot入门使用，SpringBoot配置，Profile配置选择，JUnit、Redis、MyBatis整合</description><pubDate>Wed, 25 Jun 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;SpringBoot笔记&lt;/h1&gt;
&lt;p&gt;SpringBoot是快速构建Spring项目的框架，不是对Spring功能的增强&lt;/p&gt;
&lt;p&gt;Spring存在缺点：需要写很多的配置类，依赖繁琐（版本兼容，依赖管理）&lt;/p&gt;
&lt;p&gt;SpringBoot自动配置，在项目启动的时候将项目的配置自动完成&lt;/p&gt;
&lt;p&gt;SpringBoot起步依赖：简单而言起步依赖就是将具体的某种功能的坐标打包到一起，并提供一些默认功能&lt;/p&gt;
&lt;p&gt;辅助功能：提供了一些大型项目中常见的非功能性特性，如嵌入式服务器，安全，指标健康检测，外部配置等&lt;/p&gt;
&lt;h2&gt;快速入门&lt;/h2&gt;
&lt;p&gt;搭建SpringBoot工程，定义HelloController.hello方法，返回Hello SpringBoot!&lt;/p&gt;
&lt;p&gt;实现步骤：&lt;/p&gt;
&lt;p&gt;1.创建Maven项目&lt;/p&gt;
&lt;p&gt;2.导入SpringBoot起步依赖&lt;/p&gt;
&lt;p&gt;3.定义Controller&lt;/p&gt;
&lt;p&gt;4.编写引导类&lt;/p&gt;
&lt;p&gt;5.启动测试&lt;/p&gt;
&lt;p&gt;导入Maven依赖&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Controller编写&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@RestController
public class HelloController {
    @RequestMapping(&quot;/hello&quot;)
    public String hello() {
        return &quot;Hello Spring Boot&quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编写引导类，这里还默认在请求映射的时候返回Hello World字符串作为响应体返回&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@RestController
@SpringBootApplication
public class Springboot001Application {
	@RequestMapping(&quot;/&quot;)
	public String home() {
		return &quot;Hello World&quot;;
	}

	public static void main(String[] args) {
		SpringApplication.run(Springboot001Application.class, args);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;SpringBoot在打包的时候通过jar包进行打包&lt;/p&gt;
&lt;p&gt;我们通过IDEA的SpringBoot也可以快速创建SpringBoot工程，可以很便捷的创建引导类，引入起步依赖&lt;/p&gt;
&lt;p&gt;我们在起步依赖中定义的spring-boot-starter-parent定义了各种技术的版本信息，组合了一台最优搭配的技术版本&lt;/p&gt;
&lt;p&gt;在starter中，定义了完成该功能需要的坐标集合，其中大部分信息来自于父工程&lt;/p&gt;
&lt;h2&gt;SpringBoot配置&lt;/h2&gt;
&lt;p&gt;由propertis和yaml两种配置&lt;/p&gt;
&lt;p&gt;application.properties&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server.port=8080
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;spring.application.name=springboot-002
server.port=8080
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;application.yml&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server:
  port: 8080
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;server:
  port: 8082
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在同一级目录下，同样的配置，优先级priperties&amp;gt;yml&amp;gt;yaml&lt;/p&gt;
&lt;h2&gt;YAML&lt;/h2&gt;
&lt;p&gt;YAML Ain&apos;t Markup Language&lt;/p&gt;
&lt;p&gt;是一种直观的被电脑识别的数据序列化格式，同时容易被人类阅读，容易和脚本语言交互，文件拓展名是yml或yaml&lt;/p&gt;
&lt;h3&gt;基本语法&lt;/h3&gt;
&lt;p&gt;大小写敏感&lt;/p&gt;
&lt;p&gt;数据值前边必须要有空格作为分隔符，最少一个空格&lt;/p&gt;
&lt;p&gt;使用缩进表示层级关系&lt;/p&gt;
&lt;p&gt;缩进的空格数不重要，只需要相同层级的元素左侧对齐即可&lt;/p&gt;
&lt;p&gt;#表示注释，作用到行尾&lt;/p&gt;
&lt;h3&gt;数据格式&lt;/h3&gt;
&lt;p&gt;对象：键值对的集合&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#换行写法
person: 
  name: &apos;zhangsan&apos;
  age: 20
  
#行内写法
person: {name: &apos;zhangsan&apos;,age: 20}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;行内写法不多，了解即可&lt;/p&gt;
&lt;p&gt;数组：一组按次序排列的值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;address: 
  - &apos;beijing&apos;
  - &apos;shanghai&apos;
address: [&apos;beijing&apos;,&apos;shanghai&apos;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;纯量：单个的，不可再分的值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;msg1: &apos;hello \n world&apos; #单引号忽略转义字符
msg2: &quot;hello \n world&quot; #双引号识别转义字符
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;参数引用&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;name: abc
person:
  name: ${name}
  age: 20
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;获取配置数据&lt;/h2&gt;
&lt;p&gt;SpringBoot通过了以下的方式获取配置内容&lt;/p&gt;
&lt;h3&gt;@Value&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;@Value(&quot;${name}&quot;)
private String name;

@RequestMapping(&quot;/name&quot;)
public String getNameController() {
    return name;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;@Value(&quot;${human.name}&quot;)
private String name;

@Value(&quot;${human.age}&quot;)
private int age;

@RequestMapping(&quot;/name&quot;)
public String getNameController() {
    return name + &quot; &quot; + age;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;zhangsan 20
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;数组获取&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Value(&quot;${hobbies[0]}&quot;)
private String hobbies;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Environment&lt;/h3&gt;
&lt;p&gt;相比于Value注入的对象少一点，只需要注入环境对象即可&lt;/p&gt;
&lt;p&gt;注入Environment对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Autowired
private Environment env;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再通过env对象传入键获取值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@RequestMapping(&quot;/name&quot;)
public String getNameController() {
    System.out.println(env.getProperty(&quot;name&quot;));
    System.out.println(env.getProperty(&quot;human.age&quot;));
    return &quot;hobbies&quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;@ConfigurationProperties&lt;/h3&gt;
&lt;p&gt;添加bean对象，用@Component @ConfigurationProperties两个对象标注&lt;/p&gt;
&lt;p&gt;通过perfix属性传入对应标签&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Component
@ConfigurationProperties(prefix = &quot;person&quot;)
public class Person {
    private String name;
    private int age;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;数组的获取类似，关键就是bean对象上的两个注解&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;person:
  name: ${name}
  age: 20
  address: [shanghai,beijing]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;@Autowired
private Person person;

@RequestMapping(&quot;/name&quot;)
public String getNameController() {
    System.out.println(env.getProperty(&quot;name&quot;));
    System.out.println(env.getProperty(&quot;human.age&quot;));
    System.out.println(person);
    String[] address = person.getAddress();
    for (String s : address) {
        System.out.println(s);
    }
    return &quot;hobbies&quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Profile&lt;/h2&gt;
&lt;p&gt;在开发SpringBoot应用的时候，通常同一套程序会被安装到不同的环境中，例如开发 测试 生产，其中的配置必然是不同的，为了避免每次打包时都需要修改配置文件非常麻烦，profile提供了进行动态配置切换的功能&lt;/p&gt;
&lt;h3&gt;多文件方式&lt;/h3&gt;
&lt;p&gt;第一种方式：通过配置多个配置文件文件，格式为application-xxx.properties，在application.properties中进行配置文件的选择&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/210.png&quot; alt=&quot;210&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;spring.application.name=springboot-003-test
spring.profiles.active=dev
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;多文档方式&lt;/h3&gt;
&lt;p&gt;第二种方式：多文档配置&lt;/p&gt;
&lt;p&gt;:::warning&lt;/p&gt;
&lt;p&gt;在 &lt;strong&gt;Spring Boot 2.4+&lt;/strong&gt; 版本之后，&lt;code&gt;spring.profiles&lt;/code&gt; 的写法已经被弃用，并替换为 &lt;code&gt;spring.config.activate.on-profile&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;---
server:
  port: 8081
spring:
  config:
    activate:
      on-profile: dev
---
server:
  port: 8082
spring:
  config:
    activate:
      on-profile: test
---
server:
  port: 8083
spring:
  config:
    activate:
      on-profile: pro
---
spring:
  profiles:
    active: pro
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在spring-profiles-active中设置激活配置文件&lt;/p&gt;
&lt;h3&gt;虚拟机选项配置&lt;/h3&gt;
&lt;p&gt;还可以在SpringBoot配置的虚拟机选项中添加如下的部分选择对应的配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-Dspring.profiles.active=test
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Jar包运行参数设置&lt;/h3&gt;
&lt;p&gt;打包后通过如下指令在命令行中运行springboot程序jar包&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;java -jar .\springboot-003-test-0.0.1-SNAPSHOT.jar
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;java -jar .\springboot-003-test-0.0.1-SNAPSHOT.jar --spring.profiles.active=dev
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过--spring.profiles.active=dev指定对应的配置文件&lt;/p&gt;
&lt;h2&gt;项目配置加载顺序&lt;/h2&gt;
&lt;p&gt;内部配置和外部配置互补，算是一种优势，可以在打包后也可以修改配置参数&lt;/p&gt;
&lt;h3&gt;内部配置加载&lt;/h3&gt;
&lt;p&gt;SpringBoot程序启动的时候，会从一下的位置加载配置文件&lt;/p&gt;
&lt;p&gt;1.file../config/ : 当前项目下的/config目录下&lt;/p&gt;
&lt;p&gt;2.file../ : 当前项目的根目录下&lt;/p&gt;
&lt;p&gt;3.classpath:/config : classpath的/config目录下&lt;/p&gt;
&lt;p&gt;4.classpath:/ : classpath的根目录&lt;/p&gt;
&lt;p&gt;:::note&lt;/p&gt;
&lt;p&gt;加载顺序为上文的排列顺序，高优先级配置的属性会生效，这些配置都会被SpringBoot读取，但是高优先级存在的内容不会被低优先级的更改&lt;/p&gt;
&lt;p&gt;而低优先级存在高优先级不存在的配置也会被正确配置&lt;/p&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;h3&gt;外部配置加载&lt;/h3&gt;
&lt;p&gt;通过命令行参数指定运行端口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;java -jar springboot-004-0.0.1-SNAPSHOT.jar --server.port=8090
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过命令行指定外部的配置文件路径 e://application.yaml&lt;/p&gt;
&lt;p&gt;spring.config.location&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;java -jar springboot-004-0.0.1-SNAPSHOT.jar --spring.config.location=e://application.yaml
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还可以将配置文件放置在jar包的同级目录，或者同级下的config目录下，不指定参数也可以使配置生效&lt;/p&gt;
&lt;h2&gt;整合框架&lt;/h2&gt;
&lt;h3&gt;JUnit测试框架&lt;/h3&gt;
&lt;p&gt;1.搭建SpringBoot工程&lt;/p&gt;
&lt;p&gt;2.引入starter-test起步依赖&lt;/p&gt;
&lt;p&gt;3.编写测试类，这里在service层编写一个方法做示范&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Service
public class UserService {
    public void add() {
        System.out.println(&quot;add...&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.添加测试相关注解：&lt;/p&gt;
&lt;p&gt;@RunWith(SpringRunner.class) 这个注解好像是新版本用不上，可以不加&lt;/p&gt;
&lt;p&gt;@SpringBootTest(classes = 启动类.class)&lt;/p&gt;
&lt;p&gt;如果是测试类在启动类的同一个包下就不需要添加指定classes&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@SpringBootTest(classes = Springboot004Application.class)
public class UserServiceTest {
    @Autowired
    private UserService userService;

    @Test
    public void testAdd() {
        userService.add();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.编写测试方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void testAdd() {
    userService.add();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Redis整合&lt;/h3&gt;
&lt;p&gt;SpringBoot整合Redis非常方便&lt;/p&gt;
&lt;p&gt;实现步骤：&lt;/p&gt;
&lt;p&gt;1.搭建SpringBoot工程&lt;/p&gt;
&lt;p&gt;2.引入redis起步依赖&lt;/p&gt;
&lt;p&gt;3.配置redis相关属性&lt;/p&gt;
&lt;p&gt;4.注入RedisTemplate模板&lt;/p&gt;
&lt;p&gt;5.编写测试方法，测试&lt;/p&gt;
&lt;p&gt;先启动Redis服务，执行set get测试方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@SpringBootTest
class Springboot006ApplicationTests {

    @Autowired
    private RedisTemplate redisTemplate;

    @Test
    void testSet() {
        //存入数据
        redisTemplate.boundValueOps(&quot;name&quot;).set(&quot;zhangsan&quot;);
    }

    @Test
    void testGet() {
        Object name = redisTemplate.boundValueOps(&quot;name&quot;).get();
        System.out.println(name);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还可以在yaml配置文件中通过修改配置更改redis的地址与端口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;spring:
  data:
    redis:
      host: 127.0.0.1
      port: 6379
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;MyBatis整合&lt;/h3&gt;
&lt;p&gt;SpringBoot整合MyBatis&lt;/p&gt;
&lt;p&gt;1.搭建SpringBoot工程&lt;/p&gt;
&lt;p&gt;2.引入mybatis起步依赖，添加MySQL驱动&lt;/p&gt;
&lt;p&gt;3.编写DataSource和myBatis相关配置&lt;/p&gt;
&lt;p&gt;4.定义表和实体类&lt;/p&gt;
&lt;p&gt;5.编写dao和mapper文件/纯注解开发&lt;/p&gt;
&lt;p&gt;6.测试&lt;/p&gt;
&lt;p&gt;这里引入mybatis起步依赖的时候似乎3.5.3版本SpringBoot不支持MyBatis Framework，所以用的是3.4.8版本的SpringBoot&lt;/p&gt;
&lt;p&gt;通过yml配置jdbc数据源配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;spring:
  datasource:
    url: jdbc:mysql:///ssm
    username: root
    password: 654321
    driver-class-name: com.mysql.jdbc.Driver
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;userBean&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class User {
    private int id;
    private String password;
    private double balance;

    public User() {
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;注解实现&lt;/h4&gt;
&lt;p&gt;通过注解实现UserMapper的实现类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Mapper
public interface UserMapper {
    @Select(&quot;select * from user;&quot;)
    public List&amp;lt;User&amp;gt; findAll();

    @Select(&quot;select * from user where `id`= #{id}&quot;)
    public User findById(Integer id);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编写测试程序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@SpringBootTest
class Springboot007ApplicationTests {
	@Autowired
	UserMapper userMapper;
	@Test
	void testSelectAll() {
		List&amp;lt;User&amp;gt; users = userMapper.findAll();
		for (User user : users) {
			System.out.println(user);
		}
	}

	@Test
	void testSelectById() {
		User user = userMapper.findById(1);
		System.out.println(user);
	}
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>SpringMVC笔记（REST风格，SSM整合，异常处理器，拦截器）</title><link>https://thrinisty.github.io/posts/springmvc%E7%AC%94%E8%AE%B0rest%E9%A3%8E%E6%A0%BCssm%E6%95%B4%E5%90%88%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%99%A8%E6%8B%A6%E6%88%AA%E5%99%A8/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/springmvc%E7%AC%94%E8%AE%B0rest%E9%A3%8E%E6%A0%BCssm%E6%95%B4%E5%90%88%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%99%A8%E6%8B%A6%E6%88%AA%E5%99%A8/</guid><description>REST风格，SSM整合，异常处理器，拦截器</description><pubDate>Tue, 24 Jun 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;SpringMVC笔记&lt;/h1&gt;
&lt;h2&gt;REST风格&lt;/h2&gt;
&lt;p&gt;Representational State Transfer 表现形式状态转换&lt;img src=&quot;../images/204.png&quot; alt=&quot;204&quot; /&gt;&lt;/p&gt;
&lt;p&gt;通过访问的路径和访问的类别区分操作，一般资源后缀要加上s&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/205.png&quot; alt=&quot;205&quot; /&gt;&lt;/p&gt;
&lt;p&gt;使用这种风格访问资源称之为RESTful&lt;/p&gt;
&lt;p&gt;http://localhost:8080/MVCTest_war/rests/17&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@RequestMapping(value = &quot;/rests/{age}&quot;, method = RequestMethod.DELETE)
@ResponseBody
public String deleteRest(@PathVariable Integer age) {
    System.out.println(&quot;delete &quot; + age);//delete 17
    return &quot;success&quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过{age}建立映射，以及设置@PathVariable注解我们可以从路径上获取到参数，用method设置相应请求的类型&lt;/p&gt;
&lt;p&gt;以下是查询的格式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Controller
public class RestTestController {
    @RequestMapping(value = &quot;/rests&quot;, method = RequestMethod.GET)
    @ResponseBody
    public String getAllRests() {
        System.out.println(&quot;Get all rests&quot;);
        return &quot;success&quot;;
    }

    @RequestMapping(value = &quot;/rests/{age}&quot;, method = RequestMethod.GET)
    @ResponseBody
    public String getByAge(@PathVariable Integer age) {
        System.out.println(&quot;Get rest by age:&quot; + age);
        return &quot;success&quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Rest简化开发，我们将Mapping映射的rests提出放在类上，方法就可以只写路径参数或者不写了&lt;/p&gt;
&lt;p&gt;我们方法上的所有方法都被@ResponseBody标注，可以将注解外提到类上，对所有的方法设置请求响应体&lt;/p&gt;
&lt;p&gt;还可以将@Controller @ResponseBody两个注解合二为一为@RestController&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//@Controller
//@ResponseBody
@RestController//将上述合二为一
@RequestMapping(&quot;/rests&quot;)
public class RestsTestController {
    @RequestMapping(method = RequestMethod.GET)
    public String getAllRests() {
        System.out.println(&quot;Get all rests&quot;);
        return &quot;success&quot;;
    }

    @RequestMapping(value = &quot;{age}&quot;, method = RequestMethod.GET)
    public String getByAge(@PathVariable Integer age) {
        System.out.println(&quot;Get rest by age:&quot; + age);
        return &quot;success&quot;;
    }

    @RequestMapping(value = &quot;{age}&quot;, method = RequestMethod.DELETE)
    public String deleteRest(@PathVariable Integer age) {
        System.out.println(&quot;delete &quot; + age);
        return &quot;success&quot;;
    }

    @RequestMapping(method = RequestMethod.PUT)
    @ResponseBody
    public String updateRest(@RequestParam String name, @RequestParam int age) {
        System.out.println(&quot;update &quot; + name + &quot; &quot; + age);
        return &quot;success&quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再次用XxxMapping简化&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//@Controller
//@ResponseBody
@RestController//将上述合二为一
@RequestMapping(&quot;/rests&quot;)
public class RestsTestController {
//    @RequestMapping(method = RequestMethod.GET)
    @GetMapping
    public String getAllRests() {
        System.out.println(&quot;Get all rests&quot;);
        return &quot;get all success&quot;;
    }

//    @RequestMapping(value = &quot;{age}&quot;, method = RequestMethod.GET)
    @GetMapping(&quot;{age}&quot;)
    public String getByAge(@PathVariable Integer age) {
        System.out.println(&quot;Get rest by age:&quot; + age);
        return &quot;get one success&quot;;
    }

//    @RequestMapping(value = &quot;{age}&quot;, method = RequestMethod.DELETE)
    @DeleteMapping(&quot;{age}&quot;)
    public String deleteRest(@PathVariable Integer age) {
        System.out.println(&quot;delete &quot; + age);
        return &quot;delete success&quot;;
    }
//    @RequestMapping(value = &quot;{age}&quot;, method = RequestMethod.Put)
    @PutMapping(&quot;{age}&quot;)
    public String updateRest(@PathVariable Integer age) {
        System.out.println(&quot;update &quot; + age);
        return &quot;update success&quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们在前面ServletContainersInitConfig配置中拦截了所有的请求，所以当访问html页面的时候会被SpringMVC拦截，我们需要新建一个SpringMvcSupport类来对相应的资源放行&lt;/p&gt;
&lt;p&gt;SpringMvcConfig配置也要扫瞄config包中的SpringMvcSupport类才可以正常使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Configuration
@ComponentScan({&quot;com.learn.controller&quot;, &quot;com.learn.config&quot;})
@EnableWebMvc
public class SpringMvcConfig {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;package com.learn.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;


@Configuration
public class SpringMvcSupport extends WebMvcConfigurationSupport {
    @Override
    protected void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler(&quot;/pages/**&quot;).addResourceLocations(&quot;/pages/&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;SSM开发整合&lt;/h2&gt;
&lt;h3&gt;MyBatis&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&amp;gt;
&amp;lt;configuration&amp;gt;
    &amp;lt;!--    &amp;lt;settings&amp;gt;--&amp;gt;
    &amp;lt;!--        &amp;lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&amp;gt;--&amp;gt;
    &amp;lt;!--    &amp;lt;/settings&amp;gt;--&amp;gt;
    &amp;lt;environments default=&quot;dev&quot;&amp;gt;
        &amp;lt;environment id=&quot;dev&quot;&amp;gt;
            &amp;lt;transactionManager type=&quot;JDBC&quot;/&amp;gt;
            &amp;lt;dataSource type=&quot;POOLED&quot;&amp;gt;
                &amp;lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&amp;gt;
                &amp;lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/ssm?useSSL=false&amp;amp;amp;serverTimezone=UTC&quot;/&amp;gt;
                &amp;lt;property name=&quot;username&quot; value=&quot;root&quot;/&amp;gt;
                &amp;lt;property name=&quot;password&quot; value=&quot;654321&quot;/&amp;gt;
            &amp;lt;/dataSource&amp;gt;
        &amp;lt;/environment&amp;gt;

    &amp;lt;/environments&amp;gt;
    &amp;lt;mappers&amp;gt;
        &amp;lt;!--        用于编写SQL语句的文件--&amp;gt;
        &amp;lt;mapper resource=&quot;UserMapper.xml&quot;/&amp;gt;
    &amp;lt;/mappers&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&amp;gt;
&amp;lt;mapper namespace=&quot;userMapper&quot;&amp;gt;
    &amp;lt;select id=&quot;selectById&quot; resultType=&quot;com.bean.User&quot;&amp;gt;
        select * from user where `id` = #{id};
    &amp;lt;/select&amp;gt;
    &amp;lt;insert id=&quot;insertUser&quot;&amp;gt;
        insert into user values (#{id}, #{password}, #{balance});
    &amp;lt;/insert&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Dao&lt;/h3&gt;
&lt;p&gt;写的很简陋，将异常处理之类的都暂时省略&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Repository(&quot;userDaoImpl&quot;)
public class UserDaoImpl implements UserDao {
    @Override
    public User getUserById(Integer id) {
        SqlSession sqlSession = SqlSessionUtil.getSqlSession();
        Object object = sqlSession.selectOne(&quot;selectById&quot;, id);
        return (User) object;
    }

    @Override
    public int insertUser(User user) {
        SqlSession sqlSession = SqlSessionUtil.getSqlSession();
        int i = sqlSession.insert(&quot;insertUser&quot;, user);
        if (i &amp;gt; 0) {
            sqlSession.commit();
        } else {
            sqlSession.rollback();
        }
        return i;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Utils&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;package com.utils;

import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;

import java.io.IOException;

public class SqlSessionUtil {
    private static SqlSessionFactory sqlSessionFactory;
    static {
        try {
            sqlSessionFactory = new SqlSessionFactoryBuilder()
                    .build(Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;));
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    private SqlSessionUtil() {}
    public static SqlSession getSqlSession() {
        return sqlSessionFactory.openSession();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Cotroller&lt;/h3&gt;
&lt;p&gt;在整合使用的时候，Spring的使用需要jdk17版本，而且@PathVariable(&quot;id&quot;)需要显式的指定参数名称&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@RestController
@RequestMapping(&quot;/users&quot;)
public class UserController {
    @Autowired
    private UserDao userDao;

    @GetMapping(&quot;{id}&quot;)
    public User getUserById(@PathVariable(&quot;id&quot;) Integer id) {
        return userDao.getUserById(id);
    }

    @PostMapping
    public String insertUser(@RequestBody User user) {
        int update = userDao.insertUser(user);
        return &quot;success update line:&quot; + update;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;异常处理器&lt;/h2&gt;
&lt;p&gt;我们很容易想到通过AOP包围处理的代码&lt;/p&gt;
&lt;p&gt;而SpringMVC中有注解可以有效处理异常&lt;/p&gt;
&lt;p&gt;@RestControllerAdvice注解是控制的通知，而@ExceptionHandler(XxException.class)可以在发生相应异常的时候做对应处理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@RestControllerAdvice
public class ProjectExceptionAdvice {
    @ExceptionHandler(NullPointerException.class)
    public void doException(Exception ex) {
        System.out.println(&quot;空指针异常被捕获&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;../images/206.png&quot; alt=&quot;206&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;拦截器&lt;/h2&gt;
&lt;p&gt;是一种动态拦截方法调用的机制，在SpringMVC中动态拦截控制器方法的执行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/207.png&quot; alt=&quot;207&quot; /&gt;&lt;/p&gt;
&lt;p&gt;作用：在指定的方法调用前后执行预先设定的代码，或者阻止原始方法的执行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/208.png&quot; alt=&quot;208&quot; /&gt;&lt;/p&gt;
&lt;p&gt;根据preHandle中的返回boolean判定是继续执行还是直接跳过后续执行&lt;/p&gt;
&lt;p&gt;拦截器和过滤器的区别&lt;/p&gt;
&lt;p&gt;Filter属于Servlet技术，Interceptor属于SpringMVC技术&lt;/p&gt;
&lt;p&gt;Filter对所有访问进行增强，而Interceptor仅针对SpringMVC的访问进行增强&lt;/p&gt;
&lt;h3&gt;入门使用&lt;/h3&gt;
&lt;p&gt;在表现层新建一个ProjectInterceptor类实现HandlerInterceptor接口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.controller;

import org.springframework.stereotype.Component;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@Component
public class ProjectInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println(&quot;preHandle&quot;);
        return true;
        //这里返回false代表终止原始操作，之后的postHandleafter  Completion也不会执行
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println(&quot;postHandle&quot;);
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println(&quot;afterCompletion&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置SpringMvcSupport，添加重写方法，注入刚才编写的ProjectInterceptor，将类传入addInterceptor方法中，在调用addPathPatterns设置拦截路径&lt;/p&gt;
&lt;p&gt;/**为所有的子路径&lt;/p&gt;
&lt;p&gt;/*为一级子路径&lt;/p&gt;
&lt;p&gt;没有通配符只匹配精确路径&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Configuration
public class SpringMvcSupport extends WebMvcConfigurationSupport {
    @Autowired
    private ProjectInterceptor projectInterceptor;
    
    @Override
    protected void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(projectInterceptor).addPathPatterns(&quot;/users/**&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;preHandle //原始操作之前的代码
postHandle//原始操作之后的代码
afterCompletion//post之后的代码
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;简化配置&lt;/h3&gt;
&lt;p&gt;通过SpringMvcConfig配置类继承于WebMvcConfigurer接口，重写addInterceptors方法，即可简化实现，再扫描的时候不需要扫描config软件包下SpringMvcSupport&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Configuration
@ComponentScan({&quot;com.controller&quot;})
@EnableWebMvc
public class SpringMvcConfig implements WebMvcConfigurer {
    @Autowired
    private ProjectInterceptor projectInterceptor;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(projectInterceptor).addPathPatterns(&quot;/users/**&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种方式相较而言简便但是有缺陷，会和Spring强制绑定&lt;/p&gt;
&lt;h3&gt;拦截器参数&lt;/h3&gt;
&lt;p&gt;HttpServletRequest request, HttpServletResponse response,&lt;/p&gt;
&lt;p&gt;Object handler通过方法传入的参数可以从其中取出数据，其中handler是方法的对象&lt;/p&gt;
&lt;p&gt;ModelAndView modelAndView 其中封装了页面跳转的一些方法供以处理&lt;/p&gt;
&lt;p&gt;Exception ex 是异常信息，而我们在使用的时候一般使用异常处理器完成，而不用这个&lt;/p&gt;
&lt;p&gt;其中最常用的是preHandle，通过参数做校验，判断是否继续执行后续方法&lt;/p&gt;
&lt;h3&gt;拦截链配置&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;@Configuration
@ComponentScan({&quot;com.controller&quot;})
@EnableWebMvc
public class SpringMvcConfig implements WebMvcConfigurer {
    @Autowired
    private ProjectInterceptor projectInterceptor;
    @Autowired
    private AnotherInterceptor anotherInterceptor;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(projectInterceptor).addPathPatterns(&quot;/users/**&quot;);
        registry.addInterceptor(anotherInterceptor).addPathPatterns(&quot;/users/**&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;preHandle
another preHandle
another postHandle
postHandle
another afterCompletion
afterCompletion
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;顺序和添加的拦截器顺序有关&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;registry.addInterceptor(projectInterceptor).addPathPatterns(&quot;/users/**&quot;);
        registry.addInterceptor(anotherInterceptor).addPathPatterns(&quot;/users/**&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;前处理器按配置先后执行，而后处理器反向执行&lt;/p&gt;
&lt;p&gt;以下是当preHandle返回false的时候的处理顺序，总的来说就是先返回true后的afterCompletion无论如何后续拦截器preHandle返回false与否都要执行先前afterCompletion方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/209.png&quot; alt=&quot;209&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>MCP笔记（MCP）</title><link>https://thrinisty.github.io/posts/mcp%E7%AC%94%E8%AE%B0mcp/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/mcp%E7%AC%94%E8%AE%B0mcp/</guid><description>MCP</description><pubDate>Mon, 23 Jun 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;MCP笔记&lt;/h1&gt;
&lt;h2&gt;AI Agent——AI&lt;/h2&gt;
&lt;h3&gt;System Prompt&lt;/h3&gt;
&lt;p&gt;System Prompt：预先设计的一段文本或指令，用于定义AI Agent的角色、能力和行为边界&lt;/p&gt;
&lt;p&gt;User Prompt：用户实际输入的请求或问题，是AI生成响应的直接依据&lt;/p&gt;
&lt;p&gt;Agent Tools：AI Agent可调用的 &lt;strong&gt;外部工具或API&lt;/strong&gt;，用于扩展能力（如搜索、计算、数据库查询）&lt;/p&gt;
&lt;p&gt;AI Agent：自主的软件实体，能 &lt;strong&gt;理解目标、调用工具、决策行动&lt;/strong&gt;，并持续学习&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/194.png&quot; alt=&quot;194&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/193.png&quot; alt=&quot;193&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;Function Calling&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;传统AI&lt;/strong&gt;：仅能生成文本，无法执行实际操作（如“查股票价格”只能编造）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;带Function Calling的AI&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;解析用户意图&lt;/strong&gt; → &lt;strong&gt;生成结构化请求&lt;/strong&gt; → &lt;strong&gt;调用外部工具&lt;/strong&gt; → &lt;strong&gt;返回真实数据&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;例如：
&lt;ul&gt;
&lt;li&gt;用户问：“上海明天天气如何？”&lt;/li&gt;
&lt;li&gt;AI生成请求：&lt;code&gt;get_weather(location=&quot;上海&quot;, date=&quot;2023-10-05&quot;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;调用天气API后返回真实结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;../images/195.png&quot; alt=&quot;195&quot; /&gt;&lt;/p&gt;
&lt;p&gt;总而言之就是在AI Agent之间改用结构化的请求格式，使得访问内容更加精确，返回的结果正确率高，减少重复访问的过程，用户的Token开销&lt;/p&gt;
&lt;h2&gt;AI Tools——AI Agent&lt;/h2&gt;
&lt;p&gt;最简单的方式就是将list_files和read_file和AI Agent写在同一进程中，直接通过函数调用即可以实现&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/196.png&quot; alt=&quot;196&quot; /&gt;&lt;/p&gt;
&lt;p&gt;但是tool功能通用的情况下，可以将Agent Tools变成服务统一的托管，让所有的Agent对齐进行调用，这就是MCP&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/197.png&quot; alt=&quot;197&quot; /&gt;&lt;/p&gt;
&lt;p&gt;其中Tools的部分是MCP Server，Agent部分是MCP Client&lt;/p&gt;
&lt;h2&gt;流程图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;../images/199.png&quot; alt=&quot;199&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>MyBatis笔记（javassist生成类）</title><link>https://thrinisty.github.io/posts/mybatis%E7%AC%94%E8%AE%B0javassist%E7%94%9F%E6%88%90%E7%B1%BB/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/mybatis%E7%AC%94%E8%AE%B0javassist%E7%94%9F%E6%88%90%E7%B1%BB/</guid><description>javassist生成类</description><pubDate>Mon, 23 Jun 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;MyBatis笔记&lt;/h1&gt;
&lt;p&gt;前段时间终于将租的房子确定下来了，因为要熟悉一下周边环境，就稍微给自己放了几天假，在这几天把该买的，该收拾的都搞完了，今天是公司实习的第一天，希望在公司实习的同时不落下之前预定课业的学习&lt;/p&gt;
&lt;h2&gt;javassist&lt;/h2&gt;
&lt;h3&gt;基本使用&lt;/h3&gt;
&lt;p&gt;通过javassist我们只需要编写Dao接口，他可以帮我们动态的生成Dao实现代码&lt;/p&gt;
&lt;p&gt;引入相关依赖&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.javassist&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;javassist&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.29.2-GA&amp;lt;/version&amp;gt; &amp;lt;!-- 使用最新版本 --&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;@Test
    public void test() {
        ClassPool pool = ClassPool.getDefault();
        CtClass ctClass = pool.makeClass(&quot;com.dao.DaoImpl&quot;);
        String methodCode = &quot;public void insert() {System.out.println(123);}&quot;;
        try {
            CtMethod ctMethod = CtMethod.make(methodCode, ctClass);
            ctClass.addMethod(ctMethod);
            ctClass.toClass();

            //类加载
            Class&amp;lt;?&amp;gt; clz = Class.forName(&quot;com.dao.DaoImpl&quot;);
            Constructor&amp;lt;?&amp;gt; constructor = clz.getConstructor();
            Object object = constructor.newInstance();
            Method method = clz.getMethod(&quot;insert&quot;);
            method.invoke(object);

        } catch (Exception e) {
            System.out.println(&quot;发送错误&quot;);
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意这里在将类加载进入字节码的时候由于JDK17模块系统限制了反射访问某些关键类，会出现错误，我们通过添加JVM参数解决&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;--add-opens java.base/java.lang=ALL-UNNAMED
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;实现接口&lt;/h3&gt;
</content:encoded></item><item><title>SpringMVC笔记（基本介绍，参数传递，响应请求）</title><link>https://thrinisty.github.io/posts/springmvc%E7%AC%94%E8%AE%B0%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E5%93%8D%E5%BA%94%E8%AF%B7%E6%B1%82/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/springmvc%E7%AC%94%E8%AE%B0%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E5%93%8D%E5%BA%94%E8%AF%B7%E6%B1%82/</guid><description>SpringMVC入门使用</description><pubDate>Mon, 23 Jun 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;SpringMVC笔记&lt;/h1&gt;
&lt;p&gt;由于时间紧张，这个部分的学习用的是黑马的六小时速成视频&lt;/p&gt;
&lt;h2&gt;SpringMVC简介&lt;/h2&gt;
&lt;p&gt;在之前的小项目中我们采用的是JSP+Servlet+Dao的方式实现Web开发&lt;/p&gt;
&lt;p&gt;而我们现在采取的方式如下图所示，SpringMVC负责的是控制器的制作以及将json数据传送给前端&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/200.png&quot; alt=&quot;200&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;入门案例&lt;/h2&gt;
&lt;p&gt;程序编写的对应关系&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/201.png&quot; alt=&quot;201&quot; /&gt;&lt;/p&gt;
&lt;p&gt;导入Maven配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&amp;gt;
  &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
  &amp;lt;groupId&amp;gt;com.learn&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;MVCTest&amp;lt;/artifactId&amp;gt;
  &amp;lt;packaging&amp;gt;war&amp;lt;/packaging&amp;gt;
  &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
  &amp;lt;name&amp;gt;MVCTest Maven Webapp&amp;lt;/name&amp;gt;
  &amp;lt;url&amp;gt;http://maven.apache.org&amp;lt;/url&amp;gt;
  &amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;3.8.1&amp;lt;/version&amp;gt;
      &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;5.2.10.RELEASE&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!-- Servlet API (Tomcat 10+/Jakarta EE 10) --&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;javax.servlet&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;javax.servlet-api&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;3.1.0&amp;lt;/version&amp;gt;
      &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt; &amp;lt;!-- 由容器提供 --&amp;gt;
    &amp;lt;/dependency&amp;gt;
  &amp;lt;/dependencies&amp;gt;
  &amp;lt;build&amp;gt;
    &amp;lt;finalName&amp;gt;MVCTest&amp;lt;/finalName&amp;gt;
  &amp;lt;/build&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编写MVC的配置类，作用是扫描对应包下组件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.learn.config;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

@Configuration
@ComponentScan(&quot;com.learn.controller&quot;)
public class SpringMvcConfig {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编写Controller类&lt;/p&gt;
&lt;p&gt;作用和Servlet一致，通过@RequestMapping(&quot;/save&quot;)注解映射到对应路径类的本身通过Controller注解标识&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.learn.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class UserController {
    @RequestMapping(&quot;/save&quot;)
    public void save() {
        System.out.println(&quot;User saved&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Spring MVC 中用于 &lt;strong&gt;替代传统 &lt;code&gt;web.xml&lt;/code&gt; 配置的基于 Java 的初始化类&lt;/strong&gt;，它通过实现 &lt;code&gt;AbstractDispatcherServletInitializer&lt;/code&gt; 抽象类来完成 Spring MVC 的初始化配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.learn.config;

import org.springframework.web.context.WebApplicationContext;
import org.springframework.web.context.support.AnnotationConfigWebApplicationContext;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;
import org.springframework.web.servlet.support.AbstractDispatcherServletInitializer;

public class ServletContainersInitConfig extends AbstractDispatcherServletInitializer {
    //加载容器对象
    @Override
    protected WebApplicationContext createServletApplicationContext() {
        AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();
        context.register(SpringMvcConfig.class);
        return context;
    }

    //过滤所有的对象管理，归SpringMVC管理
    @Override
    protected String[] getServletMappings() {
        return new String[]{&quot;/&quot;};
    }

    @Override
    protected WebApplicationContext createRootApplicationContext() {
        return null;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们上述访问/save路径的时候网页会发生错误，这是因为我们没有设置响应体，我们现在通过@ResponseBody注解标识返回的内容直接显示在页面上&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Controller
public class UserController {
    @RequestMapping(&quot;/save&quot;)
    @ResponseBody
    public String save() {
        System.out.println(&quot;User saved&quot;);
        return &quot;{&apos;info&apos;:&apos;User saved&apos;}&quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;启动服务器请求&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/202.png&quot; alt=&quot;202&quot; /&gt;&lt;/p&gt;
&lt;p&gt;单次请求过程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/203.png&quot; alt=&quot;203&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Spring和SpringMVC加载管理&lt;/p&gt;
&lt;p&gt;我们在实际使用Spring和SpringMVC管理Bean对象的时候，我们一般用SpringMVC扫描controller包，而Spring扫描dao包以及service包，要使得他们二者管理的范围不重复，我们有两种方式&lt;/p&gt;
&lt;p&gt;第一种：分别扫描具体的包&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Configuration
@ComponentScan({&quot;com.learn.service&quot;, &quot;com.learn.dao&quot;})
public class SpringConfig {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二种：扫描外层包，在排除对应不需要的包&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Configuration
@ComponentScan(value = &quot;com.learn&quot;,
        excludeFilters = @ComponentScan.Filter(
                type = FilterType.ANNOTATION,
                classes = Controller.class
        )
)
public class SpringConfig {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样的话我们执行一个测试语句，可以测试出controller的管理范围不在Spring中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
    public void TestMVC() {
        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
        ctx.register(SpringConfig.class);
        ctx.refresh();
        UserController user = ctx.getBean(&quot;userController&quot;, UserController.class);
        user.save();
    }

    @Test
    public void TestSpring() {
        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
        ctx.register(SpringConfig.class);
        ctx.refresh();
        TestPrint testPrint = ctx.getBean(&quot;testPrint&quot;, TestPrint.class);
        testPrint.print();
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后我们还需要将Spring纳入ServletContainersInitConfig的管理，将Spring也在Tomcat启动的时候初始化&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
protected WebApplicationContext createRootApplicationContext() {
    AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();
    context.register(SpringConfig.class);
    return context;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为上述代码较为麻烦，SpringMVC为我们提供了一个更加方便地实现，&lt;/p&gt;
&lt;p&gt;我们的初始化类我们还可以用ServletContainersInitConfig类继承于AbstractAnnotationConfigDispatcherServletInitializer，也可以实现预期的功能&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class ServletContainersInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer {
    @Override
    protected Class&amp;lt;?&amp;gt;[] getRootConfigClasses() {
        return new Class[]{SpringConfig.class};
    }

    @Override
    protected Class&amp;lt;?&amp;gt;[] getServletConfigClasses() {
        return new Class[]{SpringMvcConfig.class};
    }

    @Override
    protected String[] getServletMappings() {
        return new String[]{&quot;/&quot;};
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;请求路径映射&lt;/h2&gt;
&lt;p&gt;我们在前面编写了一个Controller，我们现在再加一个&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Controller
public class UserController {
    @RequestMapping(&quot;/user/save&quot;)
    @ResponseBody
    public String save() {
        System.out.println(&quot;User saved&quot;);
        return &quot;{&apos;info&apos;:&apos;User saved&apos;}&quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;@Controller
public class BookController {
    @RequestMapping(&quot;/book/save&quot;)
    @ResponseBody
    public String save() {
        System.out.println(&quot;User saved&quot;);
        return &quot;{&apos;info&apos;:&apos;User saved&apos;}&quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要区分相同的请求路径我们需要在Mapping映射的时候加上不同的前缀以示区分，除此之外我们看还可以在类上加上前缀，后面是调用名称&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Controller
@RequestMapping(&quot;/user&quot;)
public class UserController {
    @RequestMapping(&quot;/save&quot;)
    @ResponseBody
    public String save() {
        System.out.println(&quot;User saved&quot;);
        return &quot;{&apos;info&apos;:&apos;User saved&apos;}&quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;请求参数传递&lt;/h2&gt;
&lt;h3&gt;普通参数传递&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;@RequestMapping(&quot;/commonParam&quot;)
    @ResponseBody
    public String commonParam(String name) {
        System.out.println(&quot;普通参数传递&quot; + name);
        return &quot;{&apos;name&apos;:&apos;&quot;+name+&quot;&apos;}&quot;;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;get请求传入name、age参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http://localhost:8080/MVCTest_war/user/commonParam?name=nameTest&amp;amp;age=10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接收两个参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@RequestMapping(&quot;/commonParam&quot;)
    @ResponseBody
    public String commonParam(String name, int age) {
        System.out.println(&quot;普通参数传递&quot; + name + &quot; &quot; + age);
        return &quot;name:&quot; + name + &quot;,age:&quot; + age;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这里post和get不做区分&lt;/p&gt;
&lt;p&gt;post在body中编辑请求体参数&lt;/p&gt;
&lt;p&gt;不同名字参数传递，我们上述的请求名和处理器的参数变量名一致，当不一致的时候我们通过@RequestParam(&quot;name&quot;)注解绑定变量名称，默认为变量名称&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@RequestMapping(&quot;/commonParam&quot;)
@ResponseBody
public String commonParam(@RequestParam(&quot;name&quot;) String userName, int age) {
    System.out.println(&quot;普通参数传递&quot; + userName + &quot; &quot; + age);
    return &quot;name:&quot; + userName + &quot;,age:&quot; + age;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;对象传参&lt;/h3&gt;
&lt;p&gt;此外我们在实际使用的时候往往传入的是一个bean对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class User {
    private String name;
    private int age;
    public User() {}
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在接受的时候我们可以使用这个bean对象接收参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@RequestMapping(&quot;/commonParam&quot;)
@ResponseBody
public String commonParam(User user) {
    System.out.println(user);
    return &quot;{&apos;info&apos;:&apos;User saved&apos;}&quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;类嵌套传参&lt;/h3&gt;
&lt;p&gt;假设我们User现在有了一个新的引用类对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Address {
    private String city;
    private String province;
    public Address() {}
    public Address(String city, String province) {
        this.city = city;
        this.province = province;
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们要对于这个对象的请求进行赋值&lt;/p&gt;
&lt;p&gt;http://localhost:8080/MVCTest_war/user/commonParam?name=Jack&amp;amp;age=10&amp;amp;address.city=Xian&amp;amp;address.province=Shanxi&lt;/p&gt;
&lt;p&gt;通过address.属性名的形式我们可以进行对于引用对象进行参数的赋值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@RequestMapping(&quot;/commonParam&quot;)
@ResponseBody
public String commonParam(User user) {
    System.out.println(user);
    return &quot;{&apos;info&apos;:&apos;User saved&apos;}&quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;List数据传输&lt;/h3&gt;
&lt;p&gt;用List集合接收参数，这里需要使用@RequestParam注解将结果放入List中，如果不设置注解则会尝试创建List接口对象从而导致报错&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@RequestMapping(&quot;/commonParam&quot;)
@ResponseBody
public String commonParam(@RequestParam List&amp;lt;String&amp;gt; likes) {
    System.out.println(likes);
    return &quot;{&apos;info&apos;:&apos;likes&apos;}&quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;json数据传参&lt;/h3&gt;
&lt;p&gt;加入JSON的相关依赖&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;com.google.code.gson&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;gson&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;2.10.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在配置中加上@EnableWebMvc注解&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Configuration
@ComponentScan(&quot;com.learn.controller&quot;)
@EnableWebMvc
public class SpringMvcConfig {   
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在请求体中设置发送json格式的数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[&quot;game&quot;, &quot;music&quot;, &quot;travel&quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即可在控制器中用@RequestBody注解将json内容放入集合中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@RequestMapping(&quot;/commonParam&quot;)
    @ResponseBody
    public String commonParam(@RequestBody List&amp;lt;String&amp;gt; likes) {
        System.out.println(likes);
        return &quot;{&apos;info&apos;:&apos;likes&apos;}&quot;;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于Bean对象的赋值&lt;/p&gt;
&lt;p&gt;发送的json数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
    &quot;name&quot;:&quot;Jack&quot;,
    &quot;age&quot;:15,
    &quot;address&quot;:{
        province:beijing,
        city:beijing
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;@RequestMapping(&quot;/commonParam&quot;)
    @ResponseBody
    public String commonParam(@RequestBody User user) {
        System.out.println(user);
        return &quot;{&apos;info&apos;:&apos;likes&apos;}&quot;;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;日期类型传参&lt;/h3&gt;
&lt;p&gt;date1  2025/05/05&lt;/p&gt;
&lt;p&gt;date2  2025-05-05&lt;/p&gt;
&lt;p&gt;通过DateTimeFormat注解指定日期类型的格式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@RequestMapping(&quot;/commonParam&quot;)
    @ResponseBody
    public String commonParam(Date date1, @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) Date date2) {
        System.out.println(date1);
        System.out.println(date2);
        return &quot;{&apos;info&apos;:&apos;likes&apos;}&quot;;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;:::warning&lt;/p&gt;
&lt;p&gt;当发现不能按照预期的格式进行转换的时候记得检查一下@EnableWebMvc接口是否配置，其功能之一是根据类型匹配对应的类型转换器&lt;/p&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;h2&gt;响应请求&lt;/h2&gt;
&lt;p&gt;我们不加@ResponseBody的时候，返回的字符串，SpringMVC会去寻找对应的页面返回给客户端，加上后返回的则是字符串的内容&lt;/p&gt;
&lt;p&gt;如果我们需要返回一个Java Bean对象，我们设置对应返回类型，然后返回对象实例即可，在客户端会收到json格式的数据内容，这里其实是Gson帮助我们转的json格式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@RequestMapping(&quot;/returnBean&quot;)
@ResponseBody
public User returnBean() {
    User user = new User();
    user.setAge(10);
    user.setName(&quot;Jack&quot;);
    return user;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;{
    &quot;name&quot;: &quot;Jack&quot;,
    &quot;age&quot;: 10
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;返回类集合同理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@RequestMapping(&quot;/returnBean&quot;)
@ResponseBody
public List&amp;lt;User&amp;gt; returnBean() {
    List&amp;lt;User&amp;gt; result = new ArrayList&amp;lt;User&amp;gt;();
    User user = new User();
    user.setAge(10);
    user.setName(&quot;Jack&quot;);
    User user2 = new User();
    user2.setAge(20);
    user2.setName(&quot;Bob&quot;);
    result.add(user);
    result.add(user2);
    return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[
    {
        &quot;name&quot;: &quot;Jack&quot;,
        &quot;age&quot;: 10
    },
    {
        &quot;name&quot;: &quot;Bob&quot;,
        &quot;age&quot;: 20
    }
]
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>LeetCode刷题（最大子序列和，打家劫舍数组版本）</title><link>https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E6%95%B0%E7%BB%84%E7%89%88%E6%9C%AC/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E6%95%B0%E7%BB%84%E7%89%88%E6%9C%AC/</guid><description>最大子序列和，打家劫舍数组版本</description><pubDate>Sun, 22 Jun 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;最大子序列和&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;子数组&lt;/strong&gt;是数组中的一个连续部分。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：nums = [1]
输出：1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 3：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：nums = [5,4,-1,7,8]
输出：23
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;p&gt;如果是sum&amp;gt;0的时候，说明之前的结果是有增益的，需要把sum给加上当前遍历到的数字，而sum&amp;lt;=0的时候舍弃前面的结果，而将sum重新赋值当前遍历到的数字，用result存储当前遍历到的最大结果，每次循环最后的末尾用sum迭代之&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public int maxSubArray(int[] nums) {
        int result = nums[0];
        int sum = 0;
        for(int num : nums) {
            if(sum &amp;gt; 0) {
                sum += num;
            } else {
                sum = num;
            }
            result = Math.max(result, sum);
        }
        return result;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;打家劫舍数组版本&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，&lt;strong&gt;如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;给定一个代表每个房屋存放金额的非负整数数组，计算你 &lt;strong&gt;不触动警报装置的情况下&lt;/strong&gt; ，一夜之内能够偷窃到的最高金额。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;p&gt;之前做过运用二叉树存储结果的一道题目，这一道题目运用的是数组进行存储，仿照类似的解法，用一个长度为2的数组存储结果，在方法的内部递归的调用方法求出打劫下一个房屋的结果集，根据结果集分别给0不打劫的情况，1打劫的情况分别赋值，即可正确地求出结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public int rob(int[] nums) {
        int[] result = rotFun(nums, 0);
        return Math.max(result[0], result[1]);
    }

    public int[] rotFun(int[] nums, int index) {
        int[] result = new int[2];
        if(nums.length == index) {
            return result;
        }
        int[] nextTarget = rotFun(nums, index + 1);
        result[0] = Math.max(nextTarget[0], nextTarget[1]);
        result[1] = nums[index] + nextTarget[0];
        return result;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>LeetCode刷题（回文链表）</title><link>https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</guid><description>回文链表，运用中间节点和链表反转求解</description><pubDate>Thu, 19 Jun 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;回文链表&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给你一个单链表的头节点 &lt;code&gt;head&lt;/code&gt; ，请你判断该链表是否为回文链表。如果是，返回 &lt;code&gt;true&lt;/code&gt; ；否则，返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/191.jpg&quot; alt=&quot;191&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：head = [1,2,2,1]
输出：true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/192.jpg&quot; alt=&quot;192&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：head = [1,2]
输出：false
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;p&gt;解法一：运用List集合辅助判断，思路类似于判断数组是否是回文&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public boolean isPalindrome(ListNode head) {
        List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        ListNode p = head;
        while(p != null) {
            list.add(p.val);
            p = p.next;
        }
        int n = list.size();
        for(int i = 0, j = n - 1; i &amp;lt;= j; i++, j--) {
            if(list.get(i) != list.get(j)) {
                return false;
            }
        }
        return true;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是题目进阶要求空间复杂度为O(1)，不可以使用额外的存储空间&lt;/p&gt;
&lt;p&gt;解法二：运用中间节点和反转链表求解&lt;/p&gt;
&lt;p&gt;先来回顾一下运用头插法实现链表反转的方法，我们在后续中会使用到这个函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode result = new ListNode();
        ListNode p = head;
        ListNode temp;
        while(p != null) {
            temp = p.next;
            p.next = result.next;
            result.next = p;
            p = temp;
        }
        return result.next;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们再普及一个算法，用于输入一个链表的头节点输出他的中间节点，内部由快慢指针实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public ListNode returnHalf(ListNode head) {
        ListNode fast = head;
        ListNode slow = head;
        while (fast.next != null &amp;amp;&amp;amp; fast.next.next != null) {
            fast = fast.next.next;
            slow = slow.next;
        }
        return slow;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运用以上的两个函数，我们只需要将中间节点部分后的节点进行反转，在头节点和中间节点之后按照链表顺序依次判断节点内容是否相等即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public boolean isPalindrome(ListNode head) {
        if(head == null) {
            return true;
        }
        ListNode p1 = halfNode(head);
        ListNode p2 = reverseList(p1.next);
        p1 = head;
        while(p2 != null) {
            if(p1.val != p2.val) {
                return false;
            }
            p1 = p1.next;
            p2 = p2.next;
        }
        return true;
    }

    public ListNode reverseList(ListNode head) {
        ListNode result = new ListNode();
        ListNode p = head;
        ListNode temp;
        while(p != null) {
            temp = p.next;
            p.next = result.next;
            result.next = p;
            p = temp;
        }
        return result.next;
    }

    public ListNode halfNode(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        while(fast.next != null &amp;amp;&amp;amp; fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;今天的练习属于是老题新解，拓展了以下思路，运用先前的链表反转和取中间节点来解决链表回文的判断&lt;/p&gt;
</content:encoded></item><item><title>LeetCode刷题（单词拆分，最长递增子序列）</title><link>https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</guid><description>单词拆分，最长递增子序列</description><pubDate>Wed, 18 Jun 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;单词拆分&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给你一个字符串 &lt;code&gt;s&lt;/code&gt; 和一个字符串列表 &lt;code&gt;wordDict&lt;/code&gt; 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 &lt;code&gt;s&lt;/code&gt; 则返回 &lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;**注意：**不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]
输出: true
解释: 返回 true 因为 &quot;leetcode&quot; 可以由 &quot;leet&quot; 和 &quot;code&quot; 拼接成。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]
输出: true
解释: 返回 true 因为 &quot;applepenapple&quot; 可以由 &quot;apple&quot; &quot;pen&quot; &quot;apple&quot; 拼接成。
     注意，你可以重复使用字典中的单词。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 3：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]
输出: false
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;p&gt;这一道题我原本是打算用回溯法求解的，思路类似于之前做过的全排列，但是写一半发现如果是后面出现的单词（字典中）出现在结果的最前面，就没有办法求出正常的情况，看了下解析，应该使用动态规划求解，以下是求解思路&lt;/p&gt;
&lt;p&gt;设立一个dp数组，下表表示String前n位是否可以用wordDict字典中的单词表示，初始化dp[0]为true&lt;/p&gt;
&lt;p&gt;循环遍历字符串，位数从1增至字符串长度，在子循环中判断当前位数的字符串可否由可以组成的前半部分和后半部分包括在字典中的部分拼接形成，如果可以，将对应位数的boolean值设置为true，在循环结束后取dp[s.length()]结果返回&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public boolean wordBreak(String s, List&amp;lt;String&amp;gt; wordDict) {
        Set&amp;lt;String&amp;gt; set = new HashSet&amp;lt;&amp;gt;(wordDict);
        boolean[] dp = new boolean[s.length() + 1];
        dp[0] = true;
        for(int i = 1; i &amp;lt;= s.length(); i++) {
            for(int j = 0; j &amp;lt; i; j++) {
                if(dp[j] &amp;amp;&amp;amp; set.contains(s.substring(j, i))) {
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[s.length()];
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里之所以使用HashSet进行存储是得益于Set集合的contains函数时间复杂度是O(1)，不需要像List中需要将是所有的元素遍历后才可以得到最终的结果&lt;/p&gt;
&lt;p&gt;很好的题目，巩固了HashSet部分的知识，顺便复习了一下字符串的相关函数substring&lt;/p&gt;
&lt;h1&gt;最长的递增子序列&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，找到其中最长严格递增子序列的长度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;子序列&lt;/strong&gt; 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，&lt;code&gt;[3,6,2,7]&lt;/code&gt; 是数组 &lt;code&gt;[0,3,1,6,2,2,7]&lt;/code&gt; 的子序列。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：nums = [0,1,0,3,2,3]
输出：4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 3：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：nums = [7,7,7,7,7,7,7]
输出：1
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;p&gt;运用动态规划求解，对于结果dp而言，每单个数字，都是长度为1的递增子序列，用1将所有的dp赋值，从起始位置开始循环遍历，子循环变量j为包含j的最长子序列的结果，当其对应的数字小于外部循环对应的数字时，用dp[j] + 1迭代dp[i]的结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public int lengthOfLIS(int[] nums) {
        if(nums.length == 0) {
            return 0;
        }
        int n = nums.length;
        int[] dp = new int[n];
        Arrays.fill(dp, 1);
        for(int i = 0; i &amp;lt; n; i++) {
            for(int j = 0; j &amp;lt; i; j++) {
                if(nums[j] &amp;lt; nums[i]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
        }
        int result = 0;
        for(int num : dp) {
            result = Math.max(result, num);
        }
        return result;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者也可以在for循环中对于结果进行迭代，速度会更快一点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public int lengthOfLIS(int[] nums) {
        if(nums.length == 0) {
            return 0;
        }
        int n = nums.length;
        int[] dp = new int[n];
        Arrays.fill(dp, 1);
        int result = 0;
        for(int i = 0; i &amp;lt; n; i++) {
            for(int j = 0; j &amp;lt; i; j++) {
                if(nums[j] &amp;lt; nums[i]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            result = Math.max(result, dp[i]);
        }
        return result;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>LeetCode刷题（有效的括号，爬楼梯）</title><link>https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7%E7%88%AC%E6%A5%BC%E6%A2%AF/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7%E7%88%AC%E6%A5%BC%E6%A2%AF/</guid><description>有效的括号，爬楼梯</description><pubDate>Mon, 16 Jun 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;有效的括号&lt;/h1&gt;
&lt;p&gt;一样的今天主要还是复习软件工程，做两道简单的题目&lt;/p&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给定一个只包括 &lt;code&gt;&apos;(&apos;&lt;/code&gt;，&lt;code&gt;&apos;)&apos;&lt;/code&gt;，&lt;code&gt;&apos;{&apos;&lt;/code&gt;，&lt;code&gt;&apos;}&apos;&lt;/code&gt;，&lt;code&gt;&apos;[&apos;&lt;/code&gt;，&lt;code&gt;&apos;]&apos;&lt;/code&gt; 的字符串 &lt;code&gt;s&lt;/code&gt; ，判断字符串是否有效。&lt;/p&gt;
&lt;p&gt;有效字符串需满足：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;左括号必须用相同类型的右括号闭合。&lt;/li&gt;
&lt;li&gt;左括号必须以正确的顺序闭合。&lt;/li&gt;
&lt;li&gt;每个右括号都有一个对应的相同类型的左括号。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;**输入：**s = &quot;()&quot;&lt;/p&gt;
&lt;p&gt;**输出：**true&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;**输入：**s = &quot;()[]{}&quot;&lt;/p&gt;
&lt;p&gt;**输出：**true&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 3：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;**输入：**s = &quot;(]&quot;&lt;/p&gt;
&lt;p&gt;**输出：**false&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 4：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;**输入：**s = &quot;([])&quot;&lt;/p&gt;
&lt;p&gt;**输出：**true&lt;/p&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;p&gt;设立一个栈结构，依次遍历字符串的字符，为左括号入栈，如果不是左括号，先判断栈是否为空，为空返回false，之后弹栈用弹出的元素比较是否和入站的元素匹配，不匹配则返回false，否则继续遍历&lt;/p&gt;
&lt;p&gt;当字符串遍历完成的时候，如果合法，栈应该空的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public boolean isValid(String s) {
        if(s.length() % 2 != 0) {
            return false;
        }
        Map&amp;lt;Character, Character&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        map.put(&apos;)&apos;, &apos;(&apos;);
        map.put(&apos;]&apos;, &apos;[&apos;);
        map.put(&apos;}&apos;, &apos;{&apos;);
        Stack&amp;lt;Character&amp;gt; stack = new Stack&amp;lt;&amp;gt;();
        for(char c : s.toCharArray()) {
            if(c == &apos;(&apos; || c == &apos;[&apos; || c == &apos;{&apos;) {
                stack.push(c);
            } else if(stack.isEmpty() || stack.pop() != map.get(c)) {
                return false;
            } else {
                continue;
            }
        }
        return stack.isEmpty();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;爬楼梯&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;假设你正在爬楼梯。需要 &lt;code&gt;n&lt;/code&gt; 阶你才能到达楼顶。&lt;/p&gt;
&lt;p&gt;每次你可以爬 &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;2&lt;/code&gt; 个台阶。你有多少种不同的方法可以爬到楼顶呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;p&gt;本质上类似斐波那契数列的求解，我们运用动态规划做题&lt;/p&gt;
&lt;p&gt;设跳上 n 级台阶有 f(n) 种跳法。在所有跳法中，青蛙的最后一步只有两种情况： 跳上 1 级或 2 级台阶。&lt;/p&gt;
&lt;p&gt;当为 1 级台阶： 剩 n−1 个台阶，此情况共有 f(n−1) 种跳法。
当为 2 级台阶： 剩 n−2 个台阶，此情况共有 f(n−2) 种跳法。
即 f(n) 为以上两种情况之和，即 f(n)=f(n−1)+f(n−2) ，以上递推性质为斐波那契数列。因此，本题可转化为 求斐波那契数列的第 n 项，区别仅在于初始值不同：&lt;/p&gt;
&lt;p&gt;青蛙跳台阶问题： f(0)=1 , f(1)=1 , f(2)=2 。
斐波那契数列问题： f(0)=0 , f(1)=1 , f(2)=1 。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public int climbStairs(int n) {
        int[] result = new int[n + 1];
        result[0] = 1;
        result[1] = 1;
        for(int i = 2; i &amp;lt;= n; i++) {
            result[i] = result[i - 1] + result[i - 2];
        }
        return result[n];
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为只需要存储最后的结果，我们也可以用迭代法求解&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public int climbStairs(int n) {
        int a = 1, b = 1, sum;
        for(int i = 0; i &amp;lt; n - 1; i++) {
            sum = a + b;
            a = b;
            b = sum;
        }
        return b;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>LeetCode刷题（环形链表）</title><link>https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</guid><description>环形链表</description><pubDate>Sun, 15 Jun 2025 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;今天要复习软件工程，做两道简单一点的题目&lt;/p&gt;
&lt;h1&gt;环形链表&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/175.png&quot; alt=&quot;175&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/176.png&quot; alt=&quot;176&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：head = [1,2], pos = 0
输出：返回索引为 0 的链表节点
解释：链表中有一个环，其尾部连接到第一个节点。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 3：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/178.png&quot; alt=&quot;178&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：head = [1], pos = -1
输出：返回 null
解释：链表中没有环。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;p&gt;之前甚至做过一道要求返回环起始节点的题目，这一道直接判断是否有环即可，如果要返回环起始节点，将其中一个指针放在开头同步向后直至相遇即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Solution {
    public boolean hasCycle(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        while(true) {
            if(fast == null || fast.next == null) {
                return false;
            }
            slow = slow.next;
            fast = fast.next.next;
            if(slow == fast) {
                return true;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;两数之和&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给定一个整数数组 &lt;code&gt;nums&lt;/code&gt; 和一个整数目标值 &lt;code&gt;target&lt;/code&gt;，请你在该数组中找出 &lt;strong&gt;和为目标值&lt;/strong&gt; &lt;em&gt;&lt;code&gt;target&lt;/code&gt;&lt;/em&gt; 的那 &lt;strong&gt;两个&lt;/strong&gt; 整数，并返回它们的数组下标。&lt;/p&gt;
&lt;p&gt;你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。&lt;/p&gt;
&lt;p&gt;你可以按任意顺序返回答案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：nums = [3,2,4], target = 6
输出：[1,2]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 3：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：nums = [3,3], target = 6
输出：[0,1]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;2 &amp;lt;= nums.length &amp;lt;= 104&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-109 &amp;lt;= nums[i] &amp;lt;= 109&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-109 &amp;lt;= target &amp;lt;= 109&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;只会存在一个有效答案&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;p&gt;解法一：暴力遍历数组，直到遇见两个元素相加为预期的结果，返回下表数组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public int[] twoSum(int[] nums, int target) {
        int n = nums.length;
        for(int i = 0; i &amp;lt; n; i++) {
            for(int j = i + 1; j &amp;lt; n; j++) {
                if(nums[i] + nums[j] == target) {
                    return new int[]{i, j};
                }
            }
        }
        return null;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解法二：通过哈希表进行优化，再遍历数组的每个元素的时候，先判断map中有无target-nums[i]的键，如果有则用键取值，得到下表返回即可，如果没有将&amp;lt;值，下表&amp;gt;放入map供以后的元素取用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        for(int i = 0; i &amp;lt; nums.length; i++) {
            Set keySet = map.keySet();
            if(keySet.contains(target - nums[i])) {
                return new int[]{map.get(target - nums[i]), i};
            }
            map.put(nums[i], i);
        }
        return null;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>LeetCode刷题（任务调度器，字符串解码）</title><link>https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/</guid><description>任务调度器，字符串解码</description><pubDate>Sat, 14 Jun 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;任务调度器&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给你一个用字符数组 &lt;code&gt;tasks&lt;/code&gt; 表示的 CPU 需要执行的任务列表，用字母 A 到 Z 表示，以及一个冷却时间 &lt;code&gt;n&lt;/code&gt;。每个周期或时间间隔允许完成一项任务。任务可以按任何顺序完成，但有一个限制：两个 &lt;strong&gt;相同种类&lt;/strong&gt; 的任务之间必须有长度为 &lt;code&gt;n&lt;/code&gt; 的冷却时间。&lt;/p&gt;
&lt;p&gt;返回完成所有任务所需要的 &lt;strong&gt;最短时间间隔&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;**输入：**tasks = [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;], n = 2&lt;/p&gt;
&lt;p&gt;**输出：**8&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解释：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在完成任务 A 之后，你必须等待两个间隔。对任务 B 来说也是一样。在第 3 个间隔，A 和 B 都不能完成，所以你需要待命。在第 4 个间隔，由于已经经过了 2 个间隔，你可以再次执行 A 任务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;**输入：**tasks = [&quot;A&quot;,&quot;C&quot;,&quot;A&quot;,&quot;B&quot;,&quot;D&quot;,&quot;B&quot;], n = 1&lt;/p&gt;
&lt;p&gt;**输出：**6&lt;/p&gt;
&lt;p&gt;**解释：**一种可能的序列是：A -&amp;gt; B -&amp;gt; C -&amp;gt; D -&amp;gt; A -&amp;gt; B。&lt;/p&gt;
&lt;p&gt;由于冷却间隔为 1，你可以在完成另一个任务后重复执行这个任务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 3：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;**输入：**tasks = [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;], n = 3&lt;/p&gt;
&lt;p&gt;**输出：**10&lt;/p&gt;
&lt;p&gt;**解释：**一种可能的序列为：A -&amp;gt; B -&amp;gt; idle -&amp;gt; idle -&amp;gt; A -&amp;gt; B -&amp;gt; idle -&amp;gt; idle -&amp;gt; A -&amp;gt; B。&lt;/p&gt;
&lt;p&gt;只有两种任务类型，A 和 B，需要被 3 个间隔分割。这导致重复执行这些任务的间隔当中有两次待命状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= tasks.length &amp;lt;= 104&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tasks[i]&lt;/code&gt; 是大写英文字母&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= n &amp;lt;= 100&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;p&gt;建立一个长度为26的数组存储各个任务出现的次数，因为人物之间等效，直接用sort进行排序，从最后一个数组元素取出最多任务出现的次数，再从后向前依次遍历得出出现次数最多的任务数量，利用下图进行求解（将任务出现次数最多的任务先进行排列，让剩余的任务进行填充）注意这里是最大任务数的空位多余可以填空的情况&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/190.png&quot; alt=&quot;190&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public int leastInterval(char[] tasks, int n) {
        int[] array = new int[26];
        for(char c : tasks) {
            array[c - &apos;A&apos;]++;
        }
        Arrays.sort(array);
        int maxTimes = array[25];
        int maxCount = 1;
        for(int i = 24; i &amp;gt;= 0; i--) {
            if(array[i] == array[i + 1]) {
                maxCount++;
            } else {
                break;
            }
        }
        int result = (maxTimes - 1) * (n + 1) + maxCount;
        return Math.max(result, tasks.length);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此外，如果任务种类很多，在安排时无需冷却时间，只需要在一个任务的两次出现间填充其他任务，然后从左到右从上到下依次执行即可，由于每一个任务占用一个时间单位，我们又正正好好地使用了tasks中的所有任务，而且我们只使用tasks中的任务来占用方格（没用冷却时间）。因此这种情况下，所需要的时间即为tasks的长度。&lt;/p&gt;
&lt;p&gt;由于这种情况时再用上述公式计算会得到一个不正确且偏小的结果，因此，我们只需把公式计算的结果和tasks的长度取最大即为最终结果。&lt;/p&gt;
&lt;h1&gt;字符串解码&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给定一个经过编码的字符串，返回它解码后的字符串。&lt;/p&gt;
&lt;p&gt;编码规则为: &lt;code&gt;k[encoded_string]&lt;/code&gt;，表示其中方括号内部的 &lt;code&gt;encoded_string&lt;/code&gt; 正好重复 &lt;code&gt;k&lt;/code&gt; 次。注意 &lt;code&gt;k&lt;/code&gt; 保证为正整数。&lt;/p&gt;
&lt;p&gt;你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。&lt;/p&gt;
&lt;p&gt;此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 &lt;code&gt;k&lt;/code&gt; ，例如不会出现像 &lt;code&gt;3a&lt;/code&gt; 或 &lt;code&gt;2[4]&lt;/code&gt; 的输入。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：s = &quot;3[a]2[bc]&quot;
输出：&quot;aaabcbc&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：s = &quot;3[a2[c]]&quot;
输出：&quot;accaccacc&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 3：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：s = &quot;2[abc]3[cd]ef&quot;
输出：&quot;abcabccdcdcdef&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 4：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：s = &quot;abc3[cd]xyz&quot;
输出：&quot;abccdcdcdxyz&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;p&gt;运用递归求解，当前字符为数字的时候 count = count * 10 + (c - &apos;0&apos;) 计算重复次数，为 [ 的时候跳过，并递归地进行解码子字符串，并在最后重复子字符串count次，为 ] 的时候返回字符串，并跳过，其余情况为普通字符串，直接拼接到结果上即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    private int index = 0;
    
    public String decodeString(String s) {
        StringBuilder result = new StringBuilder();
        int count = 0;
        while(index &amp;lt; s.length()) {
            char c = s.charAt(index);
            if(c &amp;gt;= &apos;0&apos; &amp;amp;&amp;amp; c &amp;lt;= &apos;9&apos;) {
                index++;
                count = count * 10 + (c - &apos;0&apos;);
            } else if(c == &apos;[&apos;) {
                index++;
                String subString = decodeString(s);
                for(int i = 0; i &amp;lt; count; i++) {
                    result.append(subString);
                }
                count = 0;
            } else if(c == &apos;]&apos;) {
                index++;
                return result.toString();
            } else {
                index++;
                result.append(c);
            }
        }
        return result.toString();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这一题也是字节面试的算法题目（有所变化），虽然改了一小部分，但感觉还是字节地题目更加综合一点，[abc]{3}大概是这样的，需要得到字符串后再进行字符的重复而且需要处理{}&lt;/p&gt;
</content:encoded></item><item><title>LeetCode刷题（数组第K大元素）</title><link>https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E6%95%B0%E7%BB%84%E7%9A%84%E7%AC%ACk%E5%A4%A7%E5%85%83%E7%B4%A0/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E6%95%B0%E7%BB%84%E7%9A%84%E7%AC%ACk%E5%A4%A7%E5%85%83%E7%B4%A0/</guid><description>数组第K大元素</description><pubDate>Fri, 13 Jun 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;数组的第K大元素&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给定整数数组 &lt;code&gt;nums&lt;/code&gt; 和整数 &lt;code&gt;k&lt;/code&gt;，请返回数组中第 &lt;code&gt;**k**&lt;/code&gt; 个最大的元素。&lt;/p&gt;
&lt;p&gt;请注意，你需要找的是数组排序后的第 &lt;code&gt;k&lt;/code&gt; 个最大的元素，而不是第 &lt;code&gt;k&lt;/code&gt; 个不同的元素。&lt;/p&gt;
&lt;p&gt;你必须设计并实现时间复杂度为 &lt;code&gt;O(n)&lt;/code&gt; 的算法解决此问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入: [3,2,1,5,6,4], k = 2
输出: 5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入: [3,2,3,1,2,4,5,5,6], k = 4
输出: 4
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;p&gt;我们先来回顾一下数组的快速排序，我们的目的是在其基础上进行修改&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public int[] sortArray(int[] nums) {
        quickSort(nums, 0, nums.length - 1);
        return nums;
    }

    public void quickSort(int[] nums, int left, int right) {
        if(left &amp;gt;= right) {
            return;
        }
        int mid = partition(nums, left, right); 
        quickSort(nums, left, mid - 1);
        quickSort(nums, mid + 1, right);
    }

    public int partition(int[] nums, int left, int right) {
        int midNum = nums[left];
        int i = left + 1;
        int j = right;
        while(i &amp;lt;= j) {
            while(i &amp;lt;= j &amp;amp;&amp;amp; nums[i] &amp;lt; midNum) {
                i++;
            }
            while(i &amp;lt;= j &amp;amp;&amp;amp; nums[j] &amp;gt; midNum) {
                j--;
            }
            if(i &amp;lt;= j) {
                swap(nums, i, j);
                i++;
                j--;
            }
        }
        swap(nums, j, left);
        return j;
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们的partition方法和swap方法都可以复用，只需要修改Quick功能函数的逻辑即可，在快速排序中我们需要对于所选择中间值的左右两侧同时进行递归排序&lt;/p&gt;
&lt;p&gt;而在快速选择排序中我们可以先对于得到的所选值进行判断，如果是选择值的索引位置是我们需要的目标索引直接返回即可，因为左右两侧虽然没有排序完毕，但因为左边的值都是小于选取目标，右边同理，选择值的索引位置与排序过后的位置相同&lt;/p&gt;
&lt;p&gt;索引不一致的时候，递归选择一侧重新调用partition选取值即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public int findKthLargest(int[] nums, int k) {
        int target = nums.length - k;
        return quickSelect(nums, 0, nums.length - 1, target);
    }

    public int quickSelect(int[] nums, int left, int right, int target) {
        if(left == right) {
            return nums[left];
        }
        int mid = partition(nums, left, right);
        if(mid == target) {
            return nums[mid];
        } else if(mid &amp;lt; target) {
            return quickSelect(nums, mid + 1, right, target);
        } else {
            return quickSelect(nums, left, mid - 1, target);
        }
    }

    public int partition(int[] nums, int left, int right) {
        int midNum = nums[left];
        int i = left + 1;
        int j = right;
        while(i &amp;lt;= j) {
            while(i &amp;lt;= j &amp;amp;&amp;amp; nums[i] &amp;lt; midNum) {
                i++;
            }
            while(i &amp;lt;= j &amp;amp;&amp;amp; nums[j] &amp;gt; midNum) {
                j--;
            }
            if(i &amp;lt;= j) {
                swap(nums, i, j);
                i++;
                j--;
            }
        }
        swap(nums, j, left);
        return j;
    }

    public void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>MyBatis笔记（Web项目使用MyBatis）</title><link>https://thrinisty.github.io/posts/mybatis%E7%AC%94%E8%AE%B0web%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8mybatis/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/mybatis%E7%AC%94%E8%AE%B0web%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8mybatis/</guid><description>Web项目使用MyBatis</description><pubDate>Fri, 13 Jun 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;MyBatis笔记&lt;/h1&gt;
&lt;p&gt;今天我们用web使用以下MyBatis，顺便复习一下JavaWeb&lt;/p&gt;
&lt;p&gt;用Maven Archetype创建一个Web工程&lt;/p&gt;
&lt;p&gt;手动更新以下web.xml&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!--
  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the &quot;License&quot;); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
--&amp;gt;
&amp;lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee
                      http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;
         metadata-complete=&quot;false&quot;&amp;gt;
&amp;lt;/web-app&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;:::warning&lt;/p&gt;
&lt;p&gt;注意这里 metadata-complete=&quot;true&quot;不支持注解式Servlet，需要改为false&lt;/p&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;p&gt;添加一些Maven依赖&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&amp;gt;
  &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
  &amp;lt;groupId&amp;gt;com.thrinisty&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;mybatis-003&amp;lt;/artifactId&amp;gt;
  &amp;lt;packaging&amp;gt;war&amp;lt;/packaging&amp;gt;
  &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
  &amp;lt;name&amp;gt;mybatis-003 Maven Webapp&amp;lt;/name&amp;gt;
  &amp;lt;url&amp;gt;http://maven.apache.org&amp;lt;/url&amp;gt;

  &amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;javax.servlet&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;javax.servlet-api&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;4.0.1&amp;lt;/version&amp;gt;
      &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;8.0.33&amp;lt;/version&amp;gt; &amp;lt;!-- 可替换为最新版本 --&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;3.5.13&amp;lt;/version&amp;gt; &amp;lt;!-- 以最新版本为准 --&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;ch.qos.logback&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;logback-classic&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;1.5.13&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
  &amp;lt;/dependencies&amp;gt;
  &amp;lt;build&amp;gt;
    &amp;lt;finalName&amp;gt;mybatis-003&amp;lt;/finalName&amp;gt;
  &amp;lt;/build&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;bean对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Account {
    private int id;
    private String actno;
    private double balance;
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;前端页面&lt;/h2&gt;
&lt;p&gt;前端转账页面&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;银行账户转账&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;form action=&quot;/bank/transfer&quot; method=&quot;post&quot;&amp;gt;
    转出账号：&amp;lt;input type=&quot;text&quot; name=&quot;fromActno&quot;&amp;gt;&amp;lt;br/&amp;gt;
    转出账号：&amp;lt;input type=&quot;text&quot; name=&quot;toActno&quot;&amp;gt;&amp;lt;br/&amp;gt;
    转出金额：&amp;lt;input type=&quot;text&quot; name=&quot;money&quot;&amp;gt;&amp;lt;br/&amp;gt;
    &amp;lt;input type=&quot;submit&quot; value=&quot;转账&quot;&amp;gt;
&amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Servlet程序&lt;/h2&gt;
&lt;p&gt;Servlet程序，运用web.xml进行配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;servlet&amp;gt;
    &amp;lt;servlet-name&amp;gt;test&amp;lt;/servlet-name&amp;gt;
    &amp;lt;servlet-class&amp;gt;com.bank.web.AccountServlet&amp;lt;/servlet-class&amp;gt;
&amp;lt;/servlet&amp;gt;
&amp;lt;servlet-mapping&amp;gt;
    &amp;lt;servlet-name&amp;gt;test&amp;lt;/servlet-name&amp;gt;
    &amp;lt;url-pattern&amp;gt;/transfer&amp;lt;/url-pattern&amp;gt;
&amp;lt;/servlet-mapping&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public class AccountServlet extends HttpServlet {
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        String fromAccount = req.getParameter(&quot;fromActno&quot;);
        String toAccount = req.getParameter(&quot;toActno&quot;);
        double amount = Double.parseDouble(req.getParameter(&quot;money&quot;));

        //创建服务层转账服务
        AccountService service = new AccountServiceImpl();
        try {
            service.transter(fromAccount, toAccount, amount);
            //调用视图完成展示结果
            resp.sendRedirect(req.getContextPath() + &quot;/success.html&quot;);
        } catch (MoneyNotEnoughException e) {
            resp.sendRedirect(req.getContextPath() + &quot;/error1.html&quot;);
            System.out.println(&quot;余额不足&quot;);
        } catch (TransferException e) {
            resp.sendRedirect(req.getContextPath() + &quot;/error2.html&quot;);
            System.out.println(&quot;转账失败&quot;);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;服务层&lt;/h2&gt;
&lt;p&gt;AccountService类，其中用到了AccountDaoImpl的数据操作对象实现类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class AccountServiceImpl implements AccountService {
    @Override
    public void transter(String fromActno, String toActno, double money) throws MoneyNotEnoughException {
        AccountDao accountDao = new AccountDaoImpl();
        //判断转出账户余额是否充足（select）
        Account fromAccount = accountDao.selectAccount(fromActno);
        if (fromAccount != null &amp;amp;&amp;amp; money &amp;gt; fromAccount.getBalance()) {
            throw new MoneyNotEnoughException(&quot;余额不足&quot;);
        }
        //判断转出余额不足，提示用户
        //账户余额充足，更新转出账户（update）
        Account toAccount = accountDao.selectAccount(toActno);
        fromAccount.setBalance(fromAccount.getBalance() - money);
        toAccount.setBalance(toAccount.getBalance() + money);

        //更新转出账户余额（update）
        boolean flag1 = accountDao.updateAccount(fromAccount);
        boolean flag2 = accountDao.updateAccount(toAccount);
        if(!flag1 || !flag2){
            throw new TransferException(&quot;转账异常&quot;);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Dao&lt;/h2&gt;
&lt;h3&gt;MyBatis相关配置&lt;/h3&gt;
&lt;p&gt;mybatis-config.xml&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&amp;gt;
&amp;lt;configuration&amp;gt;
&amp;lt;!--    &amp;lt;settings&amp;gt;--&amp;gt;
&amp;lt;!--        &amp;lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&amp;gt;--&amp;gt;
&amp;lt;!--    &amp;lt;/settings&amp;gt;--&amp;gt;
    &amp;lt;environments default=&quot;dev&quot;&amp;gt;
        &amp;lt;environment id=&quot;dev&quot;&amp;gt;
            &amp;lt;transactionManager type=&quot;JDBC&quot;/&amp;gt;
            &amp;lt;dataSource type=&quot;POOLED&quot;&amp;gt;
                &amp;lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&amp;gt;
                &amp;lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;amp;amp;serverTimezone=UTC&quot;/&amp;gt;
                &amp;lt;property name=&quot;username&quot; value=&quot;root&quot;/&amp;gt;
                &amp;lt;property name=&quot;password&quot; value=&quot;654321&quot;/&amp;gt;
            &amp;lt;/dataSource&amp;gt;
        &amp;lt;/environment&amp;gt;

    &amp;lt;/environments&amp;gt;
    &amp;lt;mappers&amp;gt;
&amp;lt;!--        用于编写SQL语句的文件--&amp;gt;
        &amp;lt;mapper resource=&quot;AccountMapper.xml&quot;/&amp;gt;
    &amp;lt;/mappers&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;AccountMapper.xml&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&amp;gt;
&amp;lt;mapper namespace=&quot;AccountMapper&quot;&amp;gt;
    &amp;lt;select id=&quot;selectAccount&quot; resultType=&quot;com.bank.bean.Account&quot;&amp;gt;
        select * from t_act where actno = #{actno};
    &amp;lt;/select&amp;gt;
    &amp;lt;update id=&quot;updateAccount&quot;&amp;gt;
        update t_act set balance = #{balance} where actno = #{actno};
    &amp;lt;/update&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Dao使用&lt;/h3&gt;
&lt;p&gt;Account数据操作对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class AccountDaoImpl implements AccountDao {
    @Override
    public Account selectAccount(String actno) {
        SqlSession sqlSession = SqlSessionUtil.getSqlSession();
        Account account = (Account) sqlSession.selectOne(&quot;AccountMapper.selectAccount&quot;, actno);
        sqlSession.close();
        return account;
    }

    @Override
    public boolean updateAccount(Account act) {
        SqlSession sqlSession = SqlSessionUtil.getSqlSession();
        int update = sqlSession.update(&quot;AccountMapper.updateAccount&quot;, act);
        sqlSession.commit();
        sqlSession.close();
        return update == 1;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Utils工具类&lt;/h2&gt;
&lt;p&gt;用到的工具类，目的是获取到SqlSession对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class SqlSessionUtil {
    private static SqlSessionFactory sqlSessionFactory;
    static {
        try {
            sqlSessionFactory = new SqlSessionFactoryBuilder()
                    .build(Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;));
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    private SqlSessionUtil() {}
    public static SqlSession getSqlSession() {
        return sqlSessionFactory.openSession();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;事务处理&lt;/h2&gt;
&lt;p&gt;我们在上述处理中，如果在更新两个账户信息的中间发送异常，不会发生回滚，转出账户中的钱财消失，而转入账户的金额不变&lt;/p&gt;
&lt;p&gt;我看教程中使用TreadLocal解决的，大体思路是运用线程使得操作共享一个SqlSession对象&lt;/p&gt;
&lt;p&gt;但我没有学过TreadLocal，我的解决方法是重写写了一个方法，在方法中更新两个账户，并记录成功与否，如果其中有一个没有成功进行rollback回滚，否则提交并返回true&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
public boolean updateTowAccount(Account act1, Account act2) {
    SqlSession sqlSession = SqlSessionUtil.getSqlSession();
    int update1 = sqlSession.update(&quot;AccountMapper.updateAccount&quot;, act1);
    int update2 = sqlSession.update(&quot;AccountMapper.updateAccount&quot;, act2);
    if (update1 == 1 &amp;amp;&amp;amp; update2 == 1) {
        sqlSession.commit();
        sqlSession.close();
        return true;
    }
    sqlSession.rollback();
    sqlSession.close();
    return false;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;int update1 = sqlSession.update(&quot;AccountMapper.updateAccount&quot;, act1);
if (true) {
    throw new TransferException();
}
int update2 = sqlSession.update(&quot;AccountMapper.updateAccount&quot;, act2);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;模拟一下异常，好像没什么问题，这样做也可以解决事务回滚，之后找机会补一下TreadLocal&lt;/p&gt;
&lt;h2&gt;MyBatis三大对象生命周期&lt;/h2&gt;
&lt;p&gt;SqlSessionBuilder：执行结束即可被销毁，任务只是创建SqlSessionFactory，之后没有用处，这也是为什么不用单独的遍历存储SqlSessionBuilder&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sqlSessionFactory = new SqlSessionFactoryBuilder()
                    .build(Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;SqlSessionFactory：一旦创建就应该在应用运行期间一直存在，没有任何理由丢弃或新建另一个SqlSessionFactory实例对象，这也是为什么Util工具类封装的时候用静态代码块初始创建SqlSessionFactory对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static {
    try {
        sqlSessionFactory = new SqlSessionFactoryBuilder()
                .build(Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;));
    } catch (IOException e) {
        throw new RuntimeException(e);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;SqlSession：每个线程都应该有自己的SqlSession对象，SqlSession的实例不是线程安全的，因此不可以被共享，在finally语句块中关闭&lt;/p&gt;
&lt;p&gt;明天进入javassist生产类的学习，它可以帮助我们生成Dao对象&lt;/p&gt;
</content:encoded></item><item><title>LeetCode刷题（盛水最多的容器，数组的第K大元素）</title><link>https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8/</guid><description>盛水最多的容器</description><pubDate>Thu, 12 Jun 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;盛水最多的容器&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给定一个长度为 &lt;code&gt;n&lt;/code&gt; 的整数数组 &lt;code&gt;height&lt;/code&gt; 。有 &lt;code&gt;n&lt;/code&gt; 条垂线，第 &lt;code&gt;i&lt;/code&gt; 条线的两个端点是 &lt;code&gt;(i, 0)&lt;/code&gt; 和 &lt;code&gt;(i, height[i])&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;找出其中的两条线，使得它们与 &lt;code&gt;x&lt;/code&gt; 轴共同构成的容器可以容纳最多的水。&lt;/p&gt;
&lt;p&gt;返回容器可以储存的最大水量。&lt;/p&gt;
&lt;p&gt;**说明：**你不能倾斜容器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/189.jpg&quot; alt=&quot;189&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：height = [1,1]
输出：1
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;p&gt;和之前接雨水的题目类似，通过两个指针，比较取小的那一个计算出当前结果进行对于结果迭代，直到两个指针重合&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public int maxArea(int[] height) {
        int left = 0;
        int right = height.length - 1;
        int result = 0;
        while(left &amp;lt; right) {
            if(height[left] &amp;lt; height[right]) {
                result = Math.max(result, (right - left) * height[left]);
                left++;
            } else {
                result = Math.max(result, (right - left) * height[right]);
                right--;
            }
        }
        return result;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>LeetCode刷题（最小栈）</title><link>https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E6%9C%80%E5%B0%8F%E6%A0%88/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E6%9C%80%E5%B0%8F%E6%A0%88/</guid><description>最小栈实现</description><pubDate>Wed, 11 Jun 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;最小栈&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;设计一个支持 &lt;code&gt;push&lt;/code&gt; ，&lt;code&gt;pop&lt;/code&gt; ，&lt;code&gt;top&lt;/code&gt; 操作，并能在常数时间内检索到最小元素的栈。&lt;/p&gt;
&lt;p&gt;实现 &lt;code&gt;MinStack&lt;/code&gt; 类:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;MinStack()&lt;/code&gt; 初始化堆栈对象。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void push(int val)&lt;/code&gt; 将元素val推入堆栈。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void pop()&lt;/code&gt; 删除堆栈顶部的元素。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int top()&lt;/code&gt; 获取堆栈顶部的元素。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int getMin()&lt;/code&gt; 获取堆栈中的最小元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：
[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]
[[],[-2],[0],[-3],[],[],[],[]]

输出：
[null,null,null,null,-3,null,0,-2]

解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --&amp;gt; 返回 -3.
minStack.pop();
minStack.top();      --&amp;gt; 返回 0.
minStack.getMin();   --&amp;gt; 返回 -2.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;p&gt;这一道题是我同学的面试题目，他给我讲的时候我有些摸不清头脑，看了题解后清晰多了，主要的要点就是创建一个最小栈的结构辅助主栈中最小值的存储&lt;/p&gt;
&lt;p&gt;这个最小栈在主栈元素入站的时判断元素是否为最小元素亦或者最小栈中没有元素，如果符合情况进行入最小栈&lt;/p&gt;
&lt;p&gt;在pop弹出的时候，判断主栈弹出的元素是否等与最小栈栈顶的元素，满足的pop最小栈&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class MinStack {
    private Stack&amp;lt;Integer&amp;gt; stack;
    private Stack&amp;lt;Integer&amp;gt; minStack;
    public MinStack() {
        stack = new Stack&amp;lt;&amp;gt;();
        minStack = new Stack&amp;lt;&amp;gt;();
    }
    
    public void push(int val) {
        stack.push(val);
        if(minStack.isEmpty() || val &amp;lt;= minStack.peek()) {
            minStack.push(val);
        }
    }
    
    public void pop() {
        int num = stack.pop();
        if(num == minStack.peek()) {
            minStack.pop();
        }
    }
    
    public int top() {
        return stack.peek();
    }
    
    public int getMin() {
        return minStack.peek();
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>MyBatis笔记（CRUD，核心配置）</title><link>https://thrinisty.github.io/posts/mybatis%E7%AC%94%E8%AE%B0crud%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/mybatis%E7%AC%94%E8%AE%B0crud%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE/</guid><description>MyBatis增删改查，MyBatis核心配置</description><pubDate>Wed, 11 Jun 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;MyBatis笔记&lt;/h1&gt;
&lt;p&gt;昨天编写了一个MyBatis的入门程序，成功的让他跑了起来，今天使用MyBatis更加深入的部分&lt;/p&gt;
&lt;h2&gt;MyBatis工具类&lt;/h2&gt;
&lt;p&gt;我们可以封装一个工具类，便于我们获取到Session对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.batis.utils;

import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;

import java.io.IOException;

public class SqlSessionUtil {
    private static SqlSessionFactory sqlSessionFactory;
    static {
        try {
            sqlSessionFactory = new SqlSessionFactoryBuilder()
                    .build(Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;));
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
    
    private SqlSessionUtil() {}
    public static SqlSession getSqlSession() {
        return sqlSessionFactory.openSession();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试程序，可以看到代码简洁许多&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void testUtil() {
    SqlSession sqlSession = SqlSessionUtil.getSqlSession();
    int update = sqlSession.delete(&quot;deleteValue&quot;);
    System.out.println(update);
    sqlSession.commit();
    sqlSession.close();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;CRUD增删改查&lt;/h2&gt;
&lt;p&gt;在之前的时候，我们写死了插入数据和删除数据，而在实际使用的时候，我们需要的应该是代填项，等待我们插入对应数据，如JDBC中的?&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;mapper namespace=&quot;com.example.mapper.UserMapper&quot;&amp;gt;
    &amp;lt;insert id=&quot;insertValue&quot;&amp;gt;
        insert into t_car values
        (4, 301, &quot;大众&quot;, 32.00, &quot;2022-09-01&quot;, &quot;燃油车&quot;);
    &amp;lt;/insert&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再MyBatis中等效的写法应该是 #{} 代替JDBC中的 ?&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;mapper namespace=&quot;com.example.mapper.UserMapper&quot;&amp;gt;
    &amp;lt;insert id=&quot;insertValue&quot;&amp;gt;
        insert into t_car values
        (null, #{}, #{}, #{}, #{}, #{});
    &amp;lt;/insert&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Insert&lt;/h3&gt;
&lt;h4&gt;Map传入参数&lt;/h4&gt;
&lt;p&gt;另外的insert方法可以传入一个map对象，进行上述空格的赋值，在核心配置文件中的{}中填入key值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;insert id=&quot;insertValue&quot;&amp;gt;
    insert into t_car values
    (null, #{k1}, #{k2}, #{k3}, #{k4}, #{k5});
&amp;lt;/insert&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void testInsert() {
    SqlSession sqlSession = SqlSessionUtil.getSqlSession();
    Map&amp;lt;String, Object&amp;gt; map = new HashMap&amp;lt;String, Object&amp;gt;();
    map.put(&quot;k1&quot;, 401);
    map.put(&quot;k2&quot;, &quot;比亚迪&quot;);
    map.put(&quot;k3&quot;, 42.00);
    map.put(&quot;k4&quot;, LocalDate.of(2010, 12, 10));
    map.put(&quot;k5&quot;, &quot;电车&quot;);
    int i = sqlSession.insert(&quot;insertValue&quot;, map);
    sqlSession.commit();
    sqlSession.close();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;Bean传入参数&lt;/h4&gt;
&lt;p&gt;我们构造一个JavaBean对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Car {
    private Integer id;
    private String car_num;
    private String brand;
    private double guide_price;
    private LocalDate produce_time;
    private String car_type;
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在配置中的{}中传入Bean对象的属性名，其实是找getXxx方法获取参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;insert id=&quot;insertValue&quot;&amp;gt;
    insert into t_car values
    (null, #{car_num}, #{brand}, #{guide_price}, #{produce_time}, #{car_type});
&amp;lt;/insert&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void testInsertBean() {
    SqlSession sqlSession = SqlSessionUtil.getSqlSession();
    Car car = new Car(null, &quot;501&quot;, &quot;奔驰&quot;, 21.00,
            LocalDate.of(2010, 12, 10), &quot;新能源&quot;);
    int i = sqlSession.insert(&quot;insertValue&quot;, car);
    sqlSession.commit();
    sqlSession.close();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Delete&lt;/h3&gt;
&lt;p&gt;核心配置，这里的参数只有一个，#{}可以随便写一个，例如id&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;delete id=&quot;deleteValueById&quot;&amp;gt;
    delete from t_car where id = #{id};
&amp;lt;/delete&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;传入id即可，这里会自动封装&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void testDelete() {
    SqlSession sqlSession = SqlSessionUtil.getSqlSession();
    sqlSession.delete(&quot;deleteValueById&quot;, 1);
    sqlSession.commit();
    sqlSession.close();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Update&lt;/h3&gt;
&lt;p&gt;和插入一致，传入car对象，通过用属性名，调用get方法获取参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;update id=&quot;updateValueById&quot;&amp;gt;
    update t_car set car_num = #{car_num}, brand = #{brand}, guide_price = #{guide_price}, produce_time = #{produce_time},car_type = #{car_type} where id = #{id};
&amp;lt;/update&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void testUpdate() {
    SqlSession sqlSession = SqlSessionUtil.getSqlSession();
    Car car = new Car(3, &quot;100&quot;, &quot;奔驰_new&quot;, 21.00,
            LocalDate.of(2010, 12, 10), &quot;旧能源&quot;);
    sqlSession.delete(&quot;updateValueById&quot;, car);
    sqlSession.commit();
    sqlSession.close();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Select&lt;/h3&gt;
&lt;h4&gt;单个记录&lt;/h4&gt;
&lt;p&gt;在返回结果时需要用resultType指定映射的Bean对象全类名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;select id=&quot;selectById&quot; resultType=&quot;com.bean.Car&quot;&amp;gt;
    select * from t_car where id = #{id};
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用一个Object对象返回结果对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void testSelect() {
    SqlSession sqlSession = SqlSessionUtil.getSqlSession();
    Object object = sqlSession.selectOne(&quot;selectById&quot;, 3);
    System.out.println(object);
    sqlSession.commit();
    sqlSession.close();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Car{id=3, car_num=&apos;100&apos;, brand=&apos;奔驰_new&apos;, guide_price=21.0, produce_time=2010-12-10, car_type=&apos;旧能源&apos;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外这里我用的Bean对象属性值，对应着数据表的字段（名字一致），如果名称不一致，我们需要使用AS通过别名映射Bean对象属性，才可以正确对Object赋值，否则为null&lt;/p&gt;
&lt;h4&gt;所有记录&lt;/h4&gt;
&lt;p&gt;编写SQL语句&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;select id=&quot;selectAll&quot; resultType=&quot;com.bean.Car&quot;&amp;gt;
    select * from t_car;
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试程序中通过selectList返回对象结果集合&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void testSelectALL() {
    SqlSession sqlSession = SqlSessionUtil.getSqlSession();
    List&amp;lt;Object&amp;gt; list = sqlSession.selectList(&quot;selectAll&quot;);
    for (Object object : list) {
        System.out.println(object);
    }
    sqlSession.commit();
    sqlSession.close();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;namespace&lt;/h3&gt;
&lt;p&gt;我们在核心配置中引入两个Mapper配置，其中有id相同的两个SQL语句，我们要区别他们，在使用的时候通过namespace进行区分&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;mapper namespace=&quot;CarMapper&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void testSelectALL() {
    SqlSession sqlSession = SqlSessionUtil.getSqlSession();
    List&amp;lt;Object&amp;gt; list = sqlSession.selectList(&quot;CarMapper.selectAll&quot;);
    //全写，命名空间 + SQL ID，以区分不同命名空间下的相同id
    for (Object object : list) {
        System.out.println(object);
    }
    sqlSession.commit();
    sqlSession.close();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;MyBatis核心配置&lt;/h2&gt;
&lt;h3&gt;多环境配置&lt;/h3&gt;
&lt;p&gt;在核心配置中，我们配置了两个环境，默认使用dev环境，还可以配置多个环境&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;environments default=&quot;dev&quot;&amp;gt;
    &amp;lt;environment id=&quot;dev&quot;&amp;gt;
        &amp;lt;transactionManager type=&quot;JDBC&quot;/&amp;gt;
        &amp;lt;dataSource type=&quot;POOLED&quot;&amp;gt;
            &amp;lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&amp;gt;
            &amp;lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;amp;amp;serverTimezone=UTC&quot;/&amp;gt;
            &amp;lt;property name=&quot;username&quot; value=&quot;root&quot;/&amp;gt;
            &amp;lt;property name=&quot;password&quot; value=&quot;654321&quot;/&amp;gt;
        &amp;lt;/dataSource&amp;gt;
    &amp;lt;/environment&amp;gt;
    &amp;lt;environment id=&quot;another&quot;&amp;gt;
        &amp;lt;transactionManager type=&quot;JDBC&quot;/&amp;gt;
        &amp;lt;dataSource type=&quot;POOLED&quot;&amp;gt;
            &amp;lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&amp;gt;
            &amp;lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/spring6?useSSL=false&amp;amp;amp;serverTimezone=UTC&quot;/&amp;gt;
            &amp;lt;property name=&quot;username&quot; value=&quot;root&quot;/&amp;gt;
            &amp;lt;property name=&quot;password&quot; value=&quot;654321&quot;/&amp;gt;
        &amp;lt;/dataSource&amp;gt;
    &amp;lt;/environment&amp;gt;
&amp;lt;/environments&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一个environment对应一个SqlSessionFactory对象&lt;/p&gt;
&lt;p&gt;一个数据库对应一个SqlSessionFactory对象&lt;/p&gt;
&lt;p&gt;在使用另一个环境的时候可以在build方法指定第二个参数，指定环境id&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sqlSessionFactory = new SqlSessionFactoryBuilder().build(Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;), &quot;another&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样得到的环境就是我们配置的名为another的环境，sql操作的数据库就是spring6数据库&lt;/p&gt;
&lt;h3&gt;数据源DataSource&lt;/h3&gt;
&lt;p&gt;通过数据源提供connection，也可以自己提供数据源，只要数据源实现数据源接口，提供connection对象&lt;/p&gt;
&lt;p&gt;type指定的就是数据源对象，三选一：UNPOOLED、POOLED、JNDI&lt;/p&gt;
&lt;p&gt;分别对应不使用连接池、使用连接池，使用外部第三方连接池&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dataSource type=&quot;POOLED&quot;&amp;gt;
    &amp;lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&amp;gt;
    &amp;lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;amp;amp;serverTimezone=UTC&quot;/&amp;gt;
    &amp;lt;property name=&quot;username&quot; value=&quot;root&quot;/&amp;gt;
    &amp;lt;property name=&quot;password&quot; value=&quot;654321&quot;/&amp;gt;
&amp;lt;/dataSource&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中JNDI是一套规范，大部分的Web容器都实现了JNDI规范，是Java命名目录接口&lt;/p&gt;
&lt;p&gt;使用不同的type其property一般不同，例如JNDI使用initial_context和data_source即可&lt;/p&gt;
&lt;h3&gt;POOLED参数配置&lt;/h3&gt;
&lt;p&gt;使用连接池的时候可以使用很多的property参数，以达到更好的使用效率&lt;/p&gt;
&lt;p&gt;之前在Druid连接池的配置文件中我们也使用到过&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;poolMaximumActiveConnections指定最多的使用连接对象的数量&lt;/p&gt;
&lt;p&gt;poolTimeToWait指定每间隔多少秒打印日志，并且尝试获取下一个连接&lt;/p&gt;
&lt;p&gt;poolMaximumCheckoutTime设置Connection的超时时间&lt;/p&gt;
&lt;p&gt;在课程中CRUD结束后还有一个手写MyBatis的部分，时间紧张我就先跳过了，明天在Web项目中使用以下MyBatis，顺便复习Web的html，Servlet部分的知识&lt;/p&gt;
</content:encoded></item><item><title>LeetCode刷题（合并K个升序链表）</title><link>https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/</guid><description>合并K个升序链表</description><pubDate>Tue, 10 Jun 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;合并K个升序链表&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给你一个链表数组，每个链表都已经按升序排列。&lt;/p&gt;
&lt;p&gt;请你将所有链表合并到一个升序链表中，返回合并后的链表。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1-&amp;gt;4-&amp;gt;5,
  1-&amp;gt;3-&amp;gt;4,
  2-&amp;gt;6
]
将它们合并到一个有序链表中得到。
1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5-&amp;gt;6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：lists = []
输出：[]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 3：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：lists = [[]]
输出：[]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;p&gt;解法一：&lt;/p&gt;
&lt;p&gt;之前做过一道合并两个链表的题目，尝试通过逐个取出集合中的链表进行合并&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        if(lists.length == 0 || lists == null) {
            return null;
        }
        ListNode result = null;
        for(ListNode list : lists) {
            result = mergeList(result, list);
        }
        return result;
    }

    public ListNode mergeList(ListNode listA, ListNode listB) {
        ListNode result = new ListNode();
        ListNode p = result;
        while(listA != null &amp;amp;&amp;amp; listB != null) {
            if(listA.val &amp;lt;= listB.val) {
                p.next = listA;
                listA = listA.next;
                p = p.next;
            } else {
                p.next = listB;
                listB = listB.next;
                p = p.next;
            }
        }
        p.next = listA == null ? listB : listA;
        return result.next;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;原本想着应该不可以通过测试用例之类的，但是竟然过了，只是执行速度非常缓慢，时间复杂度是O(N*k^2)，其中k是链表数量，N是平均链表长度&lt;/p&gt;
&lt;p&gt;解法二：归并排序，合并两个链表的方式和第一种一致&lt;/p&gt;
&lt;p&gt;可以用归并排序，递归地将链表两两合并，相比于第一种方式而言不用重复的合并result链表，节省了很多的时间，这一题用数组的方式给出链表应该也是鼓励使用这种方式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        if(lists.length == 0 || lists == null) return null;
        return merge(lists, 0, lists.length - 1);
    }

    public ListNode merge(ListNode[] lists, int left, int right) {
        if(left == right) {
            return lists[left];
        }
        int mid = left + (right - left) / 2;
        ListNode leftList = merge(lists, left, mid);
        ListNode rightList = merge(lists, mid + 1, right);
        return mergeList(leftList, rightList);
    }

    public ListNode mergeList(ListNode listA, ListNode listB) {
        ListNode result = new ListNode();
        ListNode p = result;
        while(listA != null &amp;amp;&amp;amp; listB != null) {
            if(listA.val &amp;lt;= listB.val) {
                p.next = listA;
                listA = listA.next;
                p = p.next;
            } else {
                p.next = listB;
                listB = listB.next;
                p = p.next;
            }
        }
        p.next = listA == null ? listB : listA;
        return result.next;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;虽然说这一题是困难，但是因为之前学习数据结构和算法的时候对于链表和分治的思想掌握比较牢靠，其实也不难理解，这道题是LeetCode100的第50道了，刷的还蛮快的嘛都一半了，继续加油！！&lt;/p&gt;
</content:encoded></item><item><title>MyBatis笔记（ORM思想，入门使用，集成日志）</title><link>https://thrinisty.github.io/posts/mybatis%E7%AC%94%E8%AE%B0orm%E6%80%9D%E6%83%B3%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8%E9%9B%86%E6%88%90%E6%97%A5%E5%BF%97/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/mybatis%E7%AC%94%E8%AE%B0orm%E6%80%9D%E6%83%B3%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8%E9%9B%86%E6%88%90%E6%97%A5%E5%BF%97/</guid><description>MyBatis的入门使用，MyBatis使用日志</description><pubDate>Tue, 10 Jun 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;MyBatis笔记&lt;/h1&gt;
&lt;p&gt;接下来的几天开始MyBatis的学习，用到的课程式动力节点杜老师的B站网课&lt;/p&gt;
&lt;p&gt;&amp;lt;iframe
width=&quot;100%&quot;
height=&quot;468&quot;
src=&quot;//player.bilibili.com/player.html?bvid=BV1JP4y1Z73S&amp;amp;p=1&amp;amp;autoplay=false&quot;
scrolling=&quot;no&quot;
border=&quot;0&quot;
frameborder=&quot;no&quot;
framespacing=&quot;0&quot;
allowfullscreen=&quot;true&quot;&amp;gt;
&amp;lt;/iframe&amp;gt;&lt;/p&gt;
&lt;p&gt;本来打算用尚硅谷的课程，但是18年的视频对现在来说以及太老了，jar包之类的都是通过手动引入的，非常的不方便，而且老师的课程也算是细康，讲的挺深入的&lt;/p&gt;
&lt;p&gt;话不多说开始今天的学习&lt;/p&gt;
&lt;h2&gt;ORM对象关系映射&lt;/h2&gt;
&lt;p&gt;O：Object，指的是JVM中的Java对象&lt;/p&gt;
&lt;p&gt;R：Relational，关系型数据库&lt;/p&gt;
&lt;p&gt;M：Mapping，映射&lt;/p&gt;
&lt;p&gt;例如现在有一张数据库表，其中有数条记录，其列字段可以对应到JavaBean类对象的属性，而每一行的记录映射到Java中就是一个类的实例，其中存在一种转换关系，其中的Class对象被称为 pojo、bean、domain&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/187.png&quot; alt=&quot;187&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/188.png&quot; alt=&quot;188&quot; /&gt;&lt;/p&gt;
&lt;p&gt;MyBatis是一个半自动化的ORM，因为MyBatis框架中的SQL语句需要程序员手动编写，而Hibernate是一个全自动的ORM&lt;/p&gt;
&lt;h2&gt;MyBatis入门使用&lt;/h2&gt;
&lt;p&gt;:::warning&lt;/p&gt;
&lt;p&gt;在MyBatis的配置一般通过XML文件实现，另外还有一种基于注解的开发&lt;/p&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;p&gt;相对于JDBC，MyBatis对于JDBC进行了封装，可以避免JDBC的一些缺陷，例如sql语句写死，违反OCP开闭原则&lt;/p&gt;
&lt;p&gt;另外对于?的赋值非常繁琐，通过反射机制可以轻松实现对象的复制，参数的传入&lt;/p&gt;
&lt;h3&gt;SQL建表&lt;/h3&gt;
&lt;p&gt;用SQL语句新建立一个数据库表&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create table t_car(
	id int primary key auto_increment,
	car_num varchar(100),
	brand varchar(100),
	guide_price decimal(20,2),
	produce_time date,
	car_type varchar(100)
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;插入若干条语句&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;insert into t_car values
(4, 301, &quot;大众&quot;, 32.00, &quot;2022-09-01&quot;, &quot;燃油车&quot;),
(5, 302, &quot;一汽&quot;, 42.00, &quot;2012-04-01&quot;, &quot;电车&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;使用步骤&lt;/h3&gt;
&lt;p&gt;1.引入相关依赖&lt;/p&gt;
&lt;p&gt;在使用的时候可以通过Maven进行MyBatis的导入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependencies&amp;gt;
    &amp;lt;!-- MySQL JDBC 驱动 --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;8.0.33&amp;lt;/version&amp;gt; &amp;lt;!-- 可替换为最新版本 --&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;3.5.13&amp;lt;/version&amp;gt; &amp;lt;!-- 以最新版本为准 --&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.从XML中构建SqlSessionFactory&lt;/p&gt;
&lt;p&gt;MyBatis中有一个对象SqlSessionFactory，其需要XML进行配置，其名称一般为mybatis-config.xml，其下有两个重要的配置，一个是数据库的配置信息，林一个是UserMapper.xml，专门用于编写SQL语句的配置文件（一般一个表格对应一个）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&amp;gt;
&amp;lt;configuration&amp;gt;
    &amp;lt;environments default=&quot;dev&quot;&amp;gt;
        &amp;lt;environment id=&quot;dev&quot;&amp;gt;
            &amp;lt;transactionManager type=&quot;JDBC&quot;/&amp;gt;
            &amp;lt;dataSource type=&quot;POOLED&quot;&amp;gt;
                &amp;lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&amp;gt;
                &amp;lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;amp;amp;serverTimezone=UTC&quot;/&amp;gt;
                &amp;lt;property name=&quot;username&quot; value=&quot;root&quot;/&amp;gt;
                &amp;lt;property name=&quot;password&quot; value=&quot;654321&quot;/&amp;gt;
            &amp;lt;/dataSource&amp;gt;
        &amp;lt;/environment&amp;gt;
    &amp;lt;/environments&amp;gt;
    &amp;lt;mappers&amp;gt;
&amp;lt;!--        用于编写SQL语句的文件--&amp;gt;
        &amp;lt;mapper resource=&quot;CarMapper.xml&quot;/&amp;gt;
    &amp;lt;/mappers&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.编写XxxMapper.xml文件&lt;/p&gt;
&lt;p&gt;在这个文件中编写SQL语句，并在config中指定这个文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&amp;gt;
&amp;lt;mapper namespace=&quot;com.example.mapper.UserMapper&quot;&amp;gt;
    &amp;lt;insert id=&quot;insertValue&quot;&amp;gt;
        insert into t_car values
        (5, 301, &quot;大众&quot;, 32.00, &quot;2022-09-01&quot;, &quot;燃油车&quot;);
    &amp;lt;/insert&amp;gt;
    &amp;lt;delete id=&quot;deleteValue&quot;&amp;gt;
        delete from t_car where id = 4 or id = 5;
    &amp;lt;/delete&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.编写MyBatis程序&lt;/p&gt;
&lt;p&gt;连接数据库，操作数据库&lt;/p&gt;
&lt;p&gt;:::note&lt;/p&gt;
&lt;p&gt;SqlSession是Java程序和MySQL数据库之间的会话&lt;/p&gt;
&lt;p&gt;SqlSession通过SqlSessionFactory创建&lt;/p&gt;
&lt;p&gt;SqlSessionFactoryBuilder对象的build方法可以获取到SqlSessionFactory对象&lt;/p&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class MyBatisIntroduction {
    public static void main(String[] args) throws Exception {
        SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();
        InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);//用工具类生成输入流对象
        //其本质是底层用系统的类加载器获取到文件的流对象
        SqlSessionFactory factory = builder.build(is);//传入输入流
        SqlSession sqlSession = factory.openSession();//通过工厂获得SqlSession
        int i = sqlSession.insert(&quot;insertValue&quot;);//传入Mapper中配置的sql语句id
        System.out.println(&quot;插入了&quot; + i + &quot;条记录&quot;);
        sqlSession.commit();//这里需要手动提交
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;数据被提交成功&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;插入了1条记录
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;:::tip&lt;/p&gt;
&lt;p&gt;一些MyBatis的小细节&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;MyBatis中的SQL语句结尾的 ; 可以被省略&lt;/li&gt;
&lt;li&gt;带Resources一般的都是从类根路径下开始加载数据&lt;/li&gt;
&lt;li&gt;传入流的时候也可以使用new FileInputStream，但是需要考虑操作系统&lt;/li&gt;
&lt;li&gt;在配置传入Mapper的时候也可以用 file:///+绝对路径 进行使用&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;h3&gt;事务管理机制&lt;/h3&gt;
&lt;p&gt;在之前的时候我们需要手动提交使用commit方法才可以正确的提交数据，这是取决于事务管理器的，除了JDBC还何以使用MANAGED（大小写都可以）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;transactionManager type=&quot;JDBC&quot;/&amp;gt;
&amp;lt;transactionManager type=&quot;MANAGED&quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;JDBC： MyBatis框架管理事务，用setAutoCommit(false)开启事务，commit()提交事务，两者都是在底层调用用连接对象的对应方法&lt;/p&gt;
&lt;p&gt;MANAGER： MyBatis不再负责管理事务，事务交付于其他容器负责，例如Spring，我们之后使用Spring集成MyBatis的时候可以使用，现在暂时不多介绍&lt;/p&gt;
&lt;p&gt;通过设置 openSession(true) 可以在底层指定自动提交为true&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class MyBatisIntroduction {
    public static void main(String[] args) throws Exception {
        SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();
        InputStream inputStream = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);
        SqlSessionFactory sqlSessionFactory = builder.build(inputStream);
        SqlSession sqlSession = sqlSessionFactory.openSession(true);
        int i = sqlSession.insert(&quot;insertValue&quot;);
        System.out.println(i);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在JDBC中默认的是true，自动提交，而在MyBatis中默认创建的sqlSession对象，是开启事务的，其自动提交属性为false（在底层会根据boolean的变量进行分支判断，false则会调用setAutoCommit(false)开启事务）&lt;/p&gt;
&lt;p&gt;在MyBatis的实际使用的时候，建议开启事务，在完成后提交&lt;/p&gt;
&lt;h3&gt;完整MyBatis程序&lt;/h3&gt;
&lt;p&gt;包括了异常处理，关闭session资源&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void main(String[] args) {
    SqlSession sqlSession = null;
    try {
        SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();
        SqlSessionFactory sqlSessionFactory = builder.build(Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;));
        sqlSession = sqlSessionFactory.openSession();
        int update = sqlSession.insert(&quot;insertValue&quot;);
        sqlSession.commit();
    } catch (Exception e) {
        if (sqlSession != null) {
            sqlSession.rollback();//发生异常使回滚
        }
        e.printStackTrace();
    } finally {
        if (sqlSession != null) {
            sqlSession.close();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;集成日志组件&lt;/h2&gt;
&lt;p&gt;可以对于MyBatis集成测试组件，使测试起来更加的方便&lt;/p&gt;
&lt;p&gt;常见的日志组件：SLF4J、LOG4J、STDOUT_LOGGING等，其中STDOUT_LOGGING是标准日志，MyBatis以及实现了这种标准日志，开启使用即可&lt;/p&gt;
&lt;p&gt;在MyBatis核心的配置文件中可以通过setting标签开启日志，注意这个标签应该在environments前面&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&amp;gt;
&amp;lt;configuration&amp;gt;
    
    &amp;lt;settings&amp;gt;
        &amp;lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&amp;gt;
    &amp;lt;/settings&amp;gt;
    
    &amp;lt;environments default=&quot;dev&quot;&amp;gt;
        &amp;lt;environment id=&quot;dev&quot;&amp;gt;
            &amp;lt;transactionManager type=&quot;JDBC&quot;/&amp;gt;
            &amp;lt;dataSource type=&quot;POOLED&quot;&amp;gt;
                &amp;lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&amp;gt;
                &amp;lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;amp;amp;serverTimezone=UTC&quot;/&amp;gt;
                &amp;lt;property name=&quot;username&quot; value=&quot;root&quot;/&amp;gt;
                &amp;lt;property name=&quot;password&quot; value=&quot;654321&quot;/&amp;gt;
            &amp;lt;/dataSource&amp;gt;
        &amp;lt;/environment&amp;gt;
    &amp;lt;/environments&amp;gt;
    &amp;lt;mappers&amp;gt;
&amp;lt;!--        用于编写SQL语句的文件--&amp;gt;
        &amp;lt;mapper resource=&quot;CarMapper.xml&quot;/&amp;gt;
    &amp;lt;/mappers&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个时候运行代码就会出现日志信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Opening JDBC Connection
Created connection 1144068272.
==&amp;gt;  Preparing: insert into t_car values (4, 301, &quot;大众&quot;, 32.00, &quot;2022-09-01&quot;, &quot;燃油车&quot;);
==&amp;gt; Parameters: 
&amp;lt;==    Updates: 1
1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;SLF4J日志组件&lt;/p&gt;
&lt;p&gt;如果想要更加详细的信息，还可以继承其他的组件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;settings&amp;gt;
    &amp;lt;setting name=&quot;logImpl&quot; value=&quot;SLF4J&quot;/&amp;gt;
&amp;lt;/settings&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;引入logback依赖&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;ch.qos.logback&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;logback-classic&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.4.11&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;引入xml配置文件logback.xml或logback-test.xml，在这里可以配置日志的相关信息，以及输出的方式 控制台输出 或者也可以 在文件中保存&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;configuration&amp;gt;

    &amp;lt;!-- 控制台输出 --&amp;gt;
    &amp;lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&amp;gt;
        &amp;lt;encoder&amp;gt;
            &amp;lt;pattern&amp;gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&amp;lt;/pattern&amp;gt;
        &amp;lt;/encoder&amp;gt;
    &amp;lt;/appender&amp;gt;

    &amp;lt;!-- 设置根日志级别 --&amp;gt;
    &amp;lt;root level=&quot;INFO&quot;&amp;gt;
        &amp;lt;appender-ref ref=&quot;STDOUT&quot; /&amp;gt;
    &amp;lt;/root&amp;gt;

    &amp;lt;!-- MyBatis SQL 日志 --&amp;gt;
    &amp;lt;logger name=&quot;org.apache.ibatis&quot; level=&quot;DEBUG&quot; /&amp;gt;

    &amp;lt;!-- MyBatis SQL 绑定参数日志 --&amp;gt;
    &amp;lt;logger name=&quot;org.apache.ibatis.logging.jdbc.BaseJdbcLogger&quot; level=&quot;TRACE&quot; /&amp;gt;

    &amp;lt;!-- 如果使用 MyBatis-Spring，可加上这条 --&amp;gt;
    &amp;lt;logger name=&quot;org.mybatis.spring&quot; level=&quot;DEBUG&quot; /&amp;gt;

&amp;lt;/configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SLF4J(I): Connected with provider of type [ch.qos.logback.classic.spi.LogbackServiceProvider]
2025-06-10 22:12:01.937 [main] DEBUG o.apache.ibatis.logging.LogFactory - Logging initialized using &apos;class org.apache.ibatis.logging.slf4j.Slf4jImpl&apos; adapter.
2025-06-10 22:12:01.940 [main] DEBUG o.apache.ibatis.logging.LogFactory - Logging initialized using &apos;class org.apache.ibatis.logging.slf4j.Slf4jImpl&apos; adapter.
2025-06-10 22:12:01.972 [main] DEBUG o.a.i.d.pooled.PooledDataSource - PooledDataSource forcefully closed/removed all connections.
2025-06-10 22:12:01.973 [main] DEBUG o.a.i.d.pooled.PooledDataSource - PooledDataSource forcefully closed/removed all connections.
2025-06-10 22:12:01.973 [main] DEBUG o.a.i.d.pooled.PooledDataSource - PooledDataSource forcefully closed/removed all connections.
2025-06-10 22:12:01.973 [main] DEBUG o.a.i.d.pooled.PooledDataSource - PooledDataSource forcefully closed/removed all connections.
2025-06-10 22:12:02.060 [main] DEBUG o.a.i.t.jdbc.JdbcTransaction - Opening JDBC Connection
2025-06-10 22:12:02.330 [main] DEBUG o.a.i.d.pooled.PooledDataSource - Created connection 271379554.
2025-06-10 22:12:02.330 [main] DEBUG o.a.i.t.jdbc.JdbcTransaction - Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@102cec62]
1
2025-06-10 22:12:02.354 [main] DEBUG o.a.i.t.jdbc.JdbcTransaction - Committing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@102cec62]
2025-06-10 22:12:02.364 [main] DEBUG o.a.i.t.jdbc.JdbcTransaction - Resetting autocommit to true on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@102cec62]
2025-06-10 22:12:02.364 [main] DEBUG o.a.i.t.jdbc.JdbcTransaction - Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@102cec62]
2025-06-10 22:12:02.365 [main] DEBUG o.a.i.d.pooled.PooledDataSource - Returned connection 271379554 to pool.
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>LeetCode刷题（电话号码的字母组合，打家劫舍）</title><link>https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</guid><description>电话号码的字母组合，打家劫舍</description><pubDate>Mon, 09 Jun 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;电话号码的字母组合&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给定一个仅包含数字 &lt;code&gt;2-9&lt;/code&gt; 的字符串，返回所有它能表示的字母组合。答案可以按 &lt;strong&gt;任意顺序&lt;/strong&gt; 返回。&lt;/p&gt;
&lt;p&gt;给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/184.png&quot; alt=&quot;184&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：digits = &quot;23&quot;
输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：digits = &quot;&quot;
输出：[]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 3：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：digits = &quot;2&quot;
输出：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= digits.length &amp;lt;= 4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;digits[i]&lt;/code&gt; 是范围 &lt;code&gt;[&apos;2&apos;, &apos;9&apos;]&lt;/code&gt; 的一个数字。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;p&gt;自己写的，参考了之前的有一道括号组合的方式，用temp数组映射出对应的字符串，挨个取出递归加入之前的字符串，但是执行速度惨淡，好在可以过关&lt;/p&gt;
&lt;p&gt;想了想应该是没有用StringBuffer的缘故，重复创建字符串到缓冲池，导致的执行速度和空间存储都很差，先这样吧，之后再找时间解决&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    private String[] map = {
        &quot;&quot;,//0
        &quot;&quot;,//1
        &quot;abc&quot;,//2
        &quot;def&quot;,//3
        &quot;ghi&quot;,//4
        &quot;jkl&quot;,//5
        &quot;mno&quot;,//6
        &quot;pqrs&quot;,//7
        &quot;tuv&quot;,//8
        &quot;wxyz&quot;//9
    };
    List&amp;lt;String&amp;gt; result = new ArrayList&amp;lt;&amp;gt;();
    public List&amp;lt;String&amp;gt; letterCombinations(String digits) {
        fun(&quot;&quot;, digits, 0);
        return result;
    }
    public void fun(String str, String digits, int idx) {
        if(idx == digits.length()) {
            if(str != &quot;&quot;) {
                result.add(str);
            }
            return;
        }
        int flag = digits.charAt(idx) - &apos;0&apos;;
        String target = map[flag];
        for(int i = 0; i &amp;lt; target.length(); i++) {
            char c = target.charAt(i);
            fun(str + c, digits, idx + 1);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;打家劫舍&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 &lt;code&gt;root&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;除了 &lt;code&gt;root&lt;/code&gt; 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 &lt;strong&gt;两个直接相连的房子在同一天晚上被打劫&lt;/strong&gt; ，房屋将自动报警。&lt;/p&gt;
&lt;p&gt;给定二叉树的 &lt;code&gt;root&lt;/code&gt; 。返回 &lt;em&gt;&lt;strong&gt;在不触动警报的情况下&lt;/strong&gt; ，小偷能够盗取的最高金额&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/185.jpg&quot; alt=&quot;185&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入: root = [3,2,3,null,3,null,1]
输出: 7 
解释: 小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/186.jpg&quot; alt=&quot;186&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入: root = [3,4,5,1,3,null,1]
输出: 9
解释: 小偷一晚能够盗取的最高金额 4 + 5 = 9
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;p&gt;解法一：递归的判断是否打劫当前人家，返回最大的金钱数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public int rob(TreeNode root) {
        if(root == null){
            return 0;
        }
        int money = root.val;
        if(root.left != null) {
            money += rob(root.left.left) + rob(root.left.right);
        }
        if(root.right != null) {
            money += rob(root.right.left) + rob(root.right.right);
        }
        return Math.max(money, rob(root.left) + rob(root.right));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种方法在递归的时候会产生非常多的重复情况，会出现超时&lt;/p&gt;
&lt;p&gt;解法二：使用一个递归函数，返回一个大小为2的结果集，0表示不打劫该人家的最大金钱数，而1表示打劫该人家的最大金钱数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public int rob(TreeNode root) {
        int[] result = robArray(root);
        return Math.max(result[0], result[1]);
    }

    public int[] robArray(TreeNode root) {
        int[] result = new int[2];
        if(root == null) {
            return result;
        }
        int[] left = robArray(root.left);
        int[] right = robArray(root.right);
        result[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);
        result[1] = root.val + left[0] + right[0];
        return result;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>LeetCode刷题（岛屿数量，对称二叉树）</title><link>https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</guid><description>岛屿数量，对称二叉树</description><pubDate>Sun, 08 Jun 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;岛屿数量&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给你一个由 &lt;code&gt;&apos;1&apos;&lt;/code&gt;（陆地）和 &lt;code&gt;&apos;0&apos;&lt;/code&gt;（水）组成的的二维网格，请你计算网格中岛屿的数量。&lt;/p&gt;
&lt;p&gt;岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。&lt;/p&gt;
&lt;p&gt;此外，你可以假设该网格的四条边均被水包围。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：grid = [
  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],
  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],
  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],
  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]
]
输出：1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：grid = [
  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],
  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],
  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],
  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]
]
输出：3
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;p&gt;深度优先遍历，遍历二维数组的每一个元素，当为陆地的时候，用dfs遍历将相邻的1都置为0，使count++&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public int numIslands(char[][] grid) {
        int count = 0;
        for(int i = 0; i &amp;lt; grid.length; i++) {
            for(int j = 0; j &amp;lt; grid[0].length; j++) {
                if(grid[i][j] == &apos;1&apos;) {
                    dfs(grid, i, j);
                    count++;
                }
            }
        }
        return count;
    }

    private void dfs(char[][] grid, int i, int j) {
        if(i &amp;gt;= 0 &amp;amp;&amp;amp; i &amp;lt; grid.length &amp;amp;&amp;amp; j &amp;gt;= 0 &amp;amp;&amp;amp; j &amp;lt; grid[0].length &amp;amp;&amp;amp; grid[i][j] == &apos;1&apos;) {
            grid[i][j] = &apos;0&apos;;
            dfs(grid, i - 1, j);
            dfs(grid, i, j - 1);
            dfs(grid, i + 1, j);
            dfs(grid, i, j + 1);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;对称二叉树&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给你一个二叉树的根节点 &lt;code&gt;root&lt;/code&gt; ， 检查它是否轴对称。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/182.png&quot; alt=&quot;182&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：root = [1,2,2,3,4,4,3]
输出：true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/183.png&quot; alt=&quot;183&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：root = [1,2,2,null,3,null,3]
输出：false
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;p&gt;判断一棵树是否对成，需要判断左右孩子是否等价，其中check方法是检测左右两个孩子是否等价，等价条件为两个子节点值相同，且p.left节点等价于q.right，q.left 等价于 p.right&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public boolean isSymmetric(TreeNode root) {
        return check(root.left, root.right);
    }

    private boolean check(TreeNode p, TreeNode q) {
        if(p == null &amp;amp;&amp;amp; q == null) {
            return true;
        }
        if(p == null || q == null) {
            return false;
        }
        boolean flag1 = p.val == q.val;
        boolean flag2 = check(p.left, q.right);
        boolean flag3 = check(p.right, q.left);
        return flag1 &amp;amp;&amp;amp; flag2 &amp;amp;&amp;amp; flag3;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Spring笔记（Spring事务）</title><link>https://thrinisty.github.io/posts/spring%E7%AC%94%E8%AE%B0spring%E4%BA%8B%E5%8A%A1/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/spring%E7%AC%94%E8%AE%B0spring%E4%BA%8B%E5%8A%A1/</guid><description>Spring事务，事务的数个属性，事务注解式开发</description><pubDate>Sun, 08 Jun 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Spring笔记&lt;/h1&gt;
&lt;h2&gt;事务&lt;/h2&gt;
&lt;p&gt;一个业务流程中通常需要多条DML语句联合才可以完成，必须同时成功和失败，这要才能保证前后的正确性。&lt;/p&gt;
&lt;p&gt;事务可以通过AOP插入完成（底层也是通过AOP插入的），而Spring对于事务二次封装使得开发者更加方便使用事务，提高开发效率&lt;/p&gt;
&lt;p&gt;引入相关依赖&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- Spring Boot Starter AOP (包含 Spring AOP 核心功能) --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-aop&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;druid&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.2.18&amp;lt;/version&amp;gt; &amp;lt;!-- 请使用最新稳定版 --&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;!-- Spring JDBC (包含 spring-jdbc 和 spring-tx) --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-jdbc&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;6.1.0&amp;lt;/version&amp;gt; &amp;lt;!-- 使用最新稳定版 --&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;!-- MySQL Connector/J --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.mysql&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mysql-connector-j&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;8.0.33&amp;lt;/version&amp;gt; &amp;lt;!-- 使用最新稳定版 --&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在事务层的两条SQL语句之间模拟发生了异常，另外的一条语句不再执行，这个时候，账户的钱少了10000块，发生丢失&lt;/p&gt;
&lt;p&gt;数据操作层&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Repository(&quot;accountDao&quot;)
public class AccountDaoImpl implements AccountDao {
    @Resource(name = &quot;jdbc&quot;)
    private JdbcTemplate jdbcTemplate;

    @Override
    public Account selectByActno(String actno) {
        String sql = &quot;select actno, balance from t_act where actno = ?&quot;;
        Account account = jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper&amp;lt;&amp;gt;(Account.class), actno);
        return account;
    }

    @Override
    public int update(Account act) {
        String sql = &quot;update t_act set balance = ? where actno = ?&quot;;
        int update = jdbcTemplate.update(sql, act.getBalance(), act.getUsername());
        return update;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;控制层处理代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Service(&quot;accountService&quot;)
public class AccountServiceImpl implements AccountService {
    @Resource(name = &quot;accountDao&quot;)
    private AccountDao accountDao;

    @Override
    public void transfer(String from, String to, double balance) {
        Account fromAct = accountDao.selectByActno(from);
        if (fromAct.getBalance() &amp;lt; balance) {
            throw new RuntimeException(&quot;余额不足&quot;);
        }
        Account toAct = accountDao.selectByActno(to);
        fromAct.setUsername(from);//这里非常奇怪获取对象的时候没有将用户的名称成功的复制到Bean对象中，于是手动处理一下
        toAct.setUsername(to);
        fromAct.setBalance(fromAct.getBalance() - balance);
        toAct.setBalance(toAct.getBalance() + balance);
        int update = accountDao.update(fromAct);
        if(true) {
            throw new RuntimeException(&quot;中途发送异常&quot;);
        }
        update += accountDao.update(toAct);
        if (update != 2) {
            throw new RuntimeException(&quot;转账失败&quot;);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试程序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
    public void test() {
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
        AccountService accountService = context.getBean(&quot;accountService&quot;, AccountService.class);
        try {
            accountService.transfer(&quot;user1&quot;, &quot;user2&quot;, 10000);
            System.out.println(&quot;转账成功&quot;);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;使用事务方式&lt;/h2&gt;
&lt;p&gt;基于AOP封装，Spring提供了事务API供程序员使用，我们可以利用它解决上述问题&lt;/p&gt;
&lt;p&gt;编程式事务：通过编写代码的方式实现对于事务的管理&lt;/p&gt;
&lt;p&gt;声明式事务：基于注解方式，基于XML配置方式&lt;/p&gt;
&lt;p&gt;使用注解是最多的&lt;/p&gt;
&lt;p&gt;PlatformTransactionManager是事务管理器的核心接口，在Spring6中有两个实现，DataSourceTransactionManager：支持MyBatis，JdbcTemplate等事务管理，而JtaTransactionManager支持分布式事务管理&lt;/p&gt;
&lt;p&gt;Spring配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
                           http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&amp;gt;
    &amp;lt;context:component-scan base-package=&quot;com&quot;/&amp;gt;
    &amp;lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&amp;gt;
        &amp;lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&amp;gt;
        &amp;lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/spring6&quot;/&amp;gt;
        &amp;lt;property name=&quot;username&quot; value=&quot;root&quot;/&amp;gt;
        &amp;lt;property name=&quot;password&quot; value=&quot;654321&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;bean id=&quot;jdbc&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&amp;gt;
        &amp;lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&amp;gt;
        &amp;lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;

&amp;lt;!--    开启事务注解--&amp;gt;
    &amp;lt;tx:annotation-driven transaction-manager=&quot;txManager&quot;/&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;加上@Transactional注释&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
    @Transactional
    public void transfer(String from, String to, double balance) {
        //开启事务
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即可在发生异常的时候发生回滚，非常的方便易用，这个注解也可以作用在类上，对其所有的方法进行使用&lt;/p&gt;
&lt;p&gt;顺带提一嘴，通过Spring可以整合JUnit5测试框架，就不用再用getBean获取对象了，直接自动装配即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@ExtendWith(SpringExtension.class)
@ContextConfiguration(&quot;classpath:spring.xml&quot;)
public class BeanTest {
    @Autowired
    private AccountService accountService;

    @Test
    public void test() {
//        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
//        AccountService accountService = context.getBean(&quot;accountService&quot;, AccountService.class);
        try {
            accountService.transfer(&quot;user1&quot;, &quot;user2&quot;, 10000);
            System.out.println(&quot;转账成功&quot;);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;事务的属性&lt;/h2&gt;
&lt;p&gt;@Transactional注释的本身有很多的属性&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@Documented
@Reflective
public @interface Transactional {
    @AliasFor(&quot;transactionManager&quot;)
    String value() default &quot;&quot;;

    @AliasFor(&quot;value&quot;)
    String transactionManager() default &quot;&quot;;

    String[] label() default {};

    Propagation propagation() default Propagation.REQUIRED;
    //事务传播行为

    Isolation isolation() default Isolation.DEFAULT;
    //事务隔离级别

    int timeout() default -1;
    //事务超时时间

    String timeoutString() default &quot;&quot;;

    boolean readOnly() default false;
    //是否只读，true为只读

    Class&amp;lt;? extends Throwable&amp;gt;[] rollbackFor() default {};
	//可以设置发生何种异常时回滚
    
    String[] rollbackForClassName() default {};

    Class&amp;lt;? extends Throwable&amp;gt;[] noRollbackFor() default {};
	////可以设置发生何种异常时不回滚
    String[] noRollbackForClassName() default {};
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以下我们来挨个说明&lt;/p&gt;
&lt;h3&gt;事务传播行为&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;Propagation propagation() default Propagation.REQUIRED;
//事务传播行为
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当我们用一个被事务标注标记的方法调用里另一个被事务标注标记的方法，就应该考虑事务是如何传递的，是新开启一个事务还是合并到原有事务中，事务的传播行为在Spring中有如下的七种枚举类型&lt;/p&gt;
&lt;p&gt;REQUIRED:支持当前事务，如果不存在就新建一个（默认行为），使用原先事务&lt;/p&gt;
&lt;p&gt;SUPPORTS: 支持当前事务，如果当前没有事务，就以非事务方法执行，随和&lt;/p&gt;
&lt;p&gt;MANDATORY:必须运行在一个事务中，如果没有正在发生的事务抛出异常，强制性&lt;/p&gt;
&lt;p&gt;REQUIRES_NEW:开启一个新的事务，如果一个事务以及存在，将存在的事物挂起（不存在嵌套，之前的事务挂起）&lt;/p&gt;
&lt;p&gt;NOT_SUPPORTED:以非事务方式运行，如果事务存在，挂起当前事务&lt;/p&gt;
&lt;p&gt;NEVER:以非事务方式运行，如果事务存在，抛出异常&lt;/p&gt;
&lt;p&gt;NESTED（内嵌）:如果当前正有一个事务在进行中，则该方法应当运行在一个嵌套式事务中。被嵌套的事务可以独立于外层事务进行提交或者回滚，如果外层事务不存在，行为与 REQUIRED 一致&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实际使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们假设有一个场景，一个被事务注解修饰的方法，调用了另一个被事务注解修饰的方法，后一个注解指定为REQUIRED，那么被调用的数条执行语句就会被加入到第一个方法的事务中，若此时此刻被调用的方法抛出异常，调用方法也会受到影响从而回滚&lt;/p&gt;
&lt;p&gt;而如果第二个方法事务传播行为注解为REQUIRES_NEW，那么就会开启一个新的事务，如果其发生异常，第二个方法的数条执行语句回滚，与此同时第一个方法中如果针对于第二个方法抛出异常予以捕获，则第一个方法不会回滚&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Transactional(propagation = Propagation.REQUIRED)
public void withdraw() {
    System.out.println(&quot;该方法也有事务&quot;);   
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;事务的隔离级别&lt;/h3&gt;
&lt;p&gt;之前的MySQL中学过，现在我们复习一下&lt;/p&gt;
&lt;p&gt;脏读：当一个事务读取另一个事务尚未提交的修改时，产生脏读&lt;/p&gt;
&lt;p&gt;不可重复读：同一查询在同一事物中多次进行，由于其他提交事务所做的修改或者删除，每次返回结果不同的结果集，产生不可重复读&lt;/p&gt;
&lt;p&gt;幻读：同意查询在同一事物中多次进行，由于其他提交事务的插入操作，每次返回不同的结果集，产生了幻读&lt;/p&gt;
&lt;h4&gt;事务隔离表格&lt;/h4&gt;
&lt;p&gt;事务隔离级别：MySQL隔离级别定义了事物与事务之间的隔离程度&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;隔离级别&lt;/th&gt;
&lt;th&gt;丢失修改&lt;/th&gt;
&lt;th&gt;脏读&lt;/th&gt;
&lt;th&gt;不可重复读&lt;/th&gt;
&lt;th&gt;幻读&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;读未提交&lt;/td&gt;
&lt;td&gt;不会发生&lt;/td&gt;
&lt;td&gt;可能发生&lt;/td&gt;
&lt;td&gt;可能发生&lt;/td&gt;
&lt;td&gt;可能发生&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;读已提交&lt;/td&gt;
&lt;td&gt;不会发生&lt;/td&gt;
&lt;td&gt;不会发生&lt;/td&gt;
&lt;td&gt;可能发生&lt;/td&gt;
&lt;td&gt;可能发生&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;可重复读&lt;/td&gt;
&lt;td&gt;不会发生&lt;/td&gt;
&lt;td&gt;不会发生&lt;/td&gt;
&lt;td&gt;不会发生&lt;/td&gt;
&lt;td&gt;可能发生&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;可串行化&lt;/td&gt;
&lt;td&gt;不会发生&lt;/td&gt;
&lt;td&gt;不会发生&lt;/td&gt;
&lt;td&gt;不会发生&lt;/td&gt;
&lt;td&gt;不会发生&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;Spring隔离级别&lt;/h4&gt;
&lt;p&gt;对应着上表的四种隔离级别，默认的隔离级别是根据所选数据库决定的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public enum Isolation {
    DEFAULT(-1),
    READ_UNCOMMITTED(1),
    READ_COMMITTED(2),
    REPEATABLE_READ(4),
    SERIALIZABLE(8);

    private final int value;

    private Isolation(int value) {
        this.value = value;
    }

    public int value() {
        return this.value;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用方式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Transactional(isolation = Isolation.REPEATABLE_READ, propagation = Propagation.REQUIRED)
public void withdraw() {
    System.out.println(&quot;某一事务&quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;事务超时属性&lt;/h3&gt;
&lt;p&gt;事务的超时指的是，如果对应秒数流逝完毕的时候，而DML没有全部执行完毕，最终结果会选择回滚，在实际使用中通过timeout属性设置秒数&lt;/p&gt;
&lt;p&gt;我们测试一下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Transactional(timeout = 10)
public void save(Account account) {
    try {
        accountDao.update(account);
        Thread.sleep(1000 * 20);
    } catch (InterruptedException e) {
        throw new RuntimeException(e);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在执行DML语句后睡眠20s，而超时时间是10s&lt;/p&gt;
&lt;p&gt;但是从结果上显示，该DML语句任然被执行，这是因为在超时之前所有的DML都被执行完成&lt;/p&gt;
&lt;p&gt;交换一下顺序，这样就会出现超时&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Transactional(timeout = 5)
public void save(Account account) {
    try {
        Thread.sleep(1000 * 10);
        accountDao.update(account);
    } catch (InterruptedException e) {
        throw new RuntimeException(e);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里是面试中常考的一点&lt;/p&gt;
&lt;h3&gt;只读事务&lt;/h3&gt;
&lt;p&gt;如果设置一个事务是只读事务，则该事务中不可以执行增删改语句，启用只读的时候，可以启动Spring的优化策略，提高select语句的执行效率&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Transactional(readOnly = true)
public void getByActno(String actno) {
    Account account = accountDao.selectByActno(actno);
    account.setUsername(actno);
    System.out.println(account);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在实际使用为了增加效率可以启用一下&lt;/p&gt;
&lt;h3&gt;设置异常[不]回滚事务&lt;/h3&gt;
&lt;p&gt;在Spring事务中默认发生任何异常，进行回滚&lt;/p&gt;
&lt;p&gt;我们也可以通过rollbackFor人为设置，表示发生对应异常或者其子类异常的时候才会发生回滚&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Transactional(rollbackFor = Exception.class)
public void getByActno(String actno) {
    Account account = accountDao.selectByActno(actno);
    account.setUsername(actno);
    System.out.println(account);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以设置遇到对应异常不回滚&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Transactional(noRollbackFor = NullPointerException.class)
public void save(Account account) {
    accountDao.update(account);
    throw new NullPointerException();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在测试程序中捕获到空指针异常，但是DML语句不发生回滚&lt;/p&gt;
&lt;h2&gt;事务全注解式开发&lt;/h2&gt;
&lt;p&gt;我们以上使用事物的时候使用到了spring的xml配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
                           http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&amp;gt;
    &amp;lt;context:component-scan base-package=&quot;com&quot;/&amp;gt;
    &amp;lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&amp;gt;
        &amp;lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&amp;gt;
        &amp;lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/spring6&quot;/&amp;gt;
        &amp;lt;property name=&quot;username&quot; value=&quot;root&quot;/&amp;gt;
        &amp;lt;property name=&quot;password&quot; value=&quot;654321&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;bean id=&quot;jdbc&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&amp;gt;
        &amp;lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&amp;gt;
        &amp;lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;

&amp;lt;!--    开启事务注解--&amp;gt;
    &amp;lt;tx:annotation-driven transaction-manager=&quot;txManager&quot;/&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还是非常繁多的，我们一般在实际使用的时候，通过注解来进行配置&lt;/p&gt;
&lt;p&gt;在配置类中用@Bean注解配置几个Bean对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Configuration
@ComponentScan(&quot;com&quot;)
@EnableTransactionManagement//开启事务的注解
public class SpringConfig {
    @Bean(name = &quot;dataSource&quot;)
    public DruidDataSource getDataSource() {
        DruidDataSource ds = new DruidDataSource();
        ds.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);
        ds.setUrl(&quot;jdbc:mysql://localhost:3306/spring6&quot;);
        ds.setUsername(&quot;root&quot;);
        ds.setPassword(&quot;654321&quot;);
        return ds;
    }
    @Bean(name = &quot;jdbc&quot;)
    public JdbcTemplate getJdbcTemplate() {
        return new JdbcTemplate(getDataSource());
    }
    @Bean(name = &quot;txManager&quot;)
    public PlatformTransactionManager getTxManager() {
        return new DataSourceTransactionManager(getDataSource());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试程序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void test1() {
    ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
    IsolationService iso = context.getBean(&quot;i1&quot;, IsolationService.class);
    try {
        iso.getByActno(&quot;user1&quot;);
    } catch (Exception e) {
        System.out.println(&quot;捕获到异常&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过XML也可以实现，需要在Spring配置中用tx标签和aop标签指定需要配置的方法启用其事务，相比注解式开发确实有些复杂了，了解即可&lt;/p&gt;
&lt;h1&gt;Spring总结&lt;/h1&gt;
&lt;p&gt;Spring的教程部分到此结束，其实还有一个用Spring配置MyBatis的部分，但是我还没有学到MyBatis，加下来的数天回进行MyBatis的学习，等到完成学习之后再会过头来Spring配置MyBatis部分的学习&lt;/p&gt;
</content:encoded></item><item><title>LeetCode刷题（编辑距离，颜色分类）</title><link>https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/</guid><description>编辑距离，荷兰国旗问题</description><pubDate>Sat, 07 Jun 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;编辑距离&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给你两个单词 &lt;code&gt;word1&lt;/code&gt; 和 &lt;code&gt;word2&lt;/code&gt;， &lt;em&gt;请返回将 &lt;code&gt;word1&lt;/code&gt; 转换成 &lt;code&gt;word2&lt;/code&gt; 所使用的最少操作数&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;你可以对一个单词进行如下三种操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;插入一个字符&lt;/li&gt;
&lt;li&gt;删除一个字符&lt;/li&gt;
&lt;li&gt;替换一个字符&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;
输出：3
解释：
horse -&amp;gt; rorse (将 &apos;h&apos; 替换为 &apos;r&apos;)
rorse -&amp;gt; rose (删除 &apos;r&apos;)
rose -&amp;gt; ros (删除 &apos;e&apos;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：word1 = &quot;intention&quot;, word2 = &quot;execution&quot;
输出：5
解释：
intention -&amp;gt; inention (删除 &apos;t&apos;)
inention -&amp;gt; enention (将 &apos;i&apos; 替换为 &apos;e&apos;)
enention -&amp;gt; exention (将 &apos;n&apos; 替换为 &apos;x&apos;)
exention -&amp;gt; exection (将 &apos;n&apos; 替换为 &apos;c&apos;)
exection -&amp;gt; execution (插入 &apos;u&apos;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;p&gt;设立一个dp二维数组，存放word1与word2的前n个字符需要操作的情况，初始的情况是两个都没有字符，赋值为0，分别右下遍历二维数组，代表着从空字符串开始需要增加操作字符的数量迭代加一&lt;/p&gt;
&lt;p&gt;二维遍历整个数组，分为两种情况：&lt;/p&gt;
&lt;p&gt;1.即将放入的两个字符相等，直接从左上方的第一个二维数组元素取值即可，代表着不需要操作&lt;/p&gt;
&lt;p&gt;2.当字符不同的时候，可以从两个字符的左上情况进行替换操作，或者从左或者上进行增删操作，取三种方式的最小值，将取得的结果加一代表经历了一种操作&lt;/p&gt;
&lt;p&gt;最后对于遍历的元素赋予对应的数值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public int minDistance(String word1, String word2) {
        int n1 = word1.length();
        int n2 = word2.length();
        int[][] dp = new int[n1 + 1][n2 + 1];
        for(int i = 1; i &amp;lt;= n1; i++) {
            dp[i][0] = dp[i - 1][0] + 1;
        }
        for(int j = 1; j &amp;lt;= n2; j++) {
            dp[0][j] = dp[0][j - 1] + 1;
        }
        for(int i = 1; i &amp;lt;= n1; i++) {
            for(int j = 1; j &amp;lt;= n2; j++) {
                if(word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    int min = Math.min(dp[i - 1][j - 1], dp[i - 1][j]);
                    min = Math.min(min, dp[i][j - 1]);
                    dp[i][j] = min + 1;
                }
            }
        }
        return dp[n1][n2];
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;颜色分类&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给定一个包含红色、白色和蓝色、共 &lt;code&gt;n&lt;/code&gt; 个元素的数组 &lt;code&gt;nums&lt;/code&gt; ，&lt;strong&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95&quot;&gt;原地&lt;/a&gt;&lt;/strong&gt; 对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。&lt;/p&gt;
&lt;p&gt;我们使用整数 &lt;code&gt;0&lt;/code&gt;、 &lt;code&gt;1&lt;/code&gt; 和 &lt;code&gt;2&lt;/code&gt; 分别表示红色、白色和蓝色。&lt;/p&gt;
&lt;p&gt;必须在不使用库内置的 sort 函数的情况下解决这个问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：nums = [2,0,2,1,1,0]
输出：[0,0,1,1,2,2]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：nums = [2,0,1]
输出：[0,1,2]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;p&gt;解法一：反骨一下用一个临时的数组存储一下，把0方法到最前面，2放到最后面，剩余的用1填充&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public void sortColors(int[] nums) {
        int n = nums.length;
        int[] result = new int[n];
        int min = 0;
        int max = n - 1;
        for(int i = 0; i &amp;lt; n; i++) {
            if(nums[i] == 0) {
                result[min++] = 0;
            } else if(nums[i] == 2) {
                result[max--] = 2;
            }
        }
        for(int i = min; i &amp;lt;= max; i++) {
            result[i] = 1;
        }
        for(int i = 0; i &amp;lt; n; i++) {
            nums[i] = result[i];
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解法二：&lt;/p&gt;
&lt;p&gt;用三个指针标识，flag位操作数指针，low之前的数为0，high之后的数为2&lt;/p&gt;
&lt;p&gt;flag初始为0，当flag &amp;gt; high的时候表示处理完毕&lt;/p&gt;
&lt;p&gt;当为0的时候需要和low指向的数字就行交换将0放入low的位置，low++，而flag因为之前的数字都处理过了所以flag++&lt;/p&gt;
&lt;p&gt;当为1的时候，nums[flag]位置的数正确，flag++即可，无需交换放置&lt;/p&gt;
&lt;p&gt;当为2的时候，和max处的位置进行交换，因为交换回的数字可能是2，max--，而flag不作调整，再次判断&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public void sortColors(int[] nums) {
        int low = 0;
        int high = nums.length - 1;
        int flag = 0;
        while(flag &amp;lt;= high) {
            if(nums[flag] == 0) {
                swap(nums, low, flag);
                low++;
                flag++;
            } else if(nums[flag] == 1) {
                flag++;
            } else {
                swap(nums, flag, high);
                high--;
            }
        }
    }
    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>LeetCode刷题（买股票一次买入卖出，二叉树直径）</title><link>https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E4%B9%B0%E8%82%A1%E7%A5%A8%E4%B8%80%E6%AC%A1%E4%B9%B0%E5%85%A5%E5%8D%96%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B4%E5%BE%84/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E4%B9%B0%E8%82%A1%E7%A5%A8%E4%B8%80%E6%AC%A1%E4%B9%B0%E5%85%A5%E5%8D%96%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B4%E5%BE%84/</guid><description>区别于之前的买股票，二叉树直径</description><pubDate>Fri, 06 Jun 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;买股票的最佳时机&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给定一个数组 &lt;code&gt;prices&lt;/code&gt; ，它的第 &lt;code&gt;i&lt;/code&gt; 个元素 &lt;code&gt;prices[i]&lt;/code&gt; 表示一支给定股票第 &lt;code&gt;i&lt;/code&gt; 天的价格。&lt;/p&gt;
&lt;p&gt;你只能选择 &lt;strong&gt;某一天&lt;/strong&gt; 买入这只股票，并选择在 &lt;strong&gt;未来的某一个不同的日子&lt;/strong&gt; 卖出该股票。设计一个算法来计算你所能获取的最大利润。&lt;/p&gt;
&lt;p&gt;返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 &lt;code&gt;0&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;p&gt;这一道题目我还以为是可以多次买入卖出，只是不像之前的有冷冻期而已，但是只能买入卖出一次&lt;/p&gt;
&lt;p&gt;我们记录历史的最低价格，遍历后续元素的时候迭代刷新，并计算当前价格减去历史价格的值是否大于先前的值，迭代之，最后的max即为我们需要的结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public int maxProfit(int[] prices) {
        int max = 0;
        int min = Integer.MAX_VALUE;
        for(int price : prices) {
            min = Math.min(min, price);
            max = Math.max(max, price - min);
        }
        return max;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;二叉树直径&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给你一棵二叉树的根节点，返回该树的 &lt;strong&gt;直径&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;二叉树的 &lt;strong&gt;直径&lt;/strong&gt; 是指树中任意两个节点之间最长路径的 &lt;strong&gt;长度&lt;/strong&gt; 。这条路径可能经过也可能不经过根节点 &lt;code&gt;root&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;两节点之间路径的 &lt;strong&gt;长度&lt;/strong&gt; 由它们之间边数表示。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/181.jpg&quot; alt=&quot;181&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：root = [1,2,3,4,5]
输出：3
解释：3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：root = [1,2]
输出：1
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;p&gt;递归，取左右字数深度的和迭代结果，返回二叉树深度&lt;/p&gt;
&lt;p&gt;其实就是在之前求二叉树深度的基础上迭代result最大结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    int result = 0;
    public int diameterOfBinaryTree(TreeNode root) {
        maxDepth(root);
        return result;
    }

    private int maxDepth(TreeNode root) {
        if(root == null) {
            return 0;
        }
        int leftMax = maxDepth(root.left);
        int rightMax = maxDepth(root.right);
        int maxLength = leftMax + rightMax;
        result = Math.max(result, maxLength);
        return Math.max(leftMax, rightMax) + 1;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>LeetCode刷题（移动零）</title><link>https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E7%A7%BB%E5%8A%A8%E9%9B%B6/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E7%A7%BB%E5%8A%A8%E9%9B%B6/</guid><description>将数组的0移动到数组的末端</description><pubDate>Thu, 05 Jun 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;移动零&lt;/h1&gt;
&lt;p&gt;7号早上要考英语写作，要写两篇作文，之前在课堂上写的作文评分都不是很高也就是及格边缘，今天和明天需要背一下写作模板，LeetCode刷题部分除了复习以往的题目，就做一道题目练练手保持手感了&lt;/p&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给定一个数组 &lt;code&gt;nums&lt;/code&gt;，编写一个函数将所有 &lt;code&gt;0&lt;/code&gt; 移动到数组的末尾，同时保持非零元素的相对顺序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;请注意&lt;/strong&gt; ，必须在不复制数组的情况下原地对数组进行操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入: nums = [0]
输出: [0]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;p&gt;解法一：忽略原地操作，在list集合中存储非0数，将集合元素复制到数组中，缺少的补0，但是不符合题目要求，其实我还想到用i j 两个下表进行元素互换实现，但是这样就把非零数的顺序打乱了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public void moveZeroes(int[] nums) {
        List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        for(Integer num : nums) {
            if(num != 0) {
                list.add(num);
            }
        }
        int n = list.size();
        for(int i = 0; i &amp;lt; n; i++) {
            nums[i] = list.get(i);
        }
        for(int i = n; i &amp;lt; nums.length; i++) {
            nums[i] = 0;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解法二：原地操作，其实思路一样，确实仔细想想因为有0的存在，覆盖的元素都是被操作过的，直接用数组存储即可，没遍历到的数字不会被覆盖，思路是一样的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public void moveZeroes(int[] nums) {
        int flag = 0;
        for(int i = 0; i &amp;lt; nums.length; i++) {
            if(nums[i] != 0) {
                nums[flag++] = nums[i]; 
            }
        }
        for(int i = flag; i &amp;lt; nums.length; i++) {
            nums[i] = 0;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Spring笔记（AOP）</title><link>https://thrinisty.github.io/posts/spring%E7%AC%94%E8%AE%B0aop/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/spring%E7%AC%94%E8%AE%B0aop/</guid><description>Spring面向切面编程，切点表达式，通知类型，全注解开发</description><pubDate>Wed, 04 Jun 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Spring笔记&lt;/h1&gt;
&lt;h2&gt;AOP面向切面编程&lt;/h2&gt;
&lt;p&gt;AOP是一种编程技术，是对OOP的补充延申，底层采用动态代理实现，Spring AOP使用的动态代理是JDK动态代理 + CGLIB动态代理技术，Spring会在两者中切换&lt;/p&gt;
&lt;p&gt;IoC使软件组件松耦合，AOP可以让你能够捕捉系统中经常使用的功能，把它转化为组件&lt;/p&gt;
&lt;p&gt;一般一个系统当中都有一些系统服务，例如：日志，事务管理等称为交叉业务，切入核心代码中，在实现核心业务的时候不需要关系这些业务的实现&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/180.png&quot; alt=&quot;180&quot; /&gt;&lt;/p&gt;
&lt;p&gt;将于核心业务无关的代码独立提取出来，形成一个独立的组件，然后以横向交叉的方式运用到业务流程的过程中称之为AOP&lt;/p&gt;
&lt;p&gt;:::note&lt;/p&gt;
&lt;p&gt;AOP三大优点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;代码复用性强&lt;/li&gt;
&lt;li&gt;代码容易维护&lt;/li&gt;
&lt;li&gt;使得开发者更加专注于业务逻辑&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;h3&gt;AOP七大术语&lt;/h3&gt;
&lt;p&gt;连接点 Joinpoint：在程序的整个执行流程中，可以织入切面的位置，方法执行前后，异常抛出之后等位置&lt;/p&gt;
&lt;p&gt;切点 Pointcut：在程序执行流程中，真正织入切面的方法（一个切点对应多个连接点）&lt;/p&gt;
&lt;p&gt;通知 Advice：通知又称为增强，就是具体你要织入的代码，包括了以下的五种通知：前置通知，后置通知，环绕通知，异常通知，最终通知&lt;/p&gt;
&lt;p&gt;切面 Aspect：切点+通知即为切面&lt;/p&gt;
&lt;p&gt;织入 Weaving：把通知应用到目标对象的过程&lt;/p&gt;
&lt;p&gt;代理对象 Proxy：一个目标对象被织入通知后产生的新对象&lt;/p&gt;
&lt;p&gt;目标对象 Target：被织入通知的对象&lt;/p&gt;
&lt;h2&gt;切点表达式&lt;/h2&gt;
&lt;p&gt;切点表达式用来定义通知往哪些方法切入&lt;/p&gt;
&lt;p&gt;切入点表达式的语法格式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;execution([访问权限] 返回值类型 [全限定类名]方法名(形参列表) [异常])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;访问权限：可选项，没写包括四个权限&lt;/p&gt;
&lt;p&gt;返回类型：必填项，*表示任意类型&lt;/p&gt;
&lt;p&gt;全限定类名：可选项，两个点&quot;..&quot;代表当前包以及子包下的所有类，省略表示所有类&lt;/p&gt;
&lt;p&gt;方法名：必填项，&lt;em&gt;表示所有方法，set&lt;/em&gt;表示所有的set方法&lt;/p&gt;
&lt;p&gt;形参列表：必填项，()表示无参，(..)表示参数类型和个数随意，(*)表示一个参数方法&lt;/p&gt;
&lt;p&gt;异常：可选项，省略时表示任意类型异常&lt;/p&gt;
&lt;h3&gt;代码示例&lt;/h3&gt;
&lt;p&gt;Service包下所有的类中以delete开始的所有方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;execution(public * com.service.*delete*(..))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;mall包下所有的类的所有方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;execution(* com.mail..*(..))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所有类的所有方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;execution(* *(..))
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Spring AOP&lt;/h2&gt;
&lt;h3&gt;AOP的实现&lt;/h3&gt;
&lt;p&gt;包括三种方式：&lt;/p&gt;
&lt;p&gt;1.Spring框架结合AspectJ框架实现的AOP，基于注解方式&lt;/p&gt;
&lt;p&gt;2.Spring框架结合AspectJ框架实现的AOP，基于XML方式&lt;/p&gt;
&lt;p&gt;3.Spring框架自己实现的AOP，基于XML配置方式&lt;/p&gt;
&lt;p&gt;在实际开发中，都是通过Spring + AspectJ实现AOP，重点掌握注解方式&lt;/p&gt;
&lt;h3&gt;使用方式&lt;/h3&gt;
&lt;p&gt;引入context依赖以及spring-aspects依赖&lt;/p&gt;
&lt;p&gt;context默认有了，运用Maven添加spring-aspects依赖&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- Spring Boot Starter AOP (包含 Spring AOP 核心功能) --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-aop&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;!-- AspectJ 注解支持（可选，如果需要 @AspectJ 风格的切面） --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.aspectj&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;aspectjweaver&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.9.7&amp;lt;/version&amp;gt; &amp;lt;!-- 版本可调整 --&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在spring配置文件中引入命名空间&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
                           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&amp;gt;
    &amp;lt;context:component-scan base-package=&quot;com.thrinisty.service&quot;/&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;建立一个目标对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.thrinisty.service;

import org.springframework.stereotype.Service;

@Service(&quot;userService&quot;)
public class UserService {
    //目标类
    public void login() {
        System.out.println(&quot;系统登录&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;建立一个代理对象&lt;/p&gt;
&lt;p&gt;使用Aspect注解表名是代理对象，使用Before注解传入切点表达式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.thrinisty.service;

import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.springframework.stereotype.Component;

@Component(&quot;logAspect&quot;)
@Aspect
public class LogAspect {
    //切面 = 通知 + 切点
    @Before(&quot;execution(* com.thrinisty.service.UserService.*(..))&quot;)
    public void enhance() {
        System.out.println(&quot;一个通知，增强代码&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;spring配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
                           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&amp;gt;
    &amp;lt;context:component-scan base-package=&quot;com.thrinisty.service&quot;/&amp;gt;
    &amp;lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运用context扫描service包下的类，使用aop自动代理，并使代理默认使用CGLIB代理&lt;/p&gt;
&lt;p&gt;测试程序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void test() {
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
    UserService userService = context.getBean(&quot;userService&quot;, UserService.class);
    userService.login();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;一个通知，增强代码
系统登录
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在调用方法之前，调用了前置通知，完成了织入&lt;/p&gt;
&lt;h3&gt;通知类型&lt;/h3&gt;
&lt;p&gt;是具体你要织入的代码，包括了以下的五种通知：前置通知（Before），后置通知（AfterReturning），环绕通知（Around），异常通知（AfterThrowing），最终通知（After）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Component(&quot;logAspect&quot;)
@Aspect
public class LogAspect {
    //切面 = 通知 + 切点
    @Before(&quot;execution(* com.thrinisty.service.OrderService.generate(..))&quot;)
    public void beforeAdvice() {
        System.out.println(&quot;前置通知&quot;);
    }

    @AfterReturning(&quot;execution(* com.thrinisty.service.OrderService.generate(..))&quot;)
    public void afterReturning() {
        System.out.println(&quot;后置通知&quot;);
    }

    @Around(&quot;execution(* com.thrinisty.service.OrderService.generate(..))&quot;)
    public void aroundAdvice(ProceedingJoinPoint joinPoint) throws Throwable {
        System.out.println(&quot;前环绕&quot;);
        joinPoint.proceed();//执行目标
        System.out.println(&quot;后环绕&quot;);
    }

    @After(&quot;execution(* com.thrinisty.service.OrderService.generate(..))&quot;)
    public void finalAdvice() {
        System.out.println(&quot;最终通知&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行顺序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;前环绕
前置通知
生成订单
后置通知
最终通知
后环绕
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们在generate方法中抛出异常&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Service
public class OrderService {
    public void generate() {
        System.out.println(&quot;生成订单&quot;);
        throw new RuntimeException();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;@AfterThrowing(&quot;execution(* com.thrinisty.service.OrderService.generate(..))&quot;)
public void afterThrowing() {
    System.out.println(&quot;异常通知&quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;前环绕
前置通知
生成订单
异常通知
最终通知
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;后环绕和后置通知执行不到，在异常发生时异常通知，最终通知也正常&lt;/p&gt;
&lt;p&gt;对于两个切面切入相同的的切点，可以通过@Order注解标注执行顺序，数字越小，优先级越高&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Aspect
@Component
@Order(0)//原先的设置为1
public class SecurityAspect {
    @Before(&quot;execution(* com.thrinisty.service.OrderService.generate(..))&quot;)
    public void beforeAdvice() {
        System.out.println(&quot;前置通知：安全&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;前置通知：安全
前环绕
前置通知
生成订单
后置通知
最终通知
后环绕
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;通用切点&lt;/h3&gt;
&lt;p&gt;使用Pointcut注解可以复用一个切点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Component(&quot;logAspect&quot;)
@Aspect
@Order(0)
public class LogAspect {

    @Pointcut(&quot;execution(* com.thrinisty.service.OrderService.generate(..))&quot;)
    public void universe() {

    }

    //切面 = 通知 + 切点
    @Before(&quot;universe()&quot;)
    public void beforeAdvice() {
        System.out.println(&quot;前置通知&quot;);
    }
......
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;跨类也可以使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Aspect
@Component
@Order(0)
public class SecurityAspect {
    @Before(&quot;com.thrinisty.service.LogAspect.universe()&quot;)
    public void beforeAdvice() {
        System.out.println(&quot;前置通知：安全&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;连接点&lt;/h3&gt;
&lt;p&gt;之前环绕通知使用过连接点 ProceedingJoinPoint joinPoint，作为参数传入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Around(&quot;execution(* com.thrinisty.service.OrderService.generate(..))&quot;)
public void aroundAdvice(ProceedingJoinPoint joinPoint) throws Throwable {
    System.out.println(&quot;前环绕&quot;);
    joinPoint.proceed();//执行目标
    System.out.println(&quot;后环绕&quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在其他的通知也可以传入，joinPoint有很多方法可供调用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Before(&quot;universe()&quot;)
public void beforeAdvice(JoinPoint joinPoint) {
    System.out.println(&quot;前置通知&quot;);
    Signature signature = joinPoint.getSignature();//得到目标方法签名
    System.out.println(signature);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;前置通知
void com.thrinisty.service.OrderService.generate()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;全注解开发&lt;/h3&gt;
&lt;p&gt;流行的开发方式，全注解开发，不使用注解&lt;/p&gt;
&lt;p&gt;创建一个Config类对象，使用@Configuration标注，指定扫描包，使用代理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Configuration
@ComponentScan({&quot;com.thrinisty.service&quot;})//扫描包
@EnableAspectJAutoProxy(proxyTargetClass = true)//启用代理，并使用CGLIB代理
public class Spring6Config {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试文件，指定Config类对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void test2() {
    ApplicationContext context = new AnnotationConfigApplicationContext(Spring6Config.class);
    OrderService orderService = (OrderService) context.getBean(&quot;orderService&quot;);
    orderService.generate();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;AOP实际运用&lt;/h2&gt;
&lt;p&gt;我们用事务处理来进行举例&lt;/p&gt;
&lt;p&gt;对于一个核心的业务逻辑，st1 st2 st3，我们会在前后开启和关闭事务，保证代码全部提交或者全部回退，我们在这个时候可以采取AOP运用aroud注解利用环绕通知进行处理&lt;/p&gt;
&lt;p&gt;一个转账操作对象，我们通过Aspect在其前后分别添加开始事务，提交事务，与捕获异常回滚事务的逻辑&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Service
public class AccountService {
    public void transfer() {
        System.out.println(&quot;系统正在完成转账操作...&quot;);
    }

    public void withdraw() {
        System.out.println(&quot;系统正在完成取款操作...&quot;);
        throw new RuntimeException();//模拟运行异常
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;切面代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Component
@Aspect
public class TransactionAspect {
    @Around(&quot;execution(* com.service..*(..))&quot;)
    public void aroundAdvice(ProceedingJoinPoint joinPoint) throws Throwable {
        try{
            System.out.println(&quot;开启事务&quot;);
            //前环绕
            joinPoint.proceed();
            //后环绕
            System.out.println(&quot;提交事务&quot;);
        } catch (Throwable throwable) {
            System.out.println(&quot;回滚事务&quot;);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; @Test
    public void test() {
        ApplicationContext context = new AnnotationConfigApplicationContext(Config.class);
        AccountService accountService = context.getBean(&quot;accountService&quot;, AccountService.class);
        accountService.transfer();
        accountService.withdraw();
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;开启事务
系统正在完成转账操作...
提交事务

开启事务
系统正在完成取款操作...
回滚事务
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>LeetCode刷题（买股票，前k个高频元素）</title><link>https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E4%B9%B0%E8%82%A1%E7%A5%A8%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E4%B9%B0%E8%82%A1%E7%A5%A8%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/</guid><description>买股票含冷冻期，前k个高频元素</description><pubDate>Wed, 04 Jun 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;买股票&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给定一个整数数组&lt;code&gt;prices&lt;/code&gt;，其中第 &lt;code&gt;prices[i]&lt;/code&gt; 表示第 &lt;code&gt;*i*&lt;/code&gt; 天的股票价格 。&lt;/p&gt;
&lt;p&gt;设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入: prices = [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入: prices = [1]
输出: 0
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;p&gt;用两个数组存储分别存储持有股票时的最大资产，以及售出股票的最大资产，在第一天将buy设置为-prices[0]&lt;/p&gt;
&lt;p&gt;每天迭代数组的对应元素的时候，对于持有的数组元素取前一天的（持有股票资产）和（非持有股票买入当天股票后的资产）中的最大值，而对于售出股票的数组而言取（前一天非持有股票的资产）和（以往持有股票在当天售出）的最大值&lt;/p&gt;
&lt;p&gt;:::tip&lt;/p&gt;
&lt;p&gt;注意在买入股票的时候要求前一天不卖出，这一步的处理是迭代持有股票的数组的时候，用i-2处的非持有元素迭代（注意数组越界的处理，在i&amp;gt;=2的时候取0）&lt;/p&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        int[] buy = new int[n];
        int[] sale = new int[n];
        buy[0] = -prices[0];
        sale[0] = 0;
        for(int i = 1; i &amp;lt; n; i++) {
            buy[i] = Math.max(buy[i - 1], (i &amp;gt;= 2 ? sale[i - 2] : 0) - prices[i]);
            sale[i] = Math.max(sale[i - 1], buy[i - 1] + prices[i]);
        }
        return sale[n - 1];
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;前k个高频元素&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; 和一个整数 &lt;code&gt;k&lt;/code&gt; ，请你返回其中出现频率前 &lt;code&gt;k&lt;/code&gt; 高的元素。你可以按 &lt;strong&gt;任意顺序&lt;/strong&gt; 返回答案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入: nums = [1], k = 1
输出: [1]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= nums.length &amp;lt;= 105&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;k&lt;/code&gt; 的取值范围是 &lt;code&gt;[1, 数组中不相同的元素的个数]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;题目数据保证答案唯一，换句话说，数组中前 &lt;code&gt;k&lt;/code&gt; 个高频元素的集合是唯一的&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;p&gt;这一题我按照哈希桶的方式自己用数组的形式，将放入哈希表中的数字-出现次数，按照出现的次数作为下标放入了一个数组中&lt;/p&gt;
&lt;p&gt;本地测评没有问题，但是后续验证有两个数字出现频率相同的情况下，只会有一个数字放入到最后的结果中，应该是相同的频率下，后放入的数字会覆盖掉之前放入的数字，更改为List集合的数组后成功通过&lt;/p&gt;
&lt;p&gt;在处理List集合的时候从后向前处理，当List集合为空表示没有数字落在对应的频率中，continue继续，到有元素的List时迭代的将其中的元素放入结果集中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        int[] result = new int[k];
        Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        for(int num : nums) {
            int i = map.getOrDefault(num, 0);
            map.put(num, i + 1);
        }

        List&amp;lt;Integer&amp;gt;[] list = new List[nums.length + 1];
        Set&amp;lt;Integer&amp;gt; set = map.keySet();
        for(int num : set) {
            int i = map.get(num);
            if(list[i] == null) {
                list[i] = new ArrayList&amp;lt;Integer&amp;gt;();
            }
            list[i].add(num);
        }

        int len = 0;
        for(int i = list.length - 1; i &amp;gt;= 0; i--) {
            if(list[i] == null) {
                continue;
            }
            for(int num : list[i]) {
                result[len] = num;
                len++;
                if(len == k) {
                    return result;
                }
            }
        }
        return result;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>LeetCode刷题（消失的数字，接雨水）</title><link>https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97%E6%8E%A5%E9%9B%A8%E6%B0%B4/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97%E6%8E%A5%E9%9B%A8%E6%B0%B4/</guid><description>消失的数字，接雨水</description><pubDate>Tue, 03 Jun 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;消失的数字&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给你一个含 &lt;code&gt;n&lt;/code&gt; 个整数的数组 &lt;code&gt;nums&lt;/code&gt; ，其中 &lt;code&gt;nums[i]&lt;/code&gt; 在区间 &lt;code&gt;[1, n]&lt;/code&gt; 内。请你找出所有在 &lt;code&gt;[1, n]&lt;/code&gt; 范围内但没有出现在 &lt;code&gt;nums&lt;/code&gt; 中的数字，并以数组的形式返回结果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：nums = [4,3,2,7,8,2,3,1]
输出：[5,6]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：nums = [1,1]
输出：[2]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;p&gt;简单题我重拳出击，但自己写的没有达到n（0）的空间复杂度&lt;/p&gt;
&lt;p&gt;解法一：通过一个辅助数组记录出现过的数字，设置为true，再次遍历辅助数组，当对于数组为false的下表加入list集合&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public List&amp;lt;Integer&amp;gt; findDisappearedNumbers(int[] nums) {
        List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        int n = nums.length;
        boolean[] flags = new boolean[n + 1];
        for(int i = 0; i &amp;lt; n; i++) {
            flags[nums[i]] = true;
        }
        for(int i = 1; i &amp;lt;= n; i++) {
            if(flags[i] == false) {
                list.add(i);
            }
        }
        return list;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解法二：在原地实现&lt;/p&gt;
&lt;p&gt;1.遍历每个元素，对索引进行标记将对应索引位置的值变为负数；
2.遍历下索引，看看哪些索引位置上的数不是负数的，位置上不是负数的索引，对应的元素就是不存在的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public List&amp;lt;Integer&amp;gt; findDisappearedNumbers(int[] nums) {
        List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        int len = nums.length;
        for(int i = 0; i &amp;lt; len; i++) {
            int num = Math.abs(nums[i]);
            int idx = num - 1;
            if(nums[idx] &amp;gt; 0) {
                nums[idx] *= -1;
            }
        }
        for(int i = 0; i &amp;lt; len; i++) {
            if(nums[i] &amp;gt; 0) {
                int num = i + 1;
                list.add(num);
            }
        }
        return list;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其实本质上就是将第一种解法中的辅助数组，换为了在原数组上的下表用 - 表示为true，在不影响原数组的时候的情况下记录信息&lt;/p&gt;
&lt;h1&gt;接雨水&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给定 &lt;code&gt;n&lt;/code&gt; 个非负整数表示每个宽度为 &lt;code&gt;1&lt;/code&gt; 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/179.png&quot; alt=&quot;179&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：height = [4,2,0,3,2,5]
输出：9
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;p&gt;按照每一列进行求值，分别找出每一列左右两侧最高的值，取二者最小，如果最小的值小于或等于当前列高度，则不能储水，反之当前列可以存min - height[i]单位的水&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public int trap(int[] height) {
        int sum = 0;
        int n = height.length;
        for(int i = 1; i &amp;lt; n - 1; i++) {
            int max_left = 0;
            for(int j = 0; j &amp;lt; i; j++) {
                if(height[j] &amp;gt; max_left) {
                    max_left = height[j];
                }
            }
            int max_right = 0;
            for(int j = i + 1; j &amp;lt; n; j++) {
                if(height[j] &amp;gt; max_right) {
                    max_right = height[j];
                }
            }
            int min = Math.min(max_left, max_right);
            if(min &amp;gt; height[i]) {
                sum += min - height[i];
            }
        }
        return sum;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;空间复杂度n^2，对于测试用例的其中一个超时，其实本质上就是没有复用到左右两侧的最高列，以下是一个双指针的解法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public int trap(int[] height) {
        int n = height.length;
        int sum = 0;

        int left = 0;
        int right = n - 1;
        int leftMax = height[left];
        int rightMax = height[right];
        left++;
        right--;

        while(left &amp;lt;= right) {
            leftMax = Math.max(leftMax, height[left]);
            rightMax = Math.max(rightMax, height[right]);
            if(leftMax &amp;lt; rightMax) {
                sum += leftMax - height[left];
                left++;
            } else {
                sum += rightMax - height[right];
                right--;
            }
        }
        return sum;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Spring笔记（GoF代理模式）</title><link>https://thrinisty.github.io/posts/spring%E7%AC%94%E8%AE%B0gof%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/spring%E7%AC%94%E8%AE%B0gof%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</guid><description>静态代理，动态代理</description><pubDate>Mon, 02 Jun 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Spring笔记&lt;/h1&gt;
&lt;h2&gt;代理模式&lt;/h2&gt;
&lt;h3&gt;定义作用&lt;/h3&gt;
&lt;p&gt;代理模式，是GoF的23种设计模式之一，也是AoP面向切面编程中的核心&lt;/p&gt;
&lt;p&gt;:::note&lt;/p&gt;
&lt;p&gt;作用：&lt;/p&gt;
&lt;p&gt;当一个对象需要受保护的时候，可以使用代理对象完成某个行为&lt;/p&gt;
&lt;p&gt;当需要完成功能增强的时候，使用代理对象增强功能&lt;/p&gt;
&lt;p&gt;A对象和B对象无法直接交互的时候，可以使用代理模式解决&lt;/p&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;p&gt;为其他对象提供一种代理控制对这个对象的访问，在某些情况下，客户不想或者不能直接引用一个对象，可以通过一个称为“代理”的第三者实现间接引用，代理对象可以在客户端和目标对象之间起到中介的作用，并且可以通过代理对象增添功能或者过滤内容。&lt;/p&gt;
&lt;p&gt;通过引入一个新的对象来实现对真实对象的操作或者将新的的对象作为真实对象的一个替身，这种实现机制为代理模式，而通过引入代理对象来间接访问另一个对象，这是代理模式的模式动机。&lt;/p&gt;
&lt;h3&gt;三个角色&lt;/h3&gt;
&lt;p&gt;:::tip&lt;/p&gt;
&lt;p&gt;代理模式种拥有三大角色&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;目标角色&lt;/li&gt;
&lt;li&gt;代理对象&lt;/li&gt;
&lt;li&gt;目标对象和代理对象的公共接口（前两者需要具有相同的行为）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;h2&gt;静态代理实现&lt;/h2&gt;
&lt;p&gt;有一个接口以及接口方法的实现类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface OrderService {
    void generate();
    void modify();
    void detail();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public class OrderServiceImpl implements OrderService {
    @Override
    public void generate() {
        System.out.println(&quot;订单生成&quot;);
    }

    @Override
    public void modify() {
        System.out.println(&quot;订单修改&quot;);
    }

    @Override
    public void detail() {
        System.out.println(&quot;订单详情&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们现在需要增添功能：对每个业务接口中业务方法的解决耗时，可以在每个业务的前后取时间相减，但是违背了OCP原则，且没有复用代码&lt;/p&gt;
&lt;p&gt;我们使用代理模式处理，写一个OrderService的代理对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class OrderServiceProxy implements OrderService{
    //写入公共接口，耦合度低
    private OrderService orderService;

    public OrderServiceProxy(OrderService orderService) {
        this.orderService = orderService;
    }

    @Override
    public void generate() {
        long begin = System.currentTimeMillis();
        orderService.generate();
        long end = System.currentTimeMillis();
        System.out.println(&quot;Generate Order Time: &quot; + (end - begin));
    }

    @Override
    public void modify() {
        long begin = System.currentTimeMillis();
        orderService.modify();
        long end = System.currentTimeMillis();
        System.out.println(&quot;Modify Order Time: &quot; + (end - begin));
    }

    @Override
    public void detail() {
        long begin = System.currentTimeMillis();
        orderService.detail();
        long end = System.currentTimeMillis();
        System.out.println(&quot;Detail Order Time: &quot; + (end - begin));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在主函数中调用代理对象的方法即可完成功能的增强&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Main {
    public static void main(String[] args) {
        OrderService orderService = new OrderServiceImpl();
        OrderService proxy = new OrderServiceProxy(orderService);
        proxy.generate();
        proxy.modify();
        proxy.detail();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;订单生成
Generate Order Time: 0
订单修改
Modify Order Time: 0
订单详情
Detail Order Time: 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;虽然解决了OCP的开闭问题，但是每个接口需要实现一个代理类，会导致类的数量急剧增多，我们在实际会使用到动态代理&lt;/p&gt;
&lt;h2&gt;动态代理&lt;/h2&gt;
&lt;p&gt;帮助我们在内存中动态的生成代理类（字节码），达到减少类的数量，提高复用性&lt;/p&gt;
&lt;p&gt;JDK动态代理技术：只能代理接口&lt;/p&gt;
&lt;p&gt;CGLIB：开源项目，高性能Code生成类库，底层通过继承的方式实现，可以代理类&lt;/p&gt;
&lt;p&gt;Javassist动态代理技术：分析编辑创建Java字节码类库，通过使用Javassist对字节码作为JBoss实现动态“AOP”框架&lt;/p&gt;
&lt;h3&gt;JDK动态代理&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;package com.proxy.service;

public interface OrderService {
    void generate();
    void modify();
    void detail();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;package com.proxy.service;

public class OrderServiceImpl implements OrderService {
    @Override
    public void generate() {
        System.out.println(&quot;订单生成&quot;);
    }

    @Override
    public void modify() {
        System.out.println(&quot;订单修改&quot;);
    }

    @Override
    public void detail() {
        System.out.println(&quot;订单详情&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们通过一个Proxy对象传入三个参数&lt;/p&gt;
&lt;p&gt;1.类加载器 2.代理类实现的接口 3.调用处理器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.proxy.test;

public class ProxyTest {
    public static void main(String[] args) {
        //创建目标对象
        OrderService target = new OrderServiceImpl();
        //创建代理类，借助jdk中的类
        //1.类加载器 2.代理类实现的接口 3.调用处理器
        Object proxyObj = Proxy.newProxyInstance(
                target.getClass().getClassLoader(),
                //为了创建代理类，需要获取目标类的类加载器
                target.getClass().getInterfaces(),
                //为了实现接口方法，需要获取类的所有接口对象
                new TimerInvocationHandler(target)
                //传入实现了处理接口的实例对象
                );
        OrderService proxy = (OrderService) proxyObj;
        //调用代理类
        proxy.generate();
        proxy.modify();
        proxy.detail();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们需要实现一个InvocationHandler接口的实现类，其中有一个invoke方法可供重写，这个方法在代理对象方法被调用的时候被调用，额外的，我们需要一个带参数的构造器，用以传入目标对象，这样在invoke中就可以指定目标对象，调用方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class TimerInvocationHandler implements InvocationHandler {
    private Object target;

    public TimerInvocationHandler(Object target) {
        this.target = target;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        long begin = System.currentTimeMillis();
        Object object = method.invoke(target, args);
        long end = System.currentTimeMillis();
        System.out.println(&quot;Time: &quot; + (end - begin));
        return object;//返回方法调用的返回值
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意这里如果代理的目标方法存在返回值，需要在实现调用处理器的时候再次返回调用方法的返回值&lt;/p&gt;
&lt;p&gt;这里因为创建代理类的时候实际上我们使用到的参数也就只有一个target目标对象，我们将创建代理对象的方法进行封装&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class ProxyUtil {
    public static Object newProxyInstance(Object target) {
        return Proxy.newProxyInstance(
                target.getClass().getClassLoader(),
                //为了创建代理类，需要获取目标类的类加载器
                target.getClass().getInterfaces(),
                //为了实现接口方法，需要获取类的所有接口对象
                new TimerInvocationHandler(target)
                //传入实现了处理接口的实例对象
        );
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;直接传入target对象即可获取到代理类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Object proxyObj = ProxyUtil.newProxyInstance(target);
OrderService proxy = (OrderService) proxyObj;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;CGLIB动态代理&lt;/h3&gt;
&lt;p&gt;CGLIB 可以根据继承来代理，实现子类增强方法，调用父类的方法，注意不可以类不可以用final修饰父类，需要引入对应依赖，这里不再多做介绍&lt;/p&gt;
</content:encoded></item><item><title>LeetCode刷题（多数元素，寻找重复数）</title><link>https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</guid><description>多数元素，寻找重复数</description><pubDate>Mon, 02 Jun 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;多数元素&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给定一个大小为 &lt;code&gt;n&lt;/code&gt; 的数组 &lt;code&gt;nums&lt;/code&gt; ，返回其中的多数元素。多数元素是指在数组中出现次数 &lt;strong&gt;大于&lt;/strong&gt; &lt;code&gt;⌊ n/2 ⌋&lt;/code&gt; 的元素。&lt;/p&gt;
&lt;p&gt;你可以假设数组是非空的，并且给定的数组总是存在多数元素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：nums = [3,2,3]
输出：3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：nums = [2,2,1,1,1,2,2]
输出：2
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;p&gt;解法一：先对数组进行排序，返回数组中间的数字（无论是全在左侧还是全在右侧亦或者是其他情况，中间的数字都是大于总数一半的数字）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public int majorityElement(int[] nums) {
        Arrays.sort(nums);
        return nums[nums.length / 2];
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解法二：摩尔投票&lt;/p&gt;
&lt;p&gt;推论一： 若记 众数 的票数为 +1 ，非众数 的票数为 −1 ，则一定有所有数字的 票数和 &amp;gt;0 。&lt;/p&gt;
&lt;p&gt;推论二： 若数组的前 a 个数字的 票数和 =0 ，则 数组剩余 (n−a) 个数字的 票数和一定仍 &amp;gt;0 ，即后 (n−a) 个数字的 众数仍为 x&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public int majorityElement(int[] nums) {
        int count = 0;
        Integer candidate = null;
        for(int num : nums) {
            if(count == 0) {
                candidate = num;
            }
            count += (num == candidate) ? 1 : -1;
        }
        return candidate;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解法三：利用一个Map集合将所有的数字放入其中，value记录数字数量，再次便利map集合，当一个key对应的数值部分大于数组一半的时候返回这个key作为结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public int majorityElement(int[] nums) {
        Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        for(int num : nums) {
            int i = map.getOrDefault(num, 0);
            i++;
            map.put(num, i);
        }
        int target = nums.length / 2;
        Set&amp;lt;Integer&amp;gt; set = map.keySet();
        for(Integer key : set) {
            if(map.get(key) &amp;gt; target) {
                return key;
            }
        }
        return 0;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;寻找重复数&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给定一个包含 &lt;code&gt;n + 1&lt;/code&gt; 个整数的数组 &lt;code&gt;nums&lt;/code&gt; ，其数字都在 &lt;code&gt;[1, n]&lt;/code&gt; 范围内（包括 &lt;code&gt;1&lt;/code&gt; 和 &lt;code&gt;n&lt;/code&gt;），可知至少存在一个重复的整数。&lt;/p&gt;
&lt;p&gt;假设 &lt;code&gt;nums&lt;/code&gt; 只有 &lt;strong&gt;一个重复的整数&lt;/strong&gt; ，返回 &lt;strong&gt;这个重复的数&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;你设计的解决方案必须 &lt;strong&gt;不修改&lt;/strong&gt; 数组 &lt;code&gt;nums&lt;/code&gt; 且只用常量级 &lt;code&gt;O(1)&lt;/code&gt; 的额外空间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：nums = [1,3,4,2,2]
输出：2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：nums = [3,1,3,4,2]
输出：3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 3 :&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：nums = [3,3,3,3,3]
输出：3
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;p&gt;用数组模拟链表，当有重复的数的时候，出现环，通过快慢指针找出环的入口即为重复的数字&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public int findDuplicate(int[] nums) {
        int slow = 0;
        int fast = 0;
        do {
            slow = nums[slow];
            fast = nums[nums[fast]];
        } while(slow != fast);

        slow = 0;
        while(slow != fast) {
            slow = nums[slow];
            fast = nums[fast];
        }
        return slow;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第一次接触环形链表的判断，以及找到环的入口，不太理解，先背下来&lt;/p&gt;
&lt;p&gt;第一部分：使得快慢指针指向起始位置，开始移动，直到指向的节点重复&lt;/p&gt;
&lt;p&gt;第二部分：将慢指针指向起始位置，快慢指针依次移动一格，重复直到指向相同节点，该节点为环开始的节点&lt;/p&gt;
&lt;h1&gt;环形链表&lt;/h1&gt;
&lt;p&gt;额外加的：主要是上一题没有该题的基础&lt;/p&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;定一个链表的头节点  &lt;code&gt;head&lt;/code&gt; ，返回链表开始入环的第一个节点。 &lt;em&gt;如果链表无环，则返回 &lt;code&gt;null&lt;/code&gt;。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;如果链表中有某个节点，可以通过连续跟踪 &lt;code&gt;next&lt;/code&gt; 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 &lt;code&gt;pos&lt;/code&gt; 来表示链表尾连接到链表中的位置（&lt;strong&gt;索引从 0 开始&lt;/strong&gt;）。如果 &lt;code&gt;pos&lt;/code&gt; 是 &lt;code&gt;-1&lt;/code&gt;，则在该链表中没有环。&lt;strong&gt;注意：&lt;code&gt;pos&lt;/code&gt; 不作为参数进行传递&lt;/strong&gt;，仅仅是为了标识链表的实际情况。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不允许修改&lt;/strong&gt; 链表。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/175.png&quot; alt=&quot;175&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/176.png&quot; alt=&quot;176&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：head = [1,2], pos = 0
输出：返回索引为 0 的链表节点
解释：链表中有一个环，其尾部连接到第一个节点。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 3：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/178.png&quot; alt=&quot;178&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：head = [1], pos = -1
输出：返回 null
解释：链表中没有环。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        while(true) {
            if(fast == null || fast.next == null) {
                return null;
            }
            slow = slow.next;
            fast = fast.next.next;
            if(slow == fast) {
                break;
            }
        }
        slow = head;
        while(slow != fast) {
            slow = slow.next;
            fast = fast.next;
        }
        return slow;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>LeetCode刷题（）</title><link>https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E6%A8%A1%E6%9D%BF/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E6%A8%A1%E6%9D%BF/</guid><description>Leet</description><pubDate>Sun, 01 Jun 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;（题目）&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;h2&gt;题解&lt;/h2&gt;
</content:encoded></item><item><title>自学第三月份总结</title><link>https://thrinisty.github.io/posts/%E8%87%AA%E5%AD%A6%E7%AC%AC%E4%B8%89%E6%9C%88%E4%BB%BD%E6%80%BB%E7%BB%93/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/%E8%87%AA%E5%AD%A6%E7%AC%AC%E4%B8%89%E6%9C%88%E4%BB%BD%E6%80%BB%E7%BB%93/</guid><description>结束JavaWeb，开始Spring的学习，LeetCode刷题</description><pubDate>Sun, 01 Jun 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;自学第三月份总结&lt;/h1&gt;
&lt;p&gt;第三个月有很多的考试内容需要复习，但是好在自己还是抽空出来完成了一些学习，虽然和预期的进度差了一部分，但好在把持续学习的习惯保持了下来，以下是这个月完成的一些内容（虽然内容部分和前两个月的量没法比）&lt;/p&gt;
&lt;p&gt;劳动节过了个生日，和同学去外边玩了下，好好放松了几天，得劳逸结合吧，人太久都是紧绷的状态是会出问题的。&lt;/p&gt;
&lt;h2&gt;JavaWeb收尾&lt;/h2&gt;
&lt;p&gt;在第三个月份6号到15号的十天，完成了JavaWeb部分的学习，了解了Web项目设计用到的MVC层次结构，学会了JSP页面的设计，各种嵌入Java代码的方式，几个内置对象，但没有深入，因为貌似JSP现在的使用面不是很广，一般都是前后端分离，用不到JSP了，除此以外学了下EL表达式，和JSTL标签库，大概可以看懂怎么去用&lt;/p&gt;
&lt;p&gt;最重要的三大件（Filter，Servlet，Listener）有好好学，当为后续的Spring MVC打基础，末尾还看了下ajax的一些技术，和i18n国际化的使用，还有json的数据格式，以及转化方式，json的部分还是很重要的，Java中也用得到&lt;/p&gt;
&lt;h2&gt;Spring部分内容&lt;/h2&gt;
&lt;p&gt;从15号开始就有考试陆续开始了，得去看看知识点之类，然后做做题。Spring的学习满打满算也就5天左右，在学习中了解了IoC控制反转的思想，通过运用Spring的配置文件创建对象，完成各种类型的依赖注入，学会了一下命名空间的使用，自己实现了下工厂设计模式，会通过工厂Bean创建Bean对象的方法&lt;/p&gt;
&lt;p&gt;看了下底层源码，了解了Spring实例化Bean对象的方式，Bean对象的十步声明周期，Bean的循环依赖的解决方式（三级缓存，提前曝光），最后按照一些教程的示例自己手写了一个Spring的简单框架（使用dom4j + 反射 + map缓存），模拟了一下框架通过xml解析后通过反射创建实例，并再次赋值，最后提供getBean方法获取对象的流程，大大加深了对于Spring框架的理解&lt;/p&gt;
&lt;h2&gt;LeetCode刷题&lt;/h2&gt;
&lt;p&gt;在最后的十天左右，刷了刷LeetCode的Top100题目（每天2-3道左右），恢复了一下算法的手感，也补漏了一些都快要被遗忘的知识，线性规划，递归，二叉树的各式各样的遍历，链表结构，数组，位运算，一些内置函数等等。这一次我用的是Java语言刷的算法，作为高级语言确实相比于C语言来说方便了很多，各种List，Queue，Map集合对于题解来说是非常便捷的，刷题的效率也更高了，刷了十天，积累了也有31道这个样子。&lt;/p&gt;
&lt;p&gt;总之，刷LeetCode题还是很锻炼思维的，最近感觉脑子也转得快了点，也了解了前缀树的实现，拓广了下知识面。还因为是Java语言刷题，也顺便复习了下Java的基本语法。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;这个月忙了一些，但是也算是尽自己的努力多学了一些内容，下个月17号最后一科考试结束后，准备出发去南京实习，希望能在企业中学习到更多的知识，在此之前也尽量多学习一部分通用的知识点，也好为实习做准备&lt;/p&gt;
&lt;p&gt;而对于目前而言有以下展望：因为6月份还是有三科考试的，不可能把所有的注意力放在Spring的学习上，准备安排到20号前完成Spring 6的学习 + MyBatis的学习，剩下的Spring MVC 和 SpringBoot 2需要到公司之后再进行学习了。&lt;/p&gt;
</content:encoded></item><item><title>LeetCode刷题（排序链表，相交链表）</title><link>https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</guid><description>排序链表，相交链表</description><pubDate>Sun, 01 Jun 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;排序链表&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给你链表的头结点 &lt;code&gt;head&lt;/code&gt; ，请将其按 &lt;strong&gt;升序&lt;/strong&gt; 排列并返回 &lt;strong&gt;排序后的链表&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/172.jpg&quot; alt=&quot;172&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：head = [4,2,1,3]
输出：[1,2,3,4]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/173.jpg&quot; alt=&quot;173&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：head = [-1,5,3,4,0]
输出：[-1,0,3,4,5]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 3：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：head = []
输出：[]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;p&gt;递归 + 选择排序&lt;/p&gt;
&lt;p&gt;递归终止条件为输入的节点为空或者节点后没有新的节点&lt;/p&gt;
&lt;p&gt;用一个节点存储节点后的排序结果，让head节点插入其中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public ListNode sortList(ListNode head) {
        if(head == null || head.next == null) {
            return head;
        }
        ListNode sortedList = sortList(head.next);
        if(head.val &amp;lt; sortedList.val) {
            head.next = sortedList;
            return head;
        }
        ListNode p = sortedList;
        while(p.next != null &amp;amp;&amp;amp; head.val &amp;gt; p.next.val) {
            p = p.next;
        }
        head.next = p.next;
        p.next = head;
        return sortedList;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;相交链表&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给你两个单链表的头节点 &lt;code&gt;headA&lt;/code&gt; 和 &lt;code&gt;headB&lt;/code&gt; ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 &lt;code&gt;null&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;图示两个链表在节点 &lt;code&gt;c1&lt;/code&gt; 开始相交**：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/174.png&quot; alt=&quot;174&quot; /&gt;&lt;/p&gt;
&lt;p&gt;题目数据 &lt;strong&gt;保证&lt;/strong&gt; 整个链式结构中不存在环。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;，函数返回结果后，链表必须 &lt;strong&gt;保持其原始结构&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自定义评测：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;评测系统&lt;/strong&gt; 的输入如下（你设计的程序 &lt;strong&gt;不适用&lt;/strong&gt; 此输入）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;intersectVal&lt;/code&gt; - 相交的起始节点的值。如果不存在相交节点，这一值为 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;listA&lt;/code&gt; - 第一个链表&lt;/li&gt;
&lt;li&gt;&lt;code&gt;listB&lt;/code&gt; - 第二个链表&lt;/li&gt;
&lt;li&gt;&lt;code&gt;skipA&lt;/code&gt; - 在 &lt;code&gt;listA&lt;/code&gt; 中（从头节点开始）跳到交叉节点的节点数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;skipB&lt;/code&gt; - 在 &lt;code&gt;listB&lt;/code&gt; 中（从头节点开始）跳到交叉节点的节点数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;评测系统将根据这些输入创建链式数据结构，并将两个头节点 &lt;code&gt;headA&lt;/code&gt; 和 &lt;code&gt;headB&lt;/code&gt; 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 &lt;strong&gt;视作正确答案&lt;/strong&gt; 。&lt;/p&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;p&gt;在LeetCode解法上找到的一种直观方便的方法，很厉害啊&lt;/p&gt;
&lt;p&gt;如果两个链表相交，那么相交点之后的长度是相同的&lt;/p&gt;
&lt;p&gt;我们需要做的事情是，让两个链表从同距离末尾同等距离的位置开始遍历。这个位置只能是较短链表的头结点位置。
为此，我们必须消除两个链表的长度差&lt;/p&gt;
&lt;p&gt;指针 pA 指向 A 链表，指针 pB 指向 B 链表，依次往后遍历
如果 pA 到了末尾，则 pA = headB 继续遍历
如果 pB 到了末尾，则 pB = headA 继续遍历
比较长的链表指针指向较短链表head时，长度差就消除了
如此，只需要将最短链表遍历两次即可找到位置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if(headA == null || headB == null) {
            return null;
        }
        ListNode p1 = headA;
        ListNode p2 = headB;
        while(p1 != p2) {
            p1 = p1 == null ? headB : p1.next;
            p2 = p2 == null ? headA : p2.next;
        }
        return p1;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>MyBatis笔记（模板）</title><link>https://thrinisty.github.io/posts/mybatis%E7%AC%94%E8%AE%B0%E6%A8%A1%E6%9D%BF/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/mybatis%E7%AC%94%E8%AE%B0%E6%A8%A1%E6%9D%BF/</guid><description>MyBatis</description><pubDate>Sun, 01 Jun 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;MyBatis笔记&lt;/h1&gt;
</content:encoded></item><item><title>SpringAI笔记（模板）</title><link>https://thrinisty.github.io/posts/springai%E7%AC%94%E8%AE%B0%E6%A8%A1%E6%9D%BF/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/springai%E7%AC%94%E8%AE%B0%E6%A8%A1%E6%9D%BF/</guid><pubDate>Sun, 01 Jun 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;SpringAI笔记&lt;/h1&gt;
</content:encoded></item><item><title>LeetCode刷题（回文子串，合并有序列表）</title><link>https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E5%90%88%E5%B9%B6%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E5%90%88%E5%B9%B6%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8/</guid><description>回文子串，合并两个有序列表</description><pubDate>Sat, 31 May 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;回文子串&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给你一个字符串 &lt;code&gt;s&lt;/code&gt; ，请你统计并返回这个字符串中 &lt;strong&gt;回文子串&lt;/strong&gt; 的数目。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;回文字符串&lt;/strong&gt; 是正着读和倒过来读一样的字符串。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;子字符串&lt;/strong&gt; 是字符串中的由连续字符组成的一个序列。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：s = &quot;abc&quot;
输出：3
解释：三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：s = &quot;aaa&quot;
输出：6
解释：6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;p&gt;动态规划：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;状态转移方程：当 s[i] == s[j] &amp;amp;&amp;amp; (j - i &amp;lt; 2 || dp[i + 1][j - 1]) 时，dp[i][j]=true，否则为false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;判断两个字符间的内容是否为回文串：先看左右两个字符是否相同，不同则不为回文，相同则分为三种情况&lt;/p&gt;
&lt;p&gt;1.字符串长为1，即 j - i == 0，单个字符也算回文&lt;/p&gt;
&lt;p&gt;2.字符串长为2，即 j - i == 1，xx算回文串，且中间没有内容&lt;/p&gt;
&lt;p&gt;3.其余情况，中间内容为回文串，两边字符相同，也是回文子串&lt;/p&gt;
&lt;p&gt;我在第一次写的时候是这样写的：自认为可以完全遍历所有子串，但是遍历的方式出了点问题，顺序是 &lt;code&gt;i&lt;/code&gt; 从 &lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;n-1&lt;/code&gt;，&lt;code&gt;j&lt;/code&gt; 从 &lt;code&gt;i&lt;/code&gt; 到 &lt;code&gt;n-1&lt;/code&gt;，这意味着在计算 &lt;code&gt;dp[i][j]&lt;/code&gt; 时，&lt;code&gt;dp[i + 1][j - 1]&lt;/code&gt; 可能还没有被计算。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public int countSubstrings(String s) {
        int n = s.length();
        boolean[][] dp = new boolean[n][n];
        int result = 0;
        for(int i = 0; i &amp;lt; n; i++) {
            for(int j = i; j &amp;lt; n; j++) {
                if(s.charAt(i) == s.charAt(j) &amp;amp;&amp;amp; (j - i == 0 || j - i == 1 || dp[i + 1][j - 1])) {
                    dp[i][j] = true;
                    result++;
                } else {
                    dp[i][j] = false;
                }
            }
        }
        return result;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;正确解法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public int countSubstrings(String s) {
        int n = s.length();
        boolean[][] dp = new boolean[n][n];
        int result = 0;
        for(int j = 0; j &amp;lt; n; j++) {
            for(int i = 0; i &amp;lt;= j; i++) {
                if(s.charAt(i) == s.charAt(j) &amp;amp;&amp;amp; (j - i == 0 || j - i == 1 || dp[i + 1][j - 1])) {
                    dp[i][j] = true;
                    result++;
                } 
            }
        }
        return result;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者我们使用更加便于理解的方式（我更倾向于这种方式）&lt;/p&gt;
&lt;p&gt;以下的解法类似于之前做过的戳气球，按照长度递增，这样就可以保证，长度长的依赖的长度小的回文被优先判断出来。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public int countSubstrings(String s) {
        int n = s.length();
        boolean[][] dp = new boolean[n][n];
        int result = 0;
        for(int len = 1; len &amp;lt;= n; len++) {
            for(int i = 0; i &amp;lt;= n - len; i++) {
                int j = i + len - 1;
                if(s.charAt(i) == s.charAt(j) &amp;amp;&amp;amp; (j - i == 0 || j - i == 1 || dp[i + 1][j - 1])) {
                    dp[i][j] = true;
                    result++;
                } 
            }
        }
        return result;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;合并有序列表&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;将两个升序链表合并为一个新的 &lt;strong&gt;升序&lt;/strong&gt; 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/171.jpg&quot; alt=&quot;171&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：l1 = [], l2 = []
输出：[]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 3：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：l1 = [], l2 = [0]
输出：[0]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;p&gt;很久没有做链表的题了，有点乱不清楚指针，看了答案思路就清晰多了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode result = new ListNode();
        ListNode p = result;
        while(list1 != null &amp;amp;&amp;amp; list2 != null) {
            if(list1.val &amp;lt;= list2.val) {
                p.next = list1;
                list1 = list1.next;
                p = p.next;
            } else{
                p.next = list2;
                list2 = list2.next;
                p = p.next;
            }
        }
        p.next = list1 == null ? list2 : list1; 
        return result.next;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Spring笔记（注解式开发，JdbcTemplate）</title><link>https://thrinisty.github.io/posts/spring%E7%AC%94%E8%AE%B0%E6%B3%A8%E8%A7%A3%E5%BC%8F%E5%BC%80%E5%8F%91jdbctemplate/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/spring%E7%AC%94%E8%AE%B0%E6%B3%A8%E8%A7%A3%E5%BC%8F%E5%BC%80%E5%8F%91jdbctemplate/</guid><description>Spring IoC注解式开发，JdbcTemplate的使用</description><pubDate>Sat, 31 May 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;注解式开发&lt;/h1&gt;
&lt;p&gt;注解的存在是为了简化XML的配置，Spring 6倡导全注解式开发&lt;/p&gt;
&lt;h2&gt;注解细节回顾&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;//元注解，标注注解的注解，表示可以出现在类上和字段上
@Target(value = {ElementType.TYPE, ElementType.FIELD})
//@Target({ElementType.TYPE, ElementType.FIELD})
//注解名为value，注解可以省略
//@Target(ElementType.TYPE)
//当数组中只有一个元素，大括号可以省略
@Retention(RetentionPolicy.RUNTIME)
//保持型策略，RUNTIME使注解保存在class文件中，被反射读取
public @interface Component {
    //定义注解属性
    String value();
    String name();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用注解标注User类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Component(value = &quot;123&quot;, name = &quot;jack&quot;)
public class User {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过反射读取注解元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class TestBean {
    public static void main(String[] args) throws Exception {
        Class&amp;lt;?&amp;gt; clazz = Class.forName(&quot;com.thrinisty.bean.User&quot;);
        if(clazz.isAnnotationPresent(Component.class)) {
            //获取类上的注解
            Component annotation = clazz.getAnnotation(Component.class);
            System.out.println(annotation.value());
            System.out.println(annotation.name());
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;注解声明原理&lt;/h2&gt;
&lt;p&gt;现在有一个包名，扫描包下的所有类，当类上有@Component注解的时候，实例化对象，然后放入Map集合中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class TestBean {
    public static void main(String[] args) throws Exception {
        Map&amp;lt;String, Object&amp;gt; map = new HashMap&amp;lt;String, Object&amp;gt;();
        //包名
        String packageName = &quot;com.thrinisty.bean&quot;;
        //获取路径
        String packagePath = packageName.replaceAll(&quot;\\.&quot;, &quot;/&quot;);
        URL url = ClassLoader.getSystemClassLoader().getResource(packagePath);
        String path = url.getPath();//获取绝对路径
        File file = new File(path);
        File[] files = file.listFiles();
        for (File f : files) {
            String[] split = f.getName().split(&quot;\\.&quot;);
            String className = packageName + &quot;.&quot; + split[0];
            //获取到包下的每个类全路径
            Class&amp;lt;?&amp;gt; clazz = Class.forName(className);
            if (clazz.isAnnotationPresent(Component.class)) {
                //获取注解
                Component annotation = clazz.getAnnotation(Component.class);
                String id = annotation.value();
                Constructor&amp;lt;?&amp;gt; constructor = clazz.getConstructor();
                Object object = constructor.newInstance();
                map.put(id, object);
            }
        }
        System.out.println(map.toString());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;@Component(&quot;userBean&quot;)
public class User {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;@Component(&quot;orderBean&quot;)
public class Other {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public class Vip {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;被注解Component标注的会被反射实例化，并且放入map集合&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
orderBean=com.thrinisty.bean.Other@2e0fa5d3, userBean=com.thrinisty.bean.User@5010be6
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;声明Bean注解&lt;/h2&gt;
&lt;p&gt;:::tip&lt;/p&gt;
&lt;p&gt;负责声明Bean的注解，常见的包括四个&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;@Component：组件&lt;/li&gt;
&lt;li&gt;@Controller：控制器&lt;/li&gt;
&lt;li&gt;@Service：业务&lt;/li&gt;
&lt;li&gt;@Repository：仓库&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package org.springframework.stereotype;
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Indexed
public @interface Component {
    String value() default &quot;&quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;后面三个通过@AliasFor起一个别名，其实本实质上是组件，用哪一个都可以&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package org.springframework.stereotype;

@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component
public @interface Controller {
    @AliasFor(
        annotation = Component.class
    )
    String value() default &quot;&quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了增强代码的可读性：表示层建议用Controller，业务层建议用Service，数组操作层建议用Repository&lt;/p&gt;
&lt;h3&gt;使用方式&lt;/h3&gt;
&lt;p&gt;1.加入aop依赖&lt;/p&gt;
&lt;p&gt;2.再Spring配置中添加context命名空间，并指定扫描的包&lt;/p&gt;
&lt;p&gt;3.在Bean类上使用注解&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&amp;gt;
&amp;lt;!--        给Spring指定要扫描那些包--&amp;gt;
    &amp;lt;context:component-scan base-package=&quot;com.bean&quot;/&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注解修饰类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Component(&quot;userBean&quot;)
public class User {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果不给value赋值，默认以类的首字母小写命名（vip）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Controller
public class Vip {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试程序，和之前一样&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class TestBean {
    @Test
    public void test() {
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
        Vip vip = context.getBean(&quot;vip&quot;, Vip.class);
        User user = context.getBean(&quot;userBean&quot;, User.class);
        System.out.println(user.toString() + &quot; &quot; + vip.toString());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;多包扫描&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;package com.dao;

import org.springframework.stereotype.Component;

@Component
public class Manager {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第一种解决方式：用，隔开即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;context:component-scan base-package=&quot;com.bean, com.dao&quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二种解决方式：指定父包&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;context:component-scan base-package=&quot;com&quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;选择性实例化&lt;/h3&gt;
&lt;p&gt;假设现在又很多Bean，被四种注解标注，现在需要实例化其中一种注解的Bean，而其余的不参与实例化&lt;/p&gt;
&lt;h4&gt;第一种解法&lt;/h4&gt;
&lt;p&gt;利用 use-default-filters=&quot;false 使所有Bean注解失效&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;context:component-scan base-package=&quot;com.bean&quot; use-default-filters=&quot;false&quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再使用&amp;lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&amp;gt;指定注解全路径，使其生效&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;context:component-scan base-package=&quot;com.bean&quot; use-default-filters=&quot;false&quot;&amp;gt;
    &amp;lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&amp;gt;
&amp;lt;/context:component-scan&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;第二种解法&lt;/h4&gt;
&lt;p&gt;先全部生效，再关闭不需要的注解&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;context:component-scan base-package=&quot;com.bean&quot; use-default-filters=&quot;true&quot;&amp;gt;
    &amp;lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&amp;gt;
&amp;lt;/context:component-scan&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Component Manager
Component User
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试程序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class TestBean {
    @Test
    public void test() {
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Controller Servlet
Controller Vip
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;注入Bean注解&lt;/h2&gt;
&lt;p&gt;:::tip&lt;/p&gt;
&lt;p&gt;负责注入Bean的注解，常见的包括四个&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;@Value：专门用于注入简单类型（可以使用在属性和方法上）&lt;/li&gt;
&lt;li&gt;@Autowired： 通过类型自动装配&lt;/li&gt;
&lt;li&gt;@Qualifier：配合Autowired使用，在接口有不同实现类时候指定名字&lt;/li&gt;
&lt;li&gt;@Resource： jdk拓展，也是最推荐使用的复杂类型注入的方式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;h3&gt;Value注解&lt;/h3&gt;
&lt;p&gt;用于注入简单类型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Component
public class MyDataSource implements DataSource {
    @Value(&quot;com.mysql,cj.jdbc.Driver&quot;)
    private String driver;
    @Value(&quot;jdbc:mysql://localhost:3306/spring6&quot;)
    private String url;
    @Value(&quot;root&quot;)
    private String username;
    @Value(&quot;123456&quot;)
    private String password;
    @Override
    public String toString() {
        return &quot;MyDataSource{&quot; +
                &quot;driver=&apos;&quot; + driver + &apos;\&apos;&apos; +
                &quot;, url=&apos;&quot; + url + &apos;\&apos;&apos; +
                &quot;, username=&apos;&quot; + username + &apos;\&apos;&apos; +
                &quot;, password=&apos;&quot; + password + &apos;\&apos;&apos; +
                &apos;}&apos;;
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过构造方法参数赋值完成注入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Component
public class MyDataSource implements DataSource {
    private String driver;
    private String url;
    private String username;
    private String password;

    public MyDataSource(@Value(&quot;com.mysql,cj.jdbc.Driver&quot;) String driver,
                        @Value(&quot;jdbc:mysql://localhost:3306/spring6&quot;)String url,
                        @Value(&quot;root&quot;)String username,
                        @Value(&quot;123456&quot;)String password) {
        this.driver = driver;
        this.url = url;
        this.username = username;
        this.password = password;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试程序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void test() {
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
    MyDataSource dataSource = context.getBean(&quot;myDataSource&quot;, MyDataSource.class);
    System.out.println(dataSource);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;MyDataSource{driver=&apos;com.mysql,cj.jdbc.Driver&apos;, url=&apos;jdbc:mysql://localhost:3306/spring6&apos;, username=&apos;root&apos;, password=&apos;123456&apos;}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Autowired、Qualifier注解&lt;/h3&gt;
&lt;p&gt;Autowired注解可以用来注入非简单类型，翻译为自动装配&lt;/p&gt;
&lt;p&gt;单独使用Autowired注解，默认根据类型装配&lt;/p&gt;
&lt;p&gt;如果需要根据名字进行装配，需要联合Qualifier注解使用&lt;/p&gt;
&lt;p&gt;OrderDao接口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface OrderDao {
    void insert();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;OrderDaoImplForMySQL实现类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Repository(&quot;orderDaoImplForMySQL&quot;)
public class OrderDaoImplForMySQL implements OrderDao {
    @Override
    public void insert() {
        System.out.println(&quot;MySQL insert order&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;服务类，拥有实现类对象接口，使用@Autowired自动装配&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Service(&quot;orderService&quot;)
public class OrderService {
    @Autowired
    private OrderDao orderDao;
    public void generate() {
        orderDao.insert();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试程序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void test() {
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
    OrderService service = context.getBean(&quot;orderService&quot;, OrderService.class);
    service.generate();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;MySQL insert order
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;:::tip&lt;/p&gt;
&lt;p&gt;如果类只有一个构造方法，且属性和参数能对应上，可以省略@Autowired注解&lt;/p&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;p&gt;这种方式适用于一个接口对应的一个实现类，如果有两个实现类就不能完成自动装配，需要用Qualifier注解，实现按照名字装配&lt;/p&gt;
&lt;p&gt;现有另外的一个NoSQL实现类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Repository(&quot;orderDaoImplForNoSQL&quot;)
public class OrderDaoImplForNoSQL implements OrderDao {
    @Override
    public void insert() {
        System.out.println(&quot;NoSQL Insert Order&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注入的时候利用@Qualifier(&quot;orderDaoImplForNoSQL&quot;)指定注入的Bean对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Service(&quot;orderService&quot;)
public class OrderService {
    @Autowired
    @Qualifier(&quot;orderDaoImplForNoSQL&quot;)
    private OrderDao orderDao;
    public void generate() {
        orderDao.insert();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Resource注解&lt;/h3&gt;
&lt;p&gt;Resource注解可以完成非简单类型的注入，是Java标准规范的一部分，是标准注解，而Autowired注解是Spring框架自己的&lt;/p&gt;
&lt;p&gt;Resource注解默认根据名字进行装配，未指定名字时，使用属性名作为name，找不到会自动启动类型装配&lt;/p&gt;
&lt;p&gt;使用：直接指定名字完成按照名字装配&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Service(&quot;orderService&quot;)
public class OrderService {
    @Resource(name = &quot;orderDaoImplForNoSQL&quot;)
    private OrderDao orderDao;
    public void generate() {
        orderDao.insert();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;全注解开发&lt;/h2&gt;
&lt;p&gt;可以通过一个类代替spring配置文件，以后不需要使用Spring配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.bean3;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

@Configuration
@ComponentScan(&quot;com&quot;)
public class SpringConfig {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试程序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void testNoXML() {
    AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
    OrderService service = context.getBean(&quot;orderService&quot;, OrderService.class);
    service.generate();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;JdbcTemplate&lt;/h1&gt;
&lt;p&gt;是Spring提供的一个JDBC模板类，是对JDBC的封装，简化JDBC代码&lt;/p&gt;
&lt;p&gt;除此之外，你还可以不使用它，而是用例如MyBatis等ORM框架，我还没有学过MyBatis，先从JdbcTemplate入门使用一下&lt;/p&gt;
&lt;h2&gt;基本使用&lt;/h2&gt;
&lt;p&gt;jdbc依赖以及mysql驱动&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- Spring JDBC (包含 spring-jdbc 和 spring-tx) --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-jdbc&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;6.0.9&amp;lt;/version&amp;gt; &amp;lt;!-- 使用最新稳定版 --&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;!-- MySQL Connector/J --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.mysql&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mysql-connector-j&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;8.0.33&amp;lt;/version&amp;gt; &amp;lt;!-- 使用最新稳定版 --&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实现一个DataSource的实现类，重写getConnection方法，并纳入Spring管理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class MyDateSource implements DataSource {
    private String driver;
    private String url;
    private String username;
    private String password;
    @Override
    public Connection getConnection() throws SQLException {
        try {
            Class.forName(driver);
            Connection connection = DriverManager.getConnection(url, username, password);
            return connection;
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Spring配置：配置了一个ds数据源Bean对象，注入各个参数，用内置的jdbcTemplate对象传入ds Bean对象到 dataSource参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&amp;gt;
    &amp;lt;bean id=&quot;ds&quot; class=&quot;bean.MyDateSource&quot;&amp;gt;
        &amp;lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&amp;gt;
        &amp;lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/spring6&quot;/&amp;gt;
        &amp;lt;property name=&quot;username&quot; value=&quot;root&quot;/&amp;gt;
        &amp;lt;property name=&quot;password&quot; value=&quot;654321&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&amp;gt;
        &amp;lt;property name=&quot;dataSource&quot; ref=&quot;ds&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试程序：增加数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void test() {
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
    JdbcTemplate jdbcTemplate = context.getBean(&quot;jdbcTemplate&quot;, JdbcTemplate.class);
    String sql = &quot;insert into user (id, name, password) values (?, ?, ?)&quot;;
    int update = jdbcTemplate.update(sql, 3, &quot;Lory&quot;, &quot;135788&quot;);
    System.out.println(update);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试程序：修改数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void test() {
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
    JdbcTemplate jdbcTemplate = context.getBean(&quot;jdbcTemplate&quot;, JdbcTemplate.class);
    String sql = &quot;update user set name=? where id=?&quot;;
    int update = jdbcTemplate.update(sql, &quot;Joker&quot;, 1);
    System.out.println(update);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试程序：删除数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void test() {
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
    JdbcTemplate jdbcTemplate = context.getBean(&quot;jdbcTemplate&quot;, JdbcTemplate.class);
    String sql = &quot;delete from user where id=?&quot;;
    int update = jdbcTemplate.update(sql, 3);
    System.out.println(update);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试程序：查询单个数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void test() {
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
    JdbcTemplate jdbcTemplate = context.getBean(&quot;jdbcTemplate&quot;, JdbcTemplate.class);
    String sql = &quot;select * from user where id = ? &quot;;
    User user = jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper&amp;lt;&amp;gt;(User.class), 1);
    System.out.println(user);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;User{id=1, name=&apos;Joker&apos;, password=&apos;123456&apos;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试程序：多个查询结果，返回List集合&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void test() {
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
    JdbcTemplate jdbcTemplate = context.getBean(&quot;jdbcTemplate&quot;, JdbcTemplate.class);
    String sql = &quot;select * from user&quot;;
    List&amp;lt;User&amp;gt; list = jdbcTemplate.query(sql, new BeanPropertyRowMapper&amp;lt;&amp;gt;(User.class));
    for(User user : list){
        System.out.println(user);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;User{id=1, name=&apos;Joker&apos;, password=&apos;123456&apos;}
User{id=2, name=&apos;李四&apos;, password=&apos;654321&apos;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试程序：查询单个值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void test() {
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
    JdbcTemplate jdbcTemplate = context.getBean(&quot;jdbcTemplate&quot;, JdbcTemplate.class);
    String sql = &quot;select count(1) from user&quot;;
    Integer integer = jdbcTemplate.queryForObject(sql, int.class);
    System.out.println(integer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;整合Druid连接池&lt;/h2&gt;
&lt;p&gt;引入依赖&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;druid&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.2.18&amp;lt;/version&amp;gt; &amp;lt;!-- 请使用最新稳定版 --&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Spring配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;bean id=&quot;ds&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&amp;gt;
    &amp;lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&amp;gt;
    &amp;lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/spring6&quot;/&amp;gt;
    &amp;lt;property name=&quot;username&quot; value=&quot;root&quot;/&amp;gt;
    &amp;lt;property name=&quot;password&quot; value=&quot;654321&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;

&amp;lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&amp;gt;
    &amp;lt;property name=&quot;dataSource&quot; ref=&quot;ds&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用结果：看到输出了一些日志信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;21:28:46.235 [main] INFO com.alibaba.druid.pool.DruidDataSource -- {dataSource-1} inited
2
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Spring笔记（手写Spring）</title><link>https://thrinisty.github.io/posts/spring%E7%AC%94%E8%AE%B0%E6%89%8B%E5%86%99spring/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/spring%E7%AC%94%E8%AE%B0%E6%89%8B%E5%86%99spring/</guid><description>简单地手写一个Spring框架</description><pubDate>Fri, 30 May 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Spring笔记&lt;/h1&gt;
&lt;h2&gt;回顾反射&lt;/h2&gt;
&lt;p&gt;写一个类，通过反射执行方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.thrinisty.bean;

public class User {
    private String name;
    private int age;

    public User() {}

    @Override
    public String toString() {
        return &quot;User{&quot; +
                &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; +
                &quot;, age=&quot; + age +
                &apos;}&apos;;
    }

    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;DI核心核心代码实现：通过class类名和filed属性名称获取对象以及字段赋值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Main {
    public static void main(String[] args) throws Exception{
        String className = &quot;com.thrinisty.bean.User&quot;;
        String filedName = &quot;age&quot;;

        Class&amp;lt;?&amp;gt; cls = Class.forName(className);
        Constructor&amp;lt;?&amp;gt; constructor = cls.getDeclaredConstructor();
        String setMethodName = &quot;set&quot; + filedName.toUpperCase().charAt(0) + filedName.substring(1);
        Field field = cls.getDeclaredField(filedName);
        Method method = cls.getDeclaredMethod(setMethodName, field.getType());

        User user = (User)constructor.newInstance();
        method.invoke(user, 20);
        System.out.println(user);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;手写Spring&lt;/h2&gt;
&lt;p&gt;Spring IoC容器实现原理：工厂模式 + 解析XML + 反射机制&lt;/p&gt;
&lt;h3&gt;准备工作&lt;/h3&gt;
&lt;p&gt;jar包管理：引入dom4j配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.dom4j&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;dom4j&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.1.4&amp;lt;/version&amp;gt; &amp;lt;!-- 使用最新版本 --&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;jaxen&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;jaxen&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.2.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;使用者准备&lt;/h4&gt;
&lt;p&gt;配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans&amp;gt;
    &amp;lt;bean id=&quot;user&quot; class=&quot;com.myspring.bean.User&quot;&amp;gt;
        &amp;lt;property name=&quot;name&quot; value=&quot;张三&quot;/&amp;gt;
        &amp;lt;property name=&quot;age&quot; value=&quot;18&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;bean id=&quot;userDaoBean&quot; class=&quot;com.myspring.bean.UserDao&quot;/&amp;gt;

    &amp;lt;bean id=&quot;userService&quot; class=&quot;com.myspring.bean.UserService&quot;&amp;gt;
        &amp;lt;property name=&quot;userDao&quot; ref=&quot;userDaoBean&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;User对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.myspring.bean;

public class User {
    private String name;
    private int age;

    @Override
    public String toString() {
        return &quot;User{&quot; +
                &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; +
                &quot;, age=&quot; + age +
                &apos;}&apos;;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;UserDao对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.myspring.bean;

public class UserDao {
    public void insert() {
        System.out.println(&quot;mysql 保存用户信息&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;UserService对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.myspring.bean;

public class UserService {
    private UserDao userDao;

    public void save() {
        userDao.insert();
    }

    public UserDao getUserDao() {
        return userDao;
    }

    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;开发者框架编写&lt;/h4&gt;
&lt;p&gt;实现思路：实现ClassPathXmlApplicationContext类，私有化一个Map集合，存放bean对象的id，以及bean对象本身，提供一个getBean方法，从Map中取出对象返回&lt;/p&gt;
&lt;p&gt;ApplicationContext 接口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package org.myspringframework.core;

public interface ApplicationContext {
    Object getBean(String beanName);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ClassPathXmlApplicationContext 接口实现类的编写&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package org.myspringframework.core;

public class ClassPathXmlApplicationContext implements ApplicationContext {
    private Map&amp;lt;String, Object&amp;gt; singletonObject = new HashMap&amp;lt;&amp;gt;();

    public ClassPathXmlApplicationContext(String configLocations) {
        //解析配置文件，初始化所有Bean对象
        try {
            SAXReader reader = new SAXReader();
            InputStream in = this.getClass().getResourceAsStream(&quot;/&quot; + configLocations);
            //读文件,获取标签
            Document document = reader.read(in);
            List&amp;lt;Node&amp;gt; nodes = document.selectNodes(&quot;//bean&quot;);
            //遍历bean标签，创建对象完成曝光
            for (Node node : nodes) {
                //向下转型，为使用Element接口方法
                Element beanElt = (Element) node;
                String id = beanElt.attributeValue(&quot;id&quot;);
                String className = beanElt.attributeValue(&quot;class&quot;);
                System.out.println(&quot;创建 &quot; + id + &quot; &quot; + className);

                try {
                    Class&amp;lt;?&amp;gt; cls = Class.forName(className);
                    Constructor&amp;lt;?&amp;gt; declaredConstructor = cls.getDeclaredConstructor();
                    Object bean = declaredConstructor.newInstance();
                    singletonObject.put(id, bean);//曝光Bean对象，放入集合
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            }

            //遍历标签，完成赋值
            for (Node node : nodes) {
                try {
                    //向下转型，为使用Element接口方法
                    Element beanElt = (Element) node;
                    String id = beanElt.attributeValue(&quot;id&quot;);
                    String className = beanElt.attributeValue(&quot;class&quot;);
                    Class&amp;lt;?&amp;gt; clazz = Class.forName(className);
                    System.out.println(&quot;赋值 &quot; + id + &quot; &quot; + className);
                    List&amp;lt;Element&amp;gt; properties = beanElt.elements(&quot;property&quot;);
                    for (Element property : properties) {
                        String propertyName = property.attributeValue(&quot;name&quot;);
                        System.out.println(propertyName);
                        String setMethodName = &quot;set&quot; + propertyName.substring(0, 1).toUpperCase() + propertyName.substring(1);
                        Field filed = clazz.getDeclaredField(propertyName);
                        Method setMethod = clazz.getDeclaredMethod(setMethodName, filed.getType());
                        String value = property.attributeValue(&quot;value&quot;);
                        String ref = property.attributeValue(&quot;ref&quot;);
                        if (value != null) {
                            //获取到的value值是字符串，需要将其转为对应类型的数据再放入
                            //支持byte short int long float double boolean char
                            //并支持对应的包装类型
                            String propertyTypeSimpleName = filed.getType().getSimpleName();
                            switch (propertyTypeSimpleName) {
                                case &quot;int&quot;:
                                    setMethod.invoke(singletonObject.get(id), Integer.parseInt(value));
                                    break;
                                case &quot;String&quot;:
                                    setMethod.invoke(singletonObject.get(id), value);
                                    break;
                                default:
                            }
                            //setMethod.invoke(singletonObject.get(id), &quot;具体值&quot;);
                        }
                        if (ref != null) {
                            setMethod.invoke(singletonObject.get(id), singletonObject.get(ref));
                        }
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            }
        } catch (DocumentException e) {
            e.printStackTrace();
        }
    }

    @Override
    public Object getBean(String beanName) {
        return singletonObject.get(beanName);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试程序：使用自己编写的Spring框架进行测试&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.test;

import com.myspring.bean.UserService;
import org.junit.jupiter.api.Test;
import org.myspringframework.core.ApplicationContext;
import org.myspringframework.core.ClassPathXmlApplicationContext;

public class TestBean {
    @Test
    public void test() {
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;myspring.xml&quot;);
        Object user = context.getBean(&quot;user&quot;);
        System.out.println(user);
        UserService userService = (UserService)context.getBean(&quot;userService&quot;);
        userService.save();
        System.out.println(userService);
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>LeetCode刷题（每日温度，不同路径，完全平方数）</title><link>https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/</guid><description>每日温度（非暴力），不同路径，完全平方数</description><pubDate>Fri, 30 May 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;每日温度&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给定一个整数数组 &lt;code&gt;temperatures&lt;/code&gt; ，表示每天的温度，返回一个数组 &lt;code&gt;answer&lt;/code&gt; ，其中 &lt;code&gt;answer[i]&lt;/code&gt; 是指对于第 &lt;code&gt;i&lt;/code&gt; 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 &lt;code&gt;0&lt;/code&gt; 来代替。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入: temperatures = [73,74,75,71,69,72,76,73]
输出: [1,1,4,2,1,1,0,0]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入: temperatures = [30,40,50,60]
输出: [1,1,1,0]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 3:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入: temperatures = [30,60,90]
输出: [1,1,0]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;p&gt;方法一：暴力拆解 自己想出来的一般都超时 :(&lt;/p&gt;
&lt;p&gt;两重for循环，依次遍历后续直到遇到更高的温度，返回下表差之后break跳出循环&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        int n = temperatures.length;
        int[] result = new int[n];
        for(int i = 0; i &amp;lt; n; i++) {
            for(int j = i; j &amp;lt; n; j++) {
                if(temperatures[i] &amp;lt; temperatures[j]) {
                    result[i] = j - i;
                    break;
                }
            }
        }
        return result;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试用例是可以通过的，但是提交的时候超时，测试用例中有一个非常夸张的样例，O(n^2)直接爆炸了，得使用时间复杂度更小的解法完成&lt;/p&gt;
&lt;p&gt;方法二：&lt;/p&gt;
&lt;p&gt;从反方向开始遍历&lt;/p&gt;
&lt;p&gt;在上一种解法中，起始在第二层for循环的时候重复计算了很多没必要的情况，例如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;33 21 20 34
3  2  1  0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们在判断33后续的更高温度的时候，先看21是否高于33，如果不高于33，可以不用依次遍历21后续的数字，而是直接跳转到21对应result中的下表（因为直到该下表前都没有大于21的温度，重复遍历没有必要），当21结果为0的时候，后续也没有温度更高的结果，直接使对应结果置为0&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        int n = temperatures.length;
        int[] result = new int[n];
        for(int i = n - 2; i &amp;gt;= 0; i--) {
            for(int j = i + 1; j &amp;lt; n; j += result[j]) {
                if(temperatures[i] &amp;lt; temperatures[j]) {
                    result[i] = j - i;
                    break;
                } else if(result[j] == 0) {
                    result[i] = 0;
                    break;
                } else {
                    continue;
                }
            }
        }
        return result;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;不同路径&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;一个机器人位于一个 &lt;code&gt;m x n&lt;/code&gt; 网格的左上角 （起始点在下图中标记为 “Start” ）。&lt;/p&gt;
&lt;p&gt;机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。&lt;/p&gt;
&lt;p&gt;问总共有多少条不同的路径？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/170.png&quot; alt=&quot;170&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：m = 3, n = 7
输出：28
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：m = 3, n = 2
输出：3
解释：
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -&amp;gt; 向下 -&amp;gt; 向下
2. 向下 -&amp;gt; 向下 -&amp;gt; 向右
3. 向下 -&amp;gt; 向右 -&amp;gt; 向下
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 3：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：m = 7, n = 3
输出：28
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 4：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：m = 3, n = 3
输出：6
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;p&gt;动态规划：和之前的最小路径类似，这里循环的操作是将上节点和左节点的走法数相加&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public int uniquePaths(int m, int n) {
        int[][] result = new int[m][n];
        for(int i = 0; i &amp;lt; m; i++) {
            result[i][0] = 1;
        }
        for(int j = 0; j &amp;lt; n; j++) {
            result[0][j] = 1;
        }
        for(int i = 1; i &amp;lt; m; i++) {
            for(int j = 1; j &amp;lt; n; j++) {
                result[i][j] = result[i - 1][j] + result[i][j - 1];
            }
        }
        return result[m - 1][n - 1];
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;完全平方数&lt;/h1&gt;
&lt;h2&gt;题目表述&lt;/h2&gt;
&lt;p&gt;给你一个整数 &lt;code&gt;n&lt;/code&gt; ，返回 &lt;em&gt;和为 &lt;code&gt;n&lt;/code&gt; 的完全平方数的最少数量&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;完全平方数&lt;/strong&gt; 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，&lt;code&gt;1&lt;/code&gt;、&lt;code&gt;4&lt;/code&gt;、&lt;code&gt;9&lt;/code&gt; 和 &lt;code&gt;16&lt;/code&gt; 都是完全平方数，而 &lt;code&gt;3&lt;/code&gt; 和 &lt;code&gt;11&lt;/code&gt; 不是。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：n = 13
输出：2
解释：13 = 4 + 9
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;p&gt;运用一个数组存储对应的数字可以被完全平方数表示的最小平方数个数，第二层for循环表示，每一个直到 j * j 大于 i 的情况，而min结果是剩余的数的最小平方数个数，迭代min找出，个数最小的情况，最后再加上这个i对应的完全平方数（result = min + 1）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public int numSquares(int n) {
        int[] result = new int [n + 1];
        for(int i = 1; i &amp;lt;= n; i++) {
            int min = Integer.MAX_VALUE;
            for(int j = 1; j * j &amp;lt;= i; j++) {
                min = Math.min(min, result[i - j * j]);
            }
            result[i] = min + 1;
        }
        return result[n];
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>LeetCode刷题（戳气球，字母异位词分组，层序遍历）</title><link>https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E6%88%B3%E6%B0%94%E7%90%83%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E6%88%B3%E6%B0%94%E7%90%83%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</guid><description>戳气球，字母异位词分组，层序遍历二叉树</description><pubDate>Wed, 28 May 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;戳气球&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;有 &lt;code&gt;n&lt;/code&gt; 个气球，编号为&lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;n - 1&lt;/code&gt;，每个气球上都标有一个数字，这些数字存在数组 &lt;code&gt;nums&lt;/code&gt; 中。&lt;/p&gt;
&lt;p&gt;现在要求你戳破所有的气球。戳破第 &lt;code&gt;i&lt;/code&gt; 个气球，你可以获得 &lt;code&gt;nums[i - 1] * nums[i] * nums[i + 1]&lt;/code&gt; 枚硬币。 这里的 &lt;code&gt;i - 1&lt;/code&gt; 和 &lt;code&gt;i + 1&lt;/code&gt; 代表和 &lt;code&gt;i&lt;/code&gt; 相邻的两个气球的序号。如果 &lt;code&gt;i - 1&lt;/code&gt;或 &lt;code&gt;i + 1&lt;/code&gt; 超出了数组的边界，那么就当它是一个数字为 &lt;code&gt;1&lt;/code&gt; 的气球。&lt;/p&gt;
&lt;p&gt;求所能获得硬币的最大数量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：nums = [3,1,5,8]
输出：167
解释：
nums = [3,1,5,8] --&amp;gt; [3,5,8] --&amp;gt; [3,8] --&amp;gt; [8] --&amp;gt; []
coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：nums = [1,5]
输出：10
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;p&gt;以现在的水平而言，不看题解只能够想到构造一个新的数组用于存储开始和结尾的1，看了题解后明确思路，通过三重循环进行二维数组的动态规划得出答案&lt;/p&gt;
&lt;p&gt;:::tip&lt;/p&gt;
&lt;p&gt;三重循环分别代表的意义：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;取对应区间的长度，从最小区间3开始&lt;/li&gt;
&lt;li&gt;取对应长度区间的起始位置，根据长度的增加，上界依次减小&lt;/li&gt;
&lt;li&gt;在长度区间内，遍历开区间的节点，迭代最大的区间结果最大值&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;p&gt;在起始len为3的时候，left和right都是0，其实也就是只有一个气球可以戳&lt;/p&gt;
&lt;p&gt;在后续的len为4的时候会使用到len为3时存储的开区间分别给左右两侧赋值，即左右两侧的结果都是最大的情况，再根据剩下的节点左右乘以len长度对应的边界节点数字，相加就是len为4在最后戳对应结点的时候的最大结果，而res是为了记录遍历所有对应节点中剩余最后节点取置最大的结果，并将其写入结果集二维数组中，用以下一次个长度的使用&lt;/p&gt;
&lt;p&gt;另外注意：因为是最后一个被戳爆的，所以它周边没有球了！没有球了！只有这个开区间首尾的 i 和 j 了！！
这就是为什么DP的状态转移方程是只和 i 和 j 位置的数字有关&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public int maxCoins(int[] nums) {
        int n = nums.length;
        int temp[] = new int[n + 2];
        temp[0] = 1;
        temp[n + 1] = 1;
        for(int i = 0; i &amp;lt; n; i++) {
            temp[i + 1] = nums[i];
        } 
        int dp[][] = new int[n + 2][n + 2];
        for(int len = 3; len &amp;lt;= n + 2; len++) {
            for(int i = 0; i &amp;lt;= n + 2 - len; i++) {
                int res = 0;
                int r_b = i + len - 1;
                for(int k = i + 1; k &amp;lt; r_b; k++) {
                    int left = dp[i][k];
                    int right = dp[k][r_b];
                    res = Math.max(res, temp[i] * temp[k] * temp[r_b] + left + right);
                }
                dp[i][r_b] = res;
            }
        }
        return dp[0][n + 1];
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;字母异位词分组&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给你一个字符串数组，请你将 &lt;strong&gt;字母异位词&lt;/strong&gt; 组合在一起。可以按任意顺序返回结果列表。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字母异位词&lt;/strong&gt; 是由重新排列源单词的所有字母得到的一个新单词。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入: strs = [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]
输出: [[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入: strs = [&quot;&quot;]
输出: [[&quot;&quot;]]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 3:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入: strs = [&quot;a&quot;]
输出: [[&quot;a&quot;]]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;p&gt;利用HashMap的key值不能重复的特性，依次遍历字符串数组元素，将遍历的当前字符串用char数组存储，利用数组排序后再次构造字符串，这样得到的异构字符串会被更改成为相同的字符串&lt;/p&gt;
&lt;p&gt;从结果map集合中取出对应的List异构存储集合，利用getOrDefault对于不存在的key值创建List集合，将当前遍历的字符串str放入对应的List异构存储集合，最后再将这个集合放回map中进行更新&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; groupAnagrams(String[] strs) {
        Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; map = new HashMap();
        for(String str : strs) {
            char[] arr = str.toCharArray();
            Arrays.sort(arr);
            String key = new String(arr);
            List&amp;lt;String&amp;gt; list = map.getOrDefault(key, new ArrayList&amp;lt;String&amp;gt;());
            list.add(str);
            map.put(key, list);
        }
        List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; result = new ArrayList&amp;lt;&amp;gt;(map.values());
        return result;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;二叉树层序遍历&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给你二叉树的根节点 &lt;code&gt;root&lt;/code&gt; ，返回其节点值的 &lt;strong&gt;层序遍历&lt;/strong&gt; 。 （即逐层地，从左到右访问所有节点）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/169.jpg&quot; alt=&quot;169&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：root = [3,9,20,null,null,15,7]
输出：[[3],[9,20],[15,7]]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：root = [1]
输出：[[1]]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 3：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：root = []
输出：[]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;p&gt;通过一个队列的集合来进行层序遍历，相较于普通的层序遍历不区分层级，通过在遍历每一层的时候使用一个n变量计数，完成时对应层级结束，再取下一层计数n&lt;/p&gt;
&lt;p&gt;:::tip&lt;/p&gt;
&lt;p&gt;这里我犯了一个小错，没有用new创建新的list集合加入result，导致了每一层的结果都是15，7，之前也用过这种方式，需要注意一下&lt;/p&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; levelOrder(TreeNode root) {
        List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result = new ArrayList&amp;lt;&amp;gt;();
        List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        if(root == null) {
            return result;
        }
        Queue&amp;lt;TreeNode&amp;gt; queue = new LinkedList&amp;lt;TreeNode&amp;gt;();
        queue.offer(root);
        while(!queue.isEmpty()) {
            list.clear();
            int n = queue.size();
            for(int i = 0; i &amp;lt; n; i++) {
                TreeNode node = queue.poll();
                list.add(node.val);
                if(node.left != null) {
                    queue.offer(node.left);
                }
                if(node.right != null) {
                    queue.offer(node.right);
                }
            }
            result.add(new ArrayList&amp;lt;Integer&amp;gt;(list));
        }
        return result;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>LeetCode刷题（最小路径和，穷举二叉搜索树）</title><link>https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C%E7%A9%B7%E4%B8%BE%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C%E7%A9%B7%E4%B8%BE%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid><description>路径和动态规划，穷举二叉搜索树</description><pubDate>Tue, 27 May 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;最小路径和&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给定一个包含非负整数的 &lt;code&gt;*m* x *n*&lt;/code&gt; 网格 &lt;code&gt;grid&lt;/code&gt; ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。&lt;/p&gt;
&lt;p&gt;**说明：**每次只能向下或者向右移动一步。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/167.jpg&quot; alt=&quot;167&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
输出：7
解释：因为路径 1→3→1→1→1 的总和最小。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：grid = [[1,2,3],[4,5,6]]
输出：12
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;m == grid.length&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;n == grid[i].length&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= m, n &amp;lt;= 200&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= grid[i][j] &amp;lt;= 200&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;p&gt;使用动态规划求解，创建一个结果二维数组，赋予初始行列累加值，遍历剩余数组元素，取上左中小的结果加上目标数组对应的值，即为到该元素位置的最短路径&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public int minPathSum(int[][] grid) {
        if(grid == null || grid.length == 0 || grid[0].length == 0) {
            return 0;
        }
        int row = grid.length;
        int col = grid[0].length;
        int[][] result = new int[row][col];
        result[0][0] = grid[0][0];
        for(int i = 1; i &amp;lt; row; i++) {
            result[i][0] = result[i - 1][0] + grid[i][0];
        }
        for(int j = 1; j &amp;lt; col; j++) {
            result[0][j] = result[0][j - 1] + grid[0][j];
        }
        for(int i = 1; i &amp;lt; row; i++) {
            for(int j = 1; j &amp;lt; col; j++) {
                result[i][j] = Math.min(result[i - 1][j], result[i][j - 1]) + grid[i][j];
            }
        }
        return result[row - 1][col - 1];
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;不同的二叉搜索树&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给你一个整数 &lt;code&gt;n&lt;/code&gt; ，求恰由 &lt;code&gt;n&lt;/code&gt; 个节点组成且节点值从 &lt;code&gt;1&lt;/code&gt; 到 &lt;code&gt;n&lt;/code&gt; 互不相同的 &lt;strong&gt;二叉搜索树&lt;/strong&gt; 有多少种？返回满足题意的二叉搜索树的种数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/168.jpg&quot; alt=&quot;168&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：n = 3
输出：5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：n = 1
输出：1
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;p&gt;1.动态规划求解&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public int numTrees(int n) {
        int[] G = new int[n + 1];
        G[0] = 1;
        G[1] = 1;
        for(int i = 2; i &amp;lt;= n; i++) {
            //遍历到n的每一个结果数组，赋予对应的结果值
            for(int j = 1; j &amp;lt;= i; j++) {
                //j为节点，依次遍历对应编号的节点
                int leftNum = G[j - 1];
                //左侧有就j-1个节点，复用G中的结果情况
                int rightNum = G[i - j];
                //右侧有i-j个节点，复用其对应长的的结果
                G[i] += leftNum * rightNum;
                //求左右两侧的乘积，代表选取对应节点的情况总数
                //最后在依次对每个节点所对应的可能进行累加
            }
        } 
        return G[n];
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.数学公式求解&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public int numTrees(int n) {
        // 提示：我们在这里需要用 long 类型防止计算过程中的溢出
        long C = 1;
        for (int i = 0; i &amp;lt; n; ++i) {
            C = C * 2 * (2 * i + 1) / (i + 2);
        }
        return (int) C;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>LeetCode刷题（构造二叉树，前缀树）</title><link>https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E7%BC%80%E6%A0%91/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E7%BC%80%E6%A0%91/</guid><description>从前序与中序遍历序列构造二叉树，实现前缀树</description><pubDate>Mon, 26 May 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;前序与中序遍历序列构造二叉树&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给定两个整数数组 &lt;code&gt;preorder&lt;/code&gt; 和 &lt;code&gt;inorder&lt;/code&gt; ，其中 &lt;code&gt;preorder&lt;/code&gt; 是二叉树的&lt;strong&gt;先序遍历&lt;/strong&gt;， &lt;code&gt;inorder&lt;/code&gt; 是同一棵树的&lt;strong&gt;中序遍历&lt;/strong&gt;，请构造二叉树并返回其根节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/166.jpg&quot; alt=&quot;166&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入: preorder = [3,9,20,15,7],inorder = [9,3,15,20,7]
输出: [3,9,20,null,null,15,7]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入: preorder = [-1], inorder = [-1]
输出: [-1]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        if(preorder.length == 0 || inorder.length == 0) {
            return null;
        }
        int root_val = preorder[0];
        TreeNode root = new TreeNode(root_val);
        for(int i = 0; i &amp;lt; preorder.length; i++) {
            if(root_val == inorder[i]) {
                int[] pre_left = Arrays.copyOfRange(preorder, 1, i + 1);
                int[] in_left = Arrays.copyOfRange(inorder, 0, i);
                root.left = buildTree(pre_left, in_left);
                
                int[] pre_right = Arrays.copyOfRange(preorder, i + 1, preorder.length);
                int[] in_right = Arrays.copyOfRange(inorder, i + 1, inorder.length);
                root.right = buildTree(pre_right, in_right); 
                break;
            }   
        }
        return root;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;前缀树&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;前缀树&lt;/strong&gt; 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补全和拼写检查。&lt;/p&gt;
&lt;p&gt;请你实现 Trie 类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Trie()&lt;/code&gt; 初始化前缀树对象。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void insert(String word)&lt;/code&gt; 向前缀树中插入字符串 &lt;code&gt;word&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boolean search(String word)&lt;/code&gt; 如果字符串 &lt;code&gt;word&lt;/code&gt; 在前缀树中，返回 &lt;code&gt;true&lt;/code&gt;（即，在检索之前已经插入）；否则，返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boolean startsWith(String prefix)&lt;/code&gt; 如果之前已经插入的字符串 &lt;code&gt;word&lt;/code&gt; 的前缀之一为 &lt;code&gt;prefix&lt;/code&gt; ，返回 &lt;code&gt;true&lt;/code&gt; ；否则，返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入
[&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;search&quot;, &quot;startsWith&quot;, &quot;insert&quot;, &quot;search&quot;]
[[], [&quot;apple&quot;], [&quot;apple&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;]]
输出
[null, null, true, false, true, null, true]

解释
Trie trie = new Trie();
trie.insert(&quot;apple&quot;);
trie.search(&quot;apple&quot;);   // 返回 True
trie.search(&quot;app&quot;);     // 返回 False
trie.startsWith(&quot;app&quot;); // 返回 True
trie.insert(&quot;app&quot;);
trie.search(&quot;app&quot;);     // 返回 True
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;p&gt;相关模板&lt;/p&gt;
&lt;p&gt;在理解前缀树的定义之后，实现的思路并不复杂，但和传统的二叉树实现有些不同，创建了一个Node类用于存储树的结构，而并非直接递归的使用Trie&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Node {
        Node[] son = new Node[26];
        boolean end;
    }

class Trie {
    private Node root = new Node();

    public void insert(String word) {
        Node cur = root;
        char[] words = word.toCharArray();
        for(char c : words) {
            int i = c - &apos;a&apos;;
            if(cur.son[i] == null) {
                cur.son[i] = new Node();
            }
            cur = cur.son[i];
        }
        cur.end = true;
    }
    
    public boolean search(String word) {
        return find(word) == 2;
    }
    
    public boolean startsWith(String prefix) {
        return find(prefix) != 0;
    }

    private int find(String word) {
        Node cur = root;
        char[] words = word.toCharArray();
        for(char c : words) {
            int i = c - &apos;a&apos;;
            if(cur.son[i] == null) {
                return 0;
            }
            cur = cur.son[i];
        }
        return cur.end ? 2 : 1;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>LeetCode刷题（组合总和，公共祖先）</title><link>https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</guid><description>组合总和，二叉树的最近公共祖先</description><pubDate>Sun, 25 May 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;组合总和&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给你一个 &lt;strong&gt;无重复元素&lt;/strong&gt; 的整数数组 &lt;code&gt;candidates&lt;/code&gt; 和一个目标整数 &lt;code&gt;target&lt;/code&gt; ，找出 &lt;code&gt;candidates&lt;/code&gt; 中可以使数字和为目标数 &lt;code&gt;target&lt;/code&gt; 的 所有 &lt;strong&gt;不同组合&lt;/strong&gt; ，并以列表形式返回。你可以按 &lt;strong&gt;任意顺序&lt;/strong&gt; 返回这些组合。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;candidates&lt;/code&gt; 中的 &lt;strong&gt;同一个&lt;/strong&gt; 数字可以 &lt;strong&gt;无限制重复被选取&lt;/strong&gt; 。如果至少一个数字的被选数量不同，则两种组合是不同的。&lt;/p&gt;
&lt;p&gt;对于给定的输入，保证和为 &lt;code&gt;target&lt;/code&gt; 的不同组合数少于 &lt;code&gt;150&lt;/code&gt; 个。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：candidates = [2,3,6,7], target = 7
输出：[[2,2,3],[7]]
解释：
2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。
7 也是一个候选， 7 = 7 。
仅有这两种组合。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入: candidates = [2,3,5], target = 8
输出: [[2,2,2,2],[2,3,3],[3,5]]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 3：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入: candidates = [2], target = 1
输出: []
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;p&gt;经典的回溯法求解：思路类似于之前做过的全排列，终止判断条件为target=0或者数组遍历完成target 任然不满足条件&lt;/p&gt;
&lt;p&gt;在调用的基础上，分为了跳过当前位置的数字，以及使用当前数字两种情况，在使用的时候使list增加被使用的数字，在递归调用传入新的目标数字和后删除&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result = new ArrayList&amp;lt;&amp;gt;();
    List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();

    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; combinationSum(int[] candidates, int target) {
        fun(candidates, target, 0);
        return result;
    }

    public void fun(int[] candidates, int target, int idx) {
        if(target == 0) {
            result.add(new ArrayList&amp;lt;Integer&amp;gt;(list));
            return;
        }
        if(idx == candidates.length) {
            return;
        }
        fun(candidates, target, idx + 1);

        int newNum = candidates[idx];
        int newTarget = target - newNum;
        if(newTarget &amp;gt;= 0) {
            list.add(newNum);
            fun(candidates, newTarget, idx);
            list.remove(list.size() - 1);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;二叉树的最近公共祖先&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin&quot;&gt;百度百科&lt;/a&gt;中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（&lt;strong&gt;一个节点也可以是它自己的祖先&lt;/strong&gt;）。”&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/165.png&quot; alt=&quot;165&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/165.png&quot; alt=&quot;165&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出：5
解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 3：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：root = [1,2], p = 1, q = 2
输出：1
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;p&gt;如果当前节点是 null 或者是目标节点之一（p 或 q），直接返回当前节点。
递归左右子树：
左子树返回值为 l，右子树返回值为 r。
根据左右子树的返回值判断：
如果左子树返回 null，说明 p 和 q 都在右子树中，返回右子树的结果。
如果右子树返回 null，说明 p 和 q 都在左子树中，返回左子树的结果。
如果左右子树都不为 null，说明当前节点就是最近公共祖先，返回当前节点。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null || root == p || root == q) {
            return root;
        }
        TreeNode l = lowestCommonAncestor(root.left, p, q);
        TreeNode r = lowestCommonAncestor(root.right, p, q);
        TreeNode father;
        if(l == null) {
            father = r;
        } else {
            if(r == null) {
                father = l;
            } else {
                father = root;
            }
        }
        return father;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者通过三目运算符简化一下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null || root == p || root == q) {
            return root;
        }
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        return left == null ? right : (right == null ? left : root);
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Spring笔记（实例化方式，生命周期，循环依赖）</title><link>https://thrinisty.github.io/posts/spring%E7%AC%94%E8%AE%B0%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%96%B9%E5%BC%8F%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/spring%E7%AC%94%E8%AE%B0%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%96%B9%E5%BC%8F%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</guid><description>Bean的多种实例化方式，十部生命周期，Bean的循环依赖</description><pubDate>Sun, 25 May 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Spring笔记&lt;/h1&gt;
&lt;p&gt;​	之前的Spring的学习计划因为考试和作业被稍微耽搁了一下，原本计划是到30号以后再继续学习的，但是最近稍微忙了一下，把编译原理理论给复习完了（其实上课听了的话不会话太长时间）&lt;/p&gt;
&lt;p&gt;​	考试在28号，打算在27号和28号的两天早上再做一做题目热手，24-26号这三天还是可以抽得出时间稍微学习一下。&lt;/p&gt;
&lt;h2&gt;Bean实例化&lt;/h2&gt;
&lt;p&gt;:::note&lt;/p&gt;
&lt;p&gt;Spring为Bean提供了多种实例化的方式，通常包括四种&lt;/p&gt;
&lt;p&gt;1.通过构造方式创建实例化&lt;/p&gt;
&lt;p&gt;2.通过简单工厂模式实例化&lt;/p&gt;
&lt;p&gt;3.通过factory-bean实例化&lt;/p&gt;
&lt;p&gt;4.通过FactoryBean接口实例化&lt;/p&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;h3&gt;构造方法创建&lt;/h3&gt;
&lt;p&gt;通过静态方法创建Bean&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;bean id=&quot;personBean&quot; class=&quot;com.thrinisty.bean.Person&quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过context利用配置文件中的Bean对象，自动调用无参构造器创建对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void test01() {
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
    Person person = context.getBean(&quot;personBean&quot;, Person.class);
    person.fun();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;简单工厂模式实例化&lt;/h3&gt;
&lt;p&gt;通过factoryStar Bean对象，指定createStar方法创建Star实例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;bean id=&quot;factoryStar&quot; class=&quot;com.thrinisty.bean.StarFactory&quot; factory-method=&quot;createStar&quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public class StarFactory {
    //简单工厂
    //静态工厂方法
    public static Star createStar() {
        return new Star();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试程序，传入工厂类，底层根据配置调用构造Star的方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void test02() {
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
    Star star = context.getBean(&quot;factoryStar&quot;, Star.class);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;FactoryBean实例化&lt;/h3&gt;
&lt;p&gt;工厂方法模式实例化&lt;/p&gt;
&lt;p&gt;相比于简单工厂，通过实例方法构建对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class GunFactory {
    //工厂模式方法，是实例方法
    public Gun createGun() {
        return new Gun();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;spring配置：先创建工厂bean对象，使用Bean对象的对应方法&lt;/p&gt;
&lt;p&gt;分别通过factory-bean和factory-method指定&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;bean id=&quot;gunFactory&quot; class=&quot;com.thrinisty.bean.GunFactory&quot;/&amp;gt;
&amp;lt;bean id=&quot;getFactory&quot; factory-bean=&quot;gunFactory&quot; factory-method=&quot;createGun&quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试程序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void test03() {
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
    Gun gun = context.getBean(&quot;getFactory&quot;, Gun.class);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;FactoryBean接口&lt;/h3&gt;
&lt;p&gt;当编写的Bean实现了FactoryBean接口，就可以不用指定factory-bean和factory-method，可以简化配置&lt;/p&gt;
&lt;p&gt;实现FactoryBean接口的工厂类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class DogFactoryBean implements FactoryBean&amp;lt;Dog&amp;gt; {
    @Override
    public Dog getObject() throws Exception {
        return new Dog();
    }

    @Override
    public Class&amp;lt;?&amp;gt; getObjectType() {
        return Dog.class;
    }

    @Override
    public boolean isSingleton() {
        return FactoryBean.super.isSingleton();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;spring配置，相比于前一种方式不需要传入实例Bean对象以及对应方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;bean id=&quot;dogBean&quot; class=&quot;com.thrinisty.bean.DogFactoryBean&quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void test04() {
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
    Dog dog = context.getBean(&quot;dogBean&quot;, Dog.class);
    System.out.println(dog);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过工厂Factory相比较于直接从全路径获取Class对象，可以进行加工操作，有一些自己的优势&lt;/p&gt;
&lt;p&gt;:::tip&lt;/p&gt;
&lt;p&gt;BeanFactory与FactoryBean的区别&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;BeanFactory： Spring IoC中的顶级对象，译为Bean工厂，负责创建Bean对象&lt;/li&gt;
&lt;li&gt;FactoryBean：是一个Bean，是一个可以辅助Spring实例化Bean对象的一个Bean对象，而在Spring中Bean分为普通Bean与工厂Bean&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;h2&gt;FactoryBean实际使用&lt;/h2&gt;
&lt;p&gt;以前我们使用set注入实现日期的赋值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Student {
    private Date birth;

    public void setBirth(Date birth) {
        this.birth = birth;
    }

    @Override
    public String toString() {
        return &quot;Student{&quot; +
                &quot;birth=&quot; + birth +
                &apos;}&apos;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在配置中关联nowTime Bean对象，实现日期的注入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;bean id=&quot;student&quot; class=&quot;com.thrinisty.bean.Student&quot;&amp;gt;
    &amp;lt;property name=&quot;birth&quot; ref=&quot;nowTime&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&amp;lt;bean id=&quot;nowTime&quot; class=&quot;java.util.Date&quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是这样没有办法调用有参构造器传入指定的时间，不能作为生日使用（当前时间），接下来我们使用FactoryBean注入Date日期&lt;/p&gt;
&lt;p&gt;工厂Bean，辅助加工Date属性&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class DateFactoryBean implements FactoryBean&amp;lt;Date&amp;gt; {
    private String strDate;

    public void setStrDate(String strDate) {
        this.strDate = strDate;
    }

    @Override
    public Date getObject() throws Exception {
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
        Date date = sdf.parse(strDate);
        return date;
    }

    @Override
    public Class&amp;lt;?&amp;gt; getObjectType() {
        return null;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;构造配置，使用工厂Bean提供的Date对象关联student的日期类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;bean id=&quot;student&quot; class=&quot;com.thrinisty.bean.Student&quot;&amp;gt;
    &amp;lt;property name=&quot;birth&quot; ref=&quot;birth&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&amp;lt;bean id=&quot;birth&quot; class=&quot;com.thrinisty.bean.DateFactoryBean&quot;&amp;gt;
    &amp;lt;property name=&quot;strDate&quot; value=&quot;1980-10-11&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Bean生命周期&lt;/h2&gt;
&lt;p&gt;Bean的生命周期：Bean对象的创建，销毁是在什么时候进行的&lt;/p&gt;
&lt;h3&gt;五步生命周期&lt;/h3&gt;
&lt;p&gt;Bean实例化 -&amp;gt; Bean属性赋值 -&amp;gt; 初始化Bean -&amp;gt; 使用Bean -&amp;gt; 销毁Bean&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.thrinisty.bean;

public class User {
    private String name;

    public void setName(String name) {
        System.out.println(&quot;第二步：属性赋值&quot;);
        this.name = name;
    }

    public User() {
        System.out.println(&quot;第一步：User无参构造器&quot;);
    }

    public void initBean() {
        System.out.println(&quot;第三步：初始化Bean&quot;);
    }

    public void destroyBean() {
        System.out.println(&quot;第五步：销毁Bean&quot;);
    }

    @Override
    public String toString() {
        return &quot;User{&quot; +
                &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; +
                &apos;}&apos;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Spring中指定初始，销毁方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;bean id=&quot;user&quot; class=&quot;com.thrinisty.bean.User&quot;
    init-method=&quot;initBean&quot; destroy-method=&quot;destroyBean&quot;&amp;gt;
    &amp;lt;property name=&quot;name&quot; value=&quot;Jack&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试程序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void test01() {
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
    User user = context.getBean(&quot;user&quot;, User.class);
    System.out.println(&quot;第四步：使用Bean&quot; + user);
    ClassPathXmlApplicationContext cac = (ClassPathXmlApplicationContext)context;
    cac.close();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意要使用close方法销毁Context需要向下转型为ClassPathXmlApplicationContext&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;第一步：User无参构造器
第二步：属性赋值
第三步：初始化Bean
第四步：使用BeanUser{name=&apos;Jack&apos;}
第五步：销毁Bean
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;七步生命周期&lt;/h3&gt;
&lt;p&gt;Bean实例化 -&amp;gt; Bean属性赋值 -&amp;gt; 初始化Bean -&amp;gt; 使用Bean -&amp;gt; 销毁Bean&lt;/p&gt;
&lt;p&gt;在初始化Bean前后可以各加一个生命期，通过Bean后处理器实现&lt;/p&gt;
&lt;p&gt;执行Bean后处理器before方法-&amp;gt; 初始化Bean -&amp;gt; 执行Bean后处理器after方法&lt;/p&gt;
&lt;p&gt;创建Bean后处理器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class LogBeanPostProcessor implements BeanPostProcessor {
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        System.out.println(&quot;Before BeanPostProcessor&quot;);
        return BeanPostProcessor.super.postProcessBeforeInitialization(bean, beanName);
    }

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        System.out.println(&quot;After BeanPostProcessor&quot;);
        return BeanPostProcessor.super.postProcessAfterInitialization(bean, beanName);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Spring配置，对所有当前的xml中的Bean对象都有用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;bean class=&quot;com.thrinisty.bean.LogBeanPostProcessor&quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;第一步：User无参构造器
第二步：属性赋值
Before BeanPostProcessor
第三步：初始化Bean
After BeanPostProcessor
第四步：使用BeanUser{name=&apos;Jack&apos;}
第五步：销毁Bean
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;十步生命周期&lt;/h3&gt;
&lt;p&gt;1.在Bean后处理器Before方法之前：检测Bean是否实现BeanNameAware接口，BeanClassLoaderAware接口，BeanFactoryAware接口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class User implements BeanNameAware,
        BeanClassLoaderAware, BeanFactoryAware {
    private String name;

    @Override
    public void setBeanName(String name) {
        System.out.println(&quot;Bean名字&quot;);
    }

    @Override
    public void setBeanClassLoader(ClassLoader classLoader) {
        System.out.println(&quot;Bean类加载器&quot;);
    }

    @Override
    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
        System.out.println(&quot;BeanFactory地址&quot;);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.在Bean后处理器Before方法之后：检测Bean是否实现InitializingBean接口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
public void afterPropertiesSet() throws Exception {
    System.out.println(&quot;After PropertiesSet&quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.销毁Bean之前，使用Bean之后：检测Bean是否实现DisposableBean接口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
public void destroy() throws Exception {
    System.out.println(&quot;DisposableBean destroy&quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;第一步：User无参构造器
第二步：属性赋值

Bean名字
Bean类加载器
BeanFactory地址
Before BeanPostProcessor
After PropertiesSet

第三步：初始化Bean
After BeanPostProcessor
第四步：使用BeanUser{name=&apos;Jack&apos;}
DisposableBean destroy

第五步：销毁Bean
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;:::warning&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Spring只对singleton的Bean进行完整的生命周期管理&lt;/li&gt;
&lt;li&gt;如果是prototype作用域的Bean，Spring只负责将Bean初始化完毕，一旦用户获取到Bean，Spring就不再管理Bean生命周期（管理前八步）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;h3&gt;Spring管理new对象&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void test02(){
    Student student = new Student();
    //创建一个工厂对象，使用工厂对象完成new对象实例在Spring中的注册
    DefaultListableBeanFactory factory = new DefaultListableBeanFactory();
    factory.registerSingleton(&quot;student&quot;, student);

    Student student1 = factory.getBean(&quot;student&quot;, Student.class);
    System.out.println(student);
    System.out.println(student1);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;com.thrinisty.bean.Student@26b3fd41
com.thrinisty.bean.Student@26b3fd41
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用的是同一个对象&lt;/p&gt;
&lt;h2&gt;Bean的循环依赖&lt;/h2&gt;
&lt;p&gt;循环依赖定义：A对象中有B属性，B对象中有A属性&lt;/p&gt;
&lt;p&gt;创建夫妻两个对象类，注意避免循环调用toString&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.thrinisty.bean;

public class Husband {
    private String name;
    private Wife wife;

    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return &quot;Husband{&quot; +
                &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; +
                &quot;, wife=&quot; + wife.getName() +
                &apos;}&apos;;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setWife(Wife wife) {
        this.wife = wife;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;package com.thrinisty.bean;

public class Wife {
    private String name;
    private Husband husband;

    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return &quot;Wife{&quot; +
                &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; +
                &quot;, husband=&quot; + husband.getName() +
                &apos;}&apos;;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setHusband(Husband husband) {
        this.husband = husband;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;单例模式&lt;/h3&gt;
&lt;p&gt;spring配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;bean id=&quot;husbandBean&quot; class=&quot;com.thrinisty.bean.Husband&quot;&amp;gt;
    &amp;lt;property name=&quot;name&quot; value=&quot;Jack&quot;/&amp;gt;
    &amp;lt;property name=&quot;wife&quot; ref=&quot;wifeBean&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&amp;lt;bean id=&quot;wifeBean&quot; class=&quot;com.thrinisty.bean.Wife&quot;&amp;gt;
    &amp;lt;property name=&quot;name&quot; value=&quot;Rose&quot;/&amp;gt;
    &amp;lt;property name=&quot;husband&quot; ref=&quot;husbandBean&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;循环依赖(单例)在测试中没有问题&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void test01() {
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
    Husband husband = context.getBean(&quot;husbandBean&quot;, Husband.class);
    System.out.println(husband);
    Wife wife = context.getBean(&quot;wifeBean&quot;, Wife.class);
    System.out.println(wife);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;singleton + setter ：Spring为Bean的管理主要分为两个阶段&lt;/p&gt;
&lt;p&gt;1.Spring容器加载的时候，实例化Bean，只需要任意一个Bean实例化之后，马上进行“曝光”（不等属性赋值）&lt;/p&gt;
&lt;p&gt;2.Bean曝光之后再进行属性赋值，调用set方法进行赋值&lt;/p&gt;
&lt;p&gt;:::warning&lt;/p&gt;
&lt;p&gt;只有scope使singleton情况下，Bean才会采取提前曝光&lt;/p&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;h3&gt;多例模式&lt;/h3&gt;
&lt;p&gt;修改Bean的scope范围&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;bean id=&quot;husbandBean&quot; class=&quot;com.thrinisty.bean.Husband&quot; scope=&quot;prototype&quot;&amp;gt;
    &amp;lt;property name=&quot;name&quot; value=&quot;Jack&quot;/&amp;gt;
    &amp;lt;property name=&quot;wife&quot; ref=&quot;wifeBean&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&amp;lt;bean id=&quot;wifeBean&quot; class=&quot;com.thrinisty.bean.Wife&quot; scope=&quot;prototype&quot;&amp;gt;
    &amp;lt;property name=&quot;name&quot; value=&quot;Rose&quot;/&amp;gt;
    &amp;lt;property name=&quot;husband&quot; ref=&quot;husbandBean&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为每一次赋值都会创建新的Bean对象，会出现异常&lt;/p&gt;
&lt;p&gt;可以将husbandBean范围改为单例，就可以正常执行，不会出现循环创建Bean&lt;/p&gt;
&lt;p&gt;:::tip&lt;/p&gt;
&lt;p&gt;当两个循环依赖的Bean对象都是prototype才会发生循环创建异常&lt;/p&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;h3&gt;构造注入&lt;/h3&gt;
&lt;p&gt;无法解决循环依赖&lt;/p&gt;
&lt;p&gt;对于构造创建循环依赖的两个对象，是没有办法进行曝光赋值的，因为对象没有创建出来，创建对象依赖于另一个对象，无法执行set单例中的第一个阶段完成曝光&lt;/p&gt;
</content:encoded></item><item><title>LeetCode刷题（反转链表，二叉树展开，独立数字）</title><link>https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E7%8B%AC%E7%AB%8B%E6%95%B0%E5%AD%97/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E7%8B%AC%E7%AB%8B%E6%95%B0%E5%AD%97/</guid><description>反转链表，二叉树展开，独立数字</description><pubDate>Sat, 24 May 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;反转链表&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给你单链表的头节点 &lt;code&gt;head&lt;/code&gt; ，请你反转链表，并返回反转后的链表。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/162.jpg&quot; alt=&quot;162&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/163.jpg&quot; alt=&quot;163&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：head = [1,2]
输出：[2,1]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 3：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：head = []
输出：[]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;p&gt;设立一个哨兵节点result，其之后的链表为我们需要存储的结果&lt;/p&gt;
&lt;p&gt;通过p指针依次遍历head链表，将遍历到的每一个节点通过头插法插入result中即可实现链表反转&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public ListNode reverseList(ListNode head) {
       ListNode result = new ListNode();
       ListNode p = head;
       ListNode temp;
       while(p != null) {
        temp = p.next;
        p.next = result.next;
        result.next = p;
        p = temp;
       }
       return result.next;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;二叉树展开为链表&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给你二叉树的根结点 &lt;code&gt;root&lt;/code&gt; ，请你将它展开为一个单链表：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;展开后的单链表应该同样使用 &lt;code&gt;TreeNode&lt;/code&gt; ，其中 &lt;code&gt;right&lt;/code&gt; 子指针指向链表中下一个结点，而左子指针始终为 &lt;code&gt;null&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;展开后的单链表应该与二叉树 &lt;a href=&quot;https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin&quot;&gt;&lt;strong&gt;先序遍历&lt;/strong&gt;&lt;/a&gt; 顺序相同。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/164.jpg&quot; alt=&quot;164&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：root = [1,2,5,3,4,null,6]
输出：[1,null,2,null,3,null,4,null,5,null,6]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：root = []
输出：[]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 3：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：root = [0]
输出：[0]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;p&gt;通过先序遍历，将二叉树的节点放置于List链表中，再遍历List链表，将节点一次通过右孩子连接，而左孩子置为空&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public void flatten(TreeNode root) {
        List&amp;lt;TreeNode&amp;gt; list = new ArrayList();
        fun(root, list);
        int n = list.size();
        for(int i = 1; i &amp;lt; n; i++) {
            TreeNode node1 = list.get(i - 1);
            TreeNode node2 = list.get(i);
            node1.left = null;
            node1.right = node2;
        }
    }

    public void fun(TreeNode root, List&amp;lt;TreeNode&amp;gt; list) {
        if(root == null) {
            return;
        }
        list.add(root);
        fun(root.left, list);
        fun(root.right, list);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;只出现一次的数字&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给你一个 &lt;strong&gt;非空&lt;/strong&gt; 整数数组 &lt;code&gt;nums&lt;/code&gt; ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。&lt;/p&gt;
&lt;p&gt;你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1 ：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;**输入：**nums = [2,2,1]&lt;/p&gt;
&lt;p&gt;**输出：**1&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2 ：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;**输入：**nums = [4,1,2,1,2]&lt;/p&gt;
&lt;p&gt;**输出：**4&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 3 ：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;**输入：**nums = [1]&lt;/p&gt;
&lt;p&gt;**输出：**1&lt;/p&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;p&gt;第一种：最直观暴力的方式，遍历nums数组，依次判断list集合中是否存在相同的数字，有则删除，没有则放入，最后剩下的那一个就是只出现过一次的数字，这种解法的思想有点类似于 抽乌龟 卡牌游戏&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public int singleNumber(int[] nums) {
        List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        int n = nums.length;
        for(int i = 0; i &amp;lt; n; i++) {
            if(list.contains(nums[i])) {
                list.remove(new Integer(nums[i]));
            } else{
                list.add(nums[i]);
            }
        }
        return list.get(0);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二种：通过异或位运算求解，涉及到了数学方法，非常简单，大致思路是证明，2n + 1个数组的集体求异或，利用交换律，可以得出结果就是 0 ^ (target) = target 即我们需要的结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public int singleNumber(int[] nums) {
        int result = 0;
        int n = nums.length;
        for(int i = 0; i &amp;lt; n; i++) {
            result = result ^ nums[i];
        }
        return result;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>LeetCode刷题（乘积数组，重建队列）</title><link>https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E9%99%A4%E8%87%AA%E7%94%9F%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E9%99%A4%E8%87%AA%E7%94%9F%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97/</guid><description>除自生以外数组的乘积，根据身高重建队列</description><pubDate>Fri, 23 May 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;除自生以外数组的乘积&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt;，返回 数组 &lt;code&gt;answer&lt;/code&gt; ，其中 &lt;code&gt;answer[i]&lt;/code&gt; 等于 &lt;code&gt;nums&lt;/code&gt; 中除 &lt;code&gt;nums[i]&lt;/code&gt; 之外其余各元素的乘积 。&lt;/p&gt;
&lt;p&gt;题目数据 &lt;strong&gt;保证&lt;/strong&gt; 数组 &lt;code&gt;nums&lt;/code&gt;之中任意元素的全部前缀元素和后缀的乘积都在 &lt;strong&gt;32 位&lt;/strong&gt; 整数范围内。&lt;/p&gt;
&lt;p&gt;请 **不要使用除法，**且在 &lt;code&gt;O(n)&lt;/code&gt; 时间复杂度内完成此题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入: nums = [1,2,3,4]
输出: [24,12,8,6]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入: nums = [-1,1,0,-3,3]
输出: [0,0,9,0,0]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;p&gt;用传统的求数组乘积的方法，在数组中存在0的时候失效，因为使用除法/0会导致异常，我们构造两个辅助数组，分别计算出该位置左右两侧所有的数相乘结果，在使用两个数组逐个相乘即可得出答案&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] L = new int[n];
        int[] R = new int[n];
        int[] result = new int[n];
        L[0] = 1;
        for (int i = 1; i &amp;lt; n; i++) {
            L[i] = L[i - 1] * nums[i - 1];
        }
        R[n - 1] = 1;
        for (int i = n - 2; i &amp;gt;= 0; i--) {
            R[i] = R[i + 1] * nums[i + 1]; 
        }
        for(int i = 0; i &amp;lt; n; i++) {
            result[i] = L[i] * R[i];
        }
        return result;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还可以进一步改善，不创建辅助数组，直接在结果数组中进行操作&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] result = new int[n];

        //用结果数组存储每个数左侧的乘积
        result[0] = 1; 
        for (int i = 1; i &amp;lt; n; i++) {
            result[i] = result[i - 1] * nums[i - 1];
        }

        //右侧的乘积结果使用遍历R表示，初始为1
        int R = 1;
        for (int i = n - 1; i &amp;gt;= 0; i--) {
            result[i] *= R;
            R *= nums[i];
        }
        return result;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;根据身高重建队列&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;假设有打乱顺序的一群人站成一个队列，数组 &lt;code&gt;people&lt;/code&gt; 表示队列中一些人的属性（不一定按顺序）。每个 &lt;code&gt;people[i] = [hi, ki]&lt;/code&gt; 表示第 &lt;code&gt;i&lt;/code&gt; 个人的身高为 &lt;code&gt;hi&lt;/code&gt; ，前面 &lt;strong&gt;正好&lt;/strong&gt; 有 &lt;code&gt;ki&lt;/code&gt; 个身高大于或等于 &lt;code&gt;hi&lt;/code&gt; 的人。&lt;/p&gt;
&lt;p&gt;请你重新构造并返回输入数组 &lt;code&gt;people&lt;/code&gt; 所表示的队列。返回的队列应该格式化为数组 &lt;code&gt;queue&lt;/code&gt; ，其中 &lt;code&gt;queue[j] = [hj, kj]&lt;/code&gt; 是队列中第 &lt;code&gt;j&lt;/code&gt; 个人的属性（&lt;code&gt;queue[0]&lt;/code&gt; 是排在队列前面的人）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
解释：
编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。
编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。
编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。
编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。
编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;p&gt;先运用sort传入内部类，进行定制排序（将升高按照从大到小排列，相同时前面人数多的放在后面），实现后面的人放入集合不影响前面的队形&lt;/p&gt;
&lt;p&gt;这样的话按照顺序遍历int二维数组，将每个一维数组按照前面存在的人数进行放入（以及放入的人都比这个人要高）即可实现，最后将List集合转化为数组返回&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public int[][] reconstructQueue(int[][] people) {
        Arrays.sort(people, new Comparator&amp;lt;int[]&amp;gt;() {
            public int compare(int[] people1, int[] people2) {
                if(people1[0] != people2[0]) {
                    return people2[0] - people1[0];
                } 
                return people1[1] - people2[1];
            }
        });
        List&amp;lt;int[]&amp;gt; ans = new ArrayList&amp;lt;&amp;gt;();
        for(int [] person : people) {
            ans.add(person[1], person);
        }
       ans.toArray(people);
        return people;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public int[][] reconstructQueue(int[][] people) {
        Arrays.sort(people, new Comparator&amp;lt;int[]&amp;gt;() {
            public int compare(int[] person1, int[] person2) {
                if(person1[0] != person2[0]) {
                    return person2[0] - person1[0];
                }
                return person1[1] - person2[1];
            }
        });
        List&amp;lt;int[]&amp;gt; ans = new ArrayList&amp;lt;&amp;gt;();
        for(int[] person : people) {
            ans.add(person[1], person);
        }
        int n = ans.size();
        for(int i = 0; i &amp;lt; n; i++) {
            people[i] = ans.get(i);
        }
        return people;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>LeetCode刷题（旋转图像，将二叉树转为累加树）</title><link>https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F%E5%B0%86%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F%E5%B0%86%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91/</guid><description>旋转图像，将二叉树转为累加树</description><pubDate>Thu, 22 May 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;旋转图像&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给定一个 &lt;em&gt;n&lt;/em&gt; × &lt;em&gt;n&lt;/em&gt; 的二维矩阵 &lt;code&gt;matrix&lt;/code&gt; 表示一个图像。请你将图像顺时针旋转 90 度。&lt;/p&gt;
&lt;p&gt;你必须在**&lt;a href=&quot;https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95&quot;&gt; 原地&lt;/a&gt;** 旋转图像，这意味着你需要直接修改输入的二维矩阵。&lt;strong&gt;请不要&lt;/strong&gt; 使用另一个矩阵来旋转图像。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[[7,4,1],[8,5,2],[9,6,3]]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;p&gt;使用新的矩阵辅助完成&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        int[][] newArr = new int[n][n];
        for(int i = 0; i &amp;lt; n; i++) {
            for(int j = 0; j &amp;lt; n; j++) {
                newArr[j][n - 1 - i] = matrix[i][j];
            }
        }

         for(int i = 0; i &amp;lt; n; i++) {
            for(int j = 0; j &amp;lt; n; j++) {
                matrix[i][j] = newArr[i][j];
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用原矩阵完成（水平反转 + 对角线反转）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        int temp;
        for(int i = 0, k = n - 1; i &amp;lt; k; i++, k--) {
            for(int j = 0; j &amp;lt; n; j++) {
                temp = matrix[i][j];
                matrix[i][j] = matrix[k][j];
                matrix[k][j] = temp;
            }
        }
        for(int i = 0; i &amp;lt; n; i++) {
            for(int j = 0; j &amp;lt; i; j++) {
                temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;二叉搜索树转为累加树&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给出二叉 &lt;strong&gt;搜索&lt;/strong&gt; 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 &lt;code&gt;node&lt;/code&gt; 的新值等于原树中大于或等于 &lt;code&gt;node.val&lt;/code&gt; 的值之和。&lt;/p&gt;
&lt;p&gt;提醒一下，二叉搜索树满足下列约束条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;节点的左子树仅包含键 &lt;strong&gt;小于&lt;/strong&gt; 节点键的节点。&lt;/li&gt;
&lt;li&gt;节点的右子树仅包含键 &lt;strong&gt;大于&lt;/strong&gt; 节点键的节点。&lt;/li&gt;
&lt;li&gt;左右子树也必须是二叉搜索树。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;../images/161.png&quot; alt=&quot;161&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;p&gt;反着中序遍历，递归完成，在其中运用sum记录累加值，进行赋值操作即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    int sum = 0;
    public TreeNode convertBST(TreeNode root) {
        if(root != null) {
            convertBST(root.right);
            sum += root.val;
            root.val = sum;
            convertBST(root.left);
        }
        return root;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>LeetCode刷题（括号生成，二叉树最大深度）</title><link>https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</guid><description>括号生成，二叉树最大深度</description><pubDate>Wed, 21 May 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;括号生成&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;数字 &lt;code&gt;n&lt;/code&gt; 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 &lt;strong&gt;有效的&lt;/strong&gt; 括号组合。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：n = 3
输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：n = 1
输出：[&quot;()&quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;p&gt;解法一：用字符串存储结果&lt;/p&gt;
&lt;p&gt;利用递归解决，用left与right记录剩余的左右括号，当左括号多余右括号时才允许添加右括号（合法）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public List&amp;lt;String&amp;gt; generateParenthesis(int n) {
        List&amp;lt;String&amp;gt; result = new ArrayList&amp;lt;&amp;gt;();
        fun(result, &quot;&quot;, n, n);
        return result;
    }

    public void fun(List&amp;lt;String&amp;gt; result, String str, int left, int right) {
        if(left == 0 &amp;amp;&amp;amp; right == 0) {
            result.add(str);
        }
        if(left &amp;gt; 0) {
            fun(result, str + &quot;(&quot;, left - 1, right);
        }
        if(left &amp;lt; right) {
            fun(result, str + &quot;)&quot;, left, right - 1);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解法二：StringBuilder存储&lt;/p&gt;
&lt;p&gt;更新以下用StringBuilder存储的解法，因为不用像str一样每一次创建字符串，在内存和速度上都要由于上一种解法，这种解法需要使用到回溯&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    List&amp;lt;String&amp;gt; result = new ArrayList&amp;lt;&amp;gt;();
    public List&amp;lt;String&amp;gt; generateParenthesis(int n) {
        StringBuilder str = new StringBuilder();
        fun(str, n, n);
        return result;
    }

    public void fun(StringBuilder str, int left, int right) {
        if(left == 0 &amp;amp;&amp;amp; right == 0) {
            result.add(str.toString());
            return;
        }
        if(left != 0) {
            str.append(&apos;(&apos;);
            fun(str, left - 1, right);
            str.deleteCharAt(str.length() - 1);
        }
        if(left &amp;lt; right) {
            str.append(&apos;)&apos;);
            fun(str, left, right - 1);
            str.deleteCharAt(str.length() - 1);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;二叉树最大深度&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给定一个二叉树 &lt;code&gt;root&lt;/code&gt; ，返回其最大深度。&lt;/p&gt;
&lt;p&gt;二叉树的 &lt;strong&gt;最大深度&lt;/strong&gt; 是指从根节点到最远叶子节点的最长路径上的节点数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/160.jpg&quot; alt=&quot;160&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：root = [3,9,20,null,null,15,7]
输出：3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：root = [1,null,2]
输出：2
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;p&gt;简单的分治即可实现，注意终止条件的判断，以及返回0&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public int maxDepth(TreeNode root) {
        if(root == null) {
            return 0;
        }
        int leftMax = maxDepth(root.left);
        int rightMax = maxDepth(root.right);
        return Math.max(leftMax, rightMax) + 1;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>LeetCode刷题（全排列，合并二叉树，比特位计数）</title><link>https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E5%85%A8%E6%8E%92%E5%88%97%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E5%85%A8%E6%8E%92%E5%88%97%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/</guid><description>全排列，合并二叉树，比特位计数</description><pubDate>Tue, 20 May 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;全排列&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给定一个不含重复数字的数组 &lt;code&gt;nums&lt;/code&gt; ，返回其 &lt;em&gt;所有可能的全排列&lt;/em&gt; 。你可以 &lt;strong&gt;按任意顺序&lt;/strong&gt; 返回答案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：nums = [0,1]
输出：[[0,1],[1,0]]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 3：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：nums = [1]
输出：[[1]]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;p&gt;回溯法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result = new ArrayList&amp;lt;&amp;gt;();
    List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; permute(int[] nums) {
        int n = nums.length;
        for(int num : nums) {
            list.add(num);
        }
        fun(n, 0);
        return result;
    }

    public void fun(int n, int index) {
        if(n == index) {
            result.add(new ArrayList&amp;lt;&amp;gt;(list));
            return;
        }
        for(int i = index; i &amp;lt; n; i++) {
            Collections.swap(list, i, index);
            fun(n, index + 1);
            Collections.swap(list, i, index);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;合并二叉树&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给你两棵二叉树： &lt;code&gt;root1&lt;/code&gt; 和 &lt;code&gt;root2&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，&lt;strong&gt;不为&lt;/strong&gt; null 的节点将直接作为新二叉树的节点。&lt;/p&gt;
&lt;p&gt;返回合并后的二叉树。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; 合并过程必须从两个树的根节点开始。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/159.jpg&quot; alt=&quot;159&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
输出：[3,4,5,5,4,null,7]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：root1 = [1], root2 = [1,2]
输出：[2,2]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        if(root1 == null) {
            return root2;
        }
        if(root2 == null) {
            return root1;
        }
        TreeNode merge = new TreeNode();
        merge.val = root1.val + root2.val;
        merge.left = mergeTrees(root1.left, root2.left);
        merge.right = mergeTrees(root1.right, root2.right);
        return merge;      
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;比特位计数&lt;/h1&gt;
&lt;h2&gt;题目表述&lt;/h2&gt;
&lt;p&gt;给你一个整数 &lt;code&gt;n&lt;/code&gt; ，对于 &lt;code&gt;0 &amp;lt;= i &amp;lt;= n&lt;/code&gt; 中的每个 &lt;code&gt;i&lt;/code&gt; ，计算其二进制表示中 &lt;strong&gt;&lt;code&gt;1&lt;/code&gt; 的个数&lt;/strong&gt; ，返回一个长度为 &lt;code&gt;n + 1&lt;/code&gt; 的数组 &lt;code&gt;ans&lt;/code&gt; 作为答案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：n = 2
输出：[0,1,1]
解释：
0 --&amp;gt; 0
1 --&amp;gt; 1
2 --&amp;gt; 10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：n = 5
输出：[0,1,1,2,1,2]
解释：
0 --&amp;gt; 0
1 --&amp;gt; 1
2 --&amp;gt; 10
3 --&amp;gt; 11
4 --&amp;gt; 100
5 --&amp;gt; 101
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;p&gt;解法一：用之前汉明距离的函数进行循环赋值，可以很轻松的实现，但是时间复杂度较高在n的循环中需要套嵌一层log n来求解对应数字的含1数量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public int[] countBits(int n) {
        int[] result = new int[n + 1];
        for(int i = 0; i &amp;lt;= n; i++) {
            result[i] = count(i);
        }
        return result;
    }

    public int count(int num) {
        int result = 0;
        while(num != 0) {
            result += (1 &amp;amp; num);
            num = num &amp;gt;&amp;gt; 1;
        }
        return result;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解法二：动态规划求解&lt;/p&gt;
&lt;p&gt;对于每一个数字分为两种情况，末位不为1的情况下，它所对应的结果应该和之前求解出的num &amp;gt;&amp;gt; 1相同，而对于末尾为1的时候，结果应该是上述得出结果num - 1的1的总和结果加上末尾的1&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public int[] countBits(int n) {
        int[] result = new int[n + 1];
        for(int i = 0; i &amp;lt;= n; i++) {
            if((i &amp;amp; 1) == 0) {
                result[i] = result[i &amp;gt;&amp;gt; 1];
            } else {
                result[i] = result[i - 1] + 1;
            }
        }
        return result;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以将时间复杂度降至O(n)&lt;/p&gt;
</content:encoded></item><item><title>Spring笔记（自动装配，Bean作用域，工厂模式）</title><link>https://thrinisty.github.io/posts/spring%E7%AC%94%E8%AE%B0%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8Dbean%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/spring%E7%AC%94%E8%AE%B0%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8Dbean%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid><description>自动装配，引用外部配置文件，Bean作用域，工厂模式</description><pubDate>Tue, 20 May 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Spring笔记&lt;/h1&gt;
&lt;h2&gt;自动装配&lt;/h2&gt;
&lt;p&gt;基于set实现&lt;/p&gt;
&lt;p&gt;Spring还可以完成自动化的注入，又被称为自动装配，可以根据名字进行自动装配，也可以根据类型进行自动装配&lt;/p&gt;
&lt;p&gt;接下来以OrderService和OrderDao进行举例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class OrderDao implements UserDao {
    @Override
    public void insert() {
        System.out.println(&quot;OrderDao.insert&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public class OrderService implements UserService {
    UserDao userDao;
    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;根据名字&lt;/h3&gt;
&lt;p&gt;传统的方式进行注入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&amp;gt;
    &amp;lt;bean id=&quot;orderDao&quot; class=&quot;com.thrinisty.dao.OrderDao&quot;/&amp;gt;
    &amp;lt;bean id=&quot;orderService&quot; class=&quot;com.thrinisty.service.OrderService&quot;&amp;gt;
        &amp;lt;property name=&quot;userDao&quot; ref=&quot;orderDao&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void Test() {
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;autowire.xml&quot;);
    OrderDao orderDao = context.getBean(&quot;orderDao&quot;, OrderDao.class);
    System.out.println(orderDao);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;自动装配，这里对于OrderDao的id有严格要求，和set方法对应&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;bean id=&quot;orderService&quot; class=&quot;com.thrinisty.service.OrderService&quot; autowire=&quot;byName&quot;/&amp;gt;
&amp;lt;bean id=&quot;orderDao&quot; class=&quot;com.thrinisty.dao.OrderDao&quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;根据类型&lt;/h3&gt;
&lt;p&gt;根据类型进行装配，类型的实例不可以有多个&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;bean id=&quot;orderDao&quot; class=&quot;com.thrinisty.dao.OrderDao&quot;/&amp;gt;
&amp;lt;bean id=&quot;orderService&quot; class=&quot;com.thrinisty.service.OrderService&quot; autowire=&quot;byType&quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;外部属性配置文件&lt;/h2&gt;
&lt;p&gt;相关外部配置properties&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;driverClass=com.mysql.cj.jdbc.Driver
username=root
password=123456
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第一步：引入context命名空间&lt;/p&gt;
&lt;p&gt;第二步：通过${}使用配置文件中的数据，完成注入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&amp;gt;

    &amp;lt;context:property-placeholder location=&quot;jdbc.properties&quot;/&amp;gt;
    &amp;lt;bean id=&quot;ds&quot; class=&quot;com.thrinisty.jdbc.Source01&quot;&amp;gt;
        &amp;lt;property name=&quot;driver&quot; value=&quot;${driverClass}&quot;/&amp;gt;
        &amp;lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&amp;gt;
        &amp;lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Source01{driver=&apos;com.mysql.cj.jdbc.Driver&apos;, username=&apos;71460&apos;, password=&apos;123456&apos;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里看到我们的username值为71460，这是我的系统变量配置，和预期的有些不符（root）&lt;/p&gt;
&lt;p&gt;:::tip&lt;/p&gt;
&lt;p&gt;在写数据库配置文件的时候在配置前加上jdbc.以与系统的配置进行区分&lt;/p&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;jdbc.driverClass=com.mysql.cj.jdbc.Driver
jdbc.username=root
jdbc.password=123456
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;property name=&quot;driver&quot; value=&quot;${jdbc.driverClass}&quot;/&amp;gt;
&amp;lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&amp;gt;
&amp;lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样就没有什么问题了&lt;/p&gt;
&lt;h2&gt;Bean作用域&lt;/h2&gt;
&lt;h3&gt;单例与多例&lt;/h3&gt;
&lt;p&gt;在默认的情况下Bean对象是单例的singleton，在加载spring的xml配置文件就会创建出这样一个对象，而后续在运用getBean获取到的对象是同一个&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void test1() {
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;scope.xml&quot;);
    SpringBean springBean1 = context.getBean(&quot;springBean&quot;, SpringBean.class);
    System.out.println(springBean1);
    SpringBean springBean2 = context.getBean(&quot;springBean&quot;, SpringBean.class);
    System.out.println(springBean2);
    SpringBean springBean3 = context.getBean(&quot;springBean&quot;, SpringBean.class);
    System.out.println(springBean3);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;com.thrinisty.bean.SpringBean@51a9ad5e
com.thrinisty.bean.SpringBean@51a9ad5e
com.thrinisty.bean.SpringBean@51a9ad5e
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以通过设置Bean的作用域（scope）实现多例 prototype&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;bean id=&quot;springBean&quot; class=&quot;com.thrinisty.bean.SpringBean&quot; scope=&quot;prototype&quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;com.thrinisty.bean.SpringBean@6950ed69
com.thrinisty.bean.SpringBean@6dd7b5a3
com.thrinisty.bean.SpringBean@6f3187b0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样的话加载配置文件不会初始化实例对象，而getBean时获取新的实例&lt;/p&gt;
&lt;p&gt;其余的我们还可以设置为session（在一个会话中只有一个实例）request（在一个请求中只有一个实例）需要引入SpringMVC的Maven配置&lt;/p&gt;
&lt;h3&gt;自定义范围&lt;/h3&gt;
&lt;p&gt;除此以外还可以自定义范围（很少使用，了解即可）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class TestScope {
    @Test
    public void test1() {
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;scope.xml&quot;);
        SpringBean springBean1 = context.getBean(&quot;springBean&quot;, SpringBean.class);
        System.out.println(springBean1);

        Runnable runnable = () -&amp;gt; {
            SpringBean springBean2 = context.getBean(&quot;springBean&quot;, SpringBean.class);
            System.out.println(springBean2);
        };
        Thread thread = new Thread(runnable);
        thread.start();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;com.thrinisty.bean.SpringBean@7d94beb9
com.thrinisty.bean.SpringBean@7d94beb9
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;判断在多个线程中，通过Spring创建的对象为单例&lt;/p&gt;
&lt;p&gt;现在，我们需要在每一个线程中创建对应的实例&lt;/p&gt;
&lt;p&gt;第一步：自定义Scope，实现Scope接口&lt;/p&gt;
&lt;p&gt;Spring内置了一个线程范围的类：SimpleThreadScope，这里不再实现&lt;/p&gt;
&lt;p&gt;第二步：将自定义的Scope注册到Spring容器中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;bean class=&quot;org.springframework.beans.factory.config.CustomScopeConfigurer&quot;&amp;gt;
    &amp;lt;property name=&quot;scopes&quot;&amp;gt;
        &amp;lt;map&amp;gt;
            &amp;lt;entry key=&quot;myThread&quot;&amp;gt;
                &amp;lt;bean class=&quot;org.springframework.context.support.SimpleThreadScope&quot;/&amp;gt;
            &amp;lt;/entry&amp;gt;
        &amp;lt;/map&amp;gt;
    &amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第三步：使用Scope&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;bean id=&quot;springBean&quot; class=&quot;com.thrinisty.bean.SpringBean&quot; scope=&quot;myThread&quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编写测试&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void test1() {
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;scope.xml&quot;);
    SpringBean springBean1 = context.getBean(&quot;springBean&quot;, SpringBean.class);
    System.out.println(springBean1);
    SpringBean springBean3 = context.getBean(&quot;springBean&quot;, SpringBean.class);
    System.out.println(springBean3);
    Runnable runnable = () -&amp;gt; {
        SpringBean springBean2 = context.getBean(&quot;springBean&quot;, SpringBean.class);
        System.out.println(springBean2);
        SpringBean springBean4 = context.getBean(&quot;springBean&quot;, SpringBean.class);
        System.out.println(springBean4);
    };
    Thread thread = new Thread(runnable);
    thread.start();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;com.thrinisty.bean.SpringBean@39a2bb97
com.thrinisty.bean.SpringBean@39a2bb97
com.thrinisty.bean.SpringBean@1f702edb
com.thrinisty.bean.SpringBean@1f702edb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;证明在线程中安全&lt;/p&gt;
&lt;h2&gt;GoF工厂模式&lt;/h2&gt;
&lt;h3&gt;23种设计模式&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;创建型：用于解决创建对象问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;单例模式，工厂方法模式，抽象工厂模式，建造者模式，原型模式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结构型：一些类和对象组合在一起的经典结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;代理模式，修饰模式，适配器模式，组合模式，享元模式，外观模式，桥接模式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;行为型：解决类或者对象之间的交互问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;策略模式，模式方法模式，责任链模式，观察者模式，迭代子模型，命令模式，备忘录模式，状态模式，访问者模式，中介者模式，解释器模式&lt;/p&gt;
&lt;h3&gt;工厂三种形态&lt;/h3&gt;
&lt;p&gt;简单工厂模式，工厂方法模式，抽象工厂模式&lt;/p&gt;
&lt;h4&gt;简单工厂模式&lt;/h4&gt;
&lt;p&gt;是工厂方法模式的一种特殊实现，又称为静态工厂方法模式&lt;/p&gt;
&lt;p&gt;有三个角色：抽象产品，具体产品，工厂类&lt;/p&gt;
&lt;p&gt;具体产品&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Fighter extends Weapon{
    @Override
    public void attack() {
        System.out.println(&quot;飞机攻击&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public class Tank extends Weapon{
    @Override
    public void attack() {
        System.out.println(&quot;坦克攻击&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;抽象产品&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public abstract class Weapon {
    public abstract void attack();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;工厂类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class WeaponFactory {
    public static Weapon get(String weaponType) {
        if (&quot;Tank&quot;.equals(weaponType)) {
            return new Tank();
        } else if (&quot;Fighter&quot;.equals(weaponType)) {
            return new Fighter();
        } else {
            System.out.println(&quot;创建失败&quot;);
            return null;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试程序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test {
    public static void main(String[] args) {
        Weapon tank = WeaponFactory.get(&quot;Tank&quot;);
        if (tank != null) {
            tank.attack();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;客户只负责消费，工厂类负责生产，生产者和消费者分离，客户端不需要关注实现细节，只负责传入索要即可使用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;增加工厂产品，需要修改工厂类代码，违反OCP原则，另外工厂的责任大，发生问题的时候系统瘫痪，健壮性差&lt;/p&gt;
&lt;h4&gt;工厂方法模式&lt;/h4&gt;
&lt;p&gt;一个产品对应一个工厂&lt;/p&gt;
&lt;p&gt;解决了简单工厂模式中出现的OCP问题&lt;/p&gt;
&lt;p&gt;有四个角色：抽象产品，具体产品（多个），抽象工厂类，具体工厂类（多个）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;抽象工厂&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public abstract class WeaponFactory {
    public abstract Weapon get();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;具体工厂&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class TankFactory extends WeaponFactory{
    @Override
    public Weapon get() {
        return new Tank();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试程序&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test {
    public static void main(String[] args) {
        WeaponFactory factory = new TankFactory();
        Weapon tank = factory.get();
        tank.attack();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;添加新的产品的时候，只需要增加Weapon的实现类，以及对应武器的工厂实现类即可在不影响原有代码的基础上，通过对应的具体工厂创建武器的实例&lt;/p&gt;
&lt;p&gt;缺点：类的复杂性增加，类的数量大&lt;/p&gt;
&lt;p&gt;这两天除了Spring的学习以外，还而外的抽出时间刷了下LeetCode的Hot100，之前没有系统性地刷过题，于是计划按照通过率，从简单到难按顺序一步一步来，这段时间至少每日一题，保持一下编程的手感&lt;/p&gt;
&lt;p&gt;另外，这段时间忙着机器学习的大作业（5.30），以及编译原理实验（5.24），还要复习编译原理理论考试（5.28），网络编程理论考试，不是很能抽得出时间完成Spring的学习，我想等到端午节后再继续Spring的学习&lt;/p&gt;
</content:encoded></item><item><title>LeetCode刷题（子集，汉明距离，反转二叉树）</title><link>https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E5%AD%90%E9%9B%86%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB%E5%8F%8D%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E5%AD%90%E9%9B%86%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB%E5%8F%8D%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</guid><description>子集（二进制实现），汉明距离（位运算），反转二叉树（递归）</description><pubDate>Mon, 19 May 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;子集&lt;/h2&gt;
&lt;h3&gt;题目描述&lt;/h3&gt;
&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，数组中的元素 &lt;strong&gt;互不相同&lt;/strong&gt; 。返回该数组所有可能的子集（幂集）。&lt;/p&gt;
&lt;p&gt;解集 &lt;strong&gt;不能&lt;/strong&gt; 包含重复的子集。你可以按 &lt;strong&gt;任意顺序&lt;/strong&gt; 返回解集。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：nums = [0]
输出：[[],[0]]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;题解&lt;/h3&gt;
&lt;p&gt;:::tip&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根据返回类型判断返回值为存放List集合的大List集合&lt;/li&gt;
&lt;li&gt;存放进入list中的数据对应其mask的二进制表示形式&lt;/li&gt;
&lt;li&gt;在内部循环中逐个判断是否将对应元素存入小List集合&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result = new ArrayList&amp;lt;&amp;gt;();
    List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();

    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; subsets(int[] nums) {
        result.clear();
        int n = nums.length;
        for (int mask = 0; mask &amp;lt; (1 &amp;lt;&amp;lt; n); mask++) {
            list.clear();
            for (int i = 0; i &amp;lt; n; i++) {
                if((mask &amp;amp; (1 &amp;lt;&amp;lt; i)) != 0) {
                    list.add(nums[i]);
                }
            }
            result.add(new ArrayList&amp;lt;Integer&amp;gt;(list));
        }
        return result;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;汉明距离&lt;/h2&gt;
&lt;h3&gt;题目描述&lt;/h3&gt;
&lt;p&gt;两个整数之间的 &lt;a href=&quot;https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB&quot;&gt;汉明距离&lt;/a&gt; 指的是这两个数字对应二进制位不同的位置的数目。&lt;/p&gt;
&lt;p&gt;给你两个整数 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt;，计算并返回它们之间的汉明距离。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：x = 1, y = 4
输出：2
解释：
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑
上面的箭头指出了对应二进制位不同的位置。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：x = 3, y = 1
输出：1
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;题解&lt;/h3&gt;
&lt;p&gt;:::tip&lt;/p&gt;
&lt;p&gt;​	两个数的二进制不同的位通过取按位异或，再通过bitCount记录1个数即可&lt;/p&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;p&gt;使用Integer类静态方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public int hammingDistance(int x, int y) {
        return Integer.bitCount(x ^ y);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;自己实现计算1个数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public int hammingDistance(int x, int y) {
        int target = x ^ y;
        int result = 0;
        while(target != 0) {
            result += (target &amp;amp; 1);
            target = target &amp;gt;&amp;gt; 1;
        }
        return result;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;反转二叉树&lt;/h2&gt;
&lt;h3&gt;题目描述&lt;/h3&gt;
&lt;p&gt;给你一棵二叉树的根节点 &lt;code&gt;root&lt;/code&gt; ，翻转这棵二叉树，并返回其根节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/157.jpg&quot; alt=&quot;157&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/158.jpg&quot; alt=&quot;158&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：root = [2,1,3]
输出：[2,3,1]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 3：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：root = []
输出：[]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;题解&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root == null) {
            return null;
        }
        TreeNode left = invertTree(root.left);
        TreeNode right = invertTree(root.right);
        root.left = right;
        root.right = left;
        return root;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Spring笔记（创建对象，注入依赖，Set注入，构造注入，命名空间）</title><link>https://thrinisty.github.io/posts/spring%E7%AC%94%E8%AE%B0%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%B3%A8%E5%85%A5%E4%BE%9D%E8%B5%96set%E6%B3%A8%E5%85%A5%E6%9E%84%E9%80%A0%E6%B3%A8%E5%85%A5%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/spring%E7%AC%94%E8%AE%B0%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%B3%A8%E5%85%A5%E4%BE%9D%E8%B5%96set%E6%B3%A8%E5%85%A5%E6%9E%84%E9%80%A0%E6%B3%A8%E5%85%A5%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/</guid><description>创建对象，注入依赖，Set注入，构造注入，命名空间</description><pubDate>Mon, 19 May 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Spring笔记&lt;/h1&gt;
&lt;p&gt;Maven引入SpringFrameWork依赖&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;6.1.14&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;程序示例&lt;/h2&gt;
&lt;h3&gt;xml配置文件&lt;/h3&gt;
&lt;p&gt;按照spring要求创建配置xml文件&lt;/p&gt;
&lt;p&gt;在配置文件中进行对于User实例的创建&lt;/p&gt;
&lt;p&gt;id：唯一标识&lt;/p&gt;
&lt;p&gt;class：创建对象的全路径&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&amp;gt;
    &amp;lt;bean id=&quot;user&quot; class=&quot;com.thrinisty.bean.User&quot;/&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;通过Spring创建对象&lt;/h3&gt;
&lt;p&gt;在获取上下文的时候，可以传入多个配置文件，创建使用所有配置文件中的类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.thrinisty.test;

import com.thrinisty.bean.User;
import org.junit.jupiter.api.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class FirstTest {
    @Test
    public void test() {
        //获取Spring容器，其中ApplicationContext是接口，
        //由ClassPathXmlApplicationContext实现从配置文件获取上下文
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);
        //根据id获取bean对象
        User user = (User)(context.getBean(&quot;userBean&quot;));
        System.out.println(user);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过Spring调用util中的工具类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;bean id=&quot;date&quot; class=&quot;java.util.Date&quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Date date = (Date) (context.getBean(&quot;date&quot;));
//Date date = context.getBean(&quot;date&quot;, Date.class);
//不需要强制类型转化（传入第二个类对象参数）
System.out.println(date);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当没有获取到bean对象（没有对应id）抛出异常&lt;/p&gt;
&lt;p&gt;如果bean配置文件不再资源文件夹中，通过 FileSystemXmlApplicationContext 指定路径获取&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ApplicationContext context = new FileSystemXmlApplicationContext(&quot;d:/temp.xml&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;继承关系&lt;/h4&gt;
&lt;p&gt;其中BeanFactory是Spring中的顶级对象，其余的类基本继承这个对象&lt;/p&gt;
&lt;p&gt;根据底层代码，可以得出 Spring 的控制反转IoC是通过 XML解析 + 工厂模式 + 反射机制实现的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/156.png&quot; alt=&quot;156&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface ApplicationContext extends EnvironmentCapable, ListableBeanFactory, HierarchicalBeanFactory, MessageSource, ApplicationEventPublisher, ResourcePatternResolver
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;细节&lt;/h4&gt;
&lt;p&gt;在getBean之前，类的构造器方法就已经被执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;,&quot;beanNew.xml&quot;);
//Person person = context.getBean(&quot;person&quot;, Person.class);
//System.out.println(person);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Person constructor
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;依赖注入&lt;/h2&gt;
&lt;h3&gt;set注入&lt;/h3&gt;
&lt;p&gt;基于set方法，底层通过set方法利用反射完成注入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface UserService {
    void saveUser();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public class UserServiceImpl implements UserService {
    private UserDao userDao;

    @Override
    public void saveUser() {
        System.out.println(&quot;Service调用UserDao&quot;);
        userDao.insert();
    }

    //set方法
    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public interface UserDao {
    void insert();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public class UserDaoImpl implements UserDao {
    @Override
    public void insert() {
        System.out.println(&quot;数据库保存用户信息&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过xml配置管理bean&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&amp;gt;
    &amp;lt;bean id=&quot;userDaoBean&quot; class=&quot;com.thrinisty.dao.UserDaoImpl&quot;/&amp;gt;
    &amp;lt;bean id=&quot;userServiceBean&quot; class=&quot;com.thrinisty.service.UserServiceImpl&quot;&amp;gt;
        &amp;lt;property name=&quot;userDao&quot; ref=&quot;userDaoBean&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过property指定set方法，再指定传入的参数（ref传入BeanID）&lt;/p&gt;
&lt;p&gt;如此将service和dao两个对象通过set注入，即可通过service调用dao方法&lt;/p&gt;
&lt;p&gt;我们创建一个新的VipDao，我们我们在不修改原先代码的情况下，可以通过xml spring配置文件设置VipDao对象，再通过property标签传入set方法，以及传入的VipBean对象id就可以达到IoC的目的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;bean id=&quot;userDaoVip&quot; class=&quot;com.thrinisty.dao.UserDaoVip&quot;/&amp;gt;
&amp;lt;bean id=&quot;userServiceBean&quot; class=&quot;com.thrinisty.service.UserServiceImpl&quot;&amp;gt;
    &amp;lt;property name=&quot;userDao&quot; ref=&quot;userDaoVip&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public class UserDaoVip implements UserDao {
    @Override
    public void insert() {
        System.out.println(&quot;数据库保存VIP用户信息&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;构造注入&lt;/h3&gt;
&lt;p&gt;新创建一个继承于UserService接口的类，有一个构造方法，试图通过构造注入两个UserDao接口的实例userDaoImpl与UserDaoVip&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class CustomerService implements UserService{
    private UserDao userDaoImpl;
    private UserDao UserDaoVip;

    public CustomerService(UserDao userDaoImpl, UserDao userDaoVip) {
        this.userDaoImpl = userDaoImpl;
        UserDaoVip = userDaoVip;
    }

    @Override
    public void saveUser() {
        System.out.println(&quot;顾客调用Dao&quot;);
        userDaoImpl.insert();
        UserDaoVip.insert();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置文件&lt;/p&gt;
&lt;p&gt;配置两个UserDao的Bean对象&lt;/p&gt;
&lt;p&gt;通过constructor-arg传入各个参数，赋值为两个Bean对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&amp;gt;
    &amp;lt;bean id=&quot;userDaoBean&quot; class=&quot;com.thrinisty.dao.UserDaoImpl&quot;/&amp;gt;
    &amp;lt;bean id=&quot;userDaoVip&quot; class=&quot;com.thrinisty.dao.UserDaoVip&quot;/&amp;gt;

    &amp;lt;bean id=&quot;customerServiceBean&quot; class=&quot;com.thrinisty.service.CustomerService&quot;&amp;gt;
        &amp;lt;constructor-arg index=&quot;0&quot; ref=&quot;userDaoBean&quot;/&amp;gt;
        &amp;lt;constructor-arg index=&quot;1&quot; ref=&quot;userDaoVip&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试程序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void ConstructTest() {
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
    UserService userService= context.getBean(&quot;customerServiceBean&quot;, CustomerService.class);
    userService.saveUser();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Set注入专题&lt;/h2&gt;
&lt;p&gt;在实际使用中主要使用Set注入的方式&lt;/p&gt;
&lt;h3&gt;内/外部Bean&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;public class OrderDao implements UserDao {
    @Override
    public void insert() {
        System.out.println(&quot;OrderDao.insert&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public class OrderService implements UserService {
    UserDao userDao;

    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }

    @Override
    public void saveUser() {
        System.out.println(&quot;调用OrderDao&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&amp;gt;
    &amp;lt;bean id=&quot;orderDao&quot; class=&quot;com.thrinisty.dao.OrderDao&quot;/&amp;gt;
&amp;lt;!--    注入外部bean--&amp;gt;
    &amp;lt;bean id=&quot;orderService&quot; class=&quot;com.thrinisty.service.OrderService&quot;&amp;gt;
        &amp;lt;property name=&quot;userDao&quot; ref=&quot;orderDao&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;!--注入内部Bean--&amp;gt;
    &amp;lt;bean id=&quot;orderServiceAnother&quot; class=&quot;com.thrinisty.service.OrderService&quot;&amp;gt;
        &amp;lt;property name=&quot;userDao&quot;&amp;gt;
            &amp;lt;bean class=&quot;com.thrinisty.dao.OrderDao&quot;/&amp;gt;
        &amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void OrderDaoTest() {
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;order.xml&quot;);
    UserService userService = context.getBean(&quot;orderService[Another]&quot;, OrderService.class);
    userService.saveUser();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;都可以达到预期的目的&lt;/p&gt;
&lt;h3&gt;注入简单类型&lt;/h3&gt;
&lt;p&gt;简单类型：八种包装类，Sring类型，枚举类型，日期类，Class类，时间时区类型，Class类型&lt;/p&gt;
&lt;p&gt;User对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class User {
    private String username;
    private String password;
    private int age;
    //省略各个set方法
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;spring配置文件，通过value赋予值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;bean id=&quot;user&quot; class=&quot;com.thrinisty.bean.User&quot;&amp;gt;
    &amp;lt;property name=&quot;age&quot; value=&quot;18&quot;/&amp;gt;
    &amp;lt;property name=&quot;password&quot; value=&quot;123456&quot;/&amp;gt;
    &amp;lt;property name=&quot;username&quot; value=&quot;张三&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void test() {
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
    User user = context.getBean(&quot;user&quot;, User.class);
    System.out.println(user);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;其余的示例&lt;/h4&gt;
&lt;p&gt;其中日期当作简单类型的时候格式要求严格，一般不以简单格式注入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;bean id=&quot;simple&quot; class=&quot;com.thrinisty.bean.Simple&quot;&amp;gt;
    &amp;lt;property name=&quot;age&quot; value=&quot;10&quot;/&amp;gt;
    &amp;lt;property name=&quot;age2&quot; value=&quot;20&quot;/&amp;gt;
    &amp;lt;property name=&quot;username&quot; value=&quot;username&quot;/&amp;gt;
    &amp;lt;property name=&quot;c&quot; value=&quot;c&quot;/&amp;gt;
    &amp;lt;property name=&quot;c2&quot; value=&quot;d&quot;/&amp;gt;
    &amp;lt;property name=&quot;flag&quot; value=&quot;true&quot;/&amp;gt;
    &amp;lt;property name=&quot;flag2&quot; value=&quot;false&quot;/&amp;gt;
    &amp;lt;property name=&quot;season&quot; value=&quot;SPRING&quot;/&amp;gt;
    &amp;lt;property name=&quot;clazz&quot; value=&quot;java.io.File&quot;/&amp;gt;
    &amp;lt;property name=&quot;date&quot; value=&quot;Mon May 19 21:28:03 CST 2025&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public class Simple {
    private int age;
    private Integer age2;
    private boolean flag;
    private Boolean flag2;
    private char c;
    private Character c2;
    private Season season;
    private String username;
    private Class clazz;
    private Date date;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void test2() {
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
    Simple simple = context.getBean(&quot;simple&quot;, Simple.class);
    System.out.println(simple);
    //Simple{age=10, age2=20, flag=true, flag2=false, c=c, c2=d, season=SPRING, username=&apos;username&apos;, clazz=class java.io.File, date=Tue May 20 11:28:03 CST 2025}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们之前在学习JDBC配置文件的时候是通过properties配置文件通过Properties类通过键值的方式获取配置信息，而学了SpringSet注入后，我们可以不进行赋值，将赋值的工作交给Spring通过xml中property注入value完成&lt;/p&gt;
&lt;h3&gt;注入复杂类型&lt;/h3&gt;
&lt;h4&gt;数组注入&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class YuQian {
    private String[] hobbies;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;bean id=&quot;yuQian&quot; class=&quot;com.thrinisty.bean.YuQian&quot;&amp;gt;
    &amp;lt;property name=&quot;hobbies&quot;&amp;gt;
        &amp;lt;array&amp;gt;
            &amp;lt;value&amp;gt;抽烟&amp;lt;/value&amp;gt;
            &amp;lt;value&amp;gt;喝酒&amp;lt;/value&amp;gt;
            &amp;lt;value&amp;gt;烫头&amp;lt;/value&amp;gt;
        &amp;lt;/array&amp;gt;
    &amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;List/Set注入&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class Person {
    private List&amp;lt;String&amp;gt; names;
    private Set&amp;lt;String&amp;gt; addresses;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;bean id=&quot;person&quot; class=&quot;com.thrinisty.bean.Person&quot;&amp;gt;
    &amp;lt;property name=&quot;names&quot;&amp;gt;
        &amp;lt;list&amp;gt;
            &amp;lt;value&amp;gt;张三&amp;lt;/value&amp;gt;
            &amp;lt;value&amp;gt;张1&amp;lt;/value&amp;gt;
            &amp;lt;value&amp;gt;张2&amp;lt;/value&amp;gt;
        &amp;lt;/list&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property name=&quot;addresses&quot;&amp;gt;
        &amp;lt;set&amp;gt;
            &amp;lt;value&amp;gt;北京&amp;lt;/value&amp;gt;
            &amp;lt;value&amp;gt;上海&amp;lt;/value&amp;gt;
            &amp;lt;value&amp;gt;深圳&amp;lt;/value&amp;gt;
        &amp;lt;/set&amp;gt;
    &amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;Map注入&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;private Map&amp;lt;Integer, String&amp;gt; phoneNumbers;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;property name=&quot;phoneNumbers&quot;&amp;gt;
    &amp;lt;map&amp;gt;
        &amp;lt;entry key=&quot;1&quot; value=&quot;123&quot;/&amp;gt;
        &amp;lt;entry key=&quot;2&quot; value=&quot;23&quot;/&amp;gt;
        &amp;lt;entry key=&quot;3&quot; value=&quot;13&quot;/&amp;gt;
        &amp;lt;entry key=&quot;4&quot; value=&quot;12&quot;/&amp;gt;
    &amp;lt;/map&amp;gt;
&amp;lt;/property&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;:::tip&lt;/p&gt;
&lt;p&gt;不是简单类型使用key-ref,vallue-ref传入bean对象即可&lt;/p&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;h4&gt;Properties注入&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;private Properties properties;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;property name=&quot;properties&quot;&amp;gt;
    &amp;lt;props&amp;gt;
        &amp;lt;prop key=&quot;driver&quot;&amp;gt;com.utils&amp;lt;/prop&amp;gt;
        &amp;lt;prop key=&quot;url&quot;&amp;gt;localhost:123&amp;lt;/prop&amp;gt;
        &amp;lt;prop key=&quot;user&quot;&amp;gt;lory&amp;lt;/prop&amp;gt;
    &amp;lt;/props&amp;gt;
&amp;lt;/property&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;注入null、空字符串&lt;/h4&gt;
&lt;p&gt;手动注入null&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;property name=&quot;names&quot;&amp;gt;
    &amp;lt;list&amp;gt;
        &amp;lt;null/&amp;gt;
        &amp;lt;null/&amp;gt;
        &amp;lt;null/&amp;gt;
    &amp;lt;/list&amp;gt;
&amp;lt;/property&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;names=[null, null, null]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注入空字符串&lt;/p&gt;
&lt;p&gt;不填写value项内容即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;property name=&quot;names&quot;&amp;gt;
    &amp;lt;list&amp;gt;
        &amp;lt;value/&amp;gt;
        &amp;lt;value/&amp;gt;
        &amp;lt;value/&amp;gt;
    &amp;lt;/list&amp;gt;
&amp;lt;/property&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;注入特殊字符&lt;/h4&gt;
&lt;p&gt;使用实体符号代替 &amp;lt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;value&amp;gt;&amp;amp;lt;&amp;lt;/value&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用&amp;lt;![CDATA[]]&amp;gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;value&amp;gt;&amp;lt;![CDATA[&amp;lt;]]&amp;gt;&amp;lt;/value&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;命名空间注入&lt;/h2&gt;
&lt;h3&gt;p命名空间&lt;/h3&gt;
&lt;p&gt;目的：简化配置&lt;/p&gt;
&lt;p&gt;第一步：在spring配置文件头部添加spring配置p命名空间&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Dog {
    private String name;
    private int age;
    private Date birthday;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二步：使用p命名空间&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&amp;gt;
    &amp;lt;bean id=&quot;dog&quot; class=&quot;com.thrinisty.bean.Dog&quot; p:name=&quot;来福&quot; p:age=&quot;3&quot; p:birthday-ref=&quot;birth&quot;/&amp;gt;
    &amp;lt;bean id=&quot;birth&quot; class=&quot;java.util.Date&quot;/&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;c命名空间&lt;/h3&gt;
&lt;p&gt;简化构造注入&lt;/p&gt;
&lt;p&gt;两种方式，通过参数下表或者参数名称&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&amp;gt;
    &amp;lt;bean id=&quot;dog&quot; class=&quot;com.thrinisty.bean.Dog&quot; c:_0=&quot;来福&quot; c:_1=&quot;3&quot; c:_2-ref=&quot;birth&quot;/&amp;gt;
    &amp;lt;bean id=&quot;birth&quot; class=&quot;java.util.Date&quot;/&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;bean id=&quot;dog&quot; class=&quot;com.thrinisty.bean.Dog&quot; c:name=&quot;来福&quot; c:age=&quot;3&quot; c:birthday-ref=&quot;birth&quot;/&amp;gt;
&amp;lt;bean id=&quot;birth&quot; class=&quot;java.util.Date&quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Util命名空间&lt;/h3&gt;
&lt;p&gt;主要针对集合的复用&lt;/p&gt;
&lt;p&gt;util命名空间可以对配置进行复用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:util=&quot;http://www.springframework.org/schema/util&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd&quot;&amp;gt;
    
    &amp;lt;util:properties id=&quot;prop&quot;&amp;gt;
        &amp;lt;prop key=&quot;driver&quot;&amp;gt;com.utils.driver&amp;lt;/prop&amp;gt;
        &amp;lt;prop key=&quot;url&quot;&amp;gt;localhost:123&amp;lt;/prop&amp;gt;
        &amp;lt;prop key=&quot;username&quot;&amp;gt;root&amp;lt;/prop&amp;gt;
        &amp;lt;prop key=&quot;password&quot;&amp;gt;123456&amp;lt;/prop&amp;gt;
    &amp;lt;/util:properties&amp;gt;

    &amp;lt;bean id=&quot;s01&quot; class=&quot;com.thrinisty.jdbc.Source01&quot;&amp;gt;
        &amp;lt;property name=&quot;properties&quot; ref=&quot;prop&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;bean id=&quot;s02&quot; class=&quot;com.thrinisty.jdbc.Source02&quot;&amp;gt;
        &amp;lt;property name=&quot;properties&quot; ref=&quot;prop&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以使用util命名空间中定义的properties配置，在后续的使用中只需要property标签传入定义的配置bean即可&lt;/p&gt;
</content:encoded></item><item><title>Spring笔记（Spring基础介绍）</title><link>https://thrinisty.github.io/posts/spring%E7%AC%94%E8%AE%B0%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/spring%E7%AC%94%E8%AE%B0%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/</guid><description>Spring基础介绍，开闭，依赖倒置</description><pubDate>Fri, 16 May 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Spring笔记&lt;/h1&gt;
&lt;p&gt;Spring6框架的学习，我本来使用的是尚硅谷23年的Spring6课程，但是这套课程看了几集发现讲的有些无趣，没有去深入的挖掘一些方法的实现，也没有讲清楚为什么要使用Spring框架来进行开发，优势在哪里，下午发现了动力节点的Spring课程（21h），现在开始学习，预计8天完成&lt;/p&gt;
&lt;p&gt;&amp;lt;iframe
width=&quot;100%&quot;
height=&quot;468&quot;
src=&quot;//player.bilibili.com/player.html?bvid=BV1Ft4y1g7Fb&amp;amp;p=1&amp;amp;autoplay=false&quot;
scrolling=&quot;no&quot;
border=&quot;0&quot;
frameborder=&quot;no&quot;
framespacing=&quot;0&quot;
allowfullscreen=&quot;true&quot;&amp;gt;
&amp;lt;/iframe&amp;gt;&lt;/p&gt;
&lt;h2&gt;Spring&lt;/h2&gt;
&lt;p&gt;:::note&lt;/p&gt;
&lt;p&gt;Spring框架是一款轻量级（不需要依赖于其他的组件）的开源框架，解决了企业应用开发的复杂性，除了自己提供功能外，还提供整合其他技术和框架的能力&lt;/p&gt;
&lt;p&gt;广义上：Spring泛指以Spring Framework为核心的Spring技术栈&lt;/p&gt;
&lt;p&gt;狭义上：Spring特指Spring Framework，通常称为Spring框架&lt;/p&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/154.png&quot; alt=&quot;154&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;IoC与AOP&lt;/h2&gt;
&lt;p&gt;Spring有两个核心的模块：IoC和AOP&lt;/p&gt;
&lt;p&gt;Inverse of Control：译为“控制反转”，指把创建的对象过程交给Spring进行管理&lt;/p&gt;
&lt;p&gt;Aspect Oriented Programming：译为“面向切面的编程”，AOP用来封装多个类的公共行为，将那些与业务无关，却为业务模块所共同调用的逻辑封装起来，减少系统的重复代码，降低模块间的耦合度，另外，AOP还解决一些系统层面上的问题，如日志，事务，权限等。&lt;/p&gt;
&lt;h2&gt;入门示例&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;通过Spring创建对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;:::tip&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;引入spring相关依赖&lt;/li&gt;
&lt;li&gt;创建类，定义属性和方法&lt;/li&gt;
&lt;li&gt;按照spring要求创建xml配置文件&lt;/li&gt;
&lt;li&gt;在配置文件中配置相关信息&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;h3&gt;引入相关依赖&lt;/h3&gt;
&lt;h4&gt;springframework&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;6.1.14&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;:::tips&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过 &lt;code&gt;@Component&lt;/code&gt; 声明组件&lt;/li&gt;
&lt;li&gt;用 &lt;code&gt;@Autowired&lt;/code&gt; 自动注入依赖&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;@Configuration&lt;/code&gt; 定义配置类&lt;/li&gt;
&lt;li&gt;通过 &lt;code&gt;ApplicationContext&lt;/code&gt; 获取和管理 Bean&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;h4&gt;JUnit依赖&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- JUnit Jupiter API (测试编写) --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.junit.jupiter&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;junit-jupiter-api&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;5.3.1&amp;lt;/version&amp;gt;
    &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;!-- JUnit Jupiter Engine (测试执行) --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.junit.jupiter&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;junit-jupiter-engine&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;5.3.1&amp;lt;/version&amp;gt;
    &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;建立Spring配置文件&lt;/h3&gt;
&lt;p&gt;定义一个User类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.spring6;
public class User {
    public void add() {
        System.out.println(&quot;add&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;xml配置文件&lt;/h3&gt;
&lt;p&gt;按照spring要求创建配置xml文件&lt;/p&gt;
&lt;p&gt;在配置文件中进行对于User实例的创建&lt;/p&gt;
&lt;p&gt;id：唯一标识&lt;/p&gt;
&lt;p&gt;class：创建对象的全路径&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&amp;gt;
    &amp;lt;bean id=&quot;user&quot; class=&quot;com.spring6.User&quot;&amp;gt;&amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;进行测试&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;public class TestUser {
    @Test
    public void testUserObject() {
        //加载spring配置文件，对象创建
        ApplicationContext context =
                new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);

        //获取创建的对象
        User user = (User)context.getBean(&quot;user&quot;);
        System.out.println(user);//com.spring6.User@51bd8b5c

        //使用对象调用方法进行测试
        user.add();//add
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以正常创建对象实例（反射）并且调用&lt;/p&gt;
&lt;h2&gt;引入Spring&lt;/h2&gt;
&lt;h3&gt;OCP开闭原则&lt;/h3&gt;
&lt;p&gt;是软件开发原则中最基本的一个原则：开闭原则&lt;/p&gt;
&lt;p&gt;对于拓展开放，对于修改关闭&lt;/p&gt;
&lt;p&gt;在拓展扩展系统功能的时候，没有修改以前写完的代码，就是符合OCP原则，如果修改了之前稳定的程序，修改了之前的程序，之前的程序都需要重新测试，非常麻烦&lt;/p&gt;
&lt;p&gt;例如我们使用接口操作Dao对象的具体实现类，添加了一个新的Dao实现类，我们任然需要在调用Dao对象的程序中将原先的实例程序进行修改，违反了OCP原则&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface UserDao {
    void deleteUser();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public class UserDaoImplForMySQL implements UserDao {
    @Override
    public void deleteUser() {
        System.out.println(&quot;数据操作层&quot;);
        System.out.println(&quot;Delete User&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public class UserServiceImpl implements UserService {
    private UserDao userDao = new UserDaoImplForMySQL();
    //这里需要修改
    //private UserDao userDao = new UserDaoImplForNoSQL();
    @Override
    public void deleteRequest() {
        System.out.println(&quot;业务层&quot;);
        userDao.deleteUser();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;DIP依赖倒置原则&lt;/h3&gt;
&lt;p&gt;定义：上层不再调用下层&lt;/p&gt;
&lt;p&gt;核心：面向抽象编程，接口编程，不面向具体编程&lt;/p&gt;
&lt;p&gt;视图层调用了服务层，服务层调用了数据操作层&lt;/p&gt;
&lt;p&gt;上层的层级因为需要调用下层的对象以及方法，依赖于下层，违背了依赖倒置原则&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上层Service&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class UserServiceImpl implements UserService {
    private UserDao userDao = new UserDaoImplForMySQL();
    //这里使用了具体的下层方法 UserDaoImplForMySQL 存在依赖
    @Override
    public void deleteRequest() {
        System.out.println(&quot;业务层&quot;);
        userDao.deleteUser();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;下层Dao&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class UserDaoImplForMySQL implements UserDao {
    @Override
    public void deleteUser() {
        System.out.println(&quot;数据操作层&quot;);
        System.out.println(&quot;Delete User&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们需要解决以上的两个问题，我们需要删除用new创建的对象，将对象的创建维护的权利交付出去，这也就是我们所谓的控制反转&lt;/p&gt;
&lt;h3&gt;IoC控制反转&lt;/h3&gt;
&lt;p&gt;反转的是：不在程序中采用硬编码的方式new对象，不在程序中采用硬编码的方式维护对象的关系&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class UserAction {
    private UserService userService;//不再创建对象
    @Test
    public void deleteAction() {
        System.out.println(&quot;显示层&quot;);
        userService.deleteRequest();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public class UserServiceImpl implements UserService {
    private UserDao userDao;//不再创建对象
    @Override
    public void deleteRequest() {
        System.out.println(&quot;业务层&quot;);
        userDao.deleteUser();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这时候代码不能运行（因为对象间的关系没有建立，会发生空指针异常），我们还需要把创建的对象过程和对象间的关系交给Spring进行管理（依赖注入Dependency Injection 是控制反转的实现）&lt;/p&gt;
&lt;p&gt;依赖是两个对象之间的关系，而注入是一种手段可以产生对象关系&lt;/p&gt;
&lt;p&gt;可以通过构造方法注入（通过构造方法设置接口值），或者Set方法注入（通过Set方法设置接口值）&lt;/p&gt;
&lt;h2&gt;Spring中的八大模块&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;../images/155.png&quot; alt=&quot;155&quot; /&gt;&lt;/p&gt;
&lt;p&gt;其中的Spring Core是Spring最为核心的模块，所有的模块都是基于Spring Core开发的，而AOP是次核心的，剩余6个模块都是基于AOP + Spring Core的&lt;/p&gt;
&lt;p&gt;SSM三大框架：Spring SpringMVC MyBatis&lt;/p&gt;
&lt;p&gt;Spring Web模块：可以集成例如Struts，WebWork等MVC框架&lt;/p&gt;
&lt;p&gt;Spring Dao：通过Spring进行对于数据库的增删改查&lt;/p&gt;
&lt;p&gt;Spring ORM：可以集成常见的ORM持久层框架（MyBatis）&lt;/p&gt;
</content:encoded></item><item><title>JavaWeb笔记(ajax，i18n)</title><link>https://thrinisty.github.io/posts/javaweb%E7%AC%94%E8%AE%B0ajaxi18n/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/javaweb%E7%AC%94%E8%AE%B0ajaxi18n/</guid><description>ajax，i18n</description><pubDate>Thu, 15 May 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;JavaWeb笔记&lt;/h1&gt;
&lt;h2&gt;AJAX&lt;/h2&gt;
&lt;p&gt;Asynchronous Javascript And XML异步JavaScript与XML&lt;/p&gt;
&lt;p&gt;是一种创建交互式网页应用的网页开发技术，通过这样一种技术，我们可以在不刷新网页的情况下进行数据的局部更新，提高网页运行的效率&lt;/p&gt;
&lt;h3&gt;基本使用&lt;/h3&gt;
&lt;p&gt;我们通过如下的js代码在jsp中设置ajax访问的方法，通过click事件调用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;AJAX&amp;lt;/title&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&amp;gt;
        function ajaxRequest() {
            var xhr = new XMLHttpRequest();
            xhr.open(&quot;GET&quot;, &quot;http://localhost:8080/AJAX/ajax&quot;, true);//设置请求，如果是false则进行同步阻塞，直到完成返回之后，再执行后续代码
            xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                    if (xhr.status === 200) {
                        var Person = JSON.parse(xhr.responseText);
                        var name = Person.name;
                        var age = Person.id;
                        alert(name + &quot; age is &quot; + age);
                    }
                }
            }
            xhr.send();//发送请求
        }
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;button onclick=&quot;ajaxRequest()&quot;&amp;gt;ajax请求&amp;lt;/button&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而ajax访问的对象是AJAX的Servlet程序，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@WebServlet(&quot;/ajax&quot;)
public class AJAX extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        Person person = new Person(1, &quot;Jack&quot;);
        Gson gson = new Gson();
        String json = gson.toJson(person);
        System.out.println(json);
        resp.getWriter().write(json);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如此可以在不刷新页面的情况下获取到访问数据并且显示出来&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AJAX特点说明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;局部更新：浏览器地址栏不会发生变化，局部更新不会舍弃页面的内容&lt;/p&gt;
&lt;h3&gt;jQuery使用Ajax&lt;/h3&gt;
&lt;p&gt;客户端JSP编程在实际使用的时候，Ajax请求，和数据的处理有些复杂，我们一般不使用原生的ajax请求，而是使用jQuery提供的封装来完成Ajax请求上传以及Ajax数据的获取&lt;/p&gt;
&lt;h4&gt;ajax方法&lt;/h4&gt;
&lt;p&gt;url：表示请求的地址&lt;/p&gt;
&lt;p&gt;type：表示请求的类型（post/get）&lt;/p&gt;
&lt;p&gt;data：表示发送给服务器的数据&lt;/p&gt;
&lt;p&gt;success：请求响应，响应的回调函数&lt;/p&gt;
&lt;p&gt;dataType：响应的数据类型&lt;/p&gt;
&lt;p&gt;如果是设置响应类型为text需要手动运用JSON进行解析，但是如果是设置为json则会自动解析&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&quot;https://code.jquery.com/jquery-3.6.0.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&amp;gt;
    $(function() {
       $(&quot;#ajax1&quot;).click(function() {
          $.ajax({
              url:&quot;http://localhost:8080/AJAX/ajax&quot;,
              data:&quot;action=test&quot;,
              type:&apos;GET&apos;,
              success:function(data){
                  alert(data);
                  var person = JSON.parse(data);
                  $(&quot;#msg&quot;).html(person.id + &quot; &quot; + person.name);
              },
              dataType:&apos;text&apos; //常用的有xml，text，json
          });
       });
    });
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当数据类型dataType为json的时候，不需要手动的对于data进行转化，程序自动完成解析，直接调用data.field即可获取到对应的属性&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(&quot;#ajax1&quot;).click(function() {
   $.ajax({
       url:&quot;http://localhost:8080/AJAX/ajax&quot;,
       data:&quot;action=test&quot;,
       type:&apos;GET&apos;,
       success:function(data){
           $(&quot;#msg&quot;).html(data.id + &quot; &quot; + data.name);
       },
       dataType:&apos;json&apos; //常用的有xml，text，json
   });
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;get和post方法&lt;/h4&gt;
&lt;p&gt;url ：请求的url地址&lt;/p&gt;
&lt;p&gt;data：发送的数据&lt;/p&gt;
&lt;p&gt;callback：发送成功的回调函数&lt;/p&gt;
&lt;p&gt;type：返回的数据类型&lt;/p&gt;
&lt;p&gt;相比于ajax方法少了请求类型的参数&lt;/p&gt;
&lt;p&gt;对于get请求调用$.get参数	post请求替换即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&amp;gt;
    $(function () {
        $(&quot;#ajax1&quot;).click(function () {
            var url = &quot;http://localhost:8080/AJAX/ajax&quot;;
            var data = &quot;action=test&quot;;
            function callback(data) {
                $(&quot;#msg&quot;).html(data.id + &quot; &quot; + data.name);
            }
            var type = &quot;json&quot;;
            $.get(url, data, callback, type);
        });
    });
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;getJSON方法&lt;/h4&gt;
&lt;p&gt;相比较于get以及post方法不需要传入type参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&amp;gt;
    $(function () {
        $(&quot;#ajax1&quot;).click(function () {
            var url = &quot;http://localhost:8080/AJAX/ajax&quot;;
            var data = &quot;action=test&quot;;
            function callback(data) {
                $(&quot;#msg&quot;).html(data.id + &quot; &quot; + data.name);
            }
            $.getJSON(url, data, callback);
        });
    });
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;serialize方法&lt;/h4&gt;
&lt;p&gt;serialize可以把表单中所有的表单项内容获取到，以name=value&amp;amp;name=value的形式进行拼接，提交发送给服务器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&amp;gt;
    $(function () {
        $(&quot;#ajax1&quot;).click(function () {
            var url = &quot;http://localhost:8080/AJAX/ajax&quot;;
            var data = &quot;action=test&quot;;
            function callback(data) {
                $(&quot;#msg&quot;).html(data.id + &quot; &quot; + data.name);
            }
            var serialize = $(&quot;#form1&quot;).serialize();
            alert(serialize);
            $.getJSON(url, data + &quot;&amp;amp;&quot; + serialize, callback);
        });
    });
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    Person person = new Person(1, &quot;Jack&quot;);
    Gson gson = new Gson();
    String json = gson.toJson(person);
    System.out.println(json);
    System.out.println(req.getParameter(&quot;name&quot;));
    resp.getWriter().write(json);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;i18n国际化&lt;/h2&gt;
&lt;p&gt;:::note&lt;/p&gt;
&lt;p&gt;i18n国际化是指同一个网站可以支持多种不同的语言，以方便不同的国家，不同语种用户的访问，最简单的方式是制作不同语言的的网页，例如苹果公司就是这么做的&lt;/p&gt;
&lt;p&gt;然而这样一种方式不适合所有的公司，我们想要一个相同的网站，而不同人访问的时候可以根据用户所在的地区显示不同的语言文字，而网站的布局样式等不发生改变，就产生了国际化（internationalization）简称i18n。&lt;/p&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;h3&gt;国际化三要素&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Locale对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Locale表示不同的时区，位置，语言&lt;/p&gt;
&lt;p&gt;zh_CN	中国，中文&lt;/p&gt;
&lt;p&gt;en_US 	英文，美国&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Properties配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将这样一些配置的属性放在Properties属性配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;国际化配置文件的命名规则
baseName_locale.properties
例如中文：i18n_zh_CN.properties
例如中文：i18n_en_US.properties
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;ResourceBundle资源包&lt;/h3&gt;
&lt;p&gt;读取Locale对象和Properties配置&lt;/p&gt;
&lt;p&gt;ResourceBundle.getBundle：根据给定的baseName和Locale读取相应的配置信息，得到文字信息&lt;/p&gt;
&lt;p&gt;ResourceBundle.getString：通过key得到不同国家的语言信息&lt;/p&gt;
&lt;h3&gt;基础实例&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;public class I18N {
    public static void main(String[] args) {
        Locale locale = Locale.getDefault();
        System.out.println(locale);//zh_CN
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;:::note&lt;/p&gt;
&lt;p&gt;注意将配置文件存放在resources文件夹下&lt;/p&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;p&gt;中文配置文件i18n_zh_CN.properties&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;username=用户名
password=密码
sex=性别
age=年龄
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;英文配置文件i18n_en_US.properties&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;username=username
password=password
sex=sex
age=age
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过Locale对象创建的资源包对象，我们可以通过键的形式获取值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class I18N {
    public static void main(String[] args) {
        Locale us = Locale.US;//获取美国的Locale对象
        ResourceBundle bundle = ResourceBundle.getBundle(&quot;i18n&quot;, us);
        //通过指定的basename和Locale兑现得到Bundle对象
        System.out.println(bundle.getString(&quot;username&quot;));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;:::warning&lt;/p&gt;
&lt;p&gt;在IDEA的配置中默认使用的是&lt;strong&gt;ISO-8859-1&lt;/strong&gt;编码格式编码配置文件，但是该格式不支持中文，我们需要将其设置为UTF-8，通过工具进行Unicode转义&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;native2ascii -encoding UTF-8 i18n_zh_CN.properties i18n_zh_CN_encoded.properties
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;替换为生成的配置文件，即可正常使用&lt;/p&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class I18N {
    public static void main(String[] args) {
        Locale us = Locale.CHINA;
        ResourceBundle bundle = ResourceBundle.getBundle(&quot;i18n&quot;, us);
        //通过指定的basename和Locale兑现得到Bundle对象
        System.out.println(bundle.getString(&quot;username&quot;));//姓名
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;请求头实现国际化&lt;/h3&gt;
&lt;p&gt;Accept-Language请求头可以通过浏览器设置各个语言的权重，JSP页面也可以通过这一些请求头调对应的资源包，加载对应的语言信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;body&amp;gt;
    &amp;lt;%
        Locale locale = Locale.getDefault();
        ResourceBundle i18n = ResourceBundle.getBundle(&quot;i18n&quot;, locale);
    %&amp;gt;
    &amp;lt;form action=&quot;/login&quot; method=&quot;post&quot;&amp;gt;
        &amp;lt;%=i18n.getString(&quot;username&quot;)%&amp;gt;&amp;lt;input type=&quot;text&quot; name=&quot;username&quot;&amp;gt;&amp;lt;br/&amp;gt;
        &amp;lt;%=i18n.getString(&quot;password&quot;)%&amp;gt;&amp;lt;input type=&quot;password&quot; name=&quot;password&quot;&amp;gt;&amp;lt;br/&amp;gt;
        &amp;lt;%=i18n.getString(&quot;age&quot;)%&amp;gt;&amp;lt;input type=&quot;password&quot; name=&quot;password&quot;&amp;gt;&amp;lt;br/&amp;gt;
        &amp;lt;%=i18n.getString(&quot;sex&quot;)%&amp;gt;&amp;lt;input type=&quot;password&quot; name=&quot;password&quot;&amp;gt;&amp;lt;br/&amp;gt;
        &amp;lt;input type=&quot;submit&quot;&amp;gt;
    &amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;选择语言类型实现&lt;/h3&gt;
&lt;p&gt;通过超链接标签访问自身jsp页面并附带参数信息，按照获取到的信息设置locale对象，加载对应语言资源包&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;body&amp;gt;
    &amp;lt;%
        Locale locale = null;
        String country = request.getParameter(&quot;country&quot;);
        if(&quot;cn&quot;.equals(country)) {
            locale = Locale.CHINA;
        } else if (&quot;usa&quot;.equals(country)) {
            locale = Locale.US;
        } else {
            locale = Locale.US;
        }
        ResourceBundle i18n = ResourceBundle.getBundle(&quot;i18n&quot;, locale);
    %&amp;gt;
    &amp;lt;a href=&quot;login.jsp?country=cn&quot;&amp;gt;中文&amp;lt;/a&amp;gt;
    &amp;lt;a href=&quot;login.jsp?country=usa&quot;&amp;gt;english&amp;lt;/a&amp;gt;
    &amp;lt;form action=&quot;/login&quot; method=&quot;post&quot;&amp;gt;
        &amp;lt;%=i18n.getString(&quot;username&quot;)%&amp;gt;&amp;lt;input type=&quot;text&quot; name=&quot;username&quot;&amp;gt;&amp;lt;br/&amp;gt;
        &amp;lt;%=i18n.getString(&quot;password&quot;)%&amp;gt;&amp;lt;input type=&quot;password&quot; name=&quot;password&quot;&amp;gt;&amp;lt;br/&amp;gt;
        &amp;lt;%=i18n.getString(&quot;age&quot;)%&amp;gt;&amp;lt;input type=&quot;text&quot; name=&quot;age&quot;&amp;gt;&amp;lt;br/&amp;gt;
        &amp;lt;%=i18n.getString(&quot;sex&quot;)%&amp;gt;&amp;lt;input type=&quot;text&quot; name=&quot;sex&quot;&amp;gt;&amp;lt;br/&amp;gt;
        &amp;lt;input type=&quot;submit&quot;&amp;gt;
    &amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;JSTL标签库实现&lt;/h3&gt;
&lt;p&gt;:::note&lt;/p&gt;
&lt;p&gt;1.使用标签设置locale信息&lt;/p&gt;
&lt;p&gt;2.使用标签设置baseName&lt;/p&gt;
&lt;p&gt;3.使用标签输出国际化信息&lt;/p&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;body&amp;gt;
    &amp;lt;fmt:setLocale value=&quot;${param.locale}&quot;/&amp;gt;
    &amp;lt;fmt:setBundle basename=&quot;i18n&quot;/&amp;gt;
    &amp;lt;a href=&quot;login.jsp?locale=zh_CN&quot;&amp;gt;中文&amp;lt;/a&amp;gt;
    &amp;lt;a href=&quot;login.jsp?locale=en_US&quot;&amp;gt;english&amp;lt;/a&amp;gt;
    &amp;lt;form action=&quot;/login&quot; method=&quot;post&quot;&amp;gt;
        &amp;lt;fmt:message key=&quot;username&quot;/&amp;gt;&amp;lt;input type=&quot;text&quot; name=&quot;username&quot;&amp;gt;&amp;lt;br/&amp;gt;
        &amp;lt;fmt:message key=&quot;password&quot;/&amp;gt;&amp;lt;input type=&quot;password&quot; name=&quot;password&quot;&amp;gt;&amp;lt;br/&amp;gt;
        &amp;lt;fmt:message key=&quot;age&quot;/&amp;gt;&amp;lt;input type=&quot;text&quot; name=&quot;age&quot;&amp;gt;&amp;lt;br/&amp;gt;
        &amp;lt;fmt:message key=&quot;sex&quot;/&amp;gt;&amp;lt;input type=&quot;text&quot; name=&quot;sex&quot;&amp;gt;&amp;lt;br/&amp;gt;
        &amp;lt;input type=&quot;submit&quot;&amp;gt;
    &amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;:::warning&lt;/p&gt;
&lt;p&gt;JavaWeb完结撒花！！！&lt;/p&gt;
&lt;p&gt;:::&lt;/p&gt;
</content:encoded></item><item><title>图书管理系统</title><link>https://thrinisty.github.io/posts/java-web%E7%9A%84%E9%A2%86%E5%9F%9F%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java-web%E7%9A%84%E9%A2%86%E5%9F%9F%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</guid><description>JavaWeb简易项目</description><pubDate>Thu, 15 May 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Java Web的领域数据管理系统&lt;/h1&gt;
&lt;p&gt;是网络编程的第二次大作业，非常的简陋，而且没有做异常处理，全当水作业了&lt;/p&gt;
&lt;p&gt;远程仓库地址：https://github.com/thrinisty/BookManager.git&lt;/p&gt;
&lt;h2&gt;一、目的&lt;/h2&gt;
&lt;p&gt;1．熟悉Java Web的基本功能和使用方法。&lt;/p&gt;
&lt;p&gt;2．掌握如何使用JSP、JavaBean、Servlet等进行Web应用程序开发。&lt;/p&gt;
&lt;p&gt;3．学习Java Web网络编程的分析与设计方法。&lt;/p&gt;
&lt;h2&gt;二、环境&lt;/h2&gt;
&lt;p&gt;1．PC一台。&lt;/p&gt;
&lt;p&gt;2．IDEA编程软件&lt;/p&gt;
&lt;h2&gt;三、要求&lt;/h2&gt;
&lt;p&gt;使用Java Web，设计与实现一个领域数据管理系统，要求使用实现特定领域数据的在线访问、显示及数据管理，在实验中完成需求获取、系统分析、系统设计各阶段的基本任务。&lt;/p&gt;
&lt;h4&gt;任务一：（已实现）&lt;/h4&gt;
&lt;p&gt;设计与实现一个基于JSP+Servlet+JavaBean的领域数据管理系统，要求支持：&lt;/p&gt;
&lt;p&gt;1）支持用户注册与登录模块；&lt;/p&gt;
&lt;p&gt;2）支持特定领域数据的在线访问、可视化展示；&lt;/p&gt;
&lt;p&gt;3）支持特定领域数据的增、删、改、查操作；&lt;/p&gt;
&lt;p&gt;4）支持使用Mysql数据库对领域数据进行存储管理；&lt;/p&gt;
&lt;p&gt;5）开发的系统利用Tomcat进行部署应用。&lt;/p&gt;
&lt;h4&gt;任务二：（框架还在学习中，任务二尚未完成）&lt;/h4&gt;
&lt;p&gt;在任务一的基础上选做。使用Java Web相关开发框架，设计实现更加复杂的领域数据管理功能模块，实现较友好美观的前端Web界面，提升持久化数据管理以及系统运行性能。&lt;/p&gt;
&lt;h2&gt;四、步骤&lt;/h2&gt;
&lt;p&gt;1.分析领域数据管理程序的需求，绘制流程图，设计Web系统。&lt;/p&gt;
&lt;p&gt;设计一个图书馆的管理系统，允许登录用户进行对于书本数据库的增删改查&lt;/p&gt;
&lt;p&gt;流程图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/153.png&quot; alt=&quot;153&quot; /&gt;&lt;/p&gt;
&lt;p&gt;2.分析主要功能的实现，利用JSP进行系统开发。&lt;/p&gt;
&lt;p&gt;实现登录注册功能（通过过滤器Filter完成）&lt;/p&gt;
&lt;p&gt;实现在线访问（通过JSP页面显示）&lt;/p&gt;
&lt;p&gt;支持数据的增删改查（Servlet+BeanDao）&lt;/p&gt;
&lt;p&gt;支持数据库存储（MySQL）&lt;/p&gt;
&lt;p&gt;3.学习MVC设计模式，采取层次化设计模型，设计领域数据管理功能。&lt;/p&gt;
&lt;p&gt;工程通过JSP+Servlet+BasicDao构建层次化设计模式，完成响应功能&lt;/p&gt;
&lt;p&gt;4.完成任务一&lt;/p&gt;
&lt;h3&gt;过滤器&lt;/h3&gt;
&lt;p&gt;通过过滤没有登录的用户，禁止其访问admin文件夹下的资源&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@WebFilter(&quot;/admin/*&quot;)
public class LoginFilter implements Filter {
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        Filter.super.init(filterConfig);
    }

    @Override
    public void destroy() {
        Filter.super.destroy();
    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        HttpServletRequest request = (HttpServletRequest) servletRequest;
        HttpSession session = request.getSession();
        Object user = session.getAttribute(&quot;user&quot;);
        if (user == null) {
            servletRequest.getRequestDispatcher(&quot;/login.jsp&quot;).forward(servletRequest, servletResponse);
            return;
        } else {
            filterChain.doFilter(servletRequest, servletResponse);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;BasicDao&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;package com.bean;

import org.apache.commons.dbutils.QueryRunner;
import org.apache.commons.dbutils.handlers.BeanHandler;
import org.apache.commons.dbutils.handlers.BeanListHandler;
import org.apache.commons.dbutils.handlers.ScalarHandler;

import java.sql.Connection;
import java.util.List;

public class BasicDao&amp;lt;T&amp;gt; {//使用泛型指定具体类型
    private QueryRunner qr = new QueryRunner();

    //开发通用的dml方法，针对任意的表
    public int update(String sql, Object... parameters) {
        Connection connection = null;
        try {
            connection = JDBCUtilsDruid.getConnection();
            return qr.update(connection, sql, parameters);
            //返回受影响的行数，执行语句
        } catch (Exception e) {
            throw new RuntimeException(e);
        } finally {
            JDBCUtilsDruid.close(null, null, connection);
        }
    }

    //返回对个查询对象
    public List&amp;lt;T&amp;gt; queryMulti(String sql, Class&amp;lt;T&amp;gt; cls, Object... parameters) {
        Connection connection = null;
        try {
            connection = JDBCUtilsDruid.getConnection();
            return qr.query(connection, sql, new BeanListHandler&amp;lt;T&amp;gt;(cls), parameters);
        } catch (Exception e) {
            throw new RuntimeException(e);
        } finally {
            JDBCUtilsDruid.close(null, null, connection);
        }
    }

    //返回查询单行结果
    public T querySingle(String sql, Class&amp;lt;T&amp;gt; cls, Object... parameters) {
        Connection connection = null;
        try {
            connection = JDBCUtilsDruid.getConnection();
            return qr.query(connection, sql, new BeanHandler&amp;lt;T&amp;gt;(cls), parameters);
        } catch (Exception e) {
            throw new RuntimeException(e);
        } finally {
            JDBCUtilsDruid.close(null, null, connection);
        }
    }

    //查询单行单列的方法
    public Object queryScalar(String sql, Object... parameters) {
        Connection connection = null;
        try {
            connection = JDBCUtilsDruid.getConnection();
            return qr.query(connection, sql, new ScalarHandler(), parameters);
        } catch (Exception e) {
            throw new RuntimeException(e);
        } finally {
            JDBCUtilsDruid.close(null, null, connection);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Druid连接池&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;package com.bean;
import com.alibaba.druid.pool.DruidDataSourceFactory;
import javax.sql.DataSource;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Properties;

public class JDBCUtilsDruid {
    private static DataSource ds;

    static {
        Properties properties = new Properties();
        InputStream input;
        input = JDBCUtilsDruid.class.getClassLoader().getResourceAsStream(&quot;config.properties&quot;);
        try {
            if (input == null) {
                throw new RuntimeException(&quot;无法找到配置文件 config.properties&quot;);
            }
            properties.load(input);
            ds = DruidDataSourceFactory.createDataSource(properties);
        } catch (Exception e) {
            throw new RuntimeException(&quot;初始化数据库连接池失败&quot;, e);
        } finally {
            try {
                if (input != null) {
                    input.close();
                }
            } catch (IOException e) {
                System.out.println(&quot;关闭失败&quot;);
            }
        }
    }

    public static Connection getConnection() {
        try {
            return ds.getConnection();
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    public static void close(ResultSet result, Statement statement, Connection connection) {
        try {
            if (result != null) {
                result.close();
            }
            if (statement != null) {
                statement.close();
            }
            if (connection != null) {
                connection.close();
            }
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Book对象与User对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Book {
    private int id;
    private String title;
    private String author;
    private double price;
	//省略各种构造器以及方法
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public class User {
    private String username;
    private String password;
    //省略各种构造器以及方法
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Servlet处理程序&lt;/h3&gt;
&lt;p&gt;这里以查询为例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@WebServlet(&quot;/query&quot;)
public class Query extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        BookDao bookDao = new BookDao();
        String sql = &quot;select * from book&quot;;
        List&amp;lt;Book&amp;gt; books = bookDao.queryMulti(sql, Book.class);
        // 将数据存入request属性
        req.setAttribute(&quot;books&quot;, books);
        // 转发到JSP页面
        req.getRequestDispatcher(&quot;/admin/query.jsp&quot;).forward(req, resp);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;JSP前端设计&lt;/h3&gt;
&lt;p&gt;由于MVC的设计模式，前端很少实现响应的数据功能，只负责View显示，由大模型可以高效生成美观的的JSP页面，&lt;/p&gt;
&lt;p&gt;只需要在各个JSP页面跳转之间进行设计，访问的Servlet程序功能按钮，以及从Request域中获取响应的数据即可，这里以change.jsp为例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;h1&amp;gt;Add New Book&amp;lt;/h1&amp;gt;

&amp;lt;form action=&quot;../insert&quot; method=&quot;get&quot;&amp;gt;
  &amp;lt;div class=&quot;form-group&quot;&amp;gt;
    &amp;lt;label for=&quot;id&quot;&amp;gt;Book ID:&amp;lt;/label&amp;gt;
    &amp;lt;input type=&quot;text&quot; id=&quot;id&quot; name=&quot;id&quot; required&amp;gt;
  &amp;lt;/div&amp;gt;

  &amp;lt;div class=&quot;form-group&quot;&amp;gt;
    &amp;lt;label for=&quot;name&quot;&amp;gt;Book Name:&amp;lt;/label&amp;gt;
    &amp;lt;input type=&quot;text&quot; id=&quot;name&quot; name=&quot;name&quot; required&amp;gt;
  &amp;lt;/div&amp;gt;

  &amp;lt;div class=&quot;form-group&quot;&amp;gt;
    &amp;lt;label for=&quot;author&quot;&amp;gt;Author:&amp;lt;/label&amp;gt;
    &amp;lt;input type=&quot;text&quot; id=&quot;author&quot; name=&quot;author&quot; required&amp;gt;
  &amp;lt;/div&amp;gt;

  &amp;lt;div class=&quot;form-group&quot;&amp;gt;
    &amp;lt;label for=&quot;price&quot;&amp;gt;Price:&amp;lt;/label&amp;gt;
    &amp;lt;input type=&quot;number&quot; id=&quot;price&quot; name=&quot;price&quot; step=&quot;0.01&quot; min=&quot;0&quot; required&amp;gt;
  &amp;lt;/div&amp;gt;

  &amp;lt;button type=&quot;submit&quot; class=&quot;submit-btn&quot;&amp;gt;Add Book&amp;lt;/button&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.分析实验，总结实验心得，撰写报告。&lt;/p&gt;
&lt;p&gt;实验综合性较强，可以很好的巩固JavaWeb的各个知识点，这一次实验完成了一个简易的书籍管理系统，&lt;/p&gt;
&lt;p&gt;但是在异常处理方面上较为简陋，没有很好的处理SQL语句报错的异常处理，直接捕获抛出&lt;/p&gt;
&lt;p&gt;而且还是有很多的地方可以进行改进，例如在获取数据的时候其实可以通过Ajax请求访问，局部更新数据来实现更好的运行效率以及用户体验&lt;/p&gt;
</content:encoded></item><item><title>JavaWeb笔记(Filter，json)</title><link>https://thrinisty.github.io/posts/javaweb%E7%AC%94%E8%AE%B0filterjson/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/javaweb%E7%AC%94%E8%AE%B0filterjson/</guid><description>Filter，json</description><pubDate>Wed, 14 May 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;JavaWeb笔记&lt;/h1&gt;
&lt;h2&gt;Filter&lt;/h2&gt;
&lt;p&gt;:::note&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;过滤器：是JavaWeb的三大组件之一（Servlet，Listener，Filter）&lt;/li&gt;
&lt;li&gt;过滤器是JavaEE的规范，也就是接口&lt;/li&gt;
&lt;li&gt;Filter过滤器作用是：拦截请求，过滤响应&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;h3&gt;基本使用&lt;/h3&gt;
&lt;h4&gt;JSP页面实现&lt;/h4&gt;
&lt;p&gt;要求web工程下有一个admin目录，这个admin目录下的所有资源都要求登录后才可以使用&lt;/p&gt;
&lt;p&gt;根据之前的情况分析，我们需要将登陆的信息存储在Cookie中，如果其中的键user值为null，则没有登陆，跳转至登录页面，而又user信息，则跳转至目标资源&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Index&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;%
    Object user = session.getAttribute(&quot;user&quot;);
    if (user == null) {
        request.getRequestDispatcher(&quot;/login.jsp&quot;).forward(request,response);
        return;
    }
%&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是这样一种方式是有局限性的，没有办法跳到图片，html页面，而且当直接用对应的路径访问也可以访问到权限资源，我们这个时候就可以使用Filter过滤器来完成&lt;/p&gt;
&lt;h4&gt;Filter实现&lt;/h4&gt;
&lt;p&gt;:::note&lt;/p&gt;
&lt;p&gt;使用步骤：&lt;/p&gt;
&lt;p&gt;1.我们创建一个继承于import javax.servlet.Filter的过滤器类&lt;/p&gt;
&lt;p&gt;2.实现拦截方法doFilter&lt;/p&gt;
&lt;p&gt;3.配置拦截路径&lt;/p&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.filter;

import javax.servlet.*;
import javax.servlet.annotation.WebFilter;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpSession;
import java.io.IOException;

@WebFilter(&quot;/admin/*&quot;)//配置拦截路径
public class AdminFilter implements Filter {
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        HttpServletRequest request = (HttpServletRequest) servletRequest;
        HttpSession session = request.getSession();
        Object user = session.getAttribute(&quot;user&quot;);
        if (user == null) {
            servletRequest.getRequestDispatcher(&quot;/login.jsp&quot;).forward(servletRequest, servletResponse);
            return;
        } else {
            //让程序继续向下访问目标资源
            filterChain.doFilter(servletRequest, servletResponse);
        }
    }

    @Override
    public void destroy() {
        Filter.super.destroy();
    }

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        Filter.super.init(filterConfig);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样做就会拦截Session中user为空的客户端访问&lt;/p&gt;
&lt;p&gt;我们成功登录的逻辑通过Servlet完成，当成功将session域的user设置对应的用户名，当Session的user非空即可访问被拦截限制的资源&lt;/p&gt;
&lt;p&gt;登录JSP界面&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;form action=&quot;http://localhost:8080/Fliter/login&quot; method=&quot;get&quot;&amp;gt;
    用户名称&amp;lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;${cookie.username.value}&quot;&amp;gt;&amp;lt;br/&amp;gt;
    密码&amp;lt;input type=&quot;password&quot; name=&quot;password&quot; value=&quot;${cookie.password.value}&quot;&amp;gt;&amp;lt;br/&amp;gt;
    &amp;lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;登录Servlet&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@WebServlet(&quot;/login&quot;)
public class Login extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println(&quot;doGet&quot;);
        resp.setContentType(&quot;text/html;charset=UTF-8&quot;);
        HttpSession session = req.getSession();
        String username = req.getParameter(&quot;username&quot;);
        String password = req.getParameter(&quot;password&quot;);
        if(username.equals(&quot;admin&quot;) &amp;amp;&amp;amp; password.equals(&quot;123456&quot;)){
            System.out.println(&quot;login success&quot;);
            session.setAttribute(&quot;user&quot;, username);
            resp.getWriter().write(&quot;&amp;lt;h1&amp;gt;Login Success&amp;lt;/h1&amp;gt;&quot;);
        } else {
            System.out.println(&quot;login failed&quot;);
            req.getRequestDispatcher(&quot;/login.jsp&quot;).forward(req, resp);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;生命周期&lt;/h3&gt;
&lt;p&gt;Filter的生命周期包含几个方法：1.构造器方法 2.nit初始化方法  3.doFilter方法  4.destory销毁方法&lt;/p&gt;
&lt;p&gt;在Web工程启动的时候，1、2两部就已经被执行（Filter被创建）&lt;/p&gt;
&lt;p&gt;当在访问被拦截资源的时候的时候，调用3方法（每次）&lt;/p&gt;
&lt;p&gt;当停止Web工程的时候执行&lt;/p&gt;
&lt;h3&gt;FilterConfig类&lt;/h3&gt;
&lt;p&gt;是Filter过滤器的配置文件类&lt;/p&gt;
&lt;p&gt;Tomcat每次创建Filter的时候，同时也会创建一个FilterConfig类，包含了Filter配置文件的配置信息&lt;/p&gt;
&lt;p&gt;:::note&lt;/p&gt;
&lt;p&gt;作用：获取filter过滤器的配置内容&lt;/p&gt;
&lt;p&gt;1.获取Filter的名称 filter-name内容&lt;/p&gt;
&lt;p&gt;2.获取Filter中配置init-param初始化参数&lt;/p&gt;
&lt;p&gt;3.获取ServletContext对象&lt;/p&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;p&gt;运用注解设置过滤器的名称初始化参数的设置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@WebFilter(
        filterName = &quot;myFilter&quot;,
        urlPatterns = {&quot;/admin/*&quot;},
        initParams = {
                @WebInitParam(name = &quot;param1&quot;, value = &quot;value1&quot;),
                @WebInitParam(name = &quot;param2&quot;, value = &quot;value2&quot;)
        }
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;获取过滤器名称以及初始化参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void init(FilterConfig filterConfig) throws ServletException {
    System.out.println(filterConfig.getFilterName());//myFilter
    System.out.println(filterConfig.getInitParameter(&quot;param1&quot;));//value1
    System.out.println(filterConfig.getInitParameter(&quot;param2&quot;));//value2
    Filter.super.init(filterConfig);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Filter拦截路径&lt;/h3&gt;
&lt;p&gt;:::note&lt;/p&gt;
&lt;p&gt;有三种匹配方式，Filter只关心请求的地址是否匹配，不关心资源存在&lt;/p&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;h4&gt;精确匹配&lt;/h4&gt;
&lt;p&gt;请求地址必须为 http://localhost:8080/path/admin/1.jsp&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&quot;/admin/1.jsp&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;目录匹配&lt;/h4&gt;
&lt;p&gt;对应目录下的所有资源&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&quot;/admin/*&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;后缀名匹配&lt;/h4&gt;
&lt;p&gt;请求地址必须以.html结尾&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&quot;*.html&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;FilterChain过滤器链&lt;/h3&gt;
&lt;p&gt;FilterChain：多个过滤器如何一起工作&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/152.png&quot; alt=&quot;152&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;JSON&lt;/h2&gt;
&lt;p&gt;:::note&lt;/p&gt;
&lt;p&gt;JSON是一种轻量级的数据交换格式（和XML比较），易于人的阅读，同时易于机器的读写，采用的是完全独立于语言的文本格式，被多种语言支持，成为了理想的数据交换语言（服务器与客户端）&lt;/p&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;h3&gt;基本使用&lt;/h3&gt;
&lt;p&gt;JSON是由键值对组成，并由大括号包围，每个键由“”引起，键值之间使用冒号分隔，多组键值对之间使用逗号进行分割&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    var jsonObj = {
        &quot;key1&quot;: 12,
        &quot;key2&quot;: &quot;value2&quot;,
        &quot;key3&quot;: true,
        &quot;key4&quot;: [11,33,&quot;arr&quot;,false],
        &quot;key5&quot;: {
            &quot;key1&quot;: &quot;value1&quot;,
            &quot;key2&quot;: &quot;value2&quot;,
        },
    };
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;值可以是各种类型，甚至可以是json类型本身，以及json数组&lt;/p&gt;
&lt;p&gt;其中json其实是一个object对象，json中的key可以理解为是对象中的一个属性，json中的key访问就和访问对象的属性一样，jsonObj.key&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;alert(jsonObj.key1);
alert(jsonObj.key2);
alert(jsonObj.key3);
alert(jsonObj.key4[1]);
alert(jsonObj.key5.key1);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;访问和对象基本没什么不同&lt;/p&gt;
&lt;h3&gt;常用方法&lt;/h3&gt;
&lt;p&gt;:::note&lt;/p&gt;
&lt;p&gt;json的存在有两种形式&lt;/p&gt;
&lt;p&gt;1.对象的形式，json对象（需要操作的时候使用）&lt;/p&gt;
&lt;p&gt;2.字符串的形式存在，称为json字符串（在数据交换的时候使用）&lt;/p&gt;
&lt;p&gt;这两种格式可以相互转换&lt;/p&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;p&gt;JSON.stringify()：将json对象转换为json字符串（类似toString）&lt;/p&gt;
&lt;p&gt;JSON.parse()：把json字符串转为json对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var stringify = JSON.stringify(jsonObj);
alert(stringify);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;string输出结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{&quot;key1&quot;:12,&quot;key2&quot;:&quot;value2&quot;,&quot;key3&quot;:true,&quot;key4&quot;:[11,33,&quot;arr&quot;,false],&quot;key5&quot;:{&quot;key1&quot;:&quot;value1&quot;,&quot;key2&quot;:&quot;value2&quot;}}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;json输出结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var json = JSON.parse(stringify);
alert(json);//[object Object]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Java使用JSON&lt;/h3&gt;
&lt;p&gt;我们在Java中使用JSON之前需要先导入Googel的Gson库，使用Maven进行导入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.google.code.gson&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;gson&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.10.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试使用&lt;/p&gt;
&lt;p&gt;建立一个Person对象作为Bean&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Person {
    private String name;
    private int age;

    public Person() {}
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
    }
    @Override
    public String toString() {
        return &quot;Person{&quot; +
                &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; +
                &quot;, age=&quot; + age +
                &apos;}&apos;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;普通类转化&lt;/h4&gt;
&lt;p&gt;toJson方法可以将Bean对象转为字符串&lt;/p&gt;
&lt;p&gt;fromJson方法传入对应的json字符串以及类对象可以转为类对象的实例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class JsonTest {
    public static void main(String[] args) {
        Person person = new Person(&quot;Lory&quot;, 18);
        Gson gson = new Gson();//创建对象实例
        String json = gson.toJson(person);
        System.out.println(json);//{&quot;name&quot;:&quot;Lory&quot;,&quot;age&quot;:18}
        Person another = gson.fromJson(json, Person.class);//放入转为的类型
        System.out.println(another.getAge() + &quot; &quot; + another.getName());//18 Lory
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;List类集合转化&lt;/h4&gt;
&lt;p&gt;对于LIst集合而言，我们也可以将其通过转化toJson方法转化为Json字符串，而将Json字符串转换为对应类型则较为复杂，需要在使用fromJson转化前，实现一个继承于TypeToken类的一个格式类，其中的泛型传入&amp;lt;List&amp;lt;Person&amp;gt;&amp;gt;（或者&amp;lt;ArrayList&amp;lt;Person&amp;gt;&amp;gt;），再将这个类型zhuanwei&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class JsonTest {
    public static void main(String[] args) {
        List&amp;lt;Person&amp;gt; persons = new ArrayList&amp;lt;&amp;gt;();
        Person person1 = new Person(&quot;Lory&quot;, 18);
        Person person2 = new Person(&quot;Marry&quot;, 22);
        persons.add(person1);
        persons.add(person2);
        Gson gson = new Gson();
        String json = gson.toJson(persons);
        System.out.println(json);//[{&quot;name&quot;:&quot;Lory&quot;,&quot;age&quot;:18},{&quot;name&quot;:&quot;Marry&quot;,&quot;age&quot;:22}]

        List&amp;lt;Person&amp;gt; list = gson.fromJson(json, new PersionListType().getType());
        System.out.println(list);
    }
}

class PersionListType extends TypeToken&amp;lt;List&amp;lt;Person&amp;gt;&amp;gt; {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;Map类集合转化&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class JsonTest {
    public static void main(String[] args) {
        Map&amp;lt;String, Person&amp;gt; persons = new HashMap&amp;lt;&amp;gt;();
        Person person1 = new Person(&quot;Lory&quot;, 18);
        Person person2 = new Person(&quot;Marry&quot;, 22);
        persons.put(&quot;num1&quot;, person1);
        persons.put(&quot;num2&quot;, person2);
        System.out.println(persons);//{num1=Person{name=&apos;Lory&apos;, age=18}, num2=Person{name=&apos;Marry&apos;, age=22}}
        Gson gson = new Gson();
        String json = gson.toJson(persons);
        System.out.println(json);//{&quot;num1&quot;:{&quot;name&quot;:&quot;Lory&quot;,&quot;age&quot;:18},&quot;num2&quot;:{&quot;name&quot;:&quot;Marry&quot;,&quot;age&quot;:22}}
        Map&amp;lt;String, Person&amp;gt; map = gson.fromJson(json, new PersionMapType().getType());
        System.out.println(map.get(&quot;num1&quot;));//Person{name=&apos;Lory&apos;, age=18}
    }
}

class PersionMapType extends TypeToken&amp;lt;Map&amp;lt;String, Person&amp;gt;&amp;gt; {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里其实更推荐使用内部类，更加简洁一点&lt;/p&gt;
&lt;p&gt;最近在设计以及实现网络的大作业，学到的内容较少，预计明天完成AJAX以及i18n的学习，以及网络编程的大作业的实现（标为粗糙），应该也会整理一个报告出来&lt;/p&gt;
</content:encoded></item><item><title>JavaWeb笔记（Cookie，Session）</title><link>https://thrinisty.github.io/posts/javaweb%E7%AC%94%E8%AE%B0cookiesession/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/javaweb%E7%AC%94%E8%AE%B0cookiesession/</guid><description>Cookie，Session会话</description><pubDate>Tue, 13 May 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;JavaWeb笔记&lt;/h1&gt;
&lt;h2&gt;Cookie&lt;/h2&gt;
&lt;p&gt;Cookie大小不超过4KB&lt;/p&gt;
&lt;p&gt;Cookie是服务器通知客户端保存键值对的一种技术&lt;/p&gt;
&lt;p&gt;客户端拥有Cookie后每次请求都发送Cookie信息给服务器&lt;/p&gt;
&lt;h3&gt;Cookie使用&lt;/h3&gt;
&lt;p&gt;通过请求连接访问createCookie方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%--
  Created by IntelliJ IDEA.
  User: 71460
  Date: 2025/5/12
  Time: 20:52
  To change this template use File | Settings | File Templates.
--%&amp;gt;
&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Cookie&amp;amp;Session&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div&amp;gt;
    &amp;lt;a href=&quot;http://localhost:8080/Cookie/CookieServlet?action=createCookie&quot;
       target=&quot;_blank&quot;
       style=&quot;text-decoration: none; color: blue;&quot;&amp;gt;
        Cookie创建
    &amp;lt;/a&amp;gt;
    &amp;lt;a href=&quot;http://localhost:8080/Cookie/CookieServlet?action=getCookie&quot;
       target=&quot;_blank&quot;
       style=&quot;text-decoration: none; color: blue;&quot;&amp;gt;
        Cookie获取
    &amp;lt;/a&amp;gt;
    &amp;lt;a href=&quot;http://localhost:8080/Cookie/CookieServlet?action=updateCookie&quot;
       target=&quot;_blank&quot;
       style=&quot;text-decoration: none; color: blue;&quot;&amp;gt;
        Cookie值修改
    &amp;lt;/a&amp;gt;
    &amp;lt;a href=&quot;http://localhost:8080/Cookie/CookieServlet?action=defaultLife&quot;
       target=&quot;_blank&quot;
       style=&quot;text-decoration: none; color: blue;&quot;&amp;gt;
        Cookie生命期
    &amp;lt;/a&amp;gt;
    &amp;lt;a href=&quot;http://localhost:8080/Cookie/CookieServlet?action=testPath&quot;
       target=&quot;_blank&quot;
       style=&quot;text-decoration: none; color: blue;&quot;&amp;gt;
        CookiePath测试
    &amp;lt;/a&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Servlet get方法逻辑重写，通过action提交信息，来判断请求的功能&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    resp.setContentType(&quot;text/html;charset=UTF-8&quot;);
    System.out.println(&quot;doGet&quot;);
    String action = req.getParameter(&quot;action&quot;); // 获取 action 参数
    if (&quot;createCookie&quot;.equals(action)) {
        createCookie(req, resp); // 调用 createCookie 方法
    } else if (&quot;getCookie&quot;.equals(action)) {
        getCookie(req, resp);
    } else if (&quot;updateCookie&quot;.equals(action)) {
        updateCookie(req, resp);
    } else if (&quot;defaultLife&quot;.equals(action)) {
        defaultLife(req, resp);
    } else if (&quot;testPath&quot;.equals(action)) {
        testPath(req, resp);
    } else {
        System.out.println(&quot;doGet (default)&quot;);
        resp.getWriter().write(&quot;Default GET request&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;方法实现&lt;/h3&gt;
&lt;h4&gt;实现createCookie方法&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;protected void createCookie(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    Cookie cookie1 = new Cookie(&quot;name1&quot;, &quot;value&quot;);
    resp.addCookie(cookie1);//通知客户端保存Cookie
    Cookie cookie2 = new Cookie(&quot;name2&quot;, &quot;value&quot;);
    resp.addCookie(cookie2);//通知客户端保存Cookie
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;请求头中得到的Cookie&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cookie
name=value; JSESSIONID=4F532626BFB4F9BD1E10FB5AD9B48B8B; name1=value; name2=value; Idea-edca08ae=bf13885b-ced0-462f-82b1-c1e0b2a26978
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;服务器获取Cookie对象&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;protected void getCookie(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    Cookie[] cookies = req.getCookies();
    for (Cookie cookie : cookies) {
        resp.getWriter().write(cookie.getName() + &quot;:&quot; + cookie.getValue() +&quot;&amp;lt;br/&amp;gt;&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;name1:value
name2:value
JSESSIONID:A8B31B0AD41D5E89238669FF5CA83DB6
Idea-edca08ae:bf13885b-ced0-462f-82b1-c1e0b2a26978
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们在方法中还可以用逻辑判断取出我们想要的cookie使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for (Cookie cookie : cookies) {
    if(cookie.getName().equals(&quot;name1&quot;)) {
        System.out.println(&quot;Cookie name1 found&quot;);
        target = cookie;
    }
}
if (target != null) {
    System.out.println(&quot;Cookie function&quot;);
    resp.getWriter().write(target.getName() + &quot;:&quot; + target.getValue() + &quot;&amp;lt;br/&amp;gt;&quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;:::tip&lt;/p&gt;
&lt;p&gt;为了方便可以构造一个Cookie工具类，使用起来会方便一些&lt;/p&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class CookieUtils {
    public static Cookie findCookie(Cookie[] cookies, String name) {
        if(cookies != null || cookies.length == 0 || name != null) {
            for (Cookie cookie : cookies) {
                if(cookie.getName().equals(name)) {
                    return cookie;
                }
            }
        }
        return null;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;protected void getCookie(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    Cookie[] cookies = req.getCookies();
    Cookie target = CookieUtils.findCookie(cookies, &quot;name1&quot;);
    if (target != null) {
        System.out.println(&quot;Cookie function&quot;);
        resp.getWriter().write(target.getName() + &quot;:&quot; + target.getValue() + &quot;&amp;lt;br/&amp;gt;&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;Cookie值修改&lt;/h4&gt;
&lt;p&gt;方案一&lt;/p&gt;
&lt;p&gt;1.创建一个要修改的同名Cookie对象&lt;/p&gt;
&lt;p&gt;2.在构造器，同时赋予新的Cookie值&lt;/p&gt;
&lt;p&gt;3.调用response.addCookie(Cookie)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;protected void updateCookie(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    Cookie cookie = new Cookie(&quot;name1&quot;, &quot;newValue&quot;);
    resp.addCookie(cookie);
    resp.getWriter().write(&quot;修改cookie完成 &amp;lt;br/&amp;gt;&quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方案二&lt;/p&gt;
&lt;p&gt;1.查找到需要修改的Cookie对象&lt;/p&gt;
&lt;p&gt;2.调用setValue()方法赋予新值&lt;/p&gt;
&lt;p&gt;3.调用resp.addCookie(cookie)保存修改&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;protected void updateCookie(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    Cookie[] cookies = req.getCookies();
    Cookie target = CookieUtils.findCookie(cookies, &quot;name1&quot;);
    if (target != null) {
        target.setValue(&quot;newValue&quot;);
        resp.addCookie(target);
        resp.getWriter().write(&quot;修改cookie完成 &amp;lt;br/&amp;gt;&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;:::warning&lt;/p&gt;
&lt;p&gt;Cookie中对应的值不可以包含空格 方括号 圆括号 逗号 等号 双引号 斜杠 问好 冒号 分号 空值 中文，如果需要使用则要使用Base64编码处理&lt;/p&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;h4&gt;Cookie生命控制&lt;/h4&gt;
&lt;p&gt;Cookie的生命控制指的是如何管理Cookie什么时候被销毁&lt;/p&gt;
&lt;p&gt;setMaxAge()&lt;/p&gt;
&lt;p&gt;正数，表示指定秒数后过期&lt;/p&gt;
&lt;p&gt;负数，表示浏览器关闭的时候Cookie被删除（默认为-1）&lt;/p&gt;
&lt;p&gt;零，表示马上删除Cookie&lt;/p&gt;
&lt;p&gt;创建一个10秒有效的Cookie&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;protected void defaultLife(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    Cookie cookie = new Cookie(&quot;name&quot;, &quot;default&quot;);
    cookie.setMaxAge(10);
    resp.addCookie(cookie);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除对应的Cookie&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;protected void defaultLife(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    Cookie[] cookies = req.getCookies();
    Cookie target = CookieUtils.findCookie(cookies, &quot;name1&quot;);
    if (target != null) {
        target.setMaxAge(0);
        resp.addCookie(target);
        System.out.println(&quot;目标Cookie已被删除&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;设置path属性&lt;/h4&gt;
&lt;p&gt;Cookie的path属性可以有效地过滤哪些Cookie可以发送给服务器，哪一些不发送，path属性是通过请求的地址来进行有效的过滤，例如有如下的两个Cookie&lt;/p&gt;
&lt;p&gt;CookieA  	path=/工程路径&lt;/p&gt;
&lt;p&gt;CookieB  	path=/工程路径/doc&lt;/p&gt;
&lt;p&gt;请求地址为：http://localhost:8080/工程路径/a.html&lt;/p&gt;
&lt;p&gt;这个时候发送CookieA，而CookieB不发送&lt;/p&gt;
&lt;p&gt;请求地址为：http://localhost:8080/工程路径/abc/a.html&lt;/p&gt;
&lt;p&gt;这个时候发送CookieA，CookieB都发送（只看是否包含path属性）&lt;/p&gt;
&lt;p&gt;我们可以手动设置path属性&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;protected void testPath(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    Cookie cookie1 = new Cookie(&quot;path1&quot;, &quot;value1&quot;);
    cookie1.setPath(req.getContextPath() + &quot;/abc&quot;);
    resp.addCookie(cookie1);
    System.out.println(&quot;创建带有path路径的Cookie1&quot;);
    Cookie cookie2 = new Cookie(&quot;path2&quot;, &quot;value2&quot;);
    resp.addCookie(cookie2);
    System.out.println(&quot;创建不有path路径的Cookie2&quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当网址中没有路径/abc路径的时候不会使客户端获取到cookie1&lt;/p&gt;
&lt;p&gt;我们新建一个在 http://localhost:8080/Cookie/abc/testPath.jsp 的jsp文件，发现这个页面可以获取到cookie1&lt;/p&gt;
&lt;p&gt;:::tip&lt;/p&gt;
&lt;p&gt;通过设置Cookie的path属性，我们可以实现一些功能&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;隔离不同路径的Cookie&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;例如，网站有两个独立功能模块：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/admin&lt;/code&gt; 路径下的管理后台&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/user&lt;/code&gt; 路径下的用户中心
通过设置 &lt;code&gt;path=/admin&lt;/code&gt; 和 &lt;code&gt;path=/user&lt;/code&gt;，可防止两个模块的Cookie互相干扰，提升安全性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;避免资源请求携带无关Cookie&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;静态资源（如图片、CSS）通常存放在 &lt;code&gt;/static&lt;/code&gt; 路径。若Cookie的 &lt;code&gt;path&lt;/code&gt; 不包含此路径，浏览器请求资源时不会附带这些Cookie，减少网络开销。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多应用共享域名时的隔离&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;同一域名下部署多个应用（如 &lt;code&gt;example.com/app1&lt;/code&gt; 和 &lt;code&gt;example.com/app2&lt;/code&gt;），通过不同 &lt;code&gt;path&lt;/code&gt; 隔离各自的会话Cookie，防止数据冲突。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;精细化权限控制&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;敏感路径（如 &lt;code&gt;/settings&lt;/code&gt;）的Cookie可限制仅在该路径下发送，降低信息泄露风险。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;h3&gt;综合使用&lt;/h3&gt;
&lt;p&gt;用户免密登录&lt;/p&gt;
&lt;p&gt;在我们日常访问各大网站的时候，我们在登陆过一次后，往往之后就不需要使用账号密码再次登录，我们可以使用Cookie实现&lt;/p&gt;
&lt;p&gt;在LoginServlet程序中我们使用如下的流程实现&lt;/p&gt;
&lt;p&gt;1.获取用户名和密码&lt;/p&gt;
&lt;p&gt;2.判断用户名和密码是否正确&lt;/p&gt;
&lt;p&gt;正确允许登录，错误不允许登录&lt;/p&gt;
&lt;p&gt;如果正确将用户名和密码保存为Cookie发送给客户端&lt;/p&gt;
&lt;p&gt;jsp客户端，将输入值默认输入cookie值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%--
  Created by IntelliJ IDEA.
  User: 71460
  Date: 2025/5/13
  Time: 16:51
  To change this template use File | Settings | File Templates.
--%&amp;gt;
&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Login&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;form action=&quot;http://localhost:8080/Cookie/login&quot; method=&quot;get&quot;&amp;gt;
        用户名称&amp;lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;${cookie.username.value}&quot;&amp;gt;&amp;lt;br/&amp;gt;
        密码&amp;lt;input type=&quot;password&quot; name=&quot;password&quot; value=&quot;${cookie.password.value}&quot;&amp;gt;&amp;lt;br/&amp;gt;
        &amp;lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&amp;gt;
    &amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Servlet登录程序，当密码正确时账号密码存入Cookie，并重定向到对应页面，失败时，重写定位到登录界面&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@WebServlet(&quot;/login&quot;)
public class LoginServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        String username = req.getParameter(&quot;username&quot;);
        String password = req.getParameter(&quot;password&quot;);
        if(username.equals(&quot;lory&quot;) &amp;amp;&amp;amp; password.equals(&quot;123456&quot;)){
            Cookie cookie1 = new Cookie(&quot;username&quot;, username);
            cookie1.setMaxAge(60*60*24);
            resp.addCookie(cookie1);
            Cookie cookie2 = new Cookie(&quot;password&quot;, password);
            cookie2.setMaxAge(60*60*24);
            resp.addCookie(cookie2);
            System.out.println(&quot;Login Success&quot;);
            resp.sendRedirect(&quot;index.jsp&quot;);
        } else {
            System.out.println(&quot;Invalid username or password&quot;);
            resp.sendRedirect(&quot;login.jsp&quot;);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Session&lt;/h2&gt;
&lt;p&gt;:::note&lt;/p&gt;
&lt;p&gt;什么是&lt;strong&gt;Session&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Session是会话，用于维护一个客户端和服务器之间关联的一种技术&lt;/li&gt;
&lt;li&gt;Session是一个接口（HttpSession）&lt;/li&gt;
&lt;li&gt;每个客户端都有自己的Session会话&lt;/li&gt;
&lt;li&gt;Session会话中经常用于保存用户登录之后的信息&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;h3&gt;创建获取Session对象&lt;/h3&gt;
&lt;h4&gt;调用方法&lt;/h4&gt;
&lt;p&gt;创建和获取Session都是调用同一个API获取&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;request.getSession()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第一次创建，第二次以及之后获取之前创建的Session&lt;/p&gt;
&lt;p&gt;那么如何判断Session对象是创建出的还是获取的呢？&lt;/p&gt;
&lt;p&gt;我们通过如下的方法获取&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;session.isNew()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;true代表初次创建的，而false代表是获取到的Session&lt;/p&gt;
&lt;p&gt;每个会话都会有一个身份证号，即ID，这个ID是唯一的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;session.getId()
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;代码实现&lt;/h4&gt;
&lt;p&gt;通过createSession获取到session对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;protected void createSession(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    HttpSession session = req.getSession();
    System.out.println(session.isNew());
    System.out.println(session.getId());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;false
E40645D73ABF4618B37B7FF0363A6E1C
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Session域对象存取数据&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;protected void setAndGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    HttpSession session = req.getSession();
    session.setAttribute(&quot;key1&quot;, &quot;value1&quot;);
    session.setAttribute(&quot;key2&quot;, &quot;value2&quot;);
    Object key1 = session.getAttribute(&quot;key1&quot;);
    Object key2 = session.getAttribute(&quot;key2&quot;);
    System.out.println(&quot;key1: &quot; + key1
    + &quot; key2: &quot; + key2);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Session生命周期&lt;/h3&gt;
&lt;p&gt;session超时指的是客户端两次请求间隔的最大时长（负数不会超时）&lt;/p&gt;
&lt;p&gt;setMaxnactiveInterval方法：设置Session的超时时间，超过指定的时长Session就会被销毁&lt;/p&gt;
&lt;p&gt;getMaxnactiveInterval方法：获取Session的超时时间&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;protected void SessionLife(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        HttpSession session = req.getSession();
        session.getMaxInactiveInterval();//默认为1800s
        session.setMaxInactiveInterval(60*60);
        session.getMaxInactiveInterval();
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;默认的超时时间长短可以在Tomcat的配置中进行修改&lt;/p&gt;
&lt;p&gt;invalidate方法：使得Session被销毁&lt;/p&gt;
&lt;p&gt;:::note&lt;/p&gt;
&lt;p&gt;服务器在接收客户端的请求（无Cookie的情况下），会创建一个Session对象，并创建一个Cookie对象，装入一个JSESSIONID:sessionId键值对，最后将Cookie对象返回给服务器，此后每一次客户端在请求服务器的时候都会附带的Cookie中始终有Session的Id标识。&lt;/p&gt;
&lt;p&gt;在需要Session会话的时候，服务器会通过Cookie的SessionId找到创建完成的Session对象返回使用。&lt;/p&gt;
&lt;p&gt;所以当将对于客户端的Cookie的JSESSIONID键删除的情况下，即使服务器有客户端的Session对象，它任然会创建出一个新的Session对象&lt;/p&gt;
&lt;p&gt;:::&lt;/p&gt;
</content:encoded></item><item><title>JavaWeb笔记（文件上传）</title><link>https://thrinisty.github.io/posts/javaweb%E7%AC%94%E8%AE%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/javaweb%E7%AC%94%E8%AE%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</guid><description>JavaWeb文件传输</description><pubDate>Mon, 12 May 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;JavaWeb笔记&lt;/h1&gt;
&lt;h2&gt;文件传输&lt;/h2&gt;
&lt;p&gt;文件上传和下载是非常常见的功能，很多的系统中或者软件中都经常使用文件的上传和下载&lt;/p&gt;
&lt;h3&gt;文件上传&lt;/h3&gt;
&lt;p&gt;1.要有一个form标签，method=post请求&lt;/p&gt;
&lt;p&gt;2.form标签的encType属性必须为multipart/form-data&lt;/p&gt;
&lt;p&gt;3.在form标签中使用input type=file添加上传的文件&lt;/p&gt;
&lt;p&gt;4.使用服务器代码接收上传的文件&lt;/p&gt;
&lt;p&gt;以下是一个代码示例&lt;/p&gt;
&lt;h4&gt;实现方式&lt;/h4&gt;
&lt;p&gt;1-3：前端显示界面完成上传功能&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;body&amp;gt;
    &amp;lt;form action=&quot;http://localhost:8080/EL/photoUpload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&amp;gt;
        用户名称：&amp;lt;input type=&quot;text&quot; name=&quot;username&quot;&amp;gt;&amp;lt;br/&amp;gt;
        头像：&amp;lt;input type=&quot;file&quot; name=&quot;photo&quot;&amp;gt;&amp;lt;br/&amp;gt;
        &amp;lt;input type=&quot;submit&quot; value=&quot;上传&quot;&amp;gt;
    &amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.服务器处理上传图片的代码&lt;/p&gt;
&lt;p&gt;:::note
使用如下的Tomcat中的虚拟机选项设置字符集&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-Dfile.encoding=UTF-8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@WebServlet(&quot;/photoUpload&quot;)
public class PhotoServer extends HttpServlet {
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println(&quot;图片上传处理&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里暂时没有实现图片的Servlet处理，我们接下来通过Servlet API实现&lt;/p&gt;
&lt;p&gt;:::warning&lt;/p&gt;
&lt;p&gt;文件传输request中的数据以流的形式传输，需要使用流对象来接收，而且流对象中的内容包括了请求头部分和图片二进制数据部分，需要我们手动处理，这里建议直接调用Servlet API&lt;/p&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;h4&gt;相关工具包&lt;/h4&gt;
&lt;p&gt;在使用相关API之前，我们需要使用Maven管理工具导入相关包&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- Apache Commons FileUpload --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;commons-fileupload&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;commons-fileupload&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.5&amp;lt;/version&amp;gt; &amp;lt;!-- 最新稳定版 --&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;!-- Apache Commons IO（FileUpload 依赖它） --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;commons-io&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;commons-io&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.11.0&amp;lt;/version&amp;gt; &amp;lt;!-- 最新稳定版 --&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中有一些常用类与方法&lt;/p&gt;
&lt;p&gt;ServletFileUpLoad：用于解析上传的数据&lt;/p&gt;
&lt;p&gt;ServletFileUpLoad静态方法isMultipartContent：用于判断当前上传的数据格式是否是多段的格式&lt;/p&gt;
&lt;p&gt;parseRequest：返回FileItem类List集合，解析上传数据&lt;/p&gt;
&lt;p&gt;FileItem类方法isFormField:判断表单项是普通表单还是上传文件类型的表单&lt;/p&gt;
&lt;p&gt;FileItem类方法getFieldName：获取表单项的name属性&lt;/p&gt;
&lt;p&gt;FileItem类方法getString：获取当前表单项的值&lt;/p&gt;
&lt;p&gt;FileItem类方法getName：获取上传的文件名&lt;/p&gt;
&lt;p&gt;FileItem类方法write：传入file参数，将上传的文件写入到参数file指向的空间&lt;/p&gt;
&lt;h4&gt;文件处理实现&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;@WebServlet(&quot;/photoUpload&quot;)
public class PhotoServer extends HttpServlet {
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        resp.setContentType(&quot;text/html;charset=UTF-8&quot;);
        System.out.println(&quot;图片上传处理&quot;);
        if(ServletFileUpload.isMultipartContent(req)) {
            //创建FileItemFactory工厂实现类
            FileItemFactory fileItemFactory = new DiskFileItemFactory();
            //创建用于上传数据的工具类ServletFileUpload
            ServletFileUpload upload = new ServletFileUpload(fileItemFactory);
            try {
                List&amp;lt;FileItem&amp;gt; list = upload.parseRequest(req);
                for (FileItem item : list) {
                    if (item.isFormField()) {
                        //普通表单项
                        System.out.println(item.getFieldName() + &quot; : &quot; + item.getString());
                    } else {
                        //文件处理
                        String filePath = &quot;e:\\&quot; + item.getName();
                        item.write(new File(filePath));
                        System.out.println(&quot;存储至路径&quot; + filePath);
                    }
                }
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;文件下载&lt;/h3&gt;
&lt;p&gt;1.获取要下载的文件名&lt;/p&gt;
&lt;p&gt;2.读取要下载的文件内容（通过ServletContext获取）&lt;/p&gt;
&lt;p&gt;3.把下载的文件内容回传给客户端&lt;/p&gt;
&lt;p&gt;4.回传前通过响应头告诉客户端返回的数据类型&lt;/p&gt;
&lt;p&gt;5.告诉客户端收到的数据是用于下载使用&lt;/p&gt;
&lt;h4&gt;页面get请求&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;form action=&quot;http://localhost:8080/EL/Download&quot; method=&quot;get&quot; enctype=&quot;multipart/form-data&quot;&amp;gt;
    输入下载的文件名&amp;lt;input type=&quot;text&quot; name=&quot;filename&quot;&amp;gt;&amp;lt;br/&amp;gt;
    &amp;lt;input type=&quot;submit&quot; value=&quot;下载文件&quot;&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;Servlet服务器处理&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;@WebServlet(&quot;/Download&quot;)
public class Download extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        String fileName = req.getParameter(&quot;filename&quot;);
        //String fileName = &quot;2.jpg&quot;;
        ServletContext context = getServletContext();
        String mimeType = context.getMimeType(&quot;/file/&quot; + fileName);

        resp.setContentType(mimeType);
        resp.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename=&quot; + fileName);

        InputStream resourceAsStream = context.getResourceAsStream(&quot;/file/&quot; + fileName);//获取输入流
        OutputStream out = resp.getOutputStream();//获取响应输出流
        IOUtils.copy(resourceAsStream, out);//复制数据给输出流，输出到客户端
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;:::warning&lt;/p&gt;
&lt;p&gt;当文件路径中含有中文的时候，没有办法正常识别文件对象，我们需要处理一下头部，将文件名称进行url编码（谷歌浏览器、Edge）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;resp.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename=&quot; + URLEncoder.encode(fileName, &quot;UTF-8&quot;));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;p&gt;:::warning&lt;/p&gt;
&lt;p&gt;如果是火狐浏览器需要Base64编码解码，较为麻烦，需要手动的将文件名转化为字节数组（UTF-8），再将字节数组使用编码器实例编码，解码也一样，先将Base64编码解为字节数组，再使用String指定UTF-8编码格式将其转化为字符串&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;resp.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename==?UTF-8?B?&quot; + new BASE64Encoder().encode(fileName.getBytes(UTF-8)) + &quot;?=&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;h4&gt;进一步改进&lt;/h4&gt;
&lt;p&gt;可以通过request的请求头User-Agent对于客户端浏览器进行判断，再根据不同的分支进行响应的编码处理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if(req.getHeader(&quot;User-Agent&quot;).contains(&quot;Chrome&quot;)) {
    resp.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename=&quot; + URLEncoder.encode(fileName, &quot;UTF-8&quot;));
} else {
    resp.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename==?UTF-8?B?&quot; + new BASE64Encoder().encode(fileName.getBytes(&quot;UTF-8&quot;)) + &quot;?=&quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是在实际使用中，我们采取更加健壮的编码方式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@WebServlet(&quot;/Download&quot;)
public class Download extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        String fileName = req.getParameter(&quot;filename&quot;);
        ServletContext context = getServletContext();
        String mimeType = context.getMimeType(&quot;/file/&quot; + fileName);

        resp.setContentType(mimeType);

        // 改进的文件名编码处理（兼容所有现代浏览器）
        String encodedFileName = getEncodedFileName(fileName);
        resp.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; &quot; + encodedFileName);

        try (InputStream resourceAsStream = context.getResourceAsStream(&quot;/file/&quot; + fileName)) {
            IOUtils.copy(resourceAsStream, resp.getOutputStream());
        }
    }

    private String getEncodedFileName(String fileName) throws UnsupportedEncodingException {
        // 1. 简单ASCII文件名（兼容旧浏览器）
        String asciiFallback = &quot;filename=\&quot;&quot; + escapeAscii(fileName) + &quot;\&quot;&quot;;

        // 2. RFC 5987编码（现代浏览器优先使用这个）
        String rfc5987 = &quot;filename*=UTF-8&apos;&apos;&quot; + encodeRFC5987(fileName);

        return asciiFallback + &quot;; &quot; + rfc5987;
    }

    private String escapeAscii(String fileName) {
        // 转义ASCII文件名中的特殊字符
        return fileName.replace(&quot;\&quot;&quot;, &quot;\\\&quot;&quot;)
                .replace(&quot;\r&quot;, &quot;&quot;)
                .replace(&quot;\n&quot;, &quot;&quot;);
    }

    private String encodeRFC5987(String fileName) throws UnsupportedEncodingException {
        // 使用Java标准库进行RFC 5987编码
        return URLEncoder.encode(fileName, &quot;UTF-8&quot;)
                .replace(&quot;+&quot;, &quot;%20&quot;)
                .replace(&quot;*&quot;, &quot;%2A&quot;)
                .replace(&quot;%7E&quot;, &quot;~&quot;)
                .replace(&quot;%27&quot;, &quot;&apos;&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;今天课多，学的内容较少，但是额外抽出时间整理了一下网络编程第二个大作业的思路（JSP+Servlet+Bean实现图书管理系统），准备攒一个简易版本网络程序，就当综合使用下JavaWeb部分的知识&lt;/p&gt;
&lt;p&gt;明天打算，进入Cookie和Session部分的学习&lt;/p&gt;
</content:encoded></item><item><title>JavaWeb笔记(EL，JSTL)</title><link>https://thrinisty.github.io/posts/javaweb%E7%AC%94%E8%AE%B0eljstl/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/javaweb%E7%AC%94%E8%AE%B0eljstl/</guid><description>EL表达式，标签库</description><pubDate>Sun, 11 May 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;JSP&lt;/h1&gt;
&lt;p&gt;这两天事情确实有一点多，但好在也是顺利完成了，昨晚上还抽空更新了一下主页的样式，把就博客给迁移到了 Fuwari 新的主题上，看着确实稍微顺眼一点，今天没什么多的事情，就学一下EL表达式，JSTL标签库部分的知识&lt;/p&gt;
&lt;h2&gt;EL表达式&lt;/h2&gt;
&lt;p&gt;EL表达式全称是：Expression Language，是表达式语言&lt;/p&gt;
&lt;p&gt;作用：代替JSP页面中的表达式脚本，在JSP页面中进行数据的输出，格式比JSP输出脚本要简洁得多&lt;/p&gt;
&lt;p&gt;EL基本上是为了JSP而开发的（所以使用地位上也基本和JSP等同），在现代企业开发中如果不是为了维护老的项目，其实已经不再继续使用EL表达式了，但是多学一点总是没有坏处的&lt;/p&gt;
&lt;h3&gt;入门使用&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;EL表达式&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;%
        request.setAttribute(&quot;key&quot;, &quot;value&quot;);
    %&amp;gt;
    &amp;lt;%=request.getAttribute(&quot;key&quot;)%&amp;gt;
    ${key}
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们之前学过了通过表达式脚本标签输出内容到页面上，我们现在使用EL表达式来实现相同的功能&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;${key1}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到相比较于原先的一大串，EL表达式的形式上要简洁的多&lt;/p&gt;
&lt;p&gt;而且我们现在来尝试输出一个不存在的key对应的值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%=request.getAttribute(&quot;keyNull&quot;)%&amp;gt;
${keyNull}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;null	//null字符串	
		//无结果
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在用户的角度而言，无结果肯定是优于null的，EL表达式做了一些优化&lt;/p&gt;
&lt;p&gt;当然我们使用三目运算符，编写表达式脚本也可以实现类似的效果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%=request.getAttribute(&quot;key&quot;) == null? &quot;&quot; : request.getAttribute(&quot;key&quot;)%&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;域对象数据输出&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;EL表达式主要输出的是域对象的数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%
    pageContext.setAttribute(&quot;key&quot;, &quot;value1&quot;);
    request.setAttribute(&quot;key&quot;, &quot;value2&quot;);
    session.setAttribute(&quot;key&quot;, &quot;value3&quot;);
    application.setAttribute(&quot;key&quot;, &quot;value4&quot;);
%&amp;gt;
${key}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;value1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;:::tip
这里在key相同的情况下，优先输出域范围小的时候的值，这里和c语言中的屏蔽机制有些类似，但是在实际使用的时候不建议这么做，回减少代码的可读性
:::&lt;/p&gt;
&lt;h3&gt;Bean对象输出&lt;/h3&gt;
&lt;h4&gt;对象构造&lt;/h4&gt;
&lt;p&gt;我们先编写一个Java Person类&lt;/p&gt;
&lt;p&gt;:::important
get方法必须要添加，因为后续EL表达式调用的不是类本身的属性值，而是通过getXxx方法获取到的属性对象
:::&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.bean;

import java.util.Arrays;
import java.util.List;
import java.util.Map;

public class Person {
    private String name;
    private String[] phones;
    private List&amp;lt;String&amp;gt; cities;
    private Map&amp;lt;String, Object&amp;gt; map;

    public Person() {}

    public Person(String name, String[] phones, List&amp;lt;String&amp;gt; cities, Map&amp;lt;String, Object&amp;gt; map) {
        this.name = name;
        this.phones = phones;
        this.cities = cities;
        this.map = map;
    }
//省略set、get方法，get必须要添加
    @Override
    public String toString() {
        return &quot;Person{&quot; +
                &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; +
                &quot;, phones=&quot; + Arrays.toString(phones) +
                &quot;, cities=&quot; + cities +
                &quot;, map=&quot; + map +
                &apos;}&apos;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在JSP页面中运用代码脚本设置初值以及构造Person类的实例对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%
    String[] phones = {&quot;phone1&quot;, &quot;phone2&quot;, &quot;phone3&quot;};
    List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
    list.add(&quot;Beijing&quot;);
    list.add(&quot;Shanghai&quot;);
    Map&amp;lt;String, Object&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
    map.put(&quot;key1&quot;, &quot;value1&quot;);
    map.put(&quot;key2&quot;, &quot;value2&quot;);
    map.put(&quot;key3&quot;, &quot;value3&quot;);
    map.put(&quot;key4&quot;, &quot;value4&quot;);
    Person person = new Person(&quot;Jack&quot;, phones, list, map);
    pageContext.setAttribute(&quot;person&quot;, person);
%&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;输出方式&lt;/h4&gt;
&lt;p&gt;找到对应的get方法&lt;/p&gt;
&lt;h5&gt;类的输出&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;输出Person类数据${person}&amp;lt;br/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;输出Person类数据Person{name=&apos;Jack&apos;, phones=[phone1, phone2, phone3], cities=[Beijing, Shanghai], map={key1=value1, key2=value2, key3=value3,
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;普通属性&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;输出name属性${person.name}&amp;lt;br/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;输出name属性Jack
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;数组属性&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;输出phones数组属性${person.phones[0]}&amp;lt;br/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;输出phones数组属性phone1
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;List集合&lt;/h5&gt;
&lt;p&gt;单个数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输出city：list集合${person.cities[0]}&amp;lt;br/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;输出city：list集合Beijing
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;整个list&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输出city：list集合${person.cities}&amp;lt;br/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;输出city：list集合[Beijing, Shanghai]
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;map集合&lt;/h5&gt;
&lt;p&gt;单个数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输出map集合${person.map.key1}&amp;lt;br/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;输出map集合value1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;整个map&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输出map集合${person.map}&amp;lt;br/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;输出map集合{key1=value1, key2=value2, key3=value3, key4=value4}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;EL表达式运算&lt;/h3&gt;
&lt;h4&gt;关系运算&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;body&amp;gt;
    ${12 == 12}或${12 eq 12}&amp;lt;br/&amp;gt;
    ${12 != 12}或${12 ne 12}&amp;lt;br/&amp;gt;
    ${1 &amp;lt; 2}或${1 lt 2}&amp;lt;br/&amp;gt;
    ${1 &amp;gt; 2}或${1 gt 2}&amp;lt;br/&amp;gt;
    ${1 &amp;lt;= 2}或${1 le 2}&amp;lt;br/&amp;gt;
    ${1 &amp;gt;= 2}或${1 ge 2}&amp;lt;br/&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;页面显示&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;true或true
false或false
true或true
false或false
true或true
false或false
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;逻辑运算&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;body&amp;gt;
    ${true &amp;amp;&amp;amp; true}或${true and true}&amp;lt;br/&amp;gt;
    ${true || false}或${true or false}&amp;lt;br/&amp;gt;
    ${!true}或${not true}&amp;lt;br/&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;页面显示&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;true或true
true或true
false或false
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;算术运算&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;body&amp;gt;
    ${12 + 18}&amp;lt;br/&amp;gt;
    ${12 - 10}&amp;lt;br/&amp;gt;
    ${12 * 2}&amp;lt;br/&amp;gt;
    ${12 / 2} 或 ${12 div 2}&amp;lt;br/&amp;gt;
    ${13 % 2} 或 ${13 mod 2}&amp;lt;br/&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;页面显示&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;30
2
24
6.0 或 6.0
1 或 1
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;empty运算&lt;/h4&gt;
&lt;p&gt;可以判断一个数据是否为空，为空则输出true，其余为false&lt;/p&gt;
&lt;p&gt;值为null  值为空串  值为Object类型数组且长度为0  list、map集合元素个数为0&lt;/p&gt;
&lt;p&gt;定义一些（为空的）对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%
    Integer a = null;
    String b =&quot;&quot;;
    Object[] c = new Object[0];
    List&amp;lt;Object&amp;gt; d = new ArrayList&amp;lt;&amp;gt;();
    Map&amp;lt;String, Object&amp;gt; e = new HashMap&amp;lt;&amp;gt;();
    request.setAttribute(&quot;a&quot;, a);
    request.setAttribute(&quot;b&quot;, b);
    request.setAttribute(&quot;c&quot;, c);
    request.setAttribute(&quot;d&quot;, d);
    request.setAttribute(&quot;e&quot;, e);
%&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;${empty a}&amp;lt;br/&amp;gt;
${empty b}&amp;lt;br/&amp;gt;
${empty c}&amp;lt;br/&amp;gt;
${empty d}&amp;lt;br/&amp;gt;
${empty e}&amp;lt;br/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这些值显示都是true&lt;/p&gt;
&lt;h4&gt;点运算与中括号&lt;/h4&gt;
&lt;p&gt;点运算：可以输出Bean对象中的某个元素值&lt;/p&gt;
&lt;p&gt;中括号：可以输出有序集合中某个元素的值，还可以输出map集合中key里含有特殊字符的key值&lt;/p&gt;
&lt;p&gt;例如有一个key为a.a.a的数据放在名为map的Map集合中，我们可以使用如下的方式取出数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;${map[&apos;a.a.a&apos;]}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;EL表达式隐含对象&lt;/h3&gt;
&lt;p&gt;EL表达式中定义的，可以直接使用&lt;/p&gt;
&lt;h4&gt;隐含对象表格&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;变量&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;pageContext&lt;/td&gt;
&lt;td&gt;PageConextImpl&lt;/td&gt;
&lt;td&gt;获取jsp中的九大内置对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pageScope&lt;/td&gt;
&lt;td&gt;Map&amp;lt;String,Object&amp;gt;&lt;/td&gt;
&lt;td&gt;获取PageContext域中的数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;requestScope&lt;/td&gt;
&lt;td&gt;Map&amp;lt;String,Object&amp;gt;&lt;/td&gt;
&lt;td&gt;获取Request域中的数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sessionScope&lt;/td&gt;
&lt;td&gt;Map&amp;lt;String,Object&amp;gt;&lt;/td&gt;
&lt;td&gt;获取Session域中的数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;applicationScope&lt;/td&gt;
&lt;td&gt;Map&amp;lt;String,Object&amp;gt;&lt;/td&gt;
&lt;td&gt;获取ServletContext域中的数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;param&lt;/td&gt;
&lt;td&gt;Map&amp;lt;String,Object&amp;gt;&lt;/td&gt;
&lt;td&gt;获取请求参数的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;paramValues&lt;/td&gt;
&lt;td&gt;Map&amp;lt;String,Object[]&amp;gt;&lt;/td&gt;
&lt;td&gt;获取请求参数的值(多个)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;header&lt;/td&gt;
&lt;td&gt;Map&amp;lt;String,String&amp;gt;&lt;/td&gt;
&lt;td&gt;获取请求头的信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;headerValues&lt;/td&gt;
&lt;td&gt;Map&amp;lt;String,String[]&amp;gt;&lt;/td&gt;
&lt;td&gt;获取请求头的信息(多个)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cookie&lt;/td&gt;
&lt;td&gt;Map&amp;lt;String,Cookie&amp;gt;&lt;/td&gt;
&lt;td&gt;获取当前请求的Cookie信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;initParam&lt;/td&gt;
&lt;td&gt;Map&amp;lt;String,String&amp;gt;&lt;/td&gt;
&lt;td&gt;web.xml配置中的上下文参数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;域对象&lt;/h4&gt;
&lt;p&gt;对于四个域对象而言&lt;/p&gt;
&lt;p&gt;相比于之前获取域数据直接填入key查找对应的value，我们在使用隐含变量获取key可以避免数据的屏蔽，选择性的输出想要的域对应的值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;${变量.key}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;pageContext&lt;/h4&gt;
&lt;p&gt;获取JSP内置对象&lt;/p&gt;
&lt;p&gt;常见作用&lt;/p&gt;
&lt;p&gt;常用于输出常用信息：协议，获取服务器ip，获取服务器端口，工程路径，请求方法，获取客户端ip，获取会话id编号（上边是JSP表达式，下边是EL表达式）&lt;/p&gt;
&lt;p&gt;协议&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%request.getScheme()%&amp;gt;
${pageContext.request.scheme}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;获取服务器ip&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%request.getServerName()%&amp;gt;
${pageContext.request.servername}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;获取服务器端口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%request.getServerPort()%&amp;gt;
${pageContext.request.serverPort}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;工程路径&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%request.getContextPath()%&amp;gt;
${pageContext.request.contextPath}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;请求方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%request.getMethod()%&amp;gt;
${pageContext.request.method}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;获取客户端ip&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%request.getRemoteHost()%&amp;gt;
${pageContext.request.remoteHost}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;获取会话id编号&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%session.getId())%&amp;gt;
${pageContext.session.id}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;JSTL标签库&lt;/h2&gt;
&lt;p&gt;JSTL标签库是 JSP标准的标签库，EL表达式是为了替换JSP中的表达式脚本，而标签库则是为了替换代码脚本，使得JSP页面更加的简洁&lt;/p&gt;
&lt;h3&gt;JSTL的五个标签&lt;/h3&gt;
&lt;p&gt;对应五个不同功能&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;功能范围&lt;/th&gt;
&lt;th&gt;URI&lt;/th&gt;
&lt;th&gt;前缀&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;核心标签库&lt;/td&gt;
&lt;td&gt;http://java.sun.com/jsp/jstl/core&lt;/td&gt;
&lt;td&gt;c&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;格式化&lt;/td&gt;
&lt;td&gt;http://java.sun.com/jsp/jstl/fmt&lt;/td&gt;
&lt;td&gt;fmt&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;函数&lt;/td&gt;
&lt;td&gt;http://java.sun.com/jsp/jstl/functions&lt;/td&gt;
&lt;td&gt;fn&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;数据库&lt;/td&gt;
&lt;td&gt;http://java.sun.com/jsp/jstl/sql&lt;/td&gt;
&lt;td&gt;sql&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;XML&lt;/td&gt;
&lt;td&gt;http://java.sun.com/jsp/jstl/xml&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;一般不使用数据库标签（破坏了三层结构），XML标签（通过Session传数据）&lt;/p&gt;
&lt;h3&gt;使用步骤&lt;/h3&gt;
&lt;p&gt;导入jar包，我这里给出了Maven构建的对应坐标文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;javax.servlet&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;jstl&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.2&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在JSP文件下导入标签库（IDEA可以自动导入）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;core核心库&lt;/h3&gt;
&lt;h4&gt;set&lt;/h4&gt;
&lt;p&gt;可以往域里面那保存数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;c:set scope=&quot;request&quot; var=&quot;key&quot; value=&quot;123&quot;/&amp;gt;
${requestScope.key}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;if&lt;/h4&gt;
&lt;p&gt;做选择判断，但是不可以做if-else分支，需要使用需要再写一个if标签&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;c:set scope=&quot;request&quot; var=&quot;key&quot; value=&quot;123&quot;/&amp;gt;
&amp;lt;c:if test=&quot;${false or true}&quot;&amp;gt;
    ${requestScope.key}
&amp;lt;/c:if&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;choose&lt;/h4&gt;
&lt;p&gt;用于多路判断，和switch类似&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;c:choose&amp;gt;
    &amp;lt;c:when test=&quot;${key &amp;gt; 180}&quot;&amp;gt;
        ${key}
    &amp;lt;/c:when&amp;gt;
    &amp;lt;c:when test=&quot;${key &amp;lt; 180 &amp;amp;&amp;amp; key &amp;gt; 100}&quot;&amp;gt;
        ${key1}
    &amp;lt;/c:when&amp;gt;
    &amp;lt;c:otherwise&amp;gt;
        ${key2}
    &amp;lt;/c:otherwise&amp;gt;
&amp;lt;/c:choose&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;:::warning
choose里不可以使用html注释.&lt;/p&gt;
&lt;p&gt;otherwise和when标签的直接父标签一定要是choose&lt;/p&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;h4&gt;forEach&lt;/h4&gt;
&lt;p&gt;作用是遍历输出&lt;/p&gt;
&lt;p&gt;遍历1~10，var属性表示循环的变量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;c:forEach begin=&quot;1&quot; end=&quot;10&quot; var=&quot;i&quot;&amp;gt;
    ${i}
&amp;lt;/c:forEach&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;遍历Object数组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;body&amp;gt;
    &amp;lt;%
        Object[] arr = {&quot;Java&quot;, &quot;Cpp&quot;, 10};
        request.setAttribute(&quot;key&quot;, arr);
    %&amp;gt;
    &amp;lt;c:forEach items=&quot;${requestScope.key}&quot; var=&quot;i&quot;&amp;gt;
       ${i}
    &amp;lt;/c:forEach&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;遍历List集合（Bean对象一般可以放在表格中显示，要整齐一点）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;c:forEach items=&quot;${requestScope.person}&quot; var=&quot;person&quot;&amp;gt;
    ${person}
&amp;lt;/c:forEach&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;遍历Map集合&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;c:forEach items=&quot;${requestScope.key}&quot; var=&quot;entry&quot;&amp;gt;
    ${entry}
    ${entry.key}
    ${entry.value}
&amp;lt;/c:forEach&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个部分其实还有很多的内容，但是考虑到代码脚本也可以轻松完成，而且JSTL伴随着JSP慢慢减少使用，我不想在这个部分浪费太多时间&lt;/p&gt;
</content:encoded></item><item><title>JavaWeb笔记(JSP)</title><link>https://thrinisty.github.io/posts/javaweb%E7%AC%94%E8%AE%B0jsp/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/javaweb%E7%AC%94%E8%AE%B0jsp/</guid><description>JSP,Java服务器页面</description><pubDate>Thu, 08 May 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;JavaWeb笔记&lt;/h1&gt;
&lt;h2&gt;JSP&lt;/h2&gt;
&lt;h3&gt;初步介绍&lt;/h3&gt;
&lt;p&gt;JSP全称为Java Server Pages，java的服务器页面，主要作用为替Servlet程序回传html页面的数据，因为Servlet程序回传html页面数据是一件非常繁琐的事情，开发成本和维护成本都很高&lt;/p&gt;
&lt;p&gt;我们在使用Servlet程序回传html需要通过回传流需要一行一行地将html页面的数据传回，要会传完整一个html页面需要大量的代码使用write写入返回到客户端地浏览器&lt;/p&gt;
&lt;p&gt;以下是一个代码示例，可见非常的繁琐&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@WebServlet(&quot;/test&quot;)
public class TestServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //通过响应的回传流回传html页面数据
        // 设置响应内容类型为HTML
        resp.setContentType(&quot;text/html;charset=UTF-8&quot;);

        // 获取响应输出流
        PrintWriter out = resp.getWriter();

        // 构建HTML页面内容
        out.println(&quot;&amp;lt;!DOCTYPE html&amp;gt;&quot;);
        out.println(&quot;&amp;lt;html&amp;gt;&quot;);
        out.println(&quot;&amp;lt;head&amp;gt;&quot;);
        out.println(&quot;    &amp;lt;title&amp;gt;Servlet生成的页面&amp;lt;/title&amp;gt;&quot;);
        out.println(&quot;    &amp;lt;style&amp;gt;&quot;);
        out.println(&quot;        body { font-family: Arial, sans-serif; margin: 40px; }&quot;);
        out.println(&quot;        h1 { color: #3366cc; }&quot;);
        out.println(&quot;    &amp;lt;/style&amp;gt;&quot;);
        out.println(&quot;&amp;lt;/head&amp;gt;&quot;);
        out.println(&quot;&amp;lt;body&amp;gt;&quot;);
        out.println(&quot;    &amp;lt;h1&amp;gt;这是由TestServlet动态生成的页面&amp;lt;/h1&amp;gt;&quot;);
        out.println(&quot;    &amp;lt;p&amp;gt;当前时间: &quot; + new java.util.Date() + &quot;&amp;lt;/p&amp;gt;&quot;);
        out.println(&quot;    &amp;lt;p&amp;gt;请求方法: &quot; + req.getMethod() + &quot;&amp;lt;/p&amp;gt;&quot;);
        out.println(&quot;    &amp;lt;p&amp;gt;Servlet路径: &quot; + req.getServletPath() + &quot;&amp;lt;/p&amp;gt;&quot;);
        out.println(&quot;&amp;lt;/body&amp;gt;&quot;);
        out.println(&quot;&amp;lt;/html&amp;gt;&quot;);

        // 关闭输出流
        out.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;与此同时JSP可以很好的解决这个问题，代替了Servlet程序回传html页面的数据，注意JSP页面要通过服务器端进行解析，需要先运行Tomcat服务器后才可以显示动态生成出来，而不是像html一样可以直接通过本地的浏览器一样解析&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;JSP生成的页面&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    JSP JSP JSP
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;JSP页面本质上是一个Servlet程序，当我们第一次访问JSP页面的时候，Tomcat服务器会帮我们将jsp页面翻译为一个java源文件，并且将其编译为class字节码程序&lt;/p&gt;
&lt;p&gt;生成的Servlet继承自HttpJspBase，所以 JSP 本质上就是一个Servlet，生成的Servlet程序生成的html页面也是通过write输出流生成&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;      out.write(&quot;\r\n&quot;);
      out.write(&quot;\r\n&quot;);
      out.write(&quot;&amp;lt;html&amp;gt;\r\n&quot;);
      out.write(&quot;&amp;lt;head&amp;gt;\r\n&quot;);
      out.write(&quot;    &amp;lt;title&amp;gt;JSP生成的页面&amp;lt;/title&amp;gt;\r\n&quot;);
      out.write(&quot;&amp;lt;/head&amp;gt;\r\n&quot;);
      out.write(&quot;&amp;lt;body&amp;gt;\r\n&quot;);
      out.write(&quot;    JSP JSP JSP\r\n&quot;);
      out.write(&quot;&amp;lt;/body&amp;gt;\r\n&quot;);
      out.write(&quot;&amp;lt;/html&amp;gt;\r\n&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;JSP page&lt;/h3&gt;
&lt;p&gt;jsp的page指令可以修改jsp页面中的一些重要属性或者行为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以下是一些常见的可以修改的属性&lt;/p&gt;
&lt;p&gt;language 属性：表示jsp翻译后是什么语言文件，暂时只支持java&lt;/p&gt;
&lt;p&gt;contentType 属性：表示jsp返回的数据类型是什么，也是源码中response.setContentType设置的编码类型（一般都是UTF-8）&lt;/p&gt;
&lt;p&gt;pageEncoding 属性：表示当前jsp页面文件本身的字符集（一般都是UTF-8）&lt;/p&gt;
&lt;p&gt;import 属性：和Java一致，导入包&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%@ page import=&quot;java.util&quot; %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;autoFlush 属性：设置当out输出流缓冲区满了后，是否自动刷新缓冲区，默认为true&lt;/p&gt;
&lt;p&gt;buffer 属性：设置out输出缓冲区大小，默认为8kb&lt;/p&gt;
&lt;p&gt;errorPage 属性：设置当jsp页面运行出错的时候，会自动跳转的错误页面&lt;/p&gt;
&lt;p&gt;isErrorPage 属性：设置当前jsp页面是否是错误信息页面，默认为false，如果是true可以获取异常信息&lt;/p&gt;
&lt;p&gt;session 属性：设置访问当前jsp页面，是否会创建HttpSession对象，默认是true&lt;/p&gt;
&lt;p&gt;extends 属性：设置jsp翻译出来的java类默认继承谁&lt;/p&gt;
&lt;h3&gt;JSP脚本&lt;/h3&gt;
&lt;h4&gt;声明脚本&lt;/h4&gt;
&lt;p&gt;可以给JSP翻译出来的java类定义属性和方法，甚至是静态代码块和方法，定义的声明会生成到对应的Java源文件和class文件中&lt;/p&gt;
&lt;p&gt;格式为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%!
	Java声明语句
%&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;声明类属性&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%!
    private Integer id;
    private String name;
    private static Map&amp;lt;String,Object&amp;gt; map;
%&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;声明static静态代码块&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%!
    static {
        map = new HashMap&amp;lt;String,String&amp;gt;();
        map.put(&quot;key1&quot;, &quot;v1&quot;);
        map.put(&quot;key2&quot;, &quot;v2&quot;);
        map.put(&quot;key3&quot;, &quot;v3&quot;);
        map.put(&quot;key4&quot;, &quot;v4&quot;);
    }
%&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;声明类方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%!
    public int function(){
        return 12;
    }
%&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;声明内部类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%!
    public static class Student{
        private String name = &quot;Jack&quot;;
        private int age = 10;
    }
%&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;表达式脚本&lt;/h4&gt;
&lt;p&gt;作用：在jsp页面上输出数据&lt;/p&gt;
&lt;p&gt;格式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%=表达式%&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%=12 %&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;%=name %&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;%=&quot;字符串测试&quot; %&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;%=map %&amp;gt;&amp;lt;br&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出内容&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;JSP JSP JSP 12
TestString
字符串测试
{key1=v1, key2=v2, key3=v3, key4=v4}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;特点&lt;/p&gt;
&lt;p&gt;所有的表达式脚本都会被翻译到_jspService方法中&lt;/p&gt;
&lt;p&gt;所有的表达式脚本都会被翻译成为out.print输出到页面上&lt;/p&gt;
&lt;p&gt;由于表达式脚本翻译的内容都在_jspService方法中，所以jspService方法中的对象都可以直接使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%=request.getParameter(&quot;name&quot;)%&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;http://localhost:8080/JSPTest/Test.jsp?name=1234&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1234
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;表达式内容不可以 ; 结束&lt;/p&gt;
&lt;h4&gt;代码脚本&lt;/h4&gt;
&lt;p&gt;作用：可以在jsp页面中，编写我们自己需要的功能（java语句）&lt;/p&gt;
&lt;p&gt;格式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%
	java语句
%&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%
    int i = 12;
    if(i == 12) {
        System.out.println(i);
    }
%&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码脚本特点&lt;/p&gt;
&lt;p&gt;1.代码脚本翻译之后都在_jspServive方法中&lt;/p&gt;
&lt;p&gt;2.代码脚本中可以直接使用_jspService方法中的对象&lt;/p&gt;
&lt;p&gt;3.代码脚本还可以由多个代码脚本块组合完成一个Java语句&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%
    int i = 12;
    for (int j = 0; j &amp;lt; i; j++) {   
%&amp;gt;
&amp;lt;%
        System.out.println(&quot;j&quot;);
    }
%&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.代码脚本还可以与表达式脚本组合使用在JSP页面打印&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%
    int i = 12;
    for (int j = 0; j &amp;lt; i; j++) {
%&amp;gt;
    &amp;lt;%=j%&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;%
    }
%&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然也不建议这么使用，太过于混乱了，现在基本上都是直接使用框架了，这么些可维护性差&lt;/p&gt;
&lt;h4&gt;JSP注释&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Test&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;!--html注释--&amp;gt;
    &amp;lt;%
        //Java注释
        /*会被翻译到Java源代码中*/
    %&amp;gt;
    &amp;lt;%--JSP注释（时JSP中真正的注释）--%&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;内置对象&lt;/h3&gt;
&lt;p&gt;JSP中的内置对象，指的是Tomcat在翻译JSP页面为Servlet源代码后，内部提供的九大对象称为内置对象&lt;/p&gt;
&lt;p&gt;request：请求对象&lt;/p&gt;
&lt;p&gt;response：响应对象&lt;/p&gt;
&lt;p&gt;pageContext：jsp上下文对象&lt;/p&gt;
&lt;p&gt;session：会话对象&lt;/p&gt;
&lt;p&gt;application：ServletContext对象&lt;/p&gt;
&lt;p&gt;config：ServletConfig对象&lt;/p&gt;
&lt;p&gt;out：jsp输出流对象&lt;/p&gt;
&lt;p&gt;page：指向当前jsp的对象&lt;/p&gt;
&lt;p&gt;exception：异常对象（当页面异常isErrorPage开启时创建异常对象）&lt;/p&gt;
&lt;h4&gt;四个域对象&lt;/h4&gt;
&lt;p&gt;pageContext（PageContextImpl类）当前jsp页面范围内有效&lt;/p&gt;
&lt;p&gt;request（HttpServletRequest类）一次请求内有效（请求转发不会丢失request数据）&lt;/p&gt;
&lt;p&gt;session（HttpSession类）一个会话范围内有效（打开浏览器访问服务器，直到关闭浏览器）&lt;/p&gt;
&lt;p&gt;application（ServletContext类）整个Web工程范围内都有效（Web停止后销毁）&lt;/p&gt;
&lt;p&gt;域对象是可以像Map一样存取数据的对象，四个域对象的功能一样，不同的是特们对于数据的存取范围&lt;/p&gt;
&lt;p&gt;我在这里遇到了pageContext无法解析set/getAttribute方法，应该是缺少 JSP API 依赖导致的&lt;/p&gt;
&lt;p&gt;你的依赖中没有明确包含 &lt;code&gt;jsp-api&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这会导致 IDEA 无法解析 &lt;code&gt;pageContext&lt;/code&gt; 的方法&lt;/p&gt;
&lt;p&gt;添加如下的依赖配置即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;javax.servlet.jsp&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;javax.servlet.jsp-api&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.3.3&amp;lt;/version&amp;gt;
    &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;JSP生成的页面&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;JSP标题&amp;lt;/h1&amp;gt;
    &amp;lt;%
        pageContext.setAttribute(&quot;key1&quot;, &quot;pageContext&quot;);
        request.setAttribute(&quot;key2&quot;, &quot;Request&quot;);
        session.setAttribute(&quot;key3&quot;, &quot;Session&quot;);
        application.setAttribute(&quot;key4&quot;, &quot;Application&quot;);
    %&amp;gt;
    &amp;lt;%=pageContext.getAttribute(&quot;key1&quot;)%&amp;gt;
    &amp;lt;%=request.getAttribute(&quot;key2&quot;)%&amp;gt;
    &amp;lt;%=session.getAttribute(&quot;key3&quot;)%&amp;gt;
    &amp;lt;%=application.getAttribute(&quot;key4&quot;)%&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;虽然都可以存取顺序，但是有使用优先顺序，最好在使用条件允许下使用小的范围&lt;/p&gt;
&lt;h3&gt;输出的细节&lt;/h3&gt;
&lt;h4&gt;out与getWriter&lt;/h4&gt;
&lt;p&gt;response中表示响应，经常用于设置返回给客户端的内容（输出）&lt;/p&gt;
&lt;p&gt;out也是给用户做输出使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;JSP生成的页面&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;JSP输出&amp;lt;/h1&amp;gt;
    &amp;lt;%
        response.getWriter().write(&quot;输出一&quot;);
        out.write(&quot;输出二&quot;);
    %&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出结果：我们发现response的write输出在标题的上边，和预期有些不符&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/151.png&quot; alt=&quot;151&quot; /&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;JSP 引擎先处理模板文本 &lt;code&gt;&amp;lt;h1&amp;gt;JSP输出&amp;lt;/h1&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;遇到脚本片段时：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;response.getWriter().write()&lt;/code&gt; 立即输出到客户端&lt;/li&gt;
&lt;li&gt;&lt;code&gt;out.write()&lt;/code&gt; 写入缓冲区&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;最后 JSP 引擎刷新缓冲区，&lt;code&gt;out.write()&lt;/code&gt; 的内容才真正输出&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一般在使用中统一使用out输出，避免打乱顺序&lt;/p&gt;
&lt;h4&gt;out.print与out.write&lt;/h4&gt;
&lt;p&gt;print会将内容逐个转为字符再通过write输出，而write输出整形数据会出现问题，会将内容转为字符串（并非单个字符转化）&lt;/p&gt;
&lt;p&gt;所以在实际使用的时候输出数字用print完成（或者直接统一使用print）&lt;/p&gt;
&lt;h3&gt;常用标签&lt;/h3&gt;
&lt;h4&gt;静态包含&lt;/h4&gt;
&lt;p&gt;有的时候我们将一个页面分为数个部分显示，为了保证页面的灵活性，我们可以将单个部分提取出来编写，方便随时替换或者修改&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;JSP生成的页面&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;常用标签&amp;lt;/h1&amp;gt;
    头部信息&amp;lt;br&amp;gt;
    主体信息&amp;lt;br&amp;gt;
    页脚信息&amp;lt;br&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们将页脚信息提取出来&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;页脚&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    页脚内容(静态包含)&amp;lt;br&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用jsp页面&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;JSP生成的页面&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;常用标签&amp;lt;/h1&amp;gt;
    头部信息&amp;lt;br&amp;gt;
    主体信息&amp;lt;br&amp;gt;
    &amp;lt;%@ include file=&quot;/foot.jsp&quot;%&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;静态包含的特点：不会翻译被包含的jsp页面，而是将被包含的jsp页面拷贝到包含的位置输出&lt;/p&gt;
&lt;h4&gt;动态包含&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;JSP生成的页面&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;常用标签&amp;lt;/h1&amp;gt;
    头部信息&amp;lt;br&amp;gt;
    主体信息&amp;lt;br&amp;gt;
    &amp;lt;jsp:include page=&quot;foot.jsp&quot;&amp;gt;&amp;lt;/jsp:include&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;效果上和静态包含效果上差别不大，动态包含会把包含的jsp页面也翻译为java代码，动态包含底层调用了include方法调用被包含的页面进行输出（将被包含的页面的对象给包含页面进行使用）&lt;/p&gt;
&lt;p&gt;工程上一般使用静态代码&lt;/p&gt;
&lt;h4&gt;请求转发&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;JSP生成的页面&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;请求转发&amp;lt;/h1&amp;gt;
    &amp;lt;jsp:forward page=&quot;/servlet&quot;&amp;gt;&amp;lt;/jsp:forward&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Listener监听器&lt;/h3&gt;
&lt;p&gt;Listener监听器时JavaWeb的三大组件之一（Servler程序、Filter过滤器、Listener监听器）&lt;/p&gt;
&lt;p&gt;是JavaEE的规范，即接口，作用为监听某种事物的变化，通过回调函数，反馈给客户（程序）做一些处理&lt;/p&gt;
&lt;h4&gt;ServletContextListener&lt;/h4&gt;
&lt;p&gt;可以监听ServletContext对象的创建和销毁（ServletContext对象在Web工程启动的时候创建，在Web工程停止的时候销毁）&lt;/p&gt;
&lt;p&gt;监听到创建和销毁之后都会分别调用ServletContextListener监听器的方法反馈，这两个方法分别是contextInitialized和contextDestroyed，其中传入了ServletContextEvent对象&lt;/p&gt;
&lt;p&gt;使用方式&lt;/p&gt;
&lt;p&gt;1.编写一个类实现ServletContextListener&lt;/p&gt;
&lt;p&gt;2.实现两个回调方法&lt;/p&gt;
&lt;p&gt;3.配置web.xml监听器（配置注解@WebListener）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.listener;

import javax.servlet.ServletContextEvent;
import javax.servlet.ServletContextListener;
import javax.servlet.annotation.WebListener;
import java.awt.event.ActionListener;

@WebListener
public class ListenerTest implements ServletContextListener {
    @Override
    public void contextDestroyed(ServletContextEvent sce) {
        System.out.println(&quot;contextDestroyed&quot;);
    }

    @Override
    public void contextInitialized(ServletContextEvent sce) {
        System.out.println(&quot;contextInitialized&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这两天忙着准备面试+编译原理实验（最恶心的一个）+线性代数考试复习，暂时抽不出时间，等10号之后再开始EL表达式的学习&lt;/p&gt;
</content:encoded></item><item><title>JavaWeb笔记(Servlet)</title><link>https://thrinisty.github.io/posts/javaweb%E7%AC%94%E8%AE%B0servletservletrequestservletresponse%E9%87%8D%E5%AE%9A%E5%90%91/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/javaweb%E7%AC%94%E8%AE%B0servletservletrequestservletresponse%E9%87%8D%E5%AE%9A%E5%90%91/</guid><description>ServletRequest，ServletResponse，重定向</description><pubDate>Wed, 07 May 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;JavaWeb笔记&lt;/h1&gt;
&lt;p&gt;今天完成Servlet剩余部分的学习，JavaWeb部分的实战项目我就不练了，我打算这一个部分的练手等到学习完开发框架之后做成一整个项目&lt;/p&gt;
&lt;p&gt;今天发现自己的Servlet程序没有办法打印出中文字符，去网络上搜索了以下，回答的都是处理请求头的编码处理，但想想直接打印也是乱码，应该是Tomcat的配置出了问题，以下是解决方式：在Tomcat运行设置里的虚拟机选项填入以下内容（修改运行配置）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-Dfile.encoding=UTF-8
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;HttpServletRequest&lt;/h2&gt;
&lt;p&gt;作用：每次只要有请求进入Tomcat服务器，Tomcat服务器就会把请求过来的HTTP协议信息解析好封装到Request对象中，然后传递到service方法，在doGet和doPost方法中给我们使用，我们可以通过HttpServletRequest对象，获取到所有的请求信息&lt;/p&gt;
&lt;p&gt;http://localhost:8080/ServletTest/test?username=2022302546&amp;amp;password=123455&amp;amp;hobby=cpp&amp;amp;hobby=java&lt;/p&gt;
&lt;h3&gt;常用方法&lt;/h3&gt;
&lt;h4&gt;getRequestURI&lt;/h4&gt;
&lt;p&gt;获取请求资源路径&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;System.out.println(req.getRequestURI());
///ServletRequests/test
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;getRequestURL&lt;/h4&gt;
&lt;p&gt;获取请求的统一资源定位符&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;System.out.println(req.getRequestURL());
//http://localhost:8080/ServletRequests/test
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;getRemoteHost&lt;/h4&gt;
&lt;p&gt;获取客户端的ip地址&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;System.out.println(req.getRemoteHost());
//0:0:0:0:0:0:0:1
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;getHeader&lt;/h4&gt;
&lt;p&gt;获取请求头&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;System.out.println(req.getHeader(&quot;Accept-Language&quot;));
//zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6 取决你想要访问的头
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;getMethod&lt;/h4&gt;
&lt;p&gt;获取请求的方式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;System.out.println(req.getMethod());
//GET
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;getParameter&lt;/h4&gt;
&lt;p&gt;获取请求参数&lt;/p&gt;
&lt;p&gt;我们先加入一个html页面，其中设置一个表单，名称填为18288763320，可以在doGet中通过req参数获取到username参数对应的表单项值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Test&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;form action=&quot;http://localhost:8080/ServletTest/test&quot; method=&quot;get&quot;&amp;gt;
        名称&amp;lt;input type=&quot;text&quot; name=&quot;username&quot;&amp;gt;&amp;lt;br/&amp;gt;
        密码&amp;lt;input type=&quot;password&quot; name=&quot;password&quot;/&amp;gt;&amp;lt;br/&amp;gt;
        爱好
        &amp;lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;cpp&quot;&amp;gt;C++
        &amp;lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;java&quot;&amp;gt;Java
        &amp;lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;python&quot;&amp;gt;python
        &amp;lt;input type=&quot;submit&quot;&amp;gt;
    &amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;System.out.println(req.getParameter(&quot;username&quot;));
//18288763320
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;getParameterValues&lt;/h4&gt;
&lt;p&gt;获取请求的参数（多个值时使用，如使用勾选框的时候）返回一个数组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;String[] hobbies = req.getParameterValues(&quot;hobby&quot;);
for (String hobby : hobbies) {
    System.out.print(hobby + &quot; &quot;);
}//cpp java 
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;setCharacterEncoding&lt;/h4&gt;
&lt;p&gt;在Post请求中没法正确获取到表单中的中文字符（乱码）可通过在doPost中设置字符集解决，注意在打印请求前设置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;request.setCharacterEncoding(&quot;UTF-8&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;setAttribute&lt;/h4&gt;
&lt;p&gt;设置域数据&lt;/p&gt;
&lt;h4&gt;getAttribute&lt;/h4&gt;
&lt;p&gt;获取域数据&lt;/p&gt;
&lt;p&gt;和Map集合类似，这里不再过多说明&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;req.setAttribute(&quot;test&quot;, &quot;test&quot;);
String test = (String)req.getAttribute(&quot;test&quot;);
System.out.println(test);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;转发请求&lt;/h3&gt;
&lt;h4&gt;getRequestDispatcher&lt;/h4&gt;
&lt;p&gt;获取转发请求&lt;/p&gt;
&lt;p&gt;在第一个Servlet程序中完成请求的转发，并填入一个域数据，用以被第二个Servlet程序获取处理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@WebServlet(&quot;/test1&quot;)
public class Servlet1 extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println(&quot;doGetServlet1&quot;);
        req.setAttribute(&quot;function&quot;, &quot;target&quot;);
        //添加域数据
        RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;/test2&quot;);
        //获取到访问地址
        requestDispatcher.forward(req, resp);
        //访问目标地址，并转发请求req
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二个Servlet程序，由于也传入了req访问请求参数，可以获取到其中的信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@WebServlet(&quot;/test2&quot;)
public class Servlet2 extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println(&quot;doGetServlet2&quot;);
        System.out.println(&quot;获取到了&quot; + req.getAttribute(&quot;function&quot;));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;转发请求的特点&lt;/h4&gt;
&lt;p&gt;1.浏览器地址栏没有变化&lt;/p&gt;
&lt;p&gt;2.他们是一次请求&lt;/p&gt;
&lt;p&gt;3.可以共享Request域数据&lt;/p&gt;
&lt;p&gt;4.可以转发到WEB-INF目录下（直接通过浏览器地址栏没法访问）&lt;/p&gt;
&lt;h2&gt;base标签&lt;/h2&gt;
&lt;p&gt;我们有如下一个场景，两个页面相互跳转，通过a标签设置链接完成&lt;/p&gt;
&lt;p&gt;index.html&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Test&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;a href=&quot;a/b/c.html&quot;&amp;gt;跳转页面&amp;lt;/a&amp;gt;
    &amp;lt;a href=&quot;http://localhost:8080/ServletTest/Servlet&quot;&amp;gt;通过servlet跳转页面&amp;lt;/a&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;c.html&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;a href=&quot;../../index.html&quot;&amp;gt;跳转回index页面&amp;lt;/a&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以正常跳转，没有问题，我们现在通过Servlet转发实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;a href=&quot;http://localhost:8080/ServletTest/Servlet&quot;&amp;gt;通过servlet跳转页面&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;@WebServlet(&quot;/Servlet&quot;)
public class Servlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println(&quot;转发&quot;);
        RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;/a/b/c.html&quot;);
        //获取到访问地址
        requestDispatcher.forward(req, resp);
        //访问目标地址，并转发请求req
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在index页面中可以正常跳转到c.html页面下，但是没有办法跳转回来，因为当前的地址为 http://localhost:8080/ServletTest/Servlet （转发的时候不会跳转地址） 回溯路径是 ../../index.html 而在8080工作路径下没有c.html&lt;/p&gt;
&lt;p&gt;我们这个时候可以使用到base标签：设置当前页面中所有的相对路径工作时，参照哪一个路径进行跳转&lt;/p&gt;
&lt;p&gt;更改c.html 设置base标签，标注在当前c.html跳转时参照 http://localhost:8080/ServletTest/a/b/ 进行跳转&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
    &amp;lt;base href=&quot;http://localhost:8080/ServletTest/a/b/&quot;&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;a href=&quot;../../index.html&quot;&amp;gt;跳转回index页面&amp;lt;/a&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样就没有问题了，可以正常跳回index页面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/149.png&quot; alt=&quot;149&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;HttpServletResponse&lt;/h2&gt;
&lt;p&gt;​	HttpServletResponse类和HttpServletRequest类一样，每一次请求都会创建一个Response对线传递给Servlet程序使用，HttpServletRequest表示请求过来的信息，而HttpServletResponse表示所有响应的信息&lt;/p&gt;
&lt;p&gt;​	如果我们需要设置返回给客户端的信息，都可以通过HttpServletResponse对象来进行设置&lt;/p&gt;
&lt;h3&gt;两个输出流&lt;/h3&gt;
&lt;p&gt;二者只能使用其一&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@WebServlet(&quot;/Servlet&quot;)
public class Servlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        resp.setCharacterEncoding(&quot;UTF-8&quot;);
        //设置响应字符集为UTF-8，除此之外还要设置浏览器字符集
        resp.setHeader(&quot;Content-Type&quot;, &quot;text/html;charset=UTF-8&quot;);
        //设置浏览器字符集
        
        //resp.setContentType(&quot;text/html;charset=UTF-8&quot;);
        //同时设置以上的响应和服务器字符集，选其中之一即可（注意设置后再获取流对象）
        
        PrintWriter writer = resp.getWriter();
//        ServletOutputStream outputStream = resp.getOutputStream();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;字节流&lt;/h4&gt;
&lt;p&gt;getOutputStream&lt;/p&gt;
&lt;p&gt;常用于下载&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ServletOutputStream outputStream = resp.getOutputStream();
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;字符流&lt;/h4&gt;
&lt;p&gt;getWriter&lt;/p&gt;
&lt;p&gt;常用于回传字符串&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;PrintWriter writer = resp.getWriter();
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;PrintWriter writer = resp.getWriter();
writer.write(&quot;response&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;请求重定向&lt;/h3&gt;
&lt;p&gt;请求重定向：是指客户端给服务器发送请求，然后服务器告诉客户端说，给与新地址以访问（之前的地址可能被废弃）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/150.png&quot; alt=&quot;150&quot; /&gt;&lt;/p&gt;
&lt;p&gt;第一个访问的Servlet程序，访问第二个Servlet程序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.servlet;

@WebServlet(&quot;/index.html&quot;)
public class Servlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        resp.setStatus(302);
        resp.setHeader(&quot;Location&quot;, &quot;http://localhost:8080/ServletTest/another&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二个Servlet程序，告诉用户新的资源地址&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.servlet;

@WebServlet(&quot;/another&quot;)
public class Response extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        resp.setContentType(&quot;text/html;charset=UTF-8&quot;);
        PrintWriter writer = resp.getWriter();
        writer.write(&quot;服务暂停，可以跳转至新的页面http://localhost:8080/ServletTest/new.html&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意事项：&lt;/p&gt;
&lt;p&gt;1.浏览器地址发送变化&lt;/p&gt;
&lt;p&gt;2.两次请求&lt;/p&gt;
&lt;p&gt;3.不可以访问Request域数据&lt;/p&gt;
&lt;p&gt;4.不可以访问WEB-INF下资源&lt;/p&gt;
&lt;p&gt;5.可以访问工程外的资源&lt;/p&gt;
&lt;p&gt;或者直接调用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@WebServlet(&quot;/index.html&quot;)
public class Servlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        resp.sendRedirect(&quot;http://localhost:8080/ServletTest/new.html&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>JavaWeb笔记(Servlet)</title><link>https://thrinisty.github.io/posts/javaweb%E7%AC%94%E8%AE%B0servletservlethttp%E5%8D%8F%E8%AE%AE/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/javaweb%E7%AC%94%E8%AE%B0servletservlethttp%E5%8D%8F%E8%AE%AE/</guid><description>Servlet（Servlet，HTTP协议）</description><pubDate>Tue, 06 May 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;JavaWeb笔记&lt;/h1&gt;
&lt;p&gt;之前Maven没有配置好导致了JavaWeb的环境配置比较困难，去大概了解了一下Maven构建的相关知识，现在可以快速通过坐标导入相关的jar包了，马上开始Servlet的学习&lt;/p&gt;
&lt;h2&gt;Servlet&lt;/h2&gt;
&lt;h3&gt;入门使用&lt;/h3&gt;
&lt;p&gt;我使用的是Maven构建的Servlet程序，不需要web.xml进行注册，只需要使用@WebServlet注解完成绑定即可访问使用&lt;/p&gt;
&lt;p&gt;新建一个类，实现Servlet的接口方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@WebServlet(&quot;/hello&quot;)//使用该注解可以绑定访问/hello地址的时候调用Servlet服务
public class HelloServlet implements Servlet
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;@Override
public void init(ServletConfig servletConfig) throws ServletException {

}

@Override
public ServletConfig getServletConfig() {
    return null;
}

@Override
public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
	//该方法在调用Servlet服务的时候会被调用
    System.out.println(&quot;Hello Servlet&quot;);
}

@Override
public String getServletInfo() {
    return &quot;&quot;;
}

@Override
public void destroy() {

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：在Maven构建的Servlet程序中，index.jsp要放在src/main/webapp目录下，才可以被默认访问到&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/142.png&quot; alt=&quot;142&quot; /&gt;&lt;/p&gt;
&lt;p&gt;配置完毕的时候，我们运用浏览器访问 http://localhost:8080/ServletTest/hello 即可调用实现servlet接口的实现类中的相关方法&lt;/p&gt;
&lt;h3&gt;运行流程&lt;/h3&gt;
&lt;p&gt;以下是一个调用的流程图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/143.png&quot; alt=&quot;143&quot; /&gt;&lt;/p&gt;
&lt;p&gt;1.执行Servlet构造方法&lt;/p&gt;
&lt;p&gt;2.执行init初始化方法&lt;/p&gt;
&lt;p&gt;3.执行&lt;/p&gt;
&lt;p&gt;4.执行destroy销毁方法&lt;/p&gt;
&lt;p&gt;前两个方法在初次时调用，第二次访问/hello时，只调用service方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create Servlet
init Servlet
Servlet Running
Servlet Running
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;sevice方法&lt;/h3&gt;
&lt;p&gt;用一个html页面运用submit提交，跳转到对应的路径下也会被Servlet捕获并且调用相关方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Test&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;form action=&quot;http://localhost:8080/ServletTest/hello&quot; method=&quot;post&quot;&amp;gt;
        &amp;lt;input type=&quot;submit&quot;&amp;gt;
    &amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;@Override
public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
    System.out.println(&quot;Servlet Running&quot;);
    HttpServletRequest Request = (HttpServletRequest) servletRequest;
    String method = Request.getMethod();
    System.out.println(method);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过ServletRequest servletRequest的子类型的getMethod方法可以得到请求的类型（Post/Get）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Servlet Running
GET
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一般而言，我们在处理两种不同的请求类型的时候进行方法化处理，分别调用不同的处理操作&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
    System.out.println(&quot;Servlet Running&quot;);
    HttpServletRequest Request = (HttpServletRequest) servletRequest;
    String method = Request.getMethod();
    switch (method) {
        case &quot;GET&quot;:
            System.out.println(&quot;GET Method&quot;);
            doGet();//处理get请求的方法
            break;
        case &quot;POST&quot;:
            System.out.println(&quot;POST Method&quot;);
            doPost();//处理post请求的方法
            break;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;HttpServlet实现&lt;/h3&gt;
&lt;p&gt;在实际的开发中，很少通过实现servlet接口实现servlet程序，而是继承其子类HttpServlet来实现&lt;/p&gt;
&lt;p&gt;1.编写一个类去集成HttpServlet类&lt;/p&gt;
&lt;p&gt;2.根据业务需要重写doGet或者doPost方法&lt;/p&gt;
&lt;p&gt;3.到web.xml配置Servlet程序的访问地址（我通过@WebServlet(&quot;/test&quot;)完成）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@WebServlet(&quot;/test&quot;)
public class ServletTest extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println(&quot;Servlet Get Called&quot;);
        super.doGet(req, resp);
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println(&quot;Servlet Post Called&quot;);
        super.doPost(req, resp);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;继承关系&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../images/144.png&quot; alt=&quot;144&quot; /&gt;&lt;/p&gt;
&lt;p&gt;GenericServlet实现了Servlet接口，并做了一些空实现，持有一个ServletConfig类的引用，并对ServletConfig的使用做一些方法&lt;/p&gt;
&lt;p&gt;HttpServlet抽取类实现了service方法，并实现了请求的分发处理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;String method = req.getMethod();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而其中调用的doGet和doPost默认抛出异常，不支持请求，我们在实际使用的时候根据需要重写方法实现业务逻辑即可&lt;/p&gt;
&lt;h3&gt;ServletConfig类&lt;/h3&gt;
&lt;h4&gt;注解Servlet&lt;/h4&gt;
&lt;p&gt;首先运用注解设置访问地址以及初始化参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@WebServlet(
        urlPatterns = &quot;/hello&quot;,  // 访问路径
        initParams = {
                @WebInitParam(name = &quot;name&quot;, value = &quot;John&quot;), 
                @WebInitParam(name = &quot;age&quot;, value = &quot;25&quot;)      
        }
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从类名来看，是Servlet程序的配置信息类&lt;/p&gt;
&lt;p&gt;Servlet程序和ServletConfig对象都是由Tomcat负责创建，我们负责使用&lt;/p&gt;
&lt;p&gt;Servlet程序默认是第一次访问的时候创建，ServletConfig是每个Servlet程序创建的时候，就创建一个ServletConfig对象（其中封装了一些信息）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface ServletConfig {
    String getServletName();
    ServletContext getServletContext();
    String getInitParameter(String var1);
    Enumeration&amp;lt;String&amp;gt; getInitParameterNames();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;三大作用&lt;/h4&gt;
&lt;p&gt;1.可以获取Servlet程序的别名servlet-name的值&lt;/p&gt;
&lt;p&gt;2.获取初始化参数init-param&lt;/p&gt;
&lt;p&gt;3.获取ServletContext对象&lt;/p&gt;
&lt;p&gt;传递初始化参数的init方法，以及ServletConfig的使用方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
public void init(ServletConfig servletConfig) throws ServletException {
    //1.可以获取Servlet程序的别名servlet-name的值
    System.out.println(servletConfig.getServletName());
    //com.servlet.HelloServlet
    //2.获取初始化参数init-param
    System.out.println(servletConfig.getInitParameter(&quot;name&quot;));
    //John
    //3.获取ServletContext对象
    System.out.println(servletConfig.getServletContext());
    //org.apache.catalina.core.ApplicationContextFacade@15f00bcd
    System.out.println(&quot;init Servlet&quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;注意要点&lt;/h4&gt;
&lt;p&gt;HttpServlet在重写init方法的时候需要调用super.init去获取到父类的config类，否则会发生空指针异常&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
public void init(ServletConfig config) throws ServletException {
    super.init(config);
    System.out.println(config.getServletName());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为HttpServlet的config没有被赋予GenericServlet的config信息，指向为空&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void init(ServletConfig config) throws ServletException {
    this.config = config;
    this.init();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;ServletContext类&lt;/h3&gt;
&lt;h4&gt;定义&lt;/h4&gt;
&lt;p&gt;是一个接口，表示Servlet上下文对象&lt;/p&gt;
&lt;p&gt;一个Web工程，只有一个ServletContext对象实例&lt;/p&gt;
&lt;p&gt;ServletContext是一个域对象（可以像Map一样存取数据的对象，域指的是存取数据的操作范围）&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;比较&lt;/th&gt;
&lt;th&gt;存数&lt;/th&gt;
&lt;th&gt;取数&lt;/th&gt;
&lt;th&gt;删除数据&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Map&lt;/td&gt;
&lt;td&gt;put&lt;/td&gt;
&lt;td&gt;get&lt;/td&gt;
&lt;td&gt;remove&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;域对象&lt;/td&gt;
&lt;td&gt;setAttribute&lt;/td&gt;
&lt;td&gt;getAttribute&lt;/td&gt;
&lt;td&gt;removeAttribute&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;ServletContext是在Web工程部署启动的时候创建的，在Web工程停止的时候销毁&lt;/p&gt;
&lt;h4&gt;作用&lt;/h4&gt;
&lt;p&gt;1.获取web.xml中配置的上下文参数context-param&lt;/p&gt;
&lt;p&gt;2.获取当前的工作路径，格式：/工程路径&lt;/p&gt;
&lt;p&gt;3.获取工程部署后在服务器硬盘上的绝对路径&lt;/p&gt;
&lt;p&gt;4.像Map一样存取数据&lt;/p&gt;
&lt;h4&gt;实际使用&lt;/h4&gt;
&lt;p&gt;由于我的Servlet程序没有设置web.xml，全局上下文变量是通过一个WebListener完成的，其中存储了一个global和一个version&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.listener;

import javax.servlet.ServletContextEvent;
import javax.servlet.ServletContextListener;
import javax.servlet.annotation.WebListener;

@WebListener
public class ContextListener implements ServletContextListener {
    @Override
    public void contextInitialized(ServletContextEvent sce) {
        sce.getServletContext().setAttribute(&quot;global&quot;, &quot;Hello World&quot;);
        sce.getServletContext().setAttribute(&quot;version&quot;, &quot;1.0.0&quot;);
    }

    @Override
    public void contextDestroyed(ServletContextEvent sce) {
        System.out.println(&quot;contextDestroyed&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而要在Servlet程序中调用，则通过getServletContext获取到上下文，再通过getAttribute类似map一样的操作取出对应的值&lt;/p&gt;
&lt;p&gt;以下是HttpServlet的实现类，其中有一个getServletContext的封装方法以调用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@WebServlet(&quot;/new&quot;)
public class NewServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        String global = (String)getServletContext().getAttribute(&quot;global&quot;);
        String version = (String)getServletContext().getAttribute(&quot;version&quot;);
        System.out.println(&quot;Servlet Get Called&quot; + global + &quot; &quot; + version);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们还可以通过Context获取工作路径与部署绝对路径&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意事项&lt;/strong&gt;：getRealPath方法在一些 &lt;strong&gt;非文件系统部署（比如 WAR 包部署到云服务器）中可能返回 null&lt;/strong&gt;，因此用需要额外小心&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    String contextPath = getServletContext().getContextPath();
    String realPath = getServletContext().getRealPath(&quot;/&quot;);
    System.out.println(contextPath);
    System.out.println(realPath);
    //ServletTest
    //C:\Users\71460\Desktop\Java\Maven\Servlet\target\Servlet-1.0-SNAPSHOT\
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;HTTP协议&lt;/h3&gt;
&lt;p&gt;指客户端和服务端通信时发送数据需要遵守的规则，HTTP协议中的数据称为报文，其中的请求分为GET请求和POST请求&lt;/p&gt;
&lt;h4&gt;GET请求&lt;/h4&gt;
&lt;p&gt;1.请求行：请求的方式，请求的资源路径，请求的协议和版本号&lt;/p&gt;
&lt;p&gt;2.请求头： key:value 组成，不同的键值对表示不同的含义&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/145.png&quot; alt=&quot;145&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;Post请求&lt;/h4&gt;
&lt;p&gt;1.请求行：请求的方式，请求的资源路径，请求的协议和版本号&lt;/p&gt;
&lt;p&gt;2.请求头： key:value 组成，不同的键值对表示不同的含义&lt;/p&gt;
&lt;p&gt;空行：请求头和请求体之间有空行&lt;/p&gt;
&lt;p&gt;3.请求体：===&amp;gt;&amp;gt;&amp;gt;就是发送给服务器的数据&lt;/p&gt;
&lt;p&gt;这里表单中有隐藏数据login username，将这两个信息发送给服务器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/146.png&quot; alt=&quot;146&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;常见的请求头&lt;/h4&gt;
&lt;p&gt;Accept：告诉服务器，客户端可以接收的数据类型&lt;/p&gt;
&lt;p&gt;Accept-Language：告诉服务器客户端可以接收的语言类型，zh_CN、zh_ENG&lt;/p&gt;
&lt;p&gt;User-Agent：浏览器的信息&lt;/p&gt;
&lt;p&gt;Accept-Encoding：告诉服务器，客户端可以接收的数据编码（压缩）格式&lt;/p&gt;
&lt;p&gt;Host：表示请求的服务器ip和端口号&lt;/p&gt;
&lt;p&gt;Connection：告诉服务器当前连接如何处理，常见的有两种，Keep-Alive和Closed&lt;/p&gt;
&lt;p&gt;Referer：表示请求发起时，浏览器地址栏中的地址从哪里来&lt;/p&gt;
&lt;p&gt;Content-Type：表示发送的数据类型（图中的表示多段数据提交，以流形式提交）&lt;/p&gt;
&lt;p&gt;Content-Length：发送的数据长度&lt;/p&gt;
&lt;p&gt;Cache-Control：表示如何控制缓存，no-cache表示不缓存&lt;/p&gt;
&lt;h4&gt;Get请求和Post请求区分&lt;/h4&gt;
&lt;p&gt;Get：&lt;/p&gt;
&lt;p&gt;form method=get  a标签  link标签引入css  script引入js文件  img标签引入图片  iframe引入html页面  在浏览器地址栏中输入访问地址回车&lt;/p&gt;
&lt;p&gt;Post：&lt;/p&gt;
&lt;p&gt;form method=post&lt;/p&gt;
&lt;h3&gt;响应HTTP协议格式&lt;/h3&gt;
&lt;h4&gt;格式&lt;/h4&gt;
&lt;p&gt;1.响应行：响应的协议与版本号  响应状态码  响应状态描述符&lt;/p&gt;
&lt;p&gt;2.响应头： key:value 不同的响应头，有不同的含义&lt;/p&gt;
&lt;p&gt;空行&lt;/p&gt;
&lt;p&gt;3.响应体：---&amp;gt;&amp;gt;&amp;gt;回传给客户端的数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/147.png&quot; alt=&quot;147&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;常见响应码&lt;/h4&gt;
&lt;p&gt;200：表示请求成功&lt;/p&gt;
&lt;p&gt;302：表示请求重定向&lt;/p&gt;
&lt;p&gt;404：表示请求被服务器收到，但是预期数据不存在（请求地址出错）&lt;/p&gt;
&lt;p&gt;500：表示服务器已经收到请求，但是服务器内部错误（代码错误，发生不可预期的错误）&lt;/p&gt;
&lt;h3&gt;MIME&lt;/h3&gt;
&lt;p&gt;MIME是HTTP协议中的数据类型，全称为多功能internet邮件扩充服务，MIME类型的格式是“大类型/小类型”，并与某一种文件的扩展名相对应&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/148.png&quot; alt=&quot;148&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>自学第二月份总结</title><link>https://thrinisty.github.io/posts/%E8%87%AA%E5%AD%A6%E7%AC%AC%E4%BA%8C%E6%9C%88%E4%BB%BD%E6%80%BB%E7%BB%93/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/%E8%87%AA%E5%AD%A6%E7%AC%AC%E4%BA%8C%E6%9C%88%E4%BB%BD%E6%80%BB%E7%BB%93/</guid><description>结束Java</description><pubDate>Thu, 01 May 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;自学第二月份总结&lt;/h1&gt;
&lt;p&gt;​	在学习Java后端开发的第二个月中，用10天的时间为Java语言基础收了个尾，结束了反射，多线程基础，IO流的学习&lt;/p&gt;
&lt;p&gt;​	学习完成Java部分的内容后又花了5天的时间回顾了MySQL数据库基础，巩固了一些数据库使用上的细节（存储引擎，事务，隔离级别等）。2天的时间完成了Java8一些新特性的学习，理解了Lambda表达式的使用，Stream API的概念以及使用方式，Optional类的学习&lt;/p&gt;
&lt;p&gt;​	之后又用了两天的时间完成JDBC的相关概念学习（SQL注入，连接池）学会了如何使用JDBC操作数据库，配置DBUtils，能够独立对于JDBC结合德鲁伊连接池，阿帕奇的Utils将SQL查询封装为Dao对象便于操作，用了两天的时间对于Redis有了一些初级的了解（数据结构，NoSQL，客户端），之后又花了一天半的时间完成了git版本控制工具的使用，能够结合远程代码托管平台（Github，Gitee），使用命令行或者IDEA集成开发环境，对于自己写的代码进行版本管理&lt;/p&gt;
&lt;p&gt;​	最后的8天稍微有些懈怠，由于课程安排有些紧凑，实际上满打满算的学习只有大概5天左右，完成了JavaWeb中的一部分学习：一些前端基础（html，CSS，JavaScript，jQuery），Web服务器（Tomcat），以及依赖管理工具Maven的基本使用，我对前端这部分的理解是在实际使用中搞清楚怎么用即可，没有花太多时间去像Java基础部分一样记录较为详细的笔记。&lt;/p&gt;
&lt;p&gt;​	五一假期打算过完生日后，抽出一天时间过一遍线代考试内容（5.10）另外两天看一下编译原理实验的作业和机器学习的大作业，假期之后再进行JavaWeb中Servlet的学习。&lt;/p&gt;
</content:encoded></item><item><title>JavaWeb笔记(Tomcat，Maven，Docker)</title><link>https://thrinisty.github.io/posts/javaweb%E7%AC%94%E8%AE%B0tomcatmavendocker/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/javaweb%E7%AC%94%E8%AE%B0tomcatmavendocker/</guid><description>服务器部署Tomcat，jar包管理Maven，环境Docker</description><pubDate>Tue, 29 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;JavaWeb笔记&lt;/h1&gt;
&lt;h2&gt;Tomcat&lt;/h2&gt;
&lt;p&gt;JavaWeb：所用通过Java语言编写可以通过浏览器访问的程序的总称，基于请求和响应来开发的&lt;/p&gt;
&lt;p&gt;Web资源：根据资源实现的技术和呈现的效果不同，分为静态资源和动态资源&lt;/p&gt;
&lt;p&gt;静态资源：html，css，js，txt，mp4，jpg&lt;/p&gt;
&lt;p&gt;动态资源：jsp页面，Servlet程序&lt;/p&gt;
&lt;p&gt;常见的服务器：Tomcat，Jboss，GlassFish，Resin，WebLogic&lt;/p&gt;
&lt;h3&gt;安装启动&lt;/h3&gt;
&lt;p&gt;版本对应&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/138.png&quot; alt=&quot;138&quot; /&gt;&lt;/p&gt;
&lt;p&gt;我使用的是tomcat9.0+Servlet4.0+JDK8&lt;/p&gt;
&lt;p&gt;将Tomcat解压到你想要的路径下&lt;/p&gt;
&lt;p&gt;在安装的bin目录下双击startup启动tomcat服务器，在浏览器中输入以下网址开启Tomcat服务页面&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http://localhost:8080
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;../images/139.png&quot; alt=&quot;139&quot; /&gt;&lt;/p&gt;
&lt;p&gt;如果在启动的时候出现黑框立马闪退，有可能是没有设置系统变量&lt;/p&gt;
&lt;p&gt;变量：JAVA_HOME   值：安装的JDK目录&lt;/p&gt;
&lt;p&gt;关闭：双击shutdown.bat关闭&lt;/p&gt;
&lt;p&gt;在config目录下有一个server.xml配置文件，在其中可以修改端口号8080，可以改为一个你想要用的其他端口号替换，再重启Tomcat服务器即可完成修改&lt;/p&gt;
&lt;h3&gt;部署Web&lt;/h3&gt;
&lt;h4&gt;第一种方式&lt;/h4&gt;
&lt;p&gt;是需要把Web工程目录放入Tomcat的webapps目录下即可，这种方式比较方便&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http://localhost:8080/test/123.html
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输入路径即可访问，其中的 http://localhost:8080 代表的就是webapps目录&lt;/p&gt;
&lt;p&gt;在其他的设备通过输入部署的网络IP地址可以远程访问Web页面，例如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http://192.168.104.29:8080/test/123.html
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;第二种方式&lt;/h4&gt;
&lt;p&gt;找到Tomcat下的conf目录apache-tomcat-9.0.104\conf\Catalina\localhost，创建配置文件，在其中设置路径即可访问对应路径下的Web工程，这种方式较为灵活&lt;/p&gt;
&lt;p&gt;访问服务器的时候，只填入网址端口默认访问ROOT工程，没有地址名，访问index.html&lt;/p&gt;
&lt;h3&gt;动态web工程&lt;/h3&gt;
&lt;p&gt;使用详见&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/weixin_45791445/article/details/104574239&lt;/p&gt;
&lt;p&gt;可以在IDEA上创建动态的Web项目，并使用Tomcat部署Web服务&lt;/p&gt;
&lt;h2&gt;Maven&lt;/h2&gt;
&lt;p&gt;推荐教程：可以快速上手，理解Maven相关概念以及使用方式&lt;/p&gt;
&lt;p&gt;【一小时Maven教程】https://www.bilibili.com/video/BV1uApMeWErY?p=12&amp;amp;vd_source=586d101621a2629c1796f59df9143dff&lt;/p&gt;
&lt;p&gt;Maven是一个依赖管理工具&lt;/p&gt;
&lt;p&gt;通过Maven可以实现批量编译，组织文件结构，批量复制jar包&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/140.png&quot; alt=&quot;140&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;依赖管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Maven可以管理项目依赖，包括自动下载依赖库，自动下载依赖之间没有冲突，以来版本管理，用户只需要编写配置即可&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;构建管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;项目构建是将源代码，配置文件，资源文件等转化为能够运行或者部署的应用程序或库的过程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/141.png&quot; alt=&quot;141&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Package定义规则&lt;/p&gt;
&lt;p&gt;jar：代表普通的java工程，打包为jar结尾的文件&lt;/p&gt;
&lt;p&gt;war：代表java的web工程&lt;/p&gt;
&lt;p&gt;porn：代表不会打包，用以做继承的父工程&lt;/p&gt;
&lt;p&gt;而maven通过pom.xml配置执行打包以及构建，其中仓库存放jar包（仓库又分为本地仓库，私服仓库，中央仓库）&lt;/p&gt;
&lt;p&gt;setting.xml配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;settings&amp;gt;
  &amp;lt;!-- 原有镜像配置保持不变 --&amp;gt;
  &amp;lt;mirrors&amp;gt;
    &amp;lt;mirror&amp;gt;
      &amp;lt;id&amp;gt;aliyunmaven&amp;lt;/id&amp;gt;
      &amp;lt;url&amp;gt;https://maven.aliyun.com/repository/public&amp;lt;/url&amp;gt;
      &amp;lt;mirrorOf&amp;gt;central&amp;lt;/mirrorOf&amp;gt;
    &amp;lt;/mirror&amp;gt;
  &amp;lt;/mirrors&amp;gt;

  &amp;lt;!-- 新增以下配置 --&amp;gt;
  &amp;lt;profiles&amp;gt;
    &amp;lt;profile&amp;gt;
      &amp;lt;id&amp;gt;disable-remote-archetype&amp;lt;/id&amp;gt;
      &amp;lt;properties&amp;gt;
        &amp;lt;!-- 强制使用本地 archetype 缓存 --&amp;gt;
        &amp;lt;archetypeCatalog&amp;gt;internal&amp;lt;/archetypeCatalog&amp;gt;
      &amp;lt;/properties&amp;gt;
    &amp;lt;/profile&amp;gt;
  &amp;lt;/profiles&amp;gt;

  &amp;lt;!-- 激活配置 --&amp;gt;
  &amp;lt;activeProfiles&amp;gt;
    &amp;lt;activeProfile&amp;gt;disable-remote-archetype&amp;lt;/activeProfile&amp;gt;
  &amp;lt;/activeProfiles&amp;gt;
&amp;lt;/settings&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;父子模块管理&lt;/p&gt;
&lt;p&gt;在父工程中的pom文件下添加的依赖可以被子模块中使用，所有将公共的依赖放置在父工程中可以简化依赖，也可以设置为不默认继承依赖，而是手动集成父工程依赖&lt;/p&gt;
&lt;h2&gt;Docker&lt;/h2&gt;
&lt;h3&gt;基本概念&lt;/h3&gt;
&lt;p&gt;Docker是一个用于构建运行传送应用程序的平台，可以解决环境配置的问题，将第三方软件库，依赖等打包，运行在任何的环境&lt;/p&gt;
&lt;p&gt;Docker是一个容器的实现，容器是一个虚拟化技术是一个独立的环境，使用宿主机的OS操作系统，减少资源的浪费（运行多个操作系统和图形化界面）&lt;/p&gt;
&lt;p&gt;容器是Docker的一个运行实例，提供一个可以移植的环境，可以在这个环境中运行应用程序，镜像和容器的关系类似Java中的类和实例，Docker仓库可以存储Docker镜像和上传，我们打包容器为镜像上传给别人，别人就可以使用镜像创建相应的容器&lt;/p&gt;
&lt;h3&gt;大致使用&lt;/h3&gt;
&lt;p&gt;Dockerfile是构建指令，包含了如何配置环境的一些指令，用于告诉如何构建镜像&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM node:14-alpine
COPY index.js /index.js
CMD [&quot;node&quot;, &quot;/index.js&quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;构建镜像&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker build -t hello-docker .
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看镜像&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker image ls
REPOSITORY   TAG       IMAGE ID       CREATED        SIZE
nginx        latest    9bea9f2796e2   5 months ago   192MB
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行镜像&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run hello-docker
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以通过网页使用在线的play with docker来远程通过dockerhub下载镜像，运行容器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker pull thrinisty/hello-docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Docker Compose&lt;/h3&gt;
&lt;p&gt;用于定义和运行多容器Docker应用程序的工具，使用yaml文件来设置应用程序服务&lt;/p&gt;
&lt;p&gt;通过docker-compose.yaml配置文件将一组互相关联的容器组合在一起，形成项目，通过一条命令即可创建并启动所有的服务&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker compose up
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;实际使用&lt;/h3&gt;
&lt;p&gt;我们现在在Docker上下载一个redis的镜像，并且通过镜像创建运行redis容器，之后在宿主机上用客户端连接服务器&lt;/p&gt;
&lt;p&gt;查找可用redis镜像&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker search redis
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下载redis镜像&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker pull redis
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行redis容器，并且通过-p参数将容器端口映射到宿主机端口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run --name redis_test -p 6379:6379 -d redis
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在宿主机连接docker运行中的redis容器对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;redis-cli -h 127.0.0.1 -p 6379
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>JavaWeb笔记（jQuery）</title><link>https://thrinisty.github.io/posts/javaweb%E7%AC%94%E8%AE%B0jqueryxml/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/javaweb%E7%AC%94%E8%AE%B0jqueryxml/</guid><description>jQuery，XML</description><pubDate>Sun, 27 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;JavaWeb笔记&lt;/h1&gt;
&lt;p&gt;计划两天完成jQuery和XML部分的学习&lt;/p&gt;
&lt;h2&gt;jQuery&lt;/h2&gt;
&lt;p&gt;定义：是JavaScript和Query查询的结合，是辅助JavaScript开发的js类库&lt;/p&gt;
&lt;p&gt;核心思想：写的更少，做的更多，实现了很多浏览器的兼容问题&lt;/p&gt;
&lt;p&gt;流行程度：流行程度高，约 &lt;strong&gt;75% 的网站&lt;/strong&gt; 仍在使用 jQuery 进行 JavaScript 开发&lt;/p&gt;
&lt;p&gt;优点：开源免费，语法便捷高效，简单易用（例如操作文档对象，选择DOM元素，制作动画效果，事件处理，使用Ajax等）&lt;/p&gt;
&lt;h3&gt;入门示例&lt;/h3&gt;
&lt;p&gt;如下是一个没有注册onclick事件的按钮，要求实现点击按钮输出Hello&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;!-- 约束声明 --&amp;gt;
&amp;lt;html lang=&quot;zh&quot;&amp;gt;&amp;lt;!--html表示html开始，lang=zh表示中文，分为head和body--&amp;gt;
&amp;lt;head&amp;gt;&amp;lt;!--头部信息，一般包含title，css，js--&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;&amp;lt;!--字符集--&amp;gt;
    &amp;lt;title&amp;gt;标题&amp;lt;/title&amp;gt;&amp;lt;!--标题区域--&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;&amp;lt;!--主体内容--&amp;gt;
    &amp;lt;button id=&quot;button&quot;&amp;gt;Say&amp;lt;/button&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;传统方式：通过获取标签对象绑定事件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;!-- 约束声明 --&amp;gt;
&amp;lt;html lang=&quot;zh&quot;&amp;gt;&amp;lt;!--html表示html开始，lang=zh表示中文，分为head和body--&amp;gt;
&amp;lt;head&amp;gt;&amp;lt;!--头部信息，一般包含title，css，js--&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;&amp;lt;!--字符集--&amp;gt;
    &amp;lt;title&amp;gt;标题&amp;lt;/title&amp;gt;&amp;lt;!--标题区域--&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
        window.onload = function () {
            var Obj = document.getElementById(&quot;button&quot;);
            Obj.onclick = function () {
                alert(&quot;Hello&quot;);
            }
        }
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;&amp;lt;!--主体内容--&amp;gt;
    &amp;lt;button id=&quot;button&quot;&amp;gt;Say&amp;lt;/button&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过jQuery实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;!-- 约束声明 --&amp;gt;
&amp;lt;html lang=&quot;zh&quot;&amp;gt;&amp;lt;!--html表示html开始，lang=zh表示中文，分为head和body--&amp;gt;
&amp;lt;head&amp;gt;&amp;lt;!--头部信息，一般包含title，css，js--&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;&amp;lt;!--字符集--&amp;gt;
    &amp;lt;title&amp;gt;标题&amp;lt;/title&amp;gt;&amp;lt;!--标题区域--&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot; src=&quot;jquery-3.7.1.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
        $(function() {//表示onload事件
            var $button = $(&quot;#button&quot;);
            $button.click(function() {//绑定单击事件
                alert(&quot;Hello&quot;);
            });
        });
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;&amp;lt;!--主体内容--&amp;gt;
    &amp;lt;button id=&quot;button&quot;&amp;gt;Say&amp;lt;/button&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;$是一个函数&lt;/p&gt;
&lt;p&gt;对于框架而言jquery-3.7.1.min.js一般用于部署（快速，小），而jquery-3.7.1.js用于开发（可以方便看源码）&lt;/p&gt;
&lt;p&gt;使用jQuery查询标签对象，使用标签对象.click绑定函数&lt;/p&gt;
&lt;h3&gt;核心函数&lt;/h3&gt;
&lt;p&gt;$是jQuery核心函数，可以完成jQuery很多功能&lt;/p&gt;
&lt;p&gt;而$()就是在调用这个函数，根据传入的不同参数，实现不同的功能，以下是常见的使用方式&lt;/p&gt;
&lt;p&gt;1.当传入函数的时候，功能相当于window.onload = function() {}，在文档加载完毕后自动调用函数&lt;/p&gt;
&lt;p&gt;注意这里在加载的时间略微有区别，$内容在页面加载完毕的时候立马执行，但是原生的window.onload = function() {}还要等待标签显示内容显示完成后（例如来自网络中的图片）才会执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    $(function() {alert(&quot;jQuery&quot;)});
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.当传入HTML字符串的时候，会对我们创建这个html标签对象&lt;/p&gt;
&lt;p&gt;通过appendTo将字符串化为html标签对象添加到body，实现拼接，而非逐层添加&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;!-- 约束声明 --&amp;gt;
&amp;lt;html lang=&quot;zh&quot;&amp;gt;&amp;lt;!--html表示html开始，lang=zh表示中文，分为head和body--&amp;gt;
&amp;lt;head&amp;gt;&amp;lt;!--头部信息，一般包含title，css，js--&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;&amp;lt;!--字符集--&amp;gt;
    &amp;lt;title&amp;gt;标题&amp;lt;/title&amp;gt;&amp;lt;!--标题区域--&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot; src=&quot;jquery-3.7.1.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
        $(function() {
           $(&quot;&amp;lt;div&amp;gt;&quot;
               + &quot;&amp;lt;span&amp;gt;div-span1&amp;lt;/span&amp;gt;&quot;
               + &quot;&amp;lt;span&amp;gt;div-span2&amp;lt;/span&amp;gt;&quot;
               + &quot;&amp;lt;div&amp;gt;&quot;).appendTo(&quot;body&quot;);
        });
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;&amp;lt;!--主体内容--&amp;gt;
    &amp;lt;div&amp;gt;
        &amp;lt;span&amp;gt;div-span1&amp;lt;/span&amp;gt;
        &amp;lt;span&amp;gt;div-span2&amp;lt;/span&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.传入选择器字符串&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(&quot;#id 属性值&quot;);
$(&quot;标签名&quot;);
$(&quot;.class 属性值&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;!-- 约束声明 --&amp;gt;
&amp;lt;html lang=&quot;zh&quot;&amp;gt;&amp;lt;!--html表示html开始，lang=zh表示中文，分为head和body--&amp;gt;
&amp;lt;head&amp;gt;&amp;lt;!--头部信息，一般包含title，css，js--&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;&amp;lt;!--字符集--&amp;gt;
    &amp;lt;title&amp;gt;标题&amp;lt;/title&amp;gt;&amp;lt;!--标题区域--&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot; src=&quot;jquery-3.7.1.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
        $(function() {
           var length = $(&quot;div&quot;).length;
           alert(length);
        });
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;&amp;lt;!--主体内容--&amp;gt;
    &amp;lt;div&amp;gt;
        &amp;lt;span&amp;gt;div-span1&amp;lt;/span&amp;gt;
        &amp;lt;span&amp;gt;div-span2&amp;lt;/span&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.传入DOM对象，会将DOM对象转化为jQuery对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    $(function() {
       var Obj = document.getElementById(&quot;test&quot;);
       $Obj = $(Obj);
       $Obj.click(function() {
          alert(&quot;test&quot;);
       });
    });
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以使用jQuery对象的方法，例如绑定单击&lt;/p&gt;
&lt;p&gt;jQuery对象的本质其实是数组，其中存放的是DOM对象，可以通过访问数组的方式取出DOM对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$Obj = $(Obj);
var DOM = $Obj[0];
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;jQuery选择器&lt;/h3&gt;
&lt;h4&gt;基础选择器&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#ID
.class
element
*
selector1,selector2,selector3...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;p.class表示要符合同时满足标签名和class名，使用上大体和css那部分相同&lt;/p&gt;
&lt;h4&gt;层级选择器&lt;/h4&gt;
&lt;p&gt;取标签下的所有对应标签&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(&quot;form input&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;找到forn标签下的所有input标签&lt;/p&gt;
&lt;p&gt;取标签下的所有子标签（不算孙子节点）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(&quot;form&amp;gt;input&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;取标签后面的对应标签（同一级别）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(&quot;form+input&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;取标签后面所有的对应标签（同一级别）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(&quot;form~input&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;基本过滤选择器&lt;/h4&gt;
&lt;p&gt;first&lt;/p&gt;
&lt;p&gt;筛选出集合中的第一个&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;ul&amp;gt;
    &amp;lt;li&amp;gt;1&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;2&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;3&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;4&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    $(function() {
       alert($(&quot;li:first&quot;).text());
    });
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查询到的结果是1，过滤出第一个li标签&lt;/p&gt;
&lt;p&gt;not(selector)&lt;/p&gt;
&lt;p&gt;除去集合中满足selector的元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    $(function() {
       alert($(&quot;li:not(:first)&quot;).text());
    });
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果为234&lt;/p&gt;
&lt;p&gt;even&lt;/p&gt;
&lt;p&gt;匹配索引值位偶数的标签&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    $(function() {
       alert($(&quot;li:even&quot;).text());
    });
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果为13&lt;/p&gt;
&lt;p&gt;odd&lt;/p&gt;
&lt;p&gt;匹配索引值位奇数的标签&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    $(function() {
       alert($(&quot;li:odd&quot;).text());
    });
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;24&lt;/p&gt;
&lt;p&gt;gt(index)&lt;/p&gt;
&lt;p&gt;大于索引的标签&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    $(function() {
       alert($(&quot;li:gt(0)&quot;).text());
    });
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果为234&lt;/p&gt;
&lt;p&gt;lt(index)&lt;/p&gt;
&lt;p&gt;小于索引的标签&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    $(function() {
       alert($(&quot;li:lt(1)&quot;).text());
    });
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果为1&lt;/p&gt;
&lt;p&gt;head：标题元素&lt;/p&gt;
&lt;p&gt;animated：正在执行动画的元素&lt;/p&gt;
&lt;p&gt;eq(Index)：等于对应索引的元素&lt;/p&gt;
&lt;h4&gt;内容过滤器&lt;/h4&gt;
&lt;p&gt;contain(text)：匹配包含对应text的元素&lt;/p&gt;
&lt;p&gt;empty：匹配不包含text的元素（为空）&lt;/p&gt;
&lt;p&gt;has(selector)：匹配含有选择器匹配的元素的元素（外层元素）&lt;/p&gt;
&lt;p&gt;parent：匹配含有子元素或者文本的元素（非空）&lt;/p&gt;
&lt;h4&gt;属性过滤器&lt;/h4&gt;
&lt;p&gt;div[id]：含有id的div&lt;/p&gt;
&lt;p&gt;div[id=123]：含有id为123的div&lt;/p&gt;
&lt;p&gt;div[id!=123]：含有id不为123的div&lt;/p&gt;
&lt;p&gt;div[id^=123]：含有id且id为123开头的div&lt;/p&gt;
&lt;p&gt;div[id$=123]：含有id且id为123结尾的div&lt;/p&gt;
&lt;p&gt;div[id*=123]：含有id且id包含123的div&lt;/p&gt;
&lt;p&gt;复合选择器：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;input[id=123][name=&apos;hello&apos;][class=.myclass]
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;表单过滤器&lt;/h4&gt;
&lt;p&gt;input：匹配所有的input，extarea，select，button元素&lt;/p&gt;
&lt;p&gt;以下都是其匹配对应表单的对应type的标签元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;text：
password：
radio：
checkbox：
submit：
image：
reset：
button：
file：
hidden：
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;enabled：匹配可用的元素&lt;/p&gt;
&lt;p&gt;disabled：匹配不可用的元素（加上disabled=&quot;disabled&quot;元素）&lt;/p&gt;
&lt;p&gt;checked：匹配所有选中的checkbox元素&lt;/p&gt;
&lt;p&gt;selected：匹配选中的option元素&lt;/p&gt;
&lt;h4&gt;元素的筛选&lt;/h4&gt;
&lt;p&gt;大体上和Stream流处理的方式类似，在jQuery中其实就是将 :first  换了一种方式使用  .first()&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(#123:fist)
$(#123).first();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你学过流式处理的话其实还是很熟悉的，这里就不再记录笔记了，等碰到不会的根据需求即查即用&lt;/p&gt;
&lt;h3&gt;属性操作&lt;/h3&gt;
&lt;h4&gt;html&lt;/h4&gt;
&lt;p&gt;设置和获取其实标签和结束标签中的内容，和innerHTML一致&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;!-- 约束声明 --&amp;gt;
&amp;lt;html lang=&quot;zh&quot;&amp;gt;&amp;lt;!--html表示html开始，lang=zh表示中文，分为head和body--&amp;gt;
&amp;lt;head&amp;gt;&amp;lt;!--头部信息，一般包含title，css，js--&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;&amp;lt;!--字符集--&amp;gt;
    &amp;lt;title&amp;gt;标题&amp;lt;/title&amp;gt;&amp;lt;!--标题区域--&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot; src=&quot;jquery-3.7.1.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
        $(function() {
            alert($(&quot;div&quot;).html());
        });
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;&amp;lt;!--主体内容--&amp;gt;
    &amp;lt;div&amp;gt;div标签&amp;lt;/div&amp;gt;
    &amp;lt;span&amp;gt;span标签&amp;lt;/span&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;$(function() {
    $(&quot;div&quot;).html(&quot;&amp;lt;h1&amp;gt;重设值&amp;lt;/h1&amp;gt;&quot;)
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;传入值代表设置值，而不传参数代表获取&lt;/p&gt;
&lt;h4&gt;text&lt;/h4&gt;
&lt;p&gt;设置和获取其实标签和结束标签中的文本，和innerText一致&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(function() {
    $(&quot;div&quot;).text(&quot;text&quot;);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;val&lt;/h4&gt;
&lt;p&gt;设置和获取表单项的value属性值，和dom中的balue一致val&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;!-- 约束声明 --&amp;gt;
&amp;lt;html lang=&quot;zh&quot;&amp;gt;&amp;lt;!--html表示html开始，lang=zh表示中文，分为head和body--&amp;gt;
&amp;lt;head&amp;gt;&amp;lt;!--头部信息，一般包含title，css，js--&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;&amp;lt;!--字符集--&amp;gt;
    &amp;lt;title&amp;gt;标题&amp;lt;/title&amp;gt;&amp;lt;!--标题区域--&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot; src=&quot;jquery-3.7.1.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
        $(function() {
            var $btn = $(&quot;#btn&quot;);
            $btn.click(function() {
                alert($(&quot;#input&quot;).val());
            });
        });
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;&amp;lt;!--主体内容--&amp;gt;
    &amp;lt;div&amp;gt;div标签&amp;lt;/div&amp;gt;
    &amp;lt;input type=&quot;text&quot; id=&quot;input&quot;/&amp;gt;
    &amp;lt;button id=&quot;btn&quot;&amp;gt;click&amp;lt;/button&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;多选框中设置选中可以使用$().val([&quot;num1&quot;,&quot;num2&quot;])&lt;/p&gt;
&lt;h4&gt;attr&lt;/h4&gt;
&lt;p&gt;设置或者获取属性值，不推荐操作checked，readOnly，selected，disabled&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(function() {
    var attr = $(&quot;#input&quot;).attr(&quot;name&quot;);
    alert(attr);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;$(function() {
    $(&quot;#input&quot;).attr(&quot;name&quot;,&quot;another&quot;);
    var attr = $(&quot;#input&quot;).attr(&quot;name&quot;);
    alert(attr);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;prop&lt;/h4&gt;
&lt;p&gt;设置或者获取属性值，使用时建议与attr互补&lt;/p&gt;
&lt;p&gt;当一个标签没有name的时候查询属性值会返回undifined，我们可以使用prop返回更为直观的false和true&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;!-- 约束声明 --&amp;gt;
&amp;lt;html lang=&quot;zh&quot;&amp;gt;&amp;lt;!--html表示html开始，lang=zh表示中文，分为head和body--&amp;gt;
&amp;lt;head&amp;gt;&amp;lt;!--头部信息，一般包含title，css，js--&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;&amp;lt;!--字符集--&amp;gt;
    &amp;lt;title&amp;gt;标题&amp;lt;/title&amp;gt;&amp;lt;!--标题区域--&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot; src=&quot;jquery-3.7.1.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
        $(function() {
            $(&quot;#btn&quot;).click(function() {
               var prop = $(&quot;#check&quot;).prop(&quot;checked&quot;);
               alert(prop);
            });
        });
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;&amp;lt;!--主体内容--&amp;gt;
    &amp;lt;input id=&quot;check&quot; type=&quot;checkbox&quot;/&amp;gt;
    &amp;lt;button id=&quot;btn&quot;&amp;gt;check&amp;lt;/button&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;增删改&lt;/h3&gt;
&lt;h4&gt;添加&lt;/h4&gt;
&lt;p&gt;appendTo(content)：将调用者插入到content的最后一个子元素之后&lt;/p&gt;
&lt;p&gt;prependTo(content)：将调用者插入到content的最前一个子元素之前&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(function() {
    $(&quot;&amp;lt;h1&amp;gt;h1&amp;lt;h1/&amp;gt;&quot;).appendTo(&quot;body&quot;);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;外部插入&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;a.insertAfter(b);//得到da
a.insertBefore(b);//得到ab
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;替换&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;a.replaceWith(b);//用b替换掉a
a.replaceAll(b);//用a替换所有的b
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;删除&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;a.remove();//清除a标签
a.empty();//清除a标签中的内容
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;!-- 约束声明 --&amp;gt;
&amp;lt;html lang=&quot;zh&quot;&amp;gt;&amp;lt;!--html表示html开始，lang=zh表示中文，分为head和body--&amp;gt;
&amp;lt;head&amp;gt;&amp;lt;!--头部信息，一般包含title，css，js--&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;&amp;lt;!--字符集--&amp;gt;
    &amp;lt;title&amp;gt;标题&amp;lt;/title&amp;gt;&amp;lt;!--标题区域--&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot; src=&quot;jquery-3.7.1.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
        $(function() {
            $(&quot;#btn1&quot;).click(function() {
                $(&quot;#select1 option:selected&quot;).appendTo($(&quot;#select2&quot;));
            });
            $(&quot;#btn2&quot;).click(function() {
                $(&quot;#select1 option:selected&quot;).appendTo($(&quot;#select2&quot;));
            });
        });
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;&amp;lt;!--主体内容--&amp;gt;
    &amp;lt;select id=&quot;select1&quot; multiple=&quot;multiple&quot;&amp;gt;
        &amp;lt;option value=&quot;1&quot;&amp;gt;1&amp;lt;/option&amp;gt;
        &amp;lt;option value=&quot;2&quot;&amp;gt;2&amp;lt;/option&amp;gt;
        &amp;lt;option value=&quot;3&quot;&amp;gt;3&amp;lt;/option&amp;gt;
        &amp;lt;option value=&quot;4&quot;&amp;gt;4&amp;lt;/option&amp;gt;
        &amp;lt;option value=&quot;5&quot;&amp;gt;5&amp;lt;/option&amp;gt;
    &amp;lt;/select&amp;gt;
    &amp;lt;select id=&quot;select2&quot; multiple=&quot;multiple&quot;&amp;gt;
        &amp;lt;option value=&quot;6&quot;&amp;gt;6&amp;lt;/option&amp;gt;
        &amp;lt;option value=&quot;7&quot;&amp;gt;7&amp;lt;/option&amp;gt;
        &amp;lt;option value=&quot;8&quot;&amp;gt;8&amp;lt;/option&amp;gt;
        &amp;lt;option value=&quot;9&quot;&amp;gt;9&amp;lt;/option&amp;gt;
        &amp;lt;option value=&quot;10&quot;&amp;gt;10&amp;lt;/option&amp;gt;
    &amp;lt;/select&amp;gt;&amp;lt;br/&amp;gt;
    &amp;lt;button id=&quot;btn1&quot;&amp;gt;1&amp;lt;/button&amp;gt;
    &amp;lt;button id=&quot;btn2&quot;&amp;gt;2&amp;lt;/button&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;美化操作&lt;/h3&gt;
&lt;h4&gt;CSS样式&lt;/h4&gt;
&lt;p&gt;addClass：添加样式&lt;/p&gt;
&lt;p&gt;removeClass：移除样式&lt;/p&gt;
&lt;p&gt;toggleClass：有就删除样式，没有就添加样式&lt;/p&gt;
&lt;p&gt;offset：获取或者设置坐标&lt;/p&gt;
&lt;p&gt;以下是ai生成的网页，便于对比理解&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;zh-CN&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
    &amp;lt;title&amp;gt;jQuery 类与坐标操作示例&amp;lt;/title&amp;gt;
    &amp;lt;script src=&quot;jquery-3.7.1.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;style&amp;gt;
        .box {
            width: 100px;
            height: 100px;
            background-color: #3498db;
            margin: 20px;
            position: relative;
            transition: all 0.3s ease;
        }

        .highlight {
            background-color: #e74c3c;
            border: 3px solid #f1c40f;
            transform: scale(1.1);
        }

        .rounded {
            border-radius: 50%;
        }

        .shadow {
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        button {
            margin: 5px;
            padding: 8px 15px;
            cursor: pointer;
        }

        .info {
            margin-top: 20px;
            padding: 10px;
            background-color: #f9f9f9;
            border: 1px solid #ddd;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h1&amp;gt;jQuery 类与坐标操作示例&amp;lt;/h1&amp;gt;

&amp;lt;div class=&quot;box&quot; id=&quot;targetBox&quot;&amp;gt;可操作的盒子&amp;lt;/div&amp;gt;

&amp;lt;div&amp;gt;
    &amp;lt;button id=&quot;addHighlight&quot;&amp;gt;添加高亮样式&amp;lt;/button&amp;gt;
    &amp;lt;button id=&quot;removeHighlight&quot;&amp;gt;移除高亮样式&amp;lt;/button&amp;gt;
    &amp;lt;button id=&quot;toggleRounded&quot;&amp;gt;切换圆形样式&amp;lt;/button&amp;gt;
    &amp;lt;button id=&quot;toggleShadow&quot;&amp;gt;切换阴影样式&amp;lt;/button&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;div&amp;gt;
    &amp;lt;button id=&quot;getOffset&quot;&amp;gt;获取坐标&amp;lt;/button&amp;gt;
    &amp;lt;button id=&quot;setOffset&quot;&amp;gt;设置新坐标(右移50px)&amp;lt;/button&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;div class=&quot;info&quot; id=&quot;offsetInfo&quot;&amp;gt;
    坐标信息将显示在这里
&amp;lt;/div&amp;gt;

&amp;lt;script&amp;gt;
    $(document).ready(function() {
        // 添加类
        $(&quot;#addHighlight&quot;).click(function() {
            $(&quot;#targetBox&quot;).addClass(&quot;highlight&quot;);
            updateOffsetInfo();
        });

        // 移除类
        $(&quot;#removeHighlight&quot;).click(function() {
            $(&quot;#targetBox&quot;).removeClass(&quot;highlight&quot;);
            updateOffsetInfo();
        });

        // 切换类
        $(&quot;#toggleRounded&quot;).click(function() {
            $(&quot;#targetBox&quot;).toggleClass(&quot;rounded&quot;);
            updateOffsetInfo();
        });

        // 切换另一个类
        $(&quot;#toggleShadow&quot;).click(function() {
            $(&quot;#targetBox&quot;).toggleClass(&quot;shadow&quot;);
        });

        // 获取偏移坐标
        $(&quot;#getOffset&quot;).click(function() {
            updateOffsetInfo();
        });

        // 设置新坐标
        $(&quot;#setOffset&quot;).click(function() {
            var currentOffset = $(&quot;#targetBox&quot;).offset();
            $(&quot;#targetBox&quot;).offset({
                top: currentOffset.top,
                left: currentOffset.left + 50
            });
            updateOffsetInfo();
        });

        // 更新坐标信息显示
        function updateOffsetInfo() {
            var offset = $(&quot;#targetBox&quot;).offset();
            var classes = $(&quot;#targetBox&quot;).attr(&quot;class&quot;) || &quot;无&quot;;
            $(&quot;#offsetInfo&quot;).html(
                `当前坐标: top=${offset.top}px, left=${offset.left}px&amp;lt;br&amp;gt;
                     当前类: ${classes}`
            );
        }

        // 初始化显示坐标信息
        updateOffsetInfo();
    });
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;jQuery动画&lt;/h4&gt;
&lt;p&gt;show：显示，还可以传入显式的时间&lt;/p&gt;
&lt;p&gt;hide：将元素隐藏&lt;/p&gt;
&lt;p&gt;toggle：显示/隐藏，取决于隐藏/显示&lt;/p&gt;
&lt;p&gt;fadeIn：淡入&lt;/p&gt;
&lt;p&gt;fadeOut：淡出&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;zh-CN&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
    &amp;lt;title&amp;gt;jQuery 动画效果示例&amp;lt;/title&amp;gt;
    &amp;lt;script src=&quot;jquery-3.7.1.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;style&amp;gt;
        .box {
            width: 200px;
            height: 200px;
            background-color: #3498db;
            margin: 20px;
            padding: 20px;
            color: white;
            text-align: center;
            line-height: 200px;
            font-size: 20px;
            border-radius: 10px;
        }

        .controls {
            margin: 20px;
            padding: 15px;
            background-color: #f5f5f5;
            border-radius: 5px;
        }

        button {
            margin: 5px;
            padding: 10px 15px;
            cursor: pointer;
            background-color: #2ecc71;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 14px;
        }

        button:hover {
            background-color: #27ae60;
        }

        .speed-control {
            margin-top: 15px;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h1&amp;gt;jQuery 动画效果演示&amp;lt;/h1&amp;gt;

&amp;lt;div class=&quot;controls&quot;&amp;gt;
    &amp;lt;h2&amp;gt;基本显示/隐藏&amp;lt;/h2&amp;gt;
    &amp;lt;button id=&quot;btnShow&quot;&amp;gt;显示 (show)&amp;lt;/button&amp;gt;
    &amp;lt;button id=&quot;btnHide&quot;&amp;gt;隐藏 (hide)&amp;lt;/button&amp;gt;
    &amp;lt;button id=&quot;btnToggle&quot;&amp;gt;切换 (toggle)&amp;lt;/button&amp;gt;

    &amp;lt;div class=&quot;speed-control&quot;&amp;gt;
        动画速度：
        &amp;lt;select id=&quot;speedBasic&quot;&amp;gt;
            &amp;lt;option value=&quot;fast&quot;&amp;gt;快速&amp;lt;/option&amp;gt;
            &amp;lt;option value=&quot;normal&quot; selected&amp;gt;正常&amp;lt;/option&amp;gt;
            &amp;lt;option value=&quot;slow&quot;&amp;gt;慢速&amp;lt;/option&amp;gt;
            &amp;lt;option value=&quot;1000&quot;&amp;gt;1秒&amp;lt;/option&amp;gt;
            &amp;lt;option value=&quot;2000&quot;&amp;gt;2秒&amp;lt;/option&amp;gt;
        &amp;lt;/select&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;div class=&quot;box&quot; id=&quot;box1&quot;&amp;gt;显示/隐藏动画效果&amp;lt;/div&amp;gt;

&amp;lt;div class=&quot;controls&quot;&amp;gt;
    &amp;lt;h2&amp;gt;淡入淡出效果&amp;lt;/h2&amp;gt;
    &amp;lt;button id=&quot;btnFadeIn&quot;&amp;gt;淡入 (fadeIn)&amp;lt;/button&amp;gt;
    &amp;lt;button id=&quot;btnFadeOut&quot;&amp;gt;淡出 (fadeOut)&amp;lt;/button&amp;gt;
    &amp;lt;button id=&quot;btnFadeToggle&quot;&amp;gt;淡入淡出切换&amp;lt;/button&amp;gt;

    &amp;lt;div class=&quot;speed-control&quot;&amp;gt;
        动画速度：
        &amp;lt;select id=&quot;speedFade&quot;&amp;gt;
            &amp;lt;option value=&quot;fast&quot;&amp;gt;快速&amp;lt;/option&amp;gt;
            &amp;lt;option value=&quot;normal&quot; selected&amp;gt;正常&amp;lt;/option&amp;gt;
            &amp;lt;option value=&quot;slow&quot;&amp;gt;慢速&amp;lt;/option&amp;gt;
            &amp;lt;option value=&quot;1500&quot;&amp;gt;1.5秒&amp;lt;/option&amp;gt;
            &amp;lt;option value=&quot;3000&quot;&amp;gt;3秒&amp;lt;/option&amp;gt;
        &amp;lt;/select&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;div class=&quot;box&quot; id=&quot;box2&quot;&amp;gt;淡入淡出动画效果&amp;lt;/div&amp;gt;

&amp;lt;script&amp;gt;
    $(document).ready(function() {
        // 基本显示/隐藏控制
        $(&quot;#btnShow&quot;).click(function() {
            $(&quot;#box1&quot;).show($(&quot;#speedBasic&quot;).val());
        });

        $(&quot;#btnHide&quot;).click(function() {
            $(&quot;#box1&quot;).hide($(&quot;#speedBasic&quot;).val());
        });

        $(&quot;#btnToggle&quot;).click(function() {
            $(&quot;#box1&quot;).toggle($(&quot;#speedBasic&quot;).val());
        });

        // 淡入淡出控制
        $(&quot;#btnFadeIn&quot;).click(function() {
            $(&quot;#box2&quot;).fadeIn($(&quot;#speedFade&quot;).val());
        });

        $(&quot;#btnFadeOut&quot;).click(function() {
            $(&quot;#box2&quot;).fadeOut($(&quot;#speedFade&quot;).val());
        });

        $(&quot;#btnFadeToggle&quot;).click(function() {
            $(&quot;#box2&quot;).fadeToggle($(&quot;#speedFade&quot;).val());
        });

        // 初始化隐藏第二个盒子
        $(&quot;#box2&quot;).hide();
    });
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;事件处理&lt;/h3&gt;
&lt;p&gt;在使用上和JS差不多，加了更多的常用事件&lt;/p&gt;
&lt;h4&gt;常用的绑定方法&lt;/h4&gt;
&lt;p&gt;click：绑定单机事件以及触发的事件&lt;/p&gt;
&lt;p&gt;mouseover：鼠标移入事件&lt;/p&gt;
&lt;p&gt;bind：给元素一次性绑定一个或者多个事件&lt;/p&gt;
&lt;p&gt;one：和bind类似，但是只会触发一次&lt;/p&gt;
&lt;p&gt;live：用于绑定事件，可以绑定与选择其匹配的所有元素的事件，即使是动态创建后的元素&lt;/p&gt;
&lt;p&gt;unbind：和bind相反，解除事件绑定&lt;/p&gt;
&lt;h4&gt;冒泡&lt;/h4&gt;
&lt;p&gt;如果子元素和父元素都绑定了同一事件，当子元素被触发时，父元素也会响应，如果需要阻止则在子元素处理中返回false即可&lt;/p&gt;
&lt;h4&gt;事件对象&lt;/h4&gt;
&lt;p&gt;是封装有触发事件信息的一个JavaScript对象&lt;/p&gt;
&lt;p&gt;在给元素绑定事件的时候，在事件的function(event)参数列表中添加一个参数，这个event就是JavaScript传递参数事件处理函数的事件对象，其中包含了一些事件响应的信息&lt;/p&gt;
&lt;p&gt;有的时候需要使用到事件对象中的内容，例如获取当前操作是什么事件，并将事件打印出来&lt;/p&gt;
&lt;h2&gt;XML&lt;/h2&gt;
&lt;p&gt;xml是可扩展的标记性语言，用于保存数据，而且这些数据具有自我描述性，还可以作为项目的配置文件，另外还可以作为网络传输数据的格式（不过现在常使用json）&lt;/p&gt;
&lt;h3&gt;语法规则&lt;/h3&gt;
&lt;p&gt;XML元素命名规则：名称可以含有数字，字母，其他字符。名称不可以以数字，标点符号开始。名称不可以以xml开始。名称不可以包含空格&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;book sn=&quot;1124&quot;&amp;gt;
        &amp;lt;name&amp;gt;C++&amp;lt;/name&amp;gt;
        &amp;lt;author&amp;gt;汉顺&amp;lt;/author&amp;gt;
        &amp;lt;price&amp;gt;16&amp;lt;/price&amp;gt;
&amp;lt;/book&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;分为单标签和双标签，和html类似，写的时候建议闭合&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;br/&amp;gt;
&amp;lt;book&amp;gt;&amp;lt;/book&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;属性：和html类似，提供额外的信息给元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;book name=&quot;123&quot; id=&quot;123&quot; function=&quot;123&quot;&amp;gt;&amp;lt;/book&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;文档必须有唯一根元素，即没有父标签的元素，例如示例中的books标签&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;
&amp;lt;books&amp;gt;
    &amp;lt;book sn=&quot;1123&quot;&amp;gt;
        &amp;lt;name&amp;gt;时间简史&amp;lt;/name&amp;gt;&amp;lt;!--书名--&amp;gt;
        &amp;lt;author&amp;gt;霍金&amp;lt;/author&amp;gt;
        &amp;lt;price&amp;gt;15&amp;lt;/price&amp;gt;
    &amp;lt;/book&amp;gt;
    &amp;lt;book sn=&quot;1124&quot;&amp;gt;
        &amp;lt;name&amp;gt;C++&amp;lt;/name&amp;gt;
        &amp;lt;author&amp;gt;汉顺&amp;lt;/author&amp;gt;
        &amp;lt;price&amp;gt;16&amp;lt;/price&amp;gt;
    &amp;lt;/book&amp;gt;
&amp;lt;/books&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;文本区域：不会解析其中xml格式的内容（CDATA）&lt;/p&gt;
&lt;p&gt;格式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;![CDATA[内容部分，这个部分不会被解析]]&amp;gt;
&amp;lt;author&amp;gt;&amp;lt;![CDATA[内容部分，这个部分不会被解析]]&amp;gt;&amp;lt;/author&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;XML解析&lt;/h3&gt;
&lt;p&gt;无论是html文件还是xml文件都是标记型文档都可以使解析取出操作内容&lt;/p&gt;
&lt;h4&gt;常见的解析技术&lt;/h4&gt;
&lt;p&gt;DOM解析：标签在dom解析的时候生成各个对象，并以树形的格式连接&lt;/p&gt;
&lt;p&gt;SAX解析：这种解析方式可以一行一行读取xml文件，不会创建大量的dom对象，性能和内存都优于dom解析&lt;/p&gt;
&lt;p&gt;第三方解析：jdom在dom基础上封装，dom4j对jdom封装。pull主要用于安卓手机开发，和sax类似，是事件机制解析xml文件&lt;/p&gt;
&lt;h4&gt;dom4解析技术&lt;/h4&gt;
&lt;p&gt;引入dom4 jar包，添加到类库，以下是一个实例代码，获取document对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com;

import org.dom4j.*;
import java.util.List;

public class Main {
    public static void main(String[] args) throws DocumentException {
        SAXReader reader = new SAXReader();
        Document document = reader.read(&quot;xml/test.xml&quot;);
        Element rootElement = document.getRootElement();
        //获取根标签对象
        List&amp;lt;Element&amp;gt; books = rootElement.elements(&quot;book&quot;);
        //通过根标签对象获取book子标签对象list集合
        for (Element book : books) {
            Element name = book.element(&quot;name&quot;);
            //取出book标签的name子标签对象
            System.out.println(name.asXML());
            //调用name标签对象的asXML输出标签+内容
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;name&amp;gt;时间简史&amp;lt;/name&amp;gt;
&amp;lt;name&amp;gt;C++&amp;lt;/name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其他常见的方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;getText();//获取dom对象的内容
elementText(&quot;targetName&quot;);//获取子标签的内容
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;jQuery的学习时间拉的有点长了，明天会进入tomcat与servlet的学习&lt;/p&gt;
</content:encoded></item><item><title>JavaWeb笔记（JavaScript）</title><link>https://thrinisty.github.io/posts/javaweb%E7%AC%94%E8%AE%B0javascript%E4%BA%8B%E4%BB%B6dom%E6%A8%A1%E5%9E%8B/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/javaweb%E7%AC%94%E8%AE%B0javascript%E4%BA%8B%E4%BB%B6dom%E6%A8%A1%E5%9E%8B/</guid><description>JavaScript事件，DOM模型</description><pubDate>Sat, 26 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;JavaWeb笔记&lt;/h1&gt;
&lt;h2&gt;JavaScript事件&lt;/h2&gt;
&lt;h3&gt;事件定义&lt;/h3&gt;
&lt;p&gt;事件是电脑输入设备与页面进行交互的响应，称之为事件，如点击滑动，长按等，一下是常用的事件&lt;/p&gt;
&lt;p&gt;onload 加载完成事件（页面代码初始化）&lt;/p&gt;
&lt;p&gt;onclick 点击事件（按钮点击响应操作）&lt;/p&gt;
&lt;p&gt;onblur 失去焦点事件（用于输入框去焦点后验证输入内容是否合法）&lt;/p&gt;
&lt;p&gt;onchange 内容发送改变事件（常用于下拉列表和输入框内容发送改变后）&lt;/p&gt;
&lt;p&gt;onsubmit 表单提交事件（常用于表单提交后验证表单合法性）&lt;/p&gt;
&lt;h3&gt;事件注册&lt;/h3&gt;
&lt;p&gt;定义：又称为绑定，告诉浏览器，事件响应后需要执行的操作代码，又分为静态注册和动态注册&lt;/p&gt;
&lt;p&gt;静态注册：通过html标签的时间属性直接赋予事件响应后的代码&lt;/p&gt;
&lt;p&gt;动态注册：先通过js代码得到dom对象，再通过dom对象.事件名称=function(){}这种形式赋予事件响应后的代码。其基本的步骤为  1.获取标签对象  2.标签对象.事件名称 = function() {}&lt;/p&gt;
&lt;h3&gt;常用事件&lt;/h3&gt;
&lt;h4&gt;onload&lt;/h4&gt;
&lt;p&gt;表单初始化事件&lt;/p&gt;
&lt;p&gt;静态注册示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;JavaScript&amp;lt;/title&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
        function onLoadFun() {
            alert(&apos;静态注册&apos;);
        }
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body onload=&quot;onLoadFun();&quot;&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;动态注册实例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;JavaScript&amp;lt;/title&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
        window.onload = function() {
            alert(&quot;动态注册&quot;);
        }
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;onclick&lt;/h4&gt;
&lt;p&gt;按钮1为静态注册&lt;/p&gt;
&lt;p&gt;按钮2为动态注册：获取标签对象，通过标签对象.事件名称 = function(){}&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;JavaScript&amp;lt;/title&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
        function onclickFun() {
            alert(&quot;Hello World&quot;);
        }

        window.onload = function() {
            var obj = document.getElementById(&quot;Button&quot;);
            obj.onclick = onclickFun;
        }
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;button onclick=&quot;onclickFun()&quot;&amp;gt;按钮1&amp;lt;/button&amp;gt;
    &amp;lt;button id=&quot;Button&quot;&amp;gt;按钮2&amp;lt;/button&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;onblur&lt;/h4&gt;
&lt;p&gt;失去焦点：常用于输入框&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;JavaScript&amp;lt;/title&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
        function funOnblur(){
            //console是控制台对象，用于向浏览器控制台打印
            console.log(&quot;静态注册失去焦点事件&quot;);
        }
        window.onload = function() {
            var obj = document.getElementById(&quot;password&quot;);
            obj.onblur = function(){
                console.log(&quot;动态注册失去焦点事件&quot;);
            }
        }
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
用户名：&amp;lt;input type=&quot;text&quot; onblur=&quot;funOnblur();&quot;&amp;gt;&amp;lt;br/&amp;gt;
密 码：&amp;lt;input id=&quot;password&quot; type=&quot;text&quot;&amp;gt;&amp;lt;br/&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;onchange&lt;/h4&gt;
&lt;p&gt;内容改变：常用于下拉列表，和输入框&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;JavaScript&amp;lt;/title&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
        function funOnChange(){
            //console是控制台对象，用于向浏览器控制台打印
            console.log(&quot;静态注册内容发生更改&quot;);
        }
        window.onload = function() {
            var obj = document.getElementById(&quot;password&quot;);
            obj.onchange = function(){
                console.log(&quot;动态注册内容发生更改&quot;);
            }
        }
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
用户名：&amp;lt;input type=&quot;text&quot; onchange=&quot;funOnChange();&quot;&amp;gt;&amp;lt;br/&amp;gt;
密 码：&amp;lt;input id=&quot;password&quot; type=&quot;text&quot;&amp;gt;&amp;lt;br/&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;onsubmit&lt;/h4&gt;
&lt;p&gt;表单提交事件：用于验证表单项是否合法&lt;/p&gt;
&lt;p&gt;注意当return false的时候不提交，其中在函数中可以加入自己的判断逻辑&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;JavaScript&amp;lt;/title&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
        function funOnSubmit(){
            alert(&quot;表单提交不合法&quot;)
            return false;
        }
        window.onload = function() {
            var obj = document.getElementById(&quot;submit&quot;);
            obj.onsubmit = function(){
                alert(&quot;表单提交不合法&quot;)
                return false;
            }
        }
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;form method=&quot;get&quot; action=&quot;https://www.baidu.com&quot;  onsubmit=&quot;return funOnSubmit();&quot;&amp;gt;
        用户名：&amp;lt;input type=&quot;text&quot;&amp;gt;&amp;lt;br/&amp;gt;
        密 码：&amp;lt;input type=&quot;text&quot;&amp;gt;&amp;lt;br/&amp;gt;
        &amp;lt;input type=&quot;submit&quot; value=&quot;静态注册&quot;/&amp;gt;&amp;lt;br/&amp;gt;
    &amp;lt;/form&amp;gt;
    &amp;lt;form method=&quot;get&quot; action=&quot;https://www.baidu.com&quot; id=&quot;submit&quot;&amp;gt;
        用户名：&amp;lt;input type=&quot;text&quot;&amp;gt;&amp;lt;br/&amp;gt;
        密 码：&amp;lt;input type=&quot;text&quot;&amp;gt;&amp;lt;br/&amp;gt;
        &amp;lt;input type=&quot;submit&quot; value=&quot;静态注册&quot;/&amp;gt;
    &amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;DOM模型&lt;/h2&gt;
&lt;p&gt;Document Object Model文档对象模型&lt;/p&gt;
&lt;p&gt;将文档中的标签，属性，文本，转化为对象来管理&lt;/p&gt;
&lt;h3&gt;Document对象&lt;/h3&gt;
&lt;p&gt;一个html文档被Document对象存储，并交由Document对象管理&lt;/p&gt;
&lt;p&gt;1.Document管理了所有的HTML文档内容&lt;/p&gt;
&lt;p&gt;2.Document是一种树结构的文档，有层级关系&lt;/p&gt;
&lt;p&gt;3.Document使得所有的标签都对象化&lt;/p&gt;
&lt;p&gt;4.我们可以通过Document访问所有的标签对象&lt;/p&gt;
&lt;h3&gt;入门案例&lt;/h3&gt;
&lt;p&gt;验证输入框中内容是否符合某一个形式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;JavaScript&amp;lt;/title&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
        function onclickFunction() {
            var userObj = document.getElementById(&quot;username&quot;);//获取输入框对象
            var value = userObj.value;//获取对象（文本框）数据
            //运用正则表达式判断数据是否合法
            var patt = /^\w{5,12}$/;
            if (!patt.test(value)) {
                Warning.innerHTML = &quot;不合法&quot;
            } else {
                Warning.innerHTML = &quot;合法&quot;
            }
        }
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
        用户名：&amp;lt;input type=&quot;text&quot; id=&quot;username&quot;&amp;gt;
        &amp;lt;span id=&quot;Warning&quot; style=&quot;color: red&quot;&amp;gt;&amp;lt;/span&amp;gt;
        &amp;lt;button onclick=&quot;onclickFunction();&quot;&amp;gt;校验&amp;lt;/button&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;正则表达式&lt;/h3&gt;
&lt;p&gt;以上案例中我们使用到了正则表达式，正则表达式可以为我们判断字符串是否满足某一个模板要求&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    var patt = new RegExp(&quot;e&quot;);//判断是否含有e
    var str = &quot;still&quot;;
    alert(patt.test(str));
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    var patt = /e/;//判断是否含有e
    var str = &quot;still&quot;;
    alert(patt.test(str));
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以下是一些常见的正则表达式，我觉得在这里随用随取即可&lt;/p&gt;
&lt;p&gt;邮箱验证&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/^[^\s@]+@[^\s@]+\.[^\s@]+$/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;手机号验证&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/^1[3-9]\d{9}$/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;身份证号码验证&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/^[1-9]\d{5}(18|19|20)\d{2}(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])\d{3}[\dXx]$/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;URL验证&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;密码验证：包含数字字母至少八位&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/^(?=.*[A-Za-z])(?=.*\d)[A-Za-z\d]{8,}$/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;复杂密码（至少1个大写字母、1个小写字母、1个数字和1个特殊字符，至少8位）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&amp;amp;])[A-Za-z\d@$!%*?&amp;amp;]{8,}$/
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Document相关方法&lt;/h3&gt;
&lt;h4&gt;getElementById&lt;/h4&gt;
&lt;p&gt;通过标签id获取标签对象，注意只获取第一个符合条件的标签对象&lt;/p&gt;
&lt;p&gt;在上面有演示这里不再过多说明&lt;/p&gt;
&lt;h4&gt;getElementsByName&lt;/h4&gt;
&lt;p&gt;通过标签名称获取标签对象，注意返回所有的标签对象，是一个集合&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;JavaScript&amp;lt;/title&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
        function onclickAll() {
            var hobbies = document.getElementsByName(&quot;hobby&quot;);
            for (var i = 0; i &amp;lt; hobbies.length; i++) {
                hobbies[i].checked = true;
            }
        }
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;C++&quot;&amp;gt;C++
    &amp;lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;Java&quot;&amp;gt;Java
    &amp;lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;Python&quot;&amp;gt;Python&amp;lt;br/&amp;gt;
    &amp;lt;button onclick=&quot;onclickAll();&quot;&amp;gt;ALL&amp;lt;/button&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;getElementsByTagName&lt;/h4&gt;
&lt;p&gt;按照标签名获取多个标签对象，返回集合&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;JavaScript&amp;lt;/title&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
        function onclickAll() {
            var hobbies = document.getElementsByTagName(&quot;input&quot;);
            for (var i = 0; i &amp;lt; hobbies.length; i++) {
                hobbies[i].checked = true;
            }
        }
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;input type=&quot;checkbox&quot; value=&quot;C++&quot;&amp;gt;C++
    &amp;lt;input type=&quot;checkbox&quot; value=&quot;Java&quot;&amp;gt;Java
    &amp;lt;input type=&quot;checkbox&quot; value=&quot;Python&quot;&amp;gt;Python&amp;lt;br/&amp;gt;
    &amp;lt;button onclick=&quot;onclickAll();&quot;&amp;gt;ALL&amp;lt;/button&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;注意事项&lt;/h4&gt;
&lt;p&gt;1.以上的三个方法范围从小到大，在实际使用的时候尽量从上到下使用（id，name，Tag）&lt;/p&gt;
&lt;p&gt;2.以上方法需要在页面加载完毕后才可以使用，从上到下依次执行，在没有body加载的时候是没有办法获取得到没有创建的id的&lt;/p&gt;
&lt;h3&gt;节点&lt;/h3&gt;
&lt;p&gt;节点就是标签对象（狭义上讲，程序员可以操作的部分），其中有一些方法供我们使用&lt;/p&gt;
&lt;p&gt;以下是其常用方法和属性&lt;/p&gt;
&lt;h4&gt;方法&lt;/h4&gt;
&lt;p&gt;getElementsByTagName：获取当前节点的指定标签名孩子节点&lt;/p&gt;
&lt;p&gt;appendChild：添加一个子节点，参数是要添加的孩子节点&lt;/p&gt;
&lt;p&gt;createElement&lt;/p&gt;
&lt;p&gt;创建标签对象，再在body中添加子节点标签&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;JavaScript&amp;lt;/title&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
        window.onload = function () {
            var divObj = document.createElement(&quot;div&quot;);
            divObj.innerHTML = &quot;Hello World&quot;;
            document.body.appendChild(divObj);//通过body对象（自动创建调用方法，添加子节点）
        }
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于文本也算是节点对象，我们还可以通过如下的方式加入节点内容&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    window.onload = function () {
        var divObj = document.createElement(&quot;div&quot;);
        var text = document.createTextNode(&quot;Hello World&quot;);
        divObj.appendChild(text);
        document.body.appendChild(divObj);
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;属性&lt;/h4&gt;
&lt;p&gt;childNodes：当前节点的所有子节点&lt;/p&gt;
&lt;p&gt;firstChild：当前节点的第一个子节点&lt;/p&gt;
&lt;p&gt;lastChild：当前节点的最后一个子节点&lt;/p&gt;
&lt;p&gt;parentNode：父节点&lt;/p&gt;
&lt;p&gt;nextSibling：下一个节点&lt;/p&gt;
&lt;p&gt;previousSibling：上一个节点&lt;/p&gt;
&lt;p&gt;className：获取或设置class属性值&lt;/p&gt;
&lt;p&gt;innerText：获取或设置起始标签和结束标签中的文本&lt;/p&gt;
</content:encoded></item><item><title>JavaWeb笔记（前端基础）</title><link>https://thrinisty.github.io/posts/javaweb%E7%AC%94%E8%AE%B0htmlcssjavascript/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/javaweb%E7%AC%94%E8%AE%B0htmlcssjavascript/</guid><description>HTML，CSS，JavaScript</description><pubDate>Fri, 25 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;JavaWeb笔记&lt;/h1&gt;
&lt;p&gt;学习Redis到了Spring集成Jedis客户端那里的时候碰壁了，学习效率奇低，复盘了一下，发现是Maven和SpringBoot没有学习导致了环境上的问题，所以更改一下学习策略，先进行Java各大框架的学习，再使用Redis进行改进，这样也符合正常的学习规律&lt;/p&gt;
&lt;p&gt;首先是JavaWeb的学习，打算分出12天完成&lt;/p&gt;
&lt;p&gt;Java开发流程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/132.png&quot; alt=&quot;132&quot; /&gt;&lt;/p&gt;
&lt;p&gt;页面有三个部分内容组成：内容（html），表现（CSS），行为（JavaScript）&lt;/p&gt;
&lt;p&gt;内容是在页面上可以看到的数据，表现是这些内容在页面上的展示形式（布局颜色大小等），行为是指页面中元素与输入设备交互的响应&lt;/p&gt;
&lt;h2&gt;HTLM&lt;/h2&gt;
&lt;p&gt;Hyper Text Markup Language&lt;/p&gt;
&lt;p&gt;简介&lt;/p&gt;
&lt;p&gt;HTML通过标签来标记显示网页中的各个部分，网页文件本身就是一种文本文件，通过在文本文件中添加标记符，可以告诉浏览器中如何显示其中的内容&lt;/p&gt;
&lt;h3&gt;创建HTML文件&lt;/h3&gt;
&lt;p&gt;1.创建一个Web工程&lt;/p&gt;
&lt;p&gt;2.在工程下创建html文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;!-- 约束声明 --&amp;gt;
&amp;lt;html lang=&quot;zh&quot;&amp;gt;&amp;lt;!--html表示html开始，lang=zh表示中文，分为head和body--&amp;gt;
&amp;lt;head&amp;gt;&amp;lt;!--头部信息，一般包含title，css，js--&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;&amp;lt;!--字符集--&amp;gt;
    &amp;lt;title&amp;gt;标题&amp;lt;/title&amp;gt;&amp;lt;!--标题区域--&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;&amp;lt;!--主体内容--&amp;gt;
    hello world
    你好
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以在IDEA下运行html文件打开网页(html文件不需要编译，只需要浏览器解析即可)&lt;/p&gt;
&lt;p&gt;这里我设置的是edge浏览器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;C:\Program Files (x86)\Microsoft\Edge\Application\msedge
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;../images/133.png&quot; alt=&quot;133&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;标签&lt;/h3&gt;
&lt;p&gt;1.标签的格式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;标签名&amp;gt;封装的数据&amp;lt;/标签名&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.标签名大小写不敏感&lt;/p&gt;
&lt;p&gt;3.标签拥有自己的属性，分为基本属性（修改简单的样式效果）和实践属性（可以直接设置事件响应后的代码）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;body bgcolor=&quot;aqua&quot;&amp;gt;&amp;lt;!--主体内容--&amp;gt;
    hello world
    你好
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;../images/134.png&quot; alt=&quot;134&quot; /&gt;&lt;/p&gt;
&lt;p&gt;4.标签又分为，单标签、双标签&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;br/&amp;gt; &amp;lt;!--换行--&amp;gt;
&amp;lt;hr/&amp;gt; &amp;lt;!--水平线--&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;标签语法&lt;/h3&gt;
&lt;p&gt;标签不可以交叉嵌套&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;1&amp;gt;&amp;lt;2&amp;gt;内容&amp;lt;/2&amp;gt;&amp;lt;/1&amp;gt; &amp;lt;!--正确--&amp;gt;
&amp;lt;1&amp;gt;&amp;lt;2&amp;gt;内容&amp;lt;/1&amp;gt;&amp;lt;/2&amp;gt; &amp;lt;!--错误，但有些浏览器可以解析--&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;标签必须要闭合&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;br/&amp;gt;&amp;lt;!--正确--&amp;gt;
&amp;lt;br&amp;gt;&amp;lt;!--错误--&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;属性必须要有值，属性值必须有“”&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;body bgcolor=&quot;aqua&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注释不可以嵌套&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!--&amp;lt;!----&amp;gt;--&amp;gt;  &amp;lt;!--错误--&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;常用标签&lt;/h3&gt;
&lt;h4&gt;font标签&lt;/h4&gt;
&lt;p&gt;font改变字体颜色，大小，字体&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;/head&amp;gt;
&amp;lt;body onclick=&quot;alert(&apos;警告信息&apos;)&quot;&amp;gt;&amp;lt;!--主体内容--&amp;gt;
&amp;lt;font color=&quot;#a52a2a&quot; face=&quot;宋体&quot; size=&quot;7&quot;&amp;gt;hello world&amp;lt;br/&amp;gt;你好&amp;lt;/font&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;特殊字符&lt;/h4&gt;
&lt;p&gt;如果我们想要在浏览器上显示如下特殊字符&amp;lt;br&amp;gt;则&amp;lt;&amp;gt;会被解析，我们需要使用&amp;amp;lt 与 &amp;amp;gt代替&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;font color=&quot;#a52a2a&quot; face=&quot;宋体&quot; size=&quot;7&quot;&amp;gt;
    你好&amp;lt;br&amp;gt;你好
    你好&amp;amp;lt;br&amp;amp;gt;你好
&amp;lt;/font&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;与此类似的还有html会裁掉，我们需要保留空格，我们需要使用到&amp;amp;nbsp&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;body onclick=&quot;alert(&apos;警告信息&apos;)&quot;&amp;gt;&amp;lt;!--主体内容--&amp;gt;
&amp;lt;font color=&quot;#a52a2a&quot; face=&quot;宋体&quot; size=&quot;7&quot;&amp;gt;
    你好&amp;amp;nbsp;&amp;amp;lt;br&amp;amp;gt;&amp;amp;nbsp;你好
&amp;lt;/font&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;标题标签&lt;/h4&gt;
&lt;p&gt;h1-h6，h7会显示原文本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;body&amp;gt;&amp;lt;!--主体内容--&amp;gt;
    &amp;lt;h1&amp;gt;标题&amp;lt;/h1&amp;gt;
    &amp;lt;h2&amp;gt;标题&amp;lt;/h2&amp;gt;
    &amp;lt;h3&amp;gt;标题&amp;lt;/h3&amp;gt;
    &amp;lt;h4&amp;gt;标题&amp;lt;/h4&amp;gt;
    &amp;lt;h5&amp;gt;标题&amp;lt;/h5&amp;gt;
    &amp;lt;h6&amp;gt;标题&amp;lt;/h6&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以为标签添加属性，使其左右居中对齐&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;body&amp;gt;&amp;lt;!--主体内容--&amp;gt;
    &amp;lt;h1 align=&quot;left&quot;&amp;gt;标题&amp;lt;/h1&amp;gt;
    &amp;lt;h2 align=&quot;center&quot;&amp;gt;标题&amp;lt;/h2&amp;gt;
    &amp;lt;h3 align=&quot;right&quot;&amp;gt;标题&amp;lt;/h3&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;超链接&lt;/h4&gt;
&lt;p&gt;指定href 连接对象，也可以增加target属性设置点击操作（默认为self）&lt;/p&gt;
&lt;p&gt;blank会打开新的标签页&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;body&amp;gt;&amp;lt;!--主体内容--&amp;gt;
    &amp;lt;a href=&quot;https://www.baidu.com&quot;&amp;gt;百度&amp;lt;/a&amp;gt;
    &amp;lt;a href=&quot;https://www.baidu.com&quot; target=&quot;_self&quot;&amp;gt;百度&amp;lt;/a&amp;gt;
    &amp;lt;a href=&quot;https://www.baidu.com&quot; target=&quot;_blank&quot;&amp;gt;百度&amp;lt;/a&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;标签列表&lt;/h4&gt;
&lt;p&gt;还可以修改列表前的符号，加上type=&quot;none&quot;&lt;/p&gt;
&lt;p&gt;无序列表ul&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;body&amp;gt;&amp;lt;!--主体内容--&amp;gt;
    &amp;lt;ul&amp;gt;
        &amp;lt;li&amp;gt;赵四&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;刘能&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;沈阳&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;小宝&amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有序列表ol&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;body&amp;gt;&amp;lt;!--主体内容--&amp;gt;
    &amp;lt;ol&amp;gt;
        &amp;lt;li&amp;gt;赵四&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;刘能&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;沈阳&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;小宝&amp;lt;/li&amp;gt;
    &amp;lt;/ol&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;img标签&lt;/h4&gt;
&lt;p&gt;显示图片&lt;/p&gt;
&lt;p&gt;border是边框大小，alt是找不到显示的文本内容&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;img src=&quot;2.jpg&quot; width=&quot;200&quot; height=&quot;200&quot; border=&quot;1&quot; alt=&quot;404&quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;../images/135.png&quot; alt=&quot;135&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;表格标签&lt;/h4&gt;
&lt;p&gt;做一个代表头的，三行三列表格，显示边框&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;table&amp;gt;
    &amp;lt;tr&amp;gt;
        &amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;2&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;3&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
    &amp;lt;tr&amp;gt;
        &amp;lt;td&amp;gt;4&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;5&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;6&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
    &amp;lt;tr&amp;gt;
        &amp;lt;td&amp;gt;7&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;8&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;9&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改长宽，边框（border）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;table border=&quot;1&quot; width=&quot;400&quot; height=&quot;300&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;添加th显示表头加增粗&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;tr&amp;gt;
    &amp;lt;th&amp;gt;1&amp;lt;/th&amp;gt;
    &amp;lt;th&amp;gt;2&amp;lt;/th&amp;gt;
    &amp;lt;th&amp;gt;3&amp;lt;/th&amp;gt;
&amp;lt;/tr&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;cellspacing可以调节格子间的间距一般就使用0即可&lt;/p&gt;
&lt;p&gt;跨行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;td colspan=&quot;2&quot;&amp;gt;4&amp;lt;/td&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;跨列&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;td rowspan=&quot;2&quot;&amp;gt;6&amp;lt;/td&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以叠加使用&lt;/p&gt;
&lt;h4&gt;iframe标签&lt;/h4&gt;
&lt;p&gt;可以在html页面上打开一个小窗口加载单独的页面&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;body&amp;gt;&amp;lt;!--主体内容--&amp;gt;
    主页面
    &amp;lt;iframe src=&quot;123.html&quot;&amp;gt;&amp;lt;/iframe&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;div、span、p&lt;/h4&gt;
&lt;p&gt;div标签默认独占一行&lt;/p&gt;
&lt;p&gt;span标签长度是封装数据的长度&lt;/p&gt;
&lt;p&gt;p段落标签会在上下各空出一行，如果有则不空&lt;/p&gt;
&lt;h3&gt;表单&lt;/h3&gt;
&lt;h4&gt;入门使用&lt;/h4&gt;
&lt;p&gt;form标签就是表单&lt;/p&gt;
&lt;p&gt;表单用于收集用户信息，把信息发送给服务器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/136.png&quot; alt=&quot;136&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;body&amp;gt;&amp;lt;!--主体内容--&amp;gt;
    &amp;lt;form&amp;gt;
        用户名称：&amp;lt;input type=&quot;text&quot; value=&quot;默认值&quot;/&amp;gt;&amp;lt;br/&amp;gt;
        用户密码：&amp;lt;input type=&quot;password&quot;/&amp;gt;&amp;lt;br/&amp;gt;
        性别：&amp;lt;input type=&quot;radio&quot; name=&quot;sex&quot; checked=&quot;checked&quot;&amp;gt;男&amp;lt;input type=&quot;radio&quot; name=&quot;sex&quot;&amp;gt;女&amp;lt;br/&amp;gt;
        兴趣爱好：&amp;lt;input type=&quot;checkbox&quot;&amp;gt;Java&amp;lt;input type=&quot;checkbox&quot;&amp;gt;C++&amp;lt;input type=&quot;checkbox&quot;&amp;gt;Python&amp;lt;input type=&quot;checkbox&quot;&amp;gt;C&amp;lt;br/&amp;gt;
        国籍：&amp;lt;select&amp;gt;
        &amp;lt;option&amp;gt;国籍&amp;lt;/option&amp;gt;
        &amp;lt;option&amp;gt;美国&amp;lt;/option&amp;gt;
        &amp;lt;option selected=&quot;selected&quot;&amp;gt;中国&amp;lt;/option&amp;gt;
        &amp;lt;option&amp;gt;日本&amp;lt;/option&amp;gt;
        &amp;lt;/select&amp;gt;&amp;lt;br/&amp;gt;
        自我介绍：&amp;lt;br/&amp;gt;
        &amp;lt;textarea rows=&quot;5&quot; cols=&quot;20&quot;&amp;gt;自我介绍
        &amp;lt;/textarea&amp;gt;
        &amp;lt;input type=&quot;reset&quot; value=&quot;reset&quot;/&amp;gt;
        &amp;lt;input type=&quot;submit&quot; value=&quot;submit&quot;/&amp;gt;&amp;lt;br/&amp;gt;
        &amp;lt;input type=&quot;file&quot;/&amp;gt;
    &amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;生成的网页&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/137.png&quot; alt=&quot;137&quot; /&gt;&lt;/p&gt;
&lt;p&gt;在实际使用的时候可以将所有的表单行放入表格对齐，更加的美观&lt;/p&gt;
&lt;h4&gt;表单提交&lt;/h4&gt;
&lt;p&gt;注意需要将提交表单的对应行都添加上name才能发送到服务器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;form action=https://www.baidu.com method=&quot;get或者post&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;get：浏览器浏览器的地址是（action属性[+?+请求参数]），参数是(name=value&amp;amp;name=value...)&lt;/p&gt;
&lt;p&gt;post：可传送requuest主体的表单内容 浏览器地址中只有action，安全，长度无限制&lt;/p&gt;
&lt;h2&gt;CSS&lt;/h2&gt;
&lt;p&gt;CSS是层叠样式表单，是用于增强控制网页样式并允许将样式信息和网页内容分离的一种标记性语言&lt;/p&gt;
&lt;h3&gt;语法规则&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;选择器{
	属性: 值
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;选择器：浏览器根据选择器决定受CSS样式影响的HTML元素（标签）&lt;/p&gt;
&lt;p&gt;属性(property)：要改变的样式名，并且每个属性都有一个值，用：隔开，并被{}包围，这样就组成了一个完成的样式声明(declaration) 例如 p{color:blue}&lt;/p&gt;
&lt;p&gt;多个声明：如果定义的不只有一个声明，则需要用分号将每个声明分开&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p {
    color:red;
	font-size:80px;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;CSS注释&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/*注释内容*/
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;HTML结合使用&lt;/h3&gt;
&lt;p&gt;入门使用&lt;/p&gt;
&lt;p&gt;设置div和span的样式，这样的可读性差，没复用性&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;body&amp;gt;
    &amp;lt;div style=&quot;border: aqua solid 1px&quot;&amp;gt;CSS说明&amp;lt;/div&amp;gt;
    &amp;lt;span style=&quot;border: red solid 1px&quot;&amp;gt;CSS说明&amp;lt;/span&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;自定义样式&lt;/p&gt;
&lt;p&gt;我们可以自定义样式，对所有的特定标签生效&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;CSS&amp;lt;/title&amp;gt;
    &amp;lt;style style=&quot;height: auto&quot;&amp;gt;
        div{
            border: 1px solid black;
        }
        span{
            color: red;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div&amp;gt;CSS说明&amp;lt;/div&amp;gt;
    &amp;lt;span&amp;gt;CSS说明&amp;lt;/span&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上代码也是有缺陷的，只可以在同一个页面编辑head内容创建style设置样式，不可以多个页面复用css代码，且维护不方便，我们可以通过如下的方式多页使用&lt;/p&gt;
&lt;p&gt;link引入&lt;/p&gt;
&lt;p&gt;把css样式写成一个单独的css文件，再通过link标签引入即可复用&lt;/p&gt;
&lt;p&gt;编写.css文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;div{
    border: 1px solid black;
}
span{
    color: red;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;CSS&amp;lt;/title&amp;gt;
    &amp;lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;test.css&quot;/&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div&amp;gt;div&amp;lt;/div&amp;gt;
    &amp;lt;span&amp;gt;span&amp;lt;/span&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;后续修改在.css改即可&lt;/p&gt;
&lt;h3&gt;选择器&lt;/h3&gt;
&lt;h4&gt;标签名选择器&lt;/h4&gt;
&lt;p&gt;可以决定哪些标签被动的使用这个样式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;CSS&amp;lt;/title&amp;gt;
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        div{
            border: 1px solid #050505;
            color: #3dc6b1;
            font-size: 20px;
        }
        span{
            border: 5px solid #050505;
            color: red;
            font-size: 20px;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div&amp;gt;div&amp;lt;/div&amp;gt;
    &amp;lt;span&amp;gt;span&amp;lt;/span&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;id选择器&lt;/h4&gt;
&lt;p&gt;格式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#id 属性值{
	属性:值;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;id选择器，可以让我们通过id属性选择性的去使用样式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;CSS&amp;lt;/title&amp;gt;
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        #id001{
            border: 1px solid #050505;
            color: #3dc6b1;
            font-size: 20px;
        }
        #id002{
            border: 5px solid #050505;
            color: red;
            font-size: 20px;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div id=&quot;id001&quot;&amp;gt;div&amp;lt;/div&amp;gt;
    &amp;lt;span id=&quot;id002&quot;&amp;gt;span&amp;lt;/span&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;class选择器&lt;/h4&gt;
&lt;p&gt;使用建议&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用&lt;strong&gt;class&lt;/strong&gt;来定义可重复使用的样式&lt;/li&gt;
&lt;li&gt;使用&lt;strong&gt;id&lt;/strong&gt;来标识唯一的页面元素（通常用于JS操作或页面锚点）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;格式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.class 属性值{
	属性:值;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;CSS&amp;lt;/title&amp;gt;
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        .class01{
            border: 1px solid #050505;
            color: #3dc6b1;
            font-size: 20px;
        }
        .class02{
            border: 5px solid #050505;
            color: red;
            font-size: 20px;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div class=&quot;class01&quot;&amp;gt;div&amp;lt;/div&amp;gt;
    &amp;lt;span class=&quot;class02&quot;&amp;gt;span&amp;lt;/span&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;组合选择器&lt;/h4&gt;
&lt;p&gt;可以用多个标签去共享样式，id和class也可以&lt;/p&gt;
&lt;p&gt;格式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;选择器1, 选择器2, 选择器... {
	属性:值;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;CSS&amp;lt;/title&amp;gt;
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        div, span{
            border: 1px solid #050505;
            color: #3dc6b1;
            font-size: 20px;
        }

    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div&amp;gt;div&amp;lt;/div&amp;gt;
    &amp;lt;span&amp;gt;span&amp;lt;/span&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;常用样式&lt;/h3&gt;
&lt;p&gt;color字体颜色，border像素框，weight宽，height高，backgroud-color背景颜色，margin-left（auto）框格式左对齐，text-align（center、right、left）文字设置，text-decoration:none去除超链接&lt;/p&gt;
&lt;h2&gt;JavaScript&lt;/h2&gt;
&lt;p&gt;JavaScript语言最开始最要是为了完成页面的数据验证，运行在客户端，需要运行浏览器来解释执行JavaScript代码&lt;/p&gt;
&lt;h3&gt;特点&lt;/h3&gt;
&lt;p&gt;交互性：可以做信息的动态交互&lt;/p&gt;
&lt;p&gt;安全性：不允许直接访问本地硬盘空间&lt;/p&gt;
&lt;p&gt;跨平台性：只要是可以解释JS的浏览器都可以执行，和平台无关&lt;/p&gt;
&lt;h3&gt;HTML结合使用&lt;/h3&gt;
&lt;p&gt;第一种，在head标签中或者body标签中，使用script标签来书写Javascript代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;JavaScript&amp;lt;/title&amp;gt;
  &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    alert(&quot;Hello World!&quot;);
  &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二种，为了复用可以将Javascript代码写为一个文件，再导入这个文件到html中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;alert(&quot;Hello World!&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;JavaScript&amp;lt;/title&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot; src=&quot;Javaweb.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上两者二选一，不可以既选择js，又在同样的标签下写js代码&lt;/p&gt;
&lt;h3&gt;变量&lt;/h3&gt;
&lt;p&gt;变量可以存放某些值得内存名称，其中JavaScript中有如下的变量类型&lt;/p&gt;
&lt;p&gt;数值类型：number&lt;/p&gt;
&lt;p&gt;字符串类型：string&lt;/p&gt;
&lt;p&gt;对象类型：object&lt;/p&gt;
&lt;p&gt;布尔类型：boolean&lt;/p&gt;
&lt;p&gt;函数类型：function&lt;/p&gt;
&lt;p&gt;以下是JavaScript中特殊的值&lt;/p&gt;
&lt;p&gt;undefined：未定义，所有js变量未赋于初始值的时候，默认都是该类型&lt;/p&gt;
&lt;p&gt;null：空值&lt;/p&gt;
&lt;p&gt;NAN：非数字&lt;/p&gt;
&lt;p&gt;JS定义变量类型格式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var 变量名称;
var 变量名称 = 值
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;var i;
alert(i);/*undefined*/
i = 12;
alert(typeof (i));/*number*/
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;运算符&lt;/h3&gt;
&lt;h4&gt;比较运算符&lt;/h4&gt;
&lt;p&gt;相比较于Java中增加了===全等于&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var i;
i = (12 == &quot;12&quot;);
alert(i);/*true*/
i = (12 === &quot;12&quot;);
alert(i);/*flase*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而所有的变量都可以作为一个boolean类型的变量去使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0,null,undefined,&quot;&quot; /*false*/
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;逻辑运算符&lt;/h4&gt;
&lt;p&gt;返回确定表达式真假的第一个表达式的值&lt;/p&gt;
&lt;p&gt;&amp;amp;&amp;amp;&lt;/p&gt;
&lt;p&gt;当表达式全为真的情况下，返回最后一个表达式的值&lt;/p&gt;
&lt;p&gt;当表达式有一个为假的时候，返回第一个为假的表达式值&lt;/p&gt;
&lt;p&gt;||&lt;/p&gt;
&lt;p&gt;当表达式全为假的时候，返回最后一个表达式的值&lt;/p&gt;
&lt;p&gt;当表达式有一个为真的时候，返回第一个为真的表达式值&lt;/p&gt;
&lt;h3&gt;数组&lt;/h3&gt;
&lt;h4&gt;使用&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;var 数组名称 = [];//空数组
var 数组名称 = [1,&apos;abc&apos;,true];//定义数组时赋值
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;var arr = [123, 133, 133];
alert(arr[2]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在使用上基本上和java没有区别&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var arr = [123, 133, 133];
for (var i = 0; i &amp;lt; 2; i++) {
    alert(arr[i]);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;区别&lt;/h4&gt;
&lt;p&gt;JavaScript中的数组，只要通过数组下表赋值，那么数组下标的最大值就会给数组做扩容操作，没有赋值的内容类型是undefined&lt;/p&gt;
&lt;h3&gt;函数&lt;/h3&gt;
&lt;h4&gt;基本使用&lt;/h4&gt;
&lt;p&gt;在Javascript中有两种方式定义函数&lt;/p&gt;
&lt;p&gt;第一种：使用function关键字来定义函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function 函数名称(形参列表){
	函数体
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;function fun() {
    var arr = [123, 133, 1323];
    for (var i = 0; i &amp;lt; 3; i++) {
        alert(arr[i]);
    }
}

fun();
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;function fun(a, b, c) {
    alert(a + &quot; &quot; + b + &quot; &quot; + c);
}

var arr = [123, 133, 1323];
fun(arr[0], arr[1], arr[2]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二种：由于function在JavaScript中是一种类型，可以进行赋值操作&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var 函数名称 = function(形参列表) {
	函数体
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;function fun(a, b, c) {
    alert(a + &quot; &quot; + b + &quot; &quot; + c);
}

anotherFun = fun;
var arr = [123, 133, 1323];
anotherFun(arr[0], arr[1], arr[2]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意在，Javascript中不允许解析函数的重载，如果函数名称重名会覆盖上一次定义&lt;/p&gt;
&lt;h4&gt;隐形参数&lt;/h4&gt;
&lt;p&gt;在Javascript中存在一个arguments隐藏参数，在function函数体中不需要定义，但是可以获取所有参数的变量，很像Java中的可变参数，操作类似数组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function fun() {
    alert(&quot;无参函数fun&quot;);
    alert(arguments[0] + &quot; &quot; + arguments[1] + &quot; &quot; + arguments[2]);
}

anotherFun = fun;
var arr = [123, 133, 1323];
anotherFun(arr[0], arr[1], arr[2]);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;function fun() {
    var result = 0;
    for (var i = 0; i &amp;lt; arguments.length; i++) {
        result += arguments[i];
    }
    return result;
}

var number = fun(1, 2, 3, 4, 5);
alert(number);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;自定义对象&lt;/h3&gt;
&lt;h4&gt;Object&lt;/h4&gt;
&lt;p&gt;Object形式自定义对象&lt;/p&gt;
&lt;p&gt;定义格式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var 变量名称 = new Object();//定义空对象
变量名称.属性名 = 值;
变量名称.函数名 = function() {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用方式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;变量名称.属性名
变量名称.函数名
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;var obj = new Object();
obj.id = Math.random();
obj.fun = function(){
    alert(obj.id);
}
obj.fun();
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;{}&lt;/h4&gt;
&lt;p&gt;{}形式的自定义对象&lt;/p&gt;
&lt;p&gt;定义格式（注意各行之间用 , 间隔开，而最后一行不加 , ）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var 变量名称 = {
    属性名称:值，
    属性名称:值，
    函数名:function(){}
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用方式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var obj = {
    id:Math.random(),
    fun:function () {alert(obj.id);}
}
obj.fun();
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;总结&lt;/h1&gt;
&lt;p&gt;今天为JavaWeb开了一个头，感觉学起来还是非常轻松的，尤其是在JavaScript上由于语法和Java大体类似，只需要过一遍就可以很快的掌握语法，并加以使用，而CSS和HTML部分的学习我觉得作为主攻后端开发来说做到随超随用就行，大概了解使用方式即可&lt;/p&gt;
&lt;p&gt;明天会结束JavaScript部分的内容（事件），并开始jQuery的学习&lt;/p&gt;
</content:encoded></item><item><title>Redis</title><link>https://thrinisty.github.io/posts/redis%E7%AC%94%E8%AE%B0java%E5%AE%A2%E6%88%B7%E7%AB%AF/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/redis%E7%AC%94%E8%AE%B0java%E5%AE%A2%E6%88%B7%E7%AB%AF/</guid><description>Java客户端，待学部分，等到Java框架学习完成后进行</description><pubDate>Thu, 24 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Redis笔记&lt;/h1&gt;
&lt;h2&gt;Jedis&lt;/h2&gt;
&lt;p&gt;我们学Redis最终还是要回到编码上，我们需要使用到Redis提供的客户端，推荐的有Jedis、lettuce、Redisson&lt;/p&gt;
&lt;p&gt;Jedis，以Redis命令作为方法名称，学习成本较低，简单实用，但是Jedis实例线程不安全，多线程环境下需要基于连接池来使用&lt;/p&gt;
&lt;p&gt;Lettuce，是基于Netty实现的，支持同步，异步，响应式编程方式，线程安全，支持Redis的哨兵模式，集群模式，管道模式&lt;/p&gt;
&lt;p&gt;Redisson，是基于Redis实现的分布式，可伸缩的Java数据结构集合，包含了Map、Queue、Lock、Semaphore、AtomicLong等强大功能&lt;/p&gt;
&lt;p&gt;而其中Spring Data Redis支持jedis和lettuce&lt;/p&gt;
&lt;h3&gt;Jedis使用&lt;/h3&gt;
&lt;p&gt;用Maven添加如下的依赖&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;redis.clients&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;jedis&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;5.2.0&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;4.13.2&amp;lt;/version&amp;gt;
        &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.junit.jupiter&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;junit-jupiter&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;5.8.1&amp;lt;/version&amp;gt;
        &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;全部配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
  &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

  &amp;lt;groupId&amp;gt;org.example&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;JedisTest&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
  &amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt;

  &amp;lt;name&amp;gt;JedisTest&amp;lt;/name&amp;gt;
  &amp;lt;url&amp;gt;http://maven.apache.org&amp;lt;/url&amp;gt;

  &amp;lt;properties&amp;gt;
    &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
  &amp;lt;/properties&amp;gt;

  &amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;redis.clients&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;jedis&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;5.2.0&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;4.13.2&amp;lt;/version&amp;gt;
      &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;

  &amp;lt;/dependencies&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;测试代码&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;package org.example;

public class Main {
    public static void main(String[] args) {
        JedisTest jedis = new JedisTest();
        jedis.setUP();
        jedis.testString();
        jedis.tearDown();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Iterator;
import java.util.Map;
import java.util.Set;

public class JedisTest {
    private Jedis jedis;

    public void setUP(){
        jedis = new Jedis(&quot;192.168.104.52&quot;, 6379);
        jedis.auth(&quot;654321&quot;);
        jedis.select(0);
    }

    public void testString() {
        jedis.hset(&quot;hash&quot;, &quot;test&quot;, &quot;value&quot;);
        Map&amp;lt;String, String&amp;gt; hash = jedis.hgetAll(&quot;hash&quot;);
        Set&amp;lt;Map.Entry&amp;lt;String, String&amp;gt;&amp;gt; entrySet = hash.entrySet();
        Iterator&amp;lt;Map.Entry&amp;lt;String, String&amp;gt;&amp;gt; iterator = entrySet.iterator();
        while(iterator.hasNext()) {
            Map.Entry&amp;lt;String, String&amp;gt; entry = iterator.next();
            System.out.println(entry.getKey() + &quot; &quot; + entry.getValue());
        }
    }

    public void tearDown() {
        if(jedis != null) {
            jedis.close();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;fieldString1 HelloWorld1
test value
fieldInt 1
fieldString HelloWorld
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，所有的jedis指令名称和参数都和redis中的对应，使用起来异常的方便，Hash数据结构中的hgetAll也使用HashMap的形式返回，方便用迭代器进行处理&lt;/p&gt;
&lt;h3&gt;Jedis连接池&lt;/h3&gt;
&lt;p&gt;Jedis本身是线程不安全的，而且频繁地创建和销毁连接会有性能上的损耗，推荐使用Jedis地连接池来替代Jedis地直接连接方式&lt;/p&gt;
&lt;p&gt;封装连接池类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class JedisConnectionFactory {
    private static final JedisPool jedisPool;

    static {
        JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();
        //设置最大连接数
        jedisPoolConfig.setMaxTotal(8);
        //设置最大空闲连接
        jedisPoolConfig.setMaxIdle(8);
        //设置最小空闲连接
        jedisPoolConfig.setMinIdle(8);
        //设置最长等待时间ms
        jedisPoolConfig.setMaxWait(Duration.ofMillis(2000));
        jedisPool = new JedisPool(jedisPoolConfig, &quot;192.168.104.52&quot;, 6379, 1000, &quot;654321&quot;);
    }
    //1000 是连接 Redis 服务器的超时时间（毫秒）

    public static Jedis getJedis() {
        return jedisPool.getResource();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public class Main {
    public static void main(String[] args) {
        Jedis jedis = JedisConnectionFactory.getJedis();
        jedis.set(&quot;key&quot;, &quot;value&quot;);
        String s = jedis.get(&quot;key&quot;);
        System.out.println(s);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;SpringDataRedis&lt;/h2&gt;
&lt;p&gt;SpringData是Spring中数据操作的模块，包含对于各种数据库的集成，其中对Redis的集成模块就是SpringDataRedis，总的来说包含了以下的功能&lt;/p&gt;
&lt;p&gt;1.提供了对不同Redis客户端的整合（Lettuce和Jedis）&lt;/p&gt;
&lt;p&gt;2.提供了RedisTemplate统一API操作Redis&lt;/p&gt;
&lt;p&gt;3.支持Redis的发布订阅模型&lt;/p&gt;
&lt;p&gt;4.支持Redis哨兵和Redis集群&lt;/p&gt;
&lt;p&gt;5.支持基于Lettuce的响应式编程&lt;/p&gt;
&lt;p&gt;6.支持基于JDK，JSON，字符串，Spring对象的数据序列化和反序列化&lt;/p&gt;
&lt;p&gt;7.支持基于Redis的JDKCollection实现&lt;/p&gt;
&lt;h3&gt;快速入门&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../images/131.png&quot; alt=&quot;131&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;问题解决&lt;/h3&gt;
&lt;p&gt;IDEA下创建项目SpringBoot发生如下问题，而没有Java更低版本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;项目 SDK &apos;1.8&apos; 不支持所选版本的 Java 17。请选择较低版本的 Java，或设置较高版本的 SDK
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以尝试替换源，选择更低版本Java&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;https://start.aliyun.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Maven获取依赖&lt;/p&gt;
&lt;p&gt;如果在使用Maven获取依赖项的时候用时太久可以尝试替换&lt;/p&gt;
&lt;p&gt;配置阿里云镜像&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;~/.m2/settings.xml&lt;/code&gt; 中添加：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;mirrors&amp;gt;
    &amp;lt;mirror&amp;gt;
        &amp;lt;id&amp;gt;aliyunmaven&amp;lt;/id&amp;gt;
        &amp;lt;url&amp;gt;https://maven.aliyun.com/repository/public&amp;lt;/url&amp;gt;
        &amp;lt;mirrorOf&amp;gt;central&amp;lt;/mirrorOf&amp;gt;
    &amp;lt;/mirror&amp;gt;
&amp;lt;/mirrors&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;感觉学到这里有点寸步难行，redis的各种相关配置，用到的SpringBoot，Maven之类，我都没有接触过，还是得回到Java的开发框架进行学习，Redis教程的进度先耽搁一下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@SpringBootTest
class RedisDataApplicationTests {

    @Autowired
    private RedisTemplate redisTemplate;
    @Test
    void testString() {
        redisTemplate.opsForValue().set(&quot;dataTest&quot;, &quot;李四&quot;);
        Object dataTest = redisTemplate.opsForValue().get(&quot;dataTest&quot;);
        System.out.println(dataTest);
    }

}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Redis</title><link>https://thrinisty.github.io/posts/redis%E7%AC%94%E8%AE%B0nosqlredis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/redis%E7%AC%94%E8%AE%B0nosqlredis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid><description>NoSQL，Redis数据结构</description><pubDate>Wed, 23 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Redis笔记&lt;/h1&gt;
&lt;p&gt;花了大概两天完成，Java8内容的学习，比预期的要上了短一些，本来打算按照学习计划先进行Java开发框架的学习，但是发现面试的时候Redis考点会更多一点，所以将Redis部分的学习提前，预定大概10天完成（黑马Redis教程）&lt;/p&gt;
&lt;p&gt;教程包括了：八种不同的数据结构，两个消息队列，四个相关的运维操作，Scrip脚本，事务操作&lt;/p&gt;
&lt;h2&gt;NoSQL&lt;/h2&gt;
&lt;p&gt;SQL是关系型数据库，而NoSQL是非关系型数据库&lt;/p&gt;
&lt;h3&gt;与SQL的区别&lt;/h3&gt;
&lt;h4&gt;结构化&lt;/h4&gt;
&lt;p&gt;SQL高度结构化，每个字段每个值都会有严格的要求，一般难以修改。而NoSQL是非结构化的，对于key没有严格要求，支持自定义，还可以键值类型，列类型，文档存储，Graph存储，相对SQL，结构便于修改&lt;/p&gt;
&lt;h4&gt;关联性&lt;/h4&gt;
&lt;p&gt;SQL有外键的约束，数据是相关联的，NoSQL没有关联（程序员手动维护）&lt;/p&gt;
&lt;h4&gt;SQL查询&lt;/h4&gt;
&lt;p&gt;只要是SQL都可以使用相同的查询语句查询，而NoSQL没有固定的语法格式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/124.png&quot; alt=&quot;124&quot; /&gt;&lt;/p&gt;
&lt;p&gt;每一个类型的数据查询方式不同&lt;/p&gt;
&lt;h4&gt;事务&lt;/h4&gt;
&lt;p&gt;SQL有事务满足ACID，而NoSQL只满足BASE&lt;/p&gt;
&lt;h4&gt;总结&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;../images/125.png&quot; alt=&quot;125&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;Redis&lt;/h2&gt;
&lt;h3&gt;基本介绍&lt;/h3&gt;
&lt;p&gt;Remote Dictionary Server 远程词典服务器，是一个基于内存的键值型NoSQL数据库，以下是Redis的基本特征&lt;/p&gt;
&lt;p&gt;键值型：value支持多种不同数据结构，功能丰富&lt;/p&gt;
&lt;p&gt;单线程：每个命令具备原子性（Redis 6可以多线程处理网络请求）&lt;/p&gt;
&lt;p&gt;高性能：低延迟，速度快（基于内存，IO多路复用，良好的编码【C语言编写】）&lt;/p&gt;
&lt;p&gt;持久化：内存以往是不持久化的，而Redis定期存入磁盘，支持持久化&lt;/p&gt;
&lt;p&gt;高可用：支持主从集群，分片集群&lt;/p&gt;
&lt;p&gt;语言支持：支持多种语言的客户端&lt;/p&gt;
&lt;h3&gt;常用命令&lt;/h3&gt;
&lt;p&gt;我们一般的redis数据库会配置在Linux环境下，之后可以使用Windows的GUI软件RESP来使用Linux下的数据库&lt;/p&gt;
&lt;p&gt;再Linux下装好redis后，可以使用如下的指令&lt;/p&gt;
&lt;p&gt;命令行客户端&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;redis-cli
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;服务端启动脚本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;redis-server
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;哨兵启动脚本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;redis-sentinel
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以在redis.conf中设置，允许访问的地址，密码，是否后台运行等&lt;/p&gt;
&lt;p&gt;再用如下的指令指定配置文件启动&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;redis-server redis.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;利用如下指令查找开启的进程&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ps -ef | grep redis
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;杀死对应端口的进程&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kill -9 2574
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用命令行客户端连接redis&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;redis-cli -a ******
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;连接成功后，ping和服务端交互&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ping
PONG
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还可以进行存取数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; set name jack
OK
127.0.0.1:6379&amp;gt; set age 21
OK
127.0.0.1:6379&amp;gt; get name
&quot;jack&quot;
127.0.0.1:6379&amp;gt; get age
&quot;21&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再windows宿主机使用如下指令连接（虚拟机网络适配器改为桥接连接模式）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;redis-cli -h 192.168.104.52 -p 6379 -a ******
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用GUI客户端连接&lt;/p&gt;
&lt;p&gt;网址链接： https://github.com/lework/RedisDesktopManager-Windows&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/126.png&quot; alt=&quot;126&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;Redis数据结构&lt;/h2&gt;
&lt;p&gt;Redis是一个键值对形式存储的数据库，key一般是String类型的，不过Value的类型非常多种多样&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/127.png&quot; alt=&quot;127&quot; /&gt;&lt;/p&gt;
&lt;p&gt;其中前五种是基本数据类型，后三种是特殊数据类型&lt;/p&gt;
&lt;p&gt;数据类型的具体使用详见 https://redis.io/docs/latest/commands&lt;/p&gt;
&lt;p&gt;如果在连接到redis下的客户端中可以使用如下指令获取帮助&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;help @数据类型
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例如查看String的相关指令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;help @String
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Key的层级格式&lt;/h3&gt;
&lt;p&gt;Redis没有类似MySQL中的Table概念，而所有的键值对都是存储在一起的，怎么区分不同类型的key？&lt;/p&gt;
&lt;p&gt;例如需要存储用户，商品信息到redis，一个用户的id是1，而另一个商品id也为1&lt;/p&gt;
&lt;p&gt;而为了解决这类的问题，redis引入了key的层级结构：Redis的key允许有多个单词形成层级结构，多个单词之间用：隔开，格式如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;项目名称:业务名称:类型:id
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;格式并非固定不变，可以根据需求删除或者添加词条&lt;/p&gt;
&lt;p&gt;user相关的key：com.user:1&lt;/p&gt;
&lt;p&gt;product相关的key：com.product:1&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/128.png&quot; alt=&quot;128&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;Redis通用命令&lt;/h3&gt;
&lt;p&gt;虽然有非常多的数据类型以及相关操作，但是其中也有一些通用的命令&lt;/p&gt;
&lt;h4&gt;KEYS&lt;/h4&gt;
&lt;p&gt;查看符合模板的所有key，不建议在Redis服务器端使用，会阻塞所有的其他指令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;KEYS pattern
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例如：返回所有的键值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;KEYS *
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;返回a开头的所有键值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;KEYS a*
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;DEL&lt;/h4&gt;
&lt;p&gt;删除一个指定的键值(例如age)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DEL age
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以删除多个&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DEL k1 k2 k3
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;MSET&lt;/h4&gt;
&lt;p&gt;批量插入键值对&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MSET k1 v1 k2 v2 k3 v3 k4 v4
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;EXISTS&lt;/h4&gt;
&lt;p&gt;判断是否存在键值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;EXISTS k4
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;EXPIRE&lt;/h4&gt;
&lt;p&gt;给一个key设置有效期，有效期到达时key会被删除&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;EXPIRE key second
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;EXPIRE name 5
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;TTL&lt;/h4&gt;
&lt;p&gt;查看一个键的有效期&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;TTL key
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中返回-1代表永久有效 -2为无效，其余为有效的秒数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;TTL k1
(integer) -1
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;String类型&lt;/h3&gt;
&lt;p&gt;是字符串类型，是Redis中最简单的存储类型，value是字符串，根据不同的格式又分为了三类：String 普通字符串  int 整数类型  float  浮点类型&lt;/p&gt;
&lt;p&gt;无论是哪一种格式存储，底层都是字节数组形式，只是编码方式不同，字符串类型的最大空间不可以超过512M&lt;/p&gt;
&lt;p&gt;以下是String类型常见的命令&lt;/p&gt;
&lt;h4&gt;SET&lt;/h4&gt;
&lt;p&gt;添加或者修改一个存在的String类型的键值对&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; set k1 123
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;GET&lt;/h4&gt;
&lt;p&gt;根据key获取String类型的value&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;get k1
&quot;123&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;MSET&lt;/h4&gt;
&lt;p&gt;批量添加多个String类型的的键值对&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MSET t1 1 t2 2 t3 3
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;MGET&lt;/h4&gt;
&lt;p&gt;根据多个key获取多个String类型的value&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MGET k1 k2 k3
1) &quot;v1&quot;
2) &quot;v2&quot;
3) &quot;v3&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;INCR&lt;/h4&gt;
&lt;p&gt;让一个整型的key自增1&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;get 1
&quot;23&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;INCR 1
(integer) 24
get 1
&quot;24&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;INCRBY&lt;/h4&gt;
&lt;p&gt;让一个整形的key自增并指定步长，例如incrby num 2让num自增2&lt;/p&gt;
&lt;p&gt;在INCR的基础上增加步长&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;INCRBY 1 4
(integer) 28
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;INCRBYFLOAT&lt;/h4&gt;
&lt;p&gt;让一个浮点类型的数字自增并指定步长&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;append 2 3.1415296
(integer) 9
get 2
&quot;3.1415296&quot;
INCRBYFLOAT 2 1.1
&quot;4.2415296&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;SETNX&lt;/h4&gt;
&lt;p&gt;添加一个String类型的键值对，前提是这个key不存在，否则不执行&lt;/p&gt;
&lt;p&gt;k1以及存在，不执行语句&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SETNX k1 1
(integer) 0
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;SETEX&lt;/h4&gt;
&lt;p&gt;添加一个String类型的键值对，并且指定有效期&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SETEX key seconds value
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置键3值12，持续30每秒&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SETEX 3 30 12
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者可以这么写&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;set 3 12 ex 30
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Hash类型&lt;/h3&gt;
&lt;p&gt;Hash类型，又称为散列，它的value是一个无序字典，类似于Java中的HashMap结构，String结构是将对象序列化为JSON字符串后存储，当需要修改某个字段的时候很不方便&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/129.png&quot; alt=&quot;129&quot; /&gt;&lt;/p&gt;
&lt;p&gt;而Hash结构可以将对象中的每个字段独立存储，可以针对单个字段作增删改查&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/130.png&quot; alt=&quot;130&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;HSET&lt;/h4&gt;
&lt;p&gt;添加或者修改hash类型key的field值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hset key field value
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;hset hash1 field value
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;HGET&lt;/h4&gt;
&lt;p&gt;获取一个hash类型的key的field值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HGET key field
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;hget hash1 field
&quot;value&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;HMSET&lt;/h4&gt;
&lt;p&gt;批量添加多个hash类型key的field值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HMSET hash1 field2 value2 field3 value3
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;HMGET&lt;/h4&gt;
&lt;p&gt;批量获取多个hash类型的key的field值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HMGET hash1 field field1 field2
1) &quot;value&quot;
2) &quot;value2&quot;
3) &quot;value2&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;HDEL&lt;/h4&gt;
&lt;p&gt;删除指定hash中的某个字段&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HDEL hash fieldString
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;HGETALL&lt;/h4&gt;
&lt;p&gt;获取一个hash类型的key中所有的field和value&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HGETALL hash1
1) &quot;field&quot;
2) &quot;value&quot;
3) &quot;field1&quot;
4) &quot;value2&quot;
5) &quot;field2&quot;
6) &quot;value2&quot;
7) &quot;field3&quot;
8) &quot;value3&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;HKEYS&lt;/h4&gt;
&lt;p&gt;获取一个hash类型的所有field&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HKEYS hash1
1) &quot;field&quot;
2) &quot;field1&quot;
3) &quot;field2&quot;
4) &quot;field3&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;HVALS&lt;/h4&gt;
&lt;p&gt;获取一个hash类型的所有value&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HVALS hash1
1) &quot;value&quot;
2) &quot;value2&quot;
3) &quot;value2&quot;
4) &quot;value3&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;HINCRBY&lt;/h4&gt;
&lt;p&gt;让一个hash类型key的字段值自增，并指定步长&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HSET hash fieldInt 1
(integer) 1
HINCRBY hash fieldInt 3
(integer) 4
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;HSETNX&lt;/h4&gt;
&lt;p&gt;添加一个hash类型key的field值，前提是field不存在，否则不执行（就是不允许修改存在的键的值）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HSETNX hash fieldString HelloWorld
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;List类型&lt;/h3&gt;
&lt;p&gt;对于List而言，可以使用该数据类型进行模拟栈：只需要入口和出口在同一边，如LPUSH+LPOP或者RPUSH+RPOP&lt;/p&gt;
&lt;p&gt;也可以模拟一个队列：需要入口和出口在不同边即可，如RPUSH+LPOP或者RPUSH+LPOP&lt;/p&gt;
&lt;p&gt;阻塞队列的模拟：入口出口不同边，取出采用BLPOP或者BRPOP&lt;/p&gt;
&lt;p&gt;基本介绍&lt;/p&gt;
&lt;p&gt;Redis中的List类型，和Java中的LinkedList类似，可以看作是一个双向链表的结构，既支持正向检索也可以支持反向检索&lt;/p&gt;
&lt;p&gt;特征：有序，元素可以重复，插入和删除较快，查询效率一般&lt;/p&gt;
&lt;p&gt;以下是List的常见命令&lt;/p&gt;
&lt;h4&gt;LPUSH&lt;/h4&gt;
&lt;p&gt;向列表左侧插入一个或者多个元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;LPUSH key element ...
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;LPUSH list a b c d e f g
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;LPOP&lt;/h4&gt;
&lt;p&gt;移除并返回列表左侧的第一个元素，没有则返回nil&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;LPOP key 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;LPOP list
&quot;g&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;RPUSH&lt;/h4&gt;
&lt;p&gt;向列表右侧插入一个或者多个元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;RPUSH list a b c d e f g h
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;RPOP&lt;/h4&gt;
&lt;p&gt;移除并返回列表右侧的第一个元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;RPOP list
&quot;h&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;LRANGE&lt;/h4&gt;
&lt;p&gt;返回一段角标范围内的所有元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;LRANGE key star end
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;LRANGE list 1 3
1) &quot;b&quot;
2) &quot;c&quot;
3) &quot;d&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;BLPOP与BRPOP&lt;/h4&gt;
&lt;p&gt;和LPOP，RPOP类似，只是在没有元素时等待指定时间，而不是返回nil&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;BLPOP list 60
1) &quot;list&quot;
2) &quot;target&quot;
(15.01s)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中list本来没有值，进入阻塞等待最多60s，新创建的客户端加入list 数据 target数据被读到&lt;/p&gt;
&lt;h3&gt;Set类型&lt;/h3&gt;
&lt;p&gt;Redis的Set结构和Java中的HashSet类似，可以看为是一个value为null的HashMap，因为是一个hash表，因此具备和HashSet类似的特征：无序，元素不可重复，查找快，支持交集、并集、差集的功能&lt;/p&gt;
&lt;p&gt;以下是Set类型常见的命令&lt;/p&gt;
&lt;h4&gt;SADD&lt;/h4&gt;
&lt;p&gt;向set中添加一个或者多个元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SADD key member ...
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;SADD set a b c d e f g
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;SREM&lt;/h4&gt;
&lt;p&gt;移除set中的指定元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SREM key member ...
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;SREM set a b c
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;SCARD&lt;/h4&gt;
&lt;p&gt;返回set中的元素个数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SCARD key
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;SCARD set
(integer) 4
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;SISMEMBER&lt;/h4&gt;
&lt;p&gt;判断一个元素是否存在于set中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SISMEMBER key member
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;SISMEMBER set g
(integer) 1
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;SMEMBERS&lt;/h4&gt;
&lt;p&gt;获取set中的所有元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SMEMBERS set
1) &quot;g&quot;
2) &quot;d&quot;
3) &quot;f&quot;
4) &quot;e&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;前置操作&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SADD set1 a b c d e f
SADD set2 a b
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;SINTER&lt;/h4&gt;
&lt;p&gt;求两个集合的交集&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SINTER set1 set2
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;1) &quot;b&quot;
2) &quot;a&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;SDIFF&lt;/h4&gt;
&lt;p&gt;求两个集合的差集&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SDIFF set1 set2
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;1) &quot;c&quot;
2) &quot;e&quot;
3) &quot;f&quot;
4) &quot;d&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;SUNION&lt;/h4&gt;
&lt;p&gt;求两个集合的并集&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SUNION set1 set2
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;1) &quot;b&quot;
2) &quot;a&quot;
3) &quot;d&quot;
4) &quot;c&quot;
5) &quot;e&quot;
6) &quot;f&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;SortedSet类型&lt;/h3&gt;
&lt;p&gt;Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但是底层数据结构差别巨大，SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层是一个跳表（Skip List）加上hash表&lt;/p&gt;
&lt;p&gt;以下是SortedSet的特征：可排序 元素不重复  查询速度快&lt;/p&gt;
&lt;p&gt;因为SortedSet的可排序性，经常用于实现排行榜等功能&lt;/p&gt;
&lt;p&gt;以下是Sorted的常见命令，所有排名默认为升序，降序在命令Z后加REV即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ZREVRANGE 
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;ZADD&lt;/h4&gt;
&lt;p&gt;添加一个或者多个元素到sorted set，如果与存在则更新其score值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ZADD key score member
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;ZADD sortedset 1 Hello
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;ZREM&lt;/h4&gt;
&lt;p&gt;删除sorted set中的一个元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ZREM key member
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;zrem sortedset HelloWorld
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;ZSCORE&lt;/h4&gt;
&lt;p&gt;获取sorted set中指定元素的score值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ZSCORE key member
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;ZSCORE sortedset Hello
&quot;1&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;ZRANK&lt;/h4&gt;
&lt;p&gt;获取sorted set中的指定元素排名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ZRANK key member
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;ZRANK sortedset Hello
(integer) 0
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;ZCARD&lt;/h4&gt;
&lt;p&gt;获取sorted set中的元素个数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ZCARD key
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;zcard sortedset
(integer) 2
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;ZCOUNT&lt;/h4&gt;
&lt;p&gt;统计指定范围内元素的个数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ZCOUNT key min max
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;ZCOUNT sortedset 2 5
(integer) 1
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;ZINCRBY&lt;/h4&gt;
&lt;p&gt;让sorted set 中指定score元素自增，指定步长&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ZINCRBY key increment member
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;ZINCRBY sortedset 4 1
&quot;22&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;ZRANGE&lt;/h4&gt;
&lt;p&gt;按照score排序后，获取指定排名范围内的元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ZRANGE key min max
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;ZRANGE sortedset 0 1
1) &quot;Hello&quot;
2) &quot;World&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;ZRANGEBYSCORE&lt;/h4&gt;
&lt;p&gt;按照score排序后，获取指定score范围内的元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ZRANGEBYSCORE key min max
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;ZRANGEBYSCORE sortedset 0 44
1) &quot;Hello&quot;
2) &quot;World&quot;
3) &quot;1&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;ZDIFF、ZINTER、ZUNION&lt;/h4&gt;
&lt;p&gt;求差集、交集、并集&lt;/p&gt;
&lt;p&gt;和Set类中的类似，不再过多叙述&lt;/p&gt;
</content:encoded></item><item><title>Java8笔记</title><link>https://thrinisty.github.io/posts/java8%E7%AC%94%E8%AE%B0lambda%E8%A1%A8%E8%BE%BE%E5%BC%8Fstream-apioptional/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java8%E7%AC%94%E8%AE%B0lambda%E8%A1%A8%E8%BE%BE%E5%BC%8Fstream-apioptional/</guid><description>Lambda表达式，函数式接口，Stream API，Optional</description><pubDate>Sun, 20 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Java8笔记&lt;/h1&gt;
&lt;p&gt;拖了一天，本来打算从昨天就开始Java8特性的学习。但是有门事多题难分少的编译原理实验课把自己搞得心烦，晚上就没有精力学习了。&lt;/p&gt;
&lt;p&gt;第二天还要体测，38度的高温，就隔这室外干站着，等半天跑1000米，跑前本来想着4分30以内及格就好，压着脚步跑，结果才4分37，还贼累，险些没给自己跑死。&lt;/p&gt;
&lt;p&gt;到了期中以后了，感觉时间也是慢慢的变得紧张了起来，还是尽量多学一会把，刚回宿舍躺了一小会，算是复活了，总而言之开始今天的学习吧&lt;/p&gt;
&lt;h2&gt;Java8&lt;/h2&gt;
&lt;p&gt;为什么要学习Java8？&lt;/p&gt;
&lt;p&gt;Java8是当今企业中开发最主流的稳定版本，这个版本中出现了很多的新特性，虽然考点不多，但是可以提升Java后端开发程序员的编程效率，值得学习&lt;/p&gt;
&lt;p&gt;相关知识有Lambda表达式、Stream API、Optional&lt;/p&gt;
&lt;p&gt;计划加上今天晚上，明天，后天，一共三天完成相关知识的学习&lt;/p&gt;
&lt;h2&gt;Lambda表达式&lt;/h2&gt;
&lt;p&gt;Lambda是一个匿名函数，我们可以把Lambda表达式理解为是一段可以传递的代码，使用它可以写出更为简洁灵活的代码，代码风格更加紧凑&lt;/p&gt;
&lt;h3&gt;代码示例&lt;/h3&gt;
&lt;p&gt;我们用一串代码举例子&lt;/p&gt;
&lt;p&gt;多线程接口Runnable，实现一个类，重写run方法，start调用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test01 {
    public static void main(String[] args) {
        Cat cat = new Cat();
        Thread thread = new Thread(cat);
        thread.start();
    }
}

class Cat implements Runnable {
    @Override
    public void run() {
        System.out.println(&quot;cat&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们就是用一次这个猫猫类，我们可以稍微用匿名内部类简写一点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test01 {
    public static void main(String[] args) {
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                System.out.println(&quot;cat&quot;);
            }
        };
        Thread thread = new Thread(runnable);
        thread.start();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来我们使用以下Lambda表达式来进行改造&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test01 {
    public static void main(String[] args) {
        Runnable runnable = () -&amp;gt; System.out.println(&quot;cat&quot;);
        Thread thread = new Thread(runnable);
        thread.start();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再举一个例子，比较类的实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test01 {
    public static void main(String[] args) {
        Comparator&amp;lt;Integer&amp;gt; comparator = new Comparator&amp;lt;Integer&amp;gt;() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return Integer.compare(o1, o2);
            }
        };
        System.out.println(comparator.compare(1,3));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lambda改造&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test01 {
    public static void main(String[] args) {
        Comparator&amp;lt;Integer&amp;gt; comparator = (Integer o1, Integer o2) -&amp;gt; Integer.compare(o1, o2);
        System.out.println(comparator.compare(1,3));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方法引用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test01 {
    public static void main(String[] args) {
        Comparator&amp;lt;Integer&amp;gt; comparator = Integer :: compare;
        System.out.println(comparator.compare(1,3));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以直接便捷的实现一个类的实例，如此方便，很人性化不是吗&lt;/p&gt;
&lt;p&gt;其中 -&amp;gt; 就是Lambda操作符，在实际操作中这么写非常的快速，而且很帅，很装&lt;/p&gt;
&lt;h3&gt;具体使用&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;使用说明&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(形参列表) -&amp;gt; 重写的抽象方法体
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;-&amp;gt; 左边Lambda形参列表（是接口中抽象方法的形参列表）&lt;/p&gt;
&lt;p&gt;-&amp;gt; 右边是Lambda体（是重写的抽象方法的方法体）&lt;/p&gt;
&lt;p&gt;Lambda表达式在Java中的本质是接口的实例（万事万物皆对象）&lt;/p&gt;
&lt;p&gt;Lambda表达式的使用，分为六种情况&lt;/p&gt;
&lt;p&gt;1.无参，无返回结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;() -&amp;gt; {重写方法体}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Runnable runnable = () -&amp;gt; System.out.println(&quot;cat&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.需要一个参数，没有返回值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(类型 名称) -&amp;gt; {重写方法体}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Consumer&amp;lt;String&amp;gt; con = (String s) -&amp;gt; {System.out.println(s);}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.数据类型可以省略，因为可以由编译器推断得出&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(名称) -&amp;gt; {重写方法体}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Consumer&amp;lt;String&amp;gt; con = (s) -&amp;gt; {System.out.println(s);}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.若Lambda只需要一个参数，参数小括号也可以省略&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;名称 -&amp;gt; {重写方法体}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Consumer&amp;lt;String&amp;gt; con = s -&amp;gt; {System.out.println(s);}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.Lambda需要两个或以上的参数，执行多条语句，有返回值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(类型 名称, 类型 名称, ...) -&amp;gt; {重写方法语句; return ...;}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Comparator&amp;lt;Integer&amp;gt; comparator = (Integer o1, Integer o2) -&amp;gt; {
    System.out.println(o1);
    System.out.println(o2);
    return Integer.compare(o1, o2);}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;6.当Lambda只有一条语句的时候，大括号可以省略，对return语句return也不用写&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(类型 名称, 类型 名称, ...) -&amp;gt; [return] 重写方法体;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Comparator&amp;lt;Integer&amp;gt; comparator = (Integer o1, Integer o2) -&amp;gt; Integer.compare(o1, o2);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lambda表达式的本质实际上是接口的实例，依赖于函数式接口的实现&lt;/p&gt;
&lt;h2&gt;函数式接口&lt;/h2&gt;
&lt;p&gt;如果一个接口中只有一个方法声明，那么这个接口就是函数式接口，可以使用Lambda表达式来进行代码优化（简化）&lt;/p&gt;
&lt;p&gt;接口一般用注解@FunctionalInterface来标示，只允许声明一个方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test01 {
    public static void main(String[] args) {
        Test test = (String o) -&amp;gt; {
            System.out.println(o);
        };
        test.write(&quot;Jerry&quot;);
    }
}

@FunctionalInterface
interface Test{
    void write(String str);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以匿名内部类实例的创建，都可以用Lambda表达式来创建，在java.utils.function包下定义了Java8的函数式接口&lt;/p&gt;
&lt;h3&gt;内置核心函数式接口&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函数式接口&lt;/th&gt;
&lt;th&gt;参数类型&lt;/th&gt;
&lt;th&gt;返回类型&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;消费型接口Consumer&amp;lt;T&amp;gt;&lt;/td&gt;
&lt;td&gt;T&lt;/td&gt;
&lt;td&gt;void&lt;/td&gt;
&lt;td&gt;方法void accept(T t)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;供给型接口Supplier&amp;lt;T&amp;gt;&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;T&lt;/td&gt;
&lt;td&gt;方法T get()&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;函数型接口Function&amp;lt;T,R&amp;gt;&lt;/td&gt;
&lt;td&gt;T&lt;/td&gt;
&lt;td&gt;R&lt;/td&gt;
&lt;td&gt;方法R apply(T t)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;断定型接口Predicate&amp;lt;T&amp;gt;&lt;/td&gt;
&lt;td&gt;T&lt;/td&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;方法boolean test(T t)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;Consumer&amp;lt;T&amp;gt;&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class Test01 {
    public static void main(String[] args) {
        Consumer&amp;lt;String&amp;gt; comsumer = (s) -&amp;gt; System.out.println(s);
        comsumer.accept(&quot;Jerry&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;Supplier&amp;lt;T&amp;gt;&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class Test01 {
    public static void main(String[] args) {
        Supplier&amp;lt;Integer&amp;gt; supplier = () -&amp;gt; new Integer(13);
        System.out.println(supplier.get());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;Function&amp;lt;T,R&amp;gt;&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class Test01 {
    public static void main(String[] args) {
        Function&amp;lt;Character, Integer&amp;gt; function = (s) -&amp;gt; new Integer(s);
        System.out.println(function.apply(&apos;a&apos;));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;Predicate&amp;lt;T&amp;gt;&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class Test01 {
    public static void main(String[] args) {
        Predicate&amp;lt;String&amp;gt; predicate = (s) -&amp;gt; {
            if (&quot;hello&quot;.equals(s)) {
                return true;
            }
            return false;
        };
        System.out.println(predicate.test(&quot;he&quot;));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;方法引用&lt;/h3&gt;
&lt;p&gt;当要传递给Lambda体的操作以及有实现的方法了，就可以使用方法引用&lt;/p&gt;
&lt;p&gt;要求：实现接口的抽象方法的参数列表和返回值的类型，必须和方法引用的参数列表和返回值保持一致&lt;/p&gt;
&lt;p&gt;格式：使用&quot;::&quot;将类与方法名隔开&lt;/p&gt;
&lt;p&gt;使用场景&lt;/p&gt;
&lt;p&gt;当接口中的抽象方法的形参列表和返回值与方法引用的方法的形参列表和返回值类型相同&lt;/p&gt;
&lt;h4&gt;情况一&lt;/h4&gt;
&lt;p&gt;对象::实例方法&lt;/p&gt;
&lt;p&gt;Consumer 中的 void accept(T t)&lt;/p&gt;
&lt;p&gt;PrintStream 中的 void println(T t)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test02 {
    public static void main(String[] args) {
        Consumer&amp;lt;String&amp;gt; consumer = str -&amp;gt; System.out.println(str);
        consumer.accept(&quot;Hello world&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;类对象为System.out 实例方法是println&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test02 {
    public static void main(String[] args) {
        Consumer&amp;lt;String&amp;gt; consumer = System.out :: println;
        consumer.accept(&quot;Hello world&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;情况二&lt;/h4&gt;
&lt;p&gt;类::静态方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test02 {
    public static void main(String[] args) {
        Comparator&amp;lt;Integer&amp;gt; comparator = (o1, o2) -&amp;gt; Integer.compare(o1, o2);
        System.out.println(comparator.compare(1,3));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public class Test01 {
    public static void main(String[] args) {
        Comparator&amp;lt;Integer&amp;gt; comparator = Integer :: compare;
        System.out.println(comparator.compare(1,3));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;情况三&lt;/h4&gt;
&lt;p&gt;类::实例方法&lt;/p&gt;
&lt;p&gt;前两种使用方式要求：接口中的抽象方法的形参列表和返回值与方法引用的方法的形参列表和返回值类型相同&lt;/p&gt;
&lt;p&gt;而第三种方式可以不严格要求如上的条件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test02 {
    public static void main(String[] args) {
        Comparator&amp;lt;String&amp;gt; comparator = (s1, s2) -&amp;gt; s1.compareTo(s2);
        System.out.println(comparator.compare(&quot;adf&quot;, &quot;dgb&quot;));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;改造为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test02 {
    public static void main(String[] args) {
        Comparator&amp;lt;String&amp;gt; comparator = String :: compareTo;
        System.out.println(comparator.compare(&quot;adf&quot;, &quot;dgb&quot;));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;构造器引用&lt;/h3&gt;
&lt;p&gt;和方法引用类似，函数式接口的抽象方法的形参类型和构造器的形参列表一致&lt;/p&gt;
&lt;p&gt;通过构造器引用可以简化接口返回对应类对象的使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test02 {
    public static void main(String[] args) {
        Supplier&amp;lt;Employee&amp;gt; emp = () -&amp;gt; new Employee();
        System.out.println(emp.get());
    }
}

class Employee {
    @Override
    public String toString() {
        return &quot;Employee&quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public class Test02 {
    public static void main(String[] args) {
        Supplier&amp;lt;Employee&amp;gt; emp = Employee :: new;
        System.out.println(emp.get());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再举一个例子&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test02 {
    public static void main(String[] args) {
        Function&amp;lt;Integer, Employee&amp;gt; emp = (id) -&amp;gt; new Employee(id);
        System.out.println(emp.apply(123));
    }
}

class Employee {
    private int id;

    public Employee(int id) {
        this.id = id;
    }

    @Override
    public String toString() {
        return &quot;Employee &quot; + id;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public class Test02 {
    public static void main(String[] args) {
        Function&amp;lt;Integer, Employee&amp;gt; emp = Employee :: new;
        System.out.println(emp.apply(123));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;数组引用&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;public class Test02 {
    public static void main(String[] args) {
        Function&amp;lt;Integer, String[]&amp;gt; emp = (id) -&amp;gt; new String[id];
        String[] arr = emp.apply(10);
        System.out.println(arr.length);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public class Test02 {
    public static void main(String[] args) {
        Function&amp;lt;Integer, String[]&amp;gt; emp = String[] :: new;
        String[] arr = emp.apply(10);
        System.out.println(arr.length);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Stream API&lt;/h2&gt;
&lt;h3&gt;前置知识&lt;/h3&gt;
&lt;p&gt;Stream API (java.util.stream)把真正的函数式编程风格引入到Java中，可以用Stream API写出高效、干净、简洁的代码&lt;/p&gt;
&lt;p&gt;Stream是Java8中处理集合的关键抽象概念，可以指定你希望对集合进行的操作，可以执行非常复杂的查找，过滤和映射数据操作，类似于SQL对数据库的操作（过滤，排序，映射，规约）&lt;/p&gt;
&lt;p&gt;Stream和Collection集合的区别：Collection是一种静态的内存数据结构，而Stream是有关计算的，前者主要面向内存（存储在内存），后者主要面向CPU（通过CPU计算）&lt;/p&gt;
&lt;h3&gt;注意要点&lt;/h3&gt;
&lt;p&gt;1.Stream自己不会存储元素&lt;/p&gt;
&lt;p&gt;2.Stream不会改变源对象，而会返回一个持有结果的Stream&lt;/p&gt;
&lt;p&gt;3.Stream操作是延迟执行的，意味着他们会等到需要结果的时候才会执行&lt;/p&gt;
&lt;p&gt;大体上分为三个步骤 1.创建流 2.中间操作 3.终止操作&lt;/p&gt;
&lt;h3&gt;Stream创建&lt;/h3&gt;
&lt;h4&gt;获取集合流对象&lt;/h4&gt;
&lt;p&gt;Java8中的Collection接口被扩展，提供两个获取流的方法&lt;/p&gt;
&lt;p&gt;default Stream&amp;lt;E&amp;gt; stream() : 返回一个顺序流&lt;/p&gt;
&lt;p&gt;default Stream&amp;lt;E&amp;gt; parallelStream() : 返回一个并行流&lt;/p&gt;
&lt;p&gt;我们现在有如下的ArrayList集合对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Stream1 {
    public static void main(String[] args) {
        List&amp;lt;Employee&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        Employee person1 = new Employee(&quot;黎明&quot;, 18);
        Employee person2 = new Employee(&quot;丽丽&quot;, 11);
        Employee person3 = new Employee(&quot;黎明&quot;, 18);
        list.add(person1);
        list.add(person2);
        list.add(person3);
        System.out.println(list.size());
    }
}

class Employee {
    String name;
    int age;

    public Employee(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过两个方法获取流&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Employee&amp;gt; stream = list.stream();
//获取顺序流（按照顺序取）
Stream&amp;lt;Employee&amp;gt; employeeStream = list.parallelStream();
//获取并行流（按照多个线程取值）
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;获取数组流对象&lt;/h4&gt;
&lt;p&gt;以下是一个数组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Stream1 {
    public static void main(String[] args) {
        Employee[] employee = new Employee[3];
        Employee person1 = new Employee(&quot;黎明&quot;, 18);
        Employee person2 = new Employee(&quot;丽丽&quot;, 11);
        Employee person3 = new Employee(&quot;黎明&quot;, 18);
        employee[0] = person1;
        employee[1] = person2;
        employee[2] = person3;
    }
}

class Employee {
    String name;
    int age;

    public Employee(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Employee&amp;gt; stream = Arrays.stream(employee);
//通过Arrays的静态方法调用stream创建流实例
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;静态方法创建流&lt;/h4&gt;
&lt;p&gt;用于直接用数据创建流&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Employee&amp;gt; stream = Stream.of(person1, person2, person3);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;无限流&lt;/p&gt;
&lt;p&gt;迭代&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Integer&amp;gt; limit = Stream.iterate(0, t -&amp;gt; t + 2).limit(10);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Stream.iterate(0, t -&amp;gt; t + 2).limit(10).forEach(System.out :: println);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;生成&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Double&amp;gt; limit = Stream.generate(Math::random).limit(10);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Stream.generate(Math :: random).limit(10).forEach(System.out :: println);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Stream中间操作&lt;/h3&gt;
&lt;h4&gt;筛选与切片&lt;/h4&gt;
&lt;h5&gt;filter 筛选流&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Employee&amp;gt; stream = list.stream();
Stream&amp;lt;Employee&amp;gt; employeeStream = stream.filter(e -&amp;gt; e.age &amp;gt; 11);
employeeStream.forEach(System.out :: println);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用filter传入一个判断的Predicate函数式接口，筛选出年龄大于11的Employee对象&lt;/p&gt;
&lt;p&gt;再用终结操作forEach输出结果，这也是一个方法引用&lt;/p&gt;
&lt;h5&gt;limit 截断流&lt;/h5&gt;
&lt;p&gt;只保留几个数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Employee&amp;gt; stream = list.stream();
Stream&amp;lt;Employee&amp;gt; employeeStream = stream.limit(2);
employeeStream.forEach(System.out :: println);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意这里一旦执行了forEach流就结束，不可以再使用中间操作&lt;/p&gt;
&lt;h5&gt;skip 跳过元素&lt;/h5&gt;
&lt;p&gt;跳过前面几个数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Employee&amp;gt; stream = list.stream();
Stream&amp;lt;Employee&amp;gt; employeeStream = stream.skip(1);
employeeStream.forEach(System.out :: println);
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;distinct 筛选&lt;/h5&gt;
&lt;p&gt;和数据库筛选一样，去重&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Employee&amp;gt; stream = list.stream();
Stream&amp;lt;Employee&amp;gt; employeeStream = stream.distinct();
employeeStream.forEach(System.out :: println);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;映射&lt;/h4&gt;
&lt;h5&gt;map(Function f)&lt;/h5&gt;
&lt;p&gt;接收一个函数作为参数将元素转化为其他形式提取信息（类比于add）&lt;/p&gt;
&lt;p&gt;将List中字符串大写&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;List&amp;lt;String&amp;gt; list = Arrays.asList(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;, &quot;dd&quot;);
Stream&amp;lt;String&amp;gt; stream = list.stream();
stream.map(str -&amp;gt; str.toUpperCase()).forEach(System.out :: println);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;过滤出名字长度大于2的名字（先用map取出name，再用filter过滤）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Employee&amp;gt; stream = list.stream();
stream.map(e -&amp;gt; e.name).filter(str -&amp;gt; str.length() &amp;gt; 2).forEach(System.out :: println);
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;flatMap(Function f)&lt;/h5&gt;
&lt;p&gt;将流中的每一个值都换成另一个流，再将所有的流连接成一个流（类比于addALL）&lt;/p&gt;
&lt;p&gt;和上面的map相比将每个元素取出，转换后再连接&lt;/p&gt;
&lt;p&gt;在对于集合里面嵌套集合的时候使用方便&lt;/p&gt;
&lt;h4&gt;排序&lt;/h4&gt;
&lt;h5&gt;sorted()&lt;/h5&gt;
&lt;p&gt;产生一个新流，其中按自然顺序排序（对于实现Comparable接口的对象可以使用）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Employee&amp;gt; stream = list.stream();
stream.sorted().forEach(System.out :: println);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;按照类中的接口方法排序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
public int compareTo(Object o) {
    Employee e = (Employee) o;
    return this.age - e.age;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;sorted(Comparator com)&lt;/h5&gt;
&lt;p&gt;产生一个新流，其中按比较器顺序排序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Employee&amp;gt; stream = list.stream();
stream.sorted(
        (e1, e2) -&amp;gt; {
            return e1.age - e2.age;
        }
).forEach(System.out :: println);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Stream终止操作&lt;/h3&gt;
&lt;h4&gt;匹配查找&lt;/h4&gt;
&lt;p&gt;allMatch&lt;/p&gt;
&lt;p&gt;检查是否匹配所有元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Employee&amp;gt; stream = list.stream();
boolean b = stream.allMatch(e -&amp;gt; e.age &amp;gt; 15);
System.out.println(b);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;anyMatch&lt;/p&gt;
&lt;p&gt;检查一个匹配&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Employee&amp;gt; stream = list.stream();
boolean b = stream.allMatch(e -&amp;gt; e.age &amp;gt; 15);
System.out.println(b);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;noneMatch&lt;/p&gt;
&lt;p&gt;检查是否没有匹配元素，例如是否有员工姓“尚”&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Employee&amp;gt; stream = list.stream();
boolean b = stream.noneMatch(e -&amp;gt; e.name.startsWith(&quot;尚&quot;));
System.out.println(b);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;findFirst&lt;/p&gt;
&lt;p&gt;返回第一个元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Employee&amp;gt; stream = list.stream();
Optional&amp;lt;Employee&amp;gt; first = stream.findFirst();
System.out.println(first);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;findAny&lt;/p&gt;
&lt;p&gt;返回任意一个元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Employee&amp;gt; stream = list.stream();
Optional&amp;lt;Employee&amp;gt; first = stream.findAny();
System.out.println(first);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;count&lt;/p&gt;
&lt;p&gt;求个数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Employee&amp;gt; stream = list.stream();
long count = stream.count();
System.out.println(count);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;min&lt;/p&gt;
&lt;p&gt;返回元素最小值（要求传入Comparator）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Employee&amp;gt; stream = list.stream();
Optional&amp;lt;Employee&amp;gt; min = stream.min(
        (e1, e2) -&amp;gt; {
            return e1.age - e2.age;
        }
);
System.out.println(min);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;max&lt;/p&gt;
&lt;p&gt;返回元素最大值（要求传入Comparator）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Optional&amp;lt;Employee&amp;gt; max = stream.max(
        (e1, e2) -&amp;gt; {
            return e1.age - e2.age;
        }
);
System.out.println(max);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;forEach&lt;/p&gt;
&lt;p&gt;内部迭代&lt;/p&gt;
&lt;p&gt;传入Consumer c，以下是经典的输出遍历&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Employee&amp;gt; stream = list.stream();
stream.forEach(System.out :: println);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;规约&lt;/h4&gt;
&lt;p&gt;reduce(T identity, BinaryOperator)&lt;/p&gt;
&lt;p&gt;可以将流中的元素反复结合起来，得到一个值，返回这个值&lt;/p&gt;
&lt;p&gt;计算1-10的和（其中0为初始值）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Stream1 {
    public static void main(String[] args) {
        List&amp;lt;Integer&amp;gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        Integer reduce = list.stream().reduce(0, (i1, i2) -&amp;gt; i1 + i2);
        //Integer reduce = list.stream().reduce(0, Integer::sum);
        System.out.println(reduce);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;reduce(BinaryOperator)&lt;/p&gt;
&lt;p&gt;计算所有员工年龄总和&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Employee&amp;gt; stream = list.stream();
Optional&amp;lt;Integer&amp;gt; reduce = stream.map(e -&amp;gt; e.age).reduce(Integer::sum);
System.out.println(reduce);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;收集&lt;/h4&gt;
&lt;p&gt;collect(Collector c)&lt;/p&gt;
&lt;p&gt;将流转换为其他形式，接收一个Collector接口的实现，用于给Stream中元素做汇总的方法&lt;/p&gt;
&lt;p&gt;放入List中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;List&amp;lt;Employee&amp;gt; collect = stream.sorted(
        (e1, e2) -&amp;gt; {
            return e1.age - e2.age;
        }
).collect(Collectors.toList());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;放入Set中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Set&amp;lt;Employee&amp;gt; collect = stream.sorted(
        (e1, e2) -&amp;gt; {
            return e1.age - e2.age;
        }
).collect(Collectors.toSet());
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Optional类&lt;/h2&gt;
&lt;h3&gt;基本介绍&lt;/h3&gt;
&lt;p&gt;之前在使用Stream API的时候使用到了Optional类来存储流输出的对象&lt;/p&gt;
&lt;p&gt;Optional&amp;lt;T&amp;gt;是一个容器类，他可以保存类型T的值，代表这个值存在，或者保存null，表示这个值不存在&lt;/p&gt;
&lt;p&gt;原本的null表示一个值不存在，现在Optional可以更好地表示这个概念，并避免空指针异常&lt;/p&gt;
&lt;p&gt;Optional类的Javadoc描述如下：这是一个可以为null的容器对象，如果值存在则isPresent()方法返回true，调用get()方法会返回该对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public final class Optional&amp;lt;T&amp;gt; {
    private static final Optional&amp;lt;?&amp;gt; EMPTY = new Optional&amp;lt;&amp;gt;();
    private final T value;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;相关方法&lt;/h3&gt;
&lt;h4&gt;创建方法&lt;/h4&gt;
&lt;p&gt;Optional.of(T t)&lt;/p&gt;
&lt;p&gt;创建一个Optional实例，t必须非空&lt;/p&gt;
&lt;p&gt;Optional.empty()&lt;/p&gt;
&lt;p&gt;创建一个空的Optional实例&lt;/p&gt;
&lt;p&gt;Optional.ofNullable(T t)&lt;/p&gt;
&lt;p&gt;创建一个Optional实例，t可以为空&lt;/p&gt;
&lt;h4&gt;判断包含&lt;/h4&gt;
&lt;p&gt;boolean isPresent()&lt;/p&gt;
&lt;p&gt;判断是否包含对象&lt;/p&gt;
&lt;p&gt;void isPresent(Consumer&amp;lt;? super T&amp;gt; consumer)&lt;/p&gt;
&lt;p&gt;如果包含对象，就执行Consumer接口的实现代码，并且将该值作为参数传递给它&lt;/p&gt;
&lt;h4&gt;获取对象&lt;/h4&gt;
&lt;p&gt;T get()&lt;/p&gt;
&lt;p&gt;如果调用对象包含值，则返回该值，否则抛出异常&lt;/p&gt;
&lt;p&gt;T orElse(T other)&lt;/p&gt;
&lt;p&gt;如果有值则将其返回，否则返回指定的other对象&lt;/p&gt;
&lt;p&gt;T orElseGet(Supplier&amp;lt;? extends T&amp;gt; other)&lt;/p&gt;
&lt;p&gt;如果有值则返回，否则调用Supplier接口实现提供的对象&lt;/p&gt;
&lt;p&gt;T orElse Throw(Supplier&amp;lt;? extends X exceptionSupplier&amp;gt;)&lt;/p&gt;
&lt;p&gt;如果有值则将其返回，否则抛出由Supplier接口实现提供的异常&lt;/p&gt;
&lt;h3&gt;代码示例&lt;/h3&gt;
&lt;p&gt;在没有Optional类的时候，我们需要通过if判断语句判断对象不为空，再去调用方法，防止空指针异常，我们在学了Optional类后我们就可以用Optional去包装类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Optional&amp;lt;Employee&amp;gt; optional = Optional.of(new Employee(&quot;李&quot;, 10));
optional.orElse(new Employee(&quot;王&quot;, 10)).toString();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果没有数据，就用新创建的Employee，调用相关方法&lt;/p&gt;
&lt;p&gt;Optional其实在实际使用上没有多少的内容，主要是有一些底层框架上会使用到Optional来返回结果，懂得如何操作数据对象，看得懂相关操作即可。&lt;/p&gt;
</content:encoded></item><item><title>JDBC笔记</title><link>https://thrinisty.github.io/posts/jdbc%E7%AC%94%E8%AE%B0%E6%89%B9%E5%A4%84%E7%90%86%E8%BF%9E%E6%8E%A5%E6%B1%A0dbutilsbasicdao/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/jdbc%E7%AC%94%E8%AE%B0%E6%89%B9%E5%A4%84%E7%90%86%E8%BF%9E%E6%8E%A5%E6%B1%A0dbutilsbasicdao/</guid><description>批处理，连接池，DBUtils，BasicDao</description><pubDate>Fri, 18 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;JDBC笔记&lt;/h1&gt;
&lt;h2&gt;批处理&lt;/h2&gt;
&lt;h3&gt;基本介绍&lt;/h3&gt;
&lt;p&gt;1.当需要成批插入或者更新记录的时候，可以使用Java批处理，这一机制允许多条语句一次性提交给数据库批量处理，通常情况下比单独提交更有效率&lt;/p&gt;
&lt;p&gt;2.JDBC的批量处理语句包括了以下的方法&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方法名称&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;addBatch&lt;/td&gt;
&lt;td&gt;添加需要批量处理的SQL语句或者参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;executeBatch&lt;/td&gt;
&lt;td&gt;执行批量处理语句&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;clearBatch&lt;/td&gt;
&lt;td&gt;清空批处理包的语句&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;3.JDBC连接MySQL时，如果要使用批处理，需要在url中添加参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;?rewriteBatchedStatements=true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.批处理往往与PreparedStatement一起搭配使用，可以及减少编译次数又减少运行次数，效率大大提升&lt;/p&gt;
&lt;h3&gt;传统的添加方式&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;public class Test {
    @SuppressWarnings ({&quot;all&quot;})
    public static void main(String[] args) throws Exception{
        Connection connection = JDBCUtils.getConnection();
        String sql = &quot;insert into balance values (?,?,?)&quot;;
        PreparedStatement statement = connection.prepareStatement(sql);

        for (int i = 1; i &amp;lt; 1000; i++) {
            statement.setInt(1, i);
            statement.setString(2, &quot;TomCat&quot;);
            statement.setDouble(3, i * 2);
            statement.executeUpdate();
        }
        JDBCUtils.close(null, statement, connection);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;耗时还是挺久的大概6、7秒钟完成，感兴趣可以输出运行时间测试一下&lt;/p&gt;
&lt;h3&gt;批处理运行&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;public class Test {
    @SuppressWarnings ({&quot;all&quot;})
    public static void main(String[] args) throws Exception{
        Connection connection = JDBCUtils.getConnection();
        String sql = &quot;insert into balance values (?,?,?)&quot;;
        PreparedStatement statement = connection.prepareStatement(sql);

        for (int i = 1; i &amp;lt; 1000; i++) {
            statement.setInt(1, i);
            statement.setString(2, &quot;TomCat&quot;);
            statement.setDouble(3, i * 2);
            statement.addBatch();
            if((i + 1) % 1000 == 0) {
                statement.executeBatch();
                statement.clearBatch();
            }
        }
        JDBCUtils.close(null, statement, connection);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意在JDBCUtils工具类中的url添加相关参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;String url = agreement + &quot;//&quot; + address + &quot;:&quot; + port + &quot;/&quot; + dataBase + &quot;?rewriteBatchedStatements=true&quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运用批处理在处理大量的SQL语句的时候，速度相较于单条执行要快很多，大概的用时只需要1、2秒钟&lt;/p&gt;
&lt;h2&gt;连接池&lt;/h2&gt;
&lt;h3&gt;连接池的引入&lt;/h3&gt;
&lt;p&gt;在传统的连接方式中往往程序和数据库进行网络的连接是多次的，这张方式的连接数上限往往是有限制的，在太多的连接的时候和数据库连接取得Connection的时候会抛出Too many connection的异常，就算及时关闭连接，连接的时长也会很长&lt;/p&gt;
&lt;p&gt;问题分析&lt;/p&gt;
&lt;p&gt;1.传统的JDBC数据库连接使用DriverManager来获取，每一次向数据库建立连接的时候都要将Connection加载到内存中，再验证IP地址，用户名，密码（0.05-1s）。需要数据库链接的时候，就会向数据库要求一个，频繁的进行数据库连接操作将占用很多的系统资源，容易造成服务器崩溃&lt;/p&gt;
&lt;p&gt;2.每一次数据库连接，使用完后都得断开，如果程序出现异常未能关闭，将导致数据库内存泄漏，最终导致重启数据库&lt;/p&gt;
&lt;p&gt;3.传统获取连接的方式，不能控制创建的连接数量，如果连接过多，也可能导致内存泄漏，数据库崩溃&lt;/p&gt;
&lt;p&gt;4.解决传统开发中的数据库连接问题，可以采用数据库连接池技术（connection pool）&lt;/p&gt;
&lt;h3&gt;基本介绍&lt;/h3&gt;
&lt;p&gt;1.预先在缓冲池中放入一定数量的连接，当需要建立数据据库连接的时候，只需要从缓冲池中取出连接，使用完毕的时候再将连接放回缓冲池中即可&lt;/p&gt;
&lt;p&gt;2.数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用现有的数据库连接，而不是重新建立一个&lt;/p&gt;
&lt;p&gt;3.当应用程序向连接池请求的连接数超过最大连接数的时候，这些请求将被添加入等待队列&lt;/p&gt;
&lt;h3&gt;数据库连接池种类&lt;/h3&gt;
&lt;p&gt;1.JDBC的数据库连接池使用javax.sql.DataSource表示，DataSource是一个接口，通常由第三方来实现&lt;/p&gt;
&lt;p&gt;2.&lt;strong&gt;C3P0&lt;/strong&gt;数据库连接池，速度相对较慢，但是稳定性不错（hibernate，spring）&lt;/p&gt;
&lt;p&gt;3.DBCP数据库连接池，速度相比于C3P0较快，但是不稳定&lt;/p&gt;
&lt;p&gt;4.Proxool数据库连接处，有监控连接池状态的功能，稳定性较C3P0差一点&lt;/p&gt;
&lt;p&gt;5.BoneCP数据库连接池，速度快&lt;/p&gt;
&lt;p&gt;6.&lt;strong&gt;Druid&lt;/strong&gt;（德鲁伊）是由阿里提供的数据库连接池，集以上（C3P0、DBCP、Proxool）数据库优点于一体的数据库连接池&lt;/p&gt;
&lt;p&gt;C3P0和德鲁伊连接池是目前经常会使用的连接池，我们接下来使用的也是这两个&lt;/p&gt;
&lt;h3&gt;C3P0连接池&lt;/h3&gt;
&lt;p&gt;注意在连接池中的close不是指的是将连接断开，而是将连接放回到连接池中，供下一个getConnection使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void test01() throws Exception{
    ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource();
    String agreement = &quot;jdbc:mysql:&quot;;
    String address = &quot;localhost&quot;;
    String port = &quot;3306&quot;;
    String dataBase = &quot;jdbc&quot;;
    String url = agreement + &quot;//&quot; + address + &quot;:&quot; + port + &quot;/&quot; + dataBase;
    String user = &quot;root&quot;;
    String password = &quot;654321&quot;;
    String driver = &quot;com.mysql.cj.jdbc.Driver&quot;;

    //设置连接池基础信息
    comboPooledDataSource.setDriverClass(driver);
    comboPooledDataSource.setJdbcUrl(url);
    comboPooledDataSource.setUser(user);
    comboPooledDataSource.setPassword(password);

    //初始化连接数
    comboPooledDataSource.setInitialPoolSize(10);
    comboPooledDataSource.setMaxPoolSize(50);

    //从连接池中获取连接
    Connection connection = comboPooledDataSource.getConnection();
    connection.close();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果通过这种方式创建连接相比于JDBC的从DriverManager获取连接要快很多&lt;/p&gt;
&lt;p&gt;除此之外你还可以使用配置文件设置连接池的基础信息（在创建连接池对象的时候指定配置文件参数），感兴趣的可以下去了解&lt;/p&gt;
&lt;h3&gt;Druid连接池&lt;/h3&gt;
&lt;h4&gt;连接池基本配置&lt;/h4&gt;
&lt;p&gt;我们在使用Druid连接池的时候需要使用到配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 数据库连接配置
driverClassName=com.mysql.cj.jdbc.Driver
url=jdbc:mysql://localhost:3306/tableselect?useSSL=false&amp;amp;serverTimezone=UTC&amp;amp;characterEncoding=utf8
username=root
password=654321

# 连接池核心参数
initialSize=10
maxActive=50
minIdle=5
maxWait=60000
#maxWait指的是等待队列中最长的等待时间
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;连接池使用&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class Druid_ {
    public static void main(String[] args) throws Exception {
        testDruid();
    }

    public static void testDruid() throws Exception {
        Properties properties = new Properties();
        properties.load(new FileInputStream(&quot;src\\druid.properties&quot;));
        //创建连接池对象
        DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);
        //过去Connection连接
        Connection connection = dataSource.getConnection();
        connection.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Druid速度非常快，目前而言能用Druid尽量别用C3P0，除非要进行兼容&lt;/p&gt;
&lt;h4&gt;工具类封装&lt;/h4&gt;
&lt;p&gt;便于使用者使用，我们将德鲁伊连接池做成一个工具类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.utils;
import com.alibaba.druid.pool.DruidDataSourceFactory;
import javax.sql.DataSource;
import java.io.FileInputStream;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Properties;

public class JDBCUtilsDruid {
    private static DataSource ds;

    static {
        Properties properties = new Properties();
        try {
            properties.load(new FileInputStream(&quot;src\\druid.properties&quot;));
            ds = DruidDataSourceFactory.createDataSource(properties);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    public static Connection getConnection() {
        try {
            return ds.getConnection();
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    public static void close(ResultSet result, Statement statement, Connection connection) {
        try {
            if (result != null) {
                result.close();
            }
            if (statement != null) {
                statement.close();
            }
            if (connection != null) {
                connection.close();
            }
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用测试方法调用，这样做会方便很多&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void testUtils() {
    Connection connection = JDBCUtilsDruid.getConnection();
    JDBCUtilsDruid.close(null, null, connection);
    //这里用的是工具类的close方法
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再多说一嘴，其实这种情况下使用connection.close()方法关闭连接也没有问题，因为通过动态绑定机制，connection实际上调用的是德鲁伊的close方法。这个方法和通过DriverManager创建的连接调用的close方法有本质的区别，不会将链接关闭，而是将连接放回连接池中&lt;/p&gt;
&lt;h2&gt;DBUtils&lt;/h2&gt;
&lt;h3&gt;问题引出&lt;/h3&gt;
&lt;p&gt;当我们关闭connection后，resultSet结果集无法使用（二者相关联），而有的时候我们需要复用resultSet中的数据，关闭connection后任需要结果集&lt;/p&gt;
&lt;p&gt;resultSet不利于数据的管理，使用起来也不太方便，这个时候我们需要再Java程序中创建一个类（JavaBean）与数据库的记录做一个映射，再创建一个结果集记录封装在ArrayList&amp;lt;JavaBean&amp;gt;下，每一个集合元素对应一条记录&lt;/p&gt;
&lt;p&gt;这样的话我们使用类来获取数据就会方便一些，而且生命期更加持久，可以在不用的时候再将ArrayList集合对象释放（以上的思路可以去自己实现，以下是一个Apache提供的一个工具类，相比于自己写的更加完善方便）&lt;/p&gt;
&lt;h3&gt;commons-dbutils&lt;/h3&gt;
&lt;h4&gt;基本介绍&lt;/h4&gt;
&lt;p&gt;commons-dbutils是Apache组织提供的一个开源JDBC工具类库，它是对JDBC的封装，使用dbutils可以极大地简化JDBC编码的工作量&lt;/p&gt;
&lt;h4&gt;DBUtils类&lt;/h4&gt;
&lt;p&gt;1.QueryRunner类：该类封装了SQL的执行，是线程安全的，可以实现增删改查，批处理&lt;/p&gt;
&lt;p&gt;2.ResultSetHandler接口：该接口用于处理ResultSet，将数据按要求转化为另一种形式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/123.png&quot; alt=&quot;123&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;构造返回记录类型&lt;/h4&gt;
&lt;p&gt;要使这个自动映射正常工作，&lt;code&gt;Balance&lt;/code&gt;类需要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是一个标准的JavaBean（有无参构造函数）&lt;/li&gt;
&lt;li&gt;有与数据库列名对应的属性&lt;/li&gt;
&lt;li&gt;有这些属性的setter方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;构造一个Balance接收返回结果的类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Balance {
    private int id;
    private String name;
    private String money;
    public Balance(){}

    @Override
    public String toString() {
        return id + &quot; &quot; + name + &quot; &quot; + money;
    }

    public void setId(int id) {
        this.id = id;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setMoney(String money) {
        this.money = money;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;查询结果&lt;/h4&gt;
&lt;p&gt;利用QueryRunner对象查询数据库返回结果&lt;/p&gt;
&lt;p&gt;返回单条单列的记录（返回一个Object对象）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Druid_ {
    public static void main(String[] args) throws Exception {
        Connection connection = JDBCUtilsDruid.getConnection();
        QueryRunner queryRunner = new QueryRunner();
        //通过使用queryRunner就可以查询数据库，返回结果
        String sql = &quot;select `name` from balance where id = ?;&quot;;
        String name = (String) queryRunner.query(connection, sql, new ScalarHandler(), 100);
        System.out.println(name);
        connection.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;返回单条记录（返回一个对应的Balance对象）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Druid_ {
    public static void main(String[] args) throws Exception {
        Connection connection = JDBCUtilsDruid.getConnection();
        QueryRunner queryRunner = new QueryRunner();
        //通过使用queryRunner就可以查询数据库，返回结果
        String sql = &quot;select * from balance where id = ?;&quot;;
        Balance balance = queryRunner.query(connection, sql, new BeanHandler&amp;lt;&amp;gt;(Balance.class), 100);
        System.out.println(balance);
        connection.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;返回多条结果（返回一个存放了Balance对象的ArrayList）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Druid_ {
    public static void main(String[] args) throws Exception {
        Connection connection = JDBCUtilsDruid.getConnection();
        QueryRunner queryRunner = new QueryRunner();
        //通过使用queryRunner就可以查询数据库，返回结果
        String sql = &quot;select * from balance where id = ? or id = ?;&quot;;
        List&amp;lt;Balance&amp;gt; list = queryRunner.query(connection, sql, new BeanListHandler&amp;lt;&amp;gt;(Balance.class), 100, 200);
        //这里的100和200是可变参数，代表填入的替换？的内容
        Iterator&amp;lt;Balance&amp;gt; iterator = list.iterator();
        while(iterator.hasNext()) {
            Balance balance = iterator.next();
            System.out.println(balance);
        }
        connection.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果步入源码中我们可以发现在query方法执行获取ArrayList结果集的过程中用到的Statement和ResultSet就已经被关闭&lt;/p&gt;
&lt;p&gt;而返回的结果类型取决于第三个参数的类型，其中result返回结果底层运用到了泛型来确定result的返回类型（更具不同的参数类型有不同的处理逻辑）&lt;/p&gt;
&lt;h4&gt;增删改&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class Druid_ {
    public static void main(String[] args) throws Exception {
        Connection connection = JDBCUtilsDruid.getConnection();
        QueryRunner queryRunner = new QueryRunner();
        //通过使用queryRunner就可以查询数据库，返回结果
        String sql = &quot;insert into balance values (300, &apos;Tom&apos;, 4000), (400, &apos;King&apos;, 5000);&quot;;
        int update = queryRunner.update(connection, sql);
        System.out.println(update);
        connection.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public class Druid_ {
    public static void main(String[] args) throws Exception {
        Connection connection = JDBCUtilsDruid.getConnection();
        QueryRunner queryRunner = new QueryRunner();
        //通过使用queryRunner就可以查询数据库，返回结果
        String sql = &quot;delete from balance;&quot;;
        int update = queryRunner.update(connection, sql);
        System.out.println(update);
        connection.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public class Druid_ {
    public static void main(String[] args) throws Exception {
        Connection connection = JDBCUtilsDruid.getConnection();
        QueryRunner queryRunner = new QueryRunner();
        //通过使用queryRunner就可以查询数据库，返回结果
        String sql = &quot;update balance set name = &apos;Cat&apos;&quot;;
        int update = queryRunner.update(connection, sql);
        //返回的结果是受影响的行数
        System.out.println(update);//2
        connection.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;BasicDao&lt;/h2&gt;
&lt;h3&gt;问题引出&lt;/h3&gt;
&lt;p&gt;1.SQL语句是固定的，不可以通过参数传入，使用起来不灵活&lt;/p&gt;
&lt;p&gt;2.对于select操作，返回类型不确定，需要使用到泛型&lt;/p&gt;
&lt;p&gt;3.对于很多表而言，业务负责不可能单靠一个Java类完成&lt;/p&gt;
&lt;h3&gt;Dao&lt;/h3&gt;
&lt;p&gt;data access object 数据访问对象&lt;/p&gt;
&lt;p&gt;我们对于每一个表都会有相应的操作，我们可以将这一些操作的共有部分提到BasicDao中，这样做可以简化代码，维护可读性&lt;/p&gt;
&lt;p&gt;1.这样的通用类我们称为BasicDao，是专门和数据库交互的，即完成数据库的增删改查操作&lt;/p&gt;
&lt;p&gt;2.再BasicDao的基础上，实现一张表对应一个Dao，可以更好的完成功能&lt;/p&gt;
&lt;p&gt;接下来我们就通过代码实际实现Dao&lt;/p&gt;
&lt;h3&gt;Dao实现&lt;/h3&gt;
&lt;p&gt;设计com.dao&lt;/p&gt;
&lt;h4&gt;com.dao.utils&lt;/h4&gt;
&lt;p&gt;工具类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class JDBCUtilsDruid {
    private static DataSource ds;

    static {
        Properties properties = new Properties();
        try {
            properties.load(new FileInputStream(&quot;src\\druid.properties&quot;));
            ds = DruidDataSourceFactory.createDataSource(properties);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    public static Connection getConnection() {
        try {
            return ds.getConnection();
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    public static void close(ResultSet result, Statement statement, Connection connection) {
        try {
            if (result != null) {
                result.close();
            }
            if (statement != null) {
                statement.close();
            }
            if (connection != null) {
                connection.close();
            }
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;com.dao.domain&lt;/h4&gt;
&lt;p&gt;javabean&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Balance {
    private int id;
    private String name;
    private String money;
    public Balance(){}

    @Override
    public String toString() {
        return id + &quot; &quot; + name + &quot; &quot; + money;
    }

    public void setId(int id) {
        this.id = id;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setMoney(String money) {
        this.money = money;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;com.dao.dao&lt;/h4&gt;
&lt;p&gt;存放BasicDao&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class BasicDao&amp;lt;T&amp;gt; {//使用泛型指定具体类型
    private QueryRunner qr = new QueryRunner();

    //开发通用的dml方法，针对任意的表
    public int update(String sql, Object... parameters) {
        Connection connection = null;
        try {
            connection = JDBCUtilsDruid.getConnection();
            return qr.update(connection, sql, parameters);
            //返回受影响的行数，执行语句
        } catch (Exception e) {
            throw new RuntimeException(e);
        } finally {
            JDBCUtilsDruid.close(null, null, connection);
        }
    }

    //返回对个查询对象
    public List&amp;lt;T&amp;gt; queryMulti(String sql, Class&amp;lt;T&amp;gt; cls, Object... parameters) {
        Connection connection = null;
        try {
            connection = JDBCUtilsDruid.getConnection();
            return qr.query(connection, sql, new BeanListHandler&amp;lt;T&amp;gt;(cls), parameters);
        } catch (Exception e) {
            throw new RuntimeException(e);
        } finally {
            JDBCUtilsDruid.close(null, null, connection);
        }
    }

    //返回查询单行结果
    public T querySingle(String sql, Class&amp;lt;T&amp;gt; cls, Object... parameters) {
        Connection connection = null;
        try {
            connection = JDBCUtilsDruid.getConnection();
            return qr.query(connection, sql, new BeanHandler&amp;lt;T&amp;gt;(cls), parameters);
        } catch (Exception e) {
            throw new RuntimeException(e);
        } finally {
            JDBCUtilsDruid.close(null, null, connection);
        }
    }

    //查询单行单列的方法
    public Object queryScalar(String sql, Object... parameters) {
        Connection connection = null;
        try {
            connection = JDBCUtilsDruid.getConnection();
            return qr.query(connection, sql, new ScalarHandler(), parameters);
        } catch (Exception e) {
            throw new RuntimeException(e);
        } finally {
            JDBCUtilsDruid.close(null, null, connection);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来我们根据BasicDao来开发针对于balance表的Dao，制定了前面我们设计的BasicDao的泛型T为Balance类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class BalanceDao extends BasicDao&amp;lt;Balance&amp;gt;{
    //拥有BasicDao方法
    //除此之外还可以自定义其他的方法
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看出在没有特殊要求的情况下，我们只需要在继承的时候指定泛型类型即可创建出新的对应表Dao，非常的方便&lt;/p&gt;
&lt;h4&gt;com.dao.test&lt;/h4&gt;
&lt;p&gt;测试类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class TestDao {
    public static void main(String[] args) {
        BalanceDao balanceDao = new BalanceDao();

        String sql = &quot;select * from balance&quot;;
        List&amp;lt;Balance&amp;gt; balances = balanceDao.queryMulti(sql, Balance.class);
        for(Balance balance : balances) {
            System.out.println(balance);
        }

        sql = &quot;select * from balance where id = ?&quot;;
        Balance balance = balanceDao.querySingle(sql, Balance.class, 100);
        System.out.println(balance);

        sql = &quot;select name from balance where id = 100&quot;;
        String name =(String) balanceDao.queryScalar(sql);
        System.out.println(name);

        sql = &quot;insert into balance values (300, &apos;Tom&apos;, 4000), (400, &apos;King&apos;, 5000);&quot;;
        int update = balanceDao.update(sql);
        System.out.println(update);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看的出来还是非常方便的啊&lt;/p&gt;
&lt;h4&gt;补充&lt;/h4&gt;
&lt;p&gt;其实你要在方便一点（不想要传入Balance.class）的话还可以在BasicDao中用反射获取T类对象，将类对象传入&lt;/p&gt;
&lt;h1&gt;JDBC结语&lt;/h1&gt;
&lt;p&gt;两天的时间，学的还是挺快的，过了一遍代码，学会了使用方式，对于JDBC，连接池，DB工具，自建BasicDao有了初步的认识，对于底层的代码看了一眼，不算完全掌握&lt;/p&gt;
&lt;p&gt;反思了以下自己泛型的部分掌握还不足，决定回宿舍复习一下泛型相关的内容&lt;/p&gt;
&lt;p&gt;明天打算开始Java8特性的学习，计划三天完成，估计我的有一个面试在三天之后，面试结束再决定Java8后学哪一个开发框架，在此之前先准备下面试，背下八股之类的&lt;/p&gt;
</content:encoded></item><item><title>JDBC笔记</title><link>https://thrinisty.github.io/posts/jdbc%E7%AC%94%E8%AE%B0%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%89%A7%E8%A1%8C%E5%AF%B9%E8%B1%A1sql%E6%B3%A8%E5%85%A5%E5%B0%81%E8%A3%85%E4%BA%8B%E5%8A%A1/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/jdbc%E7%AC%94%E8%AE%B0%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%89%A7%E8%A1%8C%E5%AF%B9%E8%B1%A1sql%E6%B3%A8%E5%85%A5%E5%B0%81%E8%A3%85%E4%BA%8B%E5%8A%A1/</guid><description>快速入门，执行对象，SQL注入，封装，事务</description><pubDate>Thu, 17 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;JDBC笔记&lt;/h1&gt;
&lt;h2&gt;JDBC&lt;/h2&gt;
&lt;p&gt;JDBC是JAVA程序操作数据库的一种技术，在绝大多数的框架中JDBC一般都被封装在了各式各样的框架之中，这些框架之后也会学习。但是掌握JDBC是如何连接数据库，操作数据库，返回数据库结果，使用数据库返回结果这也是一个后端开发者应该掌握的基础，掌握了之后对后续框架的理解也是一种帮助&lt;/p&gt;
&lt;p&gt;Java对于各大数据库厂商提供了一个连接操作的统一接口，其中定义的方法包括了连接、curd、关闭连接等。而数据库工资负责实现这一些接口，方便Java的开发者利用数据库接口去创建对应数据库实例的创建，再通过动态绑定机制调用数据库实现的相关方法，以下是一个代码示例方便理解（仅仅是模拟，不代表实际开发）&lt;/p&gt;
&lt;p&gt;Java数据库接口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface JdbcInterface {
    public Object getConnection();
    public void crud();
    public void close();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;数据库实现接口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class MysqlJdbcImpl implements JdbcInterface{
    @Override
    public Object getConnection() {
        System.out.println(&quot;连接数据库&quot;);
        return null;
    }

    @Override
    public void crud() {
        System.out.println(&quot;增删改查&quot;);
    }

    @Override
    public void close() {
        System.out.println(&quot;关闭数据库&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在实际操作的时候可以创建数据库的对象实例，再调用相关方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test {
    public static void main(String[] args) {
        JdbcInterface jdbc = new MysqlJdbcImpl();
        jdbc.getConnection();
        jdbc.crud();
        jdbc.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这也是接口编程的一个极大优势，无需要更改接口定义，只需要让各自的工具实现公开的接口，就可以完成调用&lt;/p&gt;
&lt;h2&gt;JDBC快速入门&lt;/h2&gt;
&lt;p&gt;其中我们要用到的有两个包，一个是 java.sql 另一个是 javax.sql&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/121.png&quot; alt=&quot;121&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/122.png&quot; alt=&quot;122&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;JDBC编写的步骤&lt;/h3&gt;
&lt;p&gt;1.注册驱动-加载Driver类&lt;/p&gt;
&lt;p&gt;2.获取连接-得到Connection&lt;/p&gt;
&lt;p&gt;3.执行增删改查-执行sql语句&lt;/p&gt;
&lt;p&gt;4.释放资源-关闭释放&lt;/p&gt;
&lt;h3&gt;程序示例&lt;/h3&gt;
&lt;p&gt;我们通过jdbc对dept表进行增删改查操作&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE dept ( 
`deptno` INT, 
`dname` VARCHAR ( 30 ), 
`loc` VARCHAR ( 30 ) 
);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;INSERT INTO dept
VALUES
	( 10, &apos;ACCOUNTING&apos;, &apos;NEW YORK&apos; ),
	( 20, &apos;RESEARCH&apos;, &apos;DALLAS&apos; ),
	( 30, &apos;SALES&apos;, &apos;CHICAGO&apos; ),
	( 40, &apos;OPERATIONS&apos;, &apos;BOSTON&apos; );
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们首先需要对于项目安装驱动详细内容见教程&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/pan_junbiao/article/details/86626741&lt;/p&gt;
&lt;p&gt;将得到的驱动添加到库中&lt;/p&gt;
&lt;p&gt;在引入包的时候注意版本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import com.mysql.cj.jdbc.Driver;  // MySQL 8.x
// 或
import com.mysql.jdbc.Driver;     // MySQL 5.x
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public class JDBC01 {
    public static void main(String[] args) throws SQLException {
        //将驱动文件添加入库
        //1.注册驱动-加载Driver类
        Driver driver = new Driver();

        //2.获取连接-得到Connection
        String agreement = &quot;jdbc:mysql:&quot;;
        String address = &quot;localhost&quot;;
        String port = &quot;3306&quot;;
        String dataBase = &quot;jdbc&quot;;
        String url = agreement + &quot;//&quot; + address + &quot;:&quot; + port + &quot;/&quot; + dataBase;
        //将用户密码放入properties
        Properties properties = new Properties();
        properties.setProperty(&quot;user&quot;, &quot;root&quot;);
        properties.setProperty(&quot;password&quot;, &quot;654321&quot;);
        Connection connect = driver.connect(url, properties);

        //3.执行增删改查-执行sql语句
        String sql = &quot;INSERT INTO dept VALUES (10,&apos;ACCOUNTING&apos;,&apos;NEW YORK&apos;);&quot;;
        //创建一个Statement对象
        Statement statement = connect.createStatement();
        int rows = statement.executeUpdate(sql);
        //返回生效的行数，这个时候返回1代表成功
        System.out.println(rows &amp;gt; 0 ? &quot;success&quot; : &quot;fail&quot;);

        //4.释放资源-关闭释放
        statement.close();
        connect.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看数据库发现数据库中成功的添加了相关数据&lt;/p&gt;
&lt;h4&gt;动态加载&lt;/h4&gt;
&lt;p&gt;其实上述的代码中的静态加载方式可以改进为利用反射动态链接，可以更加灵活&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Class&amp;lt;?&amp;gt; cls = Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);
Driver driver = (Driver)cls.newInstance();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而且通过动态加载，我们实际上可以不用创建Driver实例加载，因为静态代码块在类加载的时候，底层以及将Driver驱动已经帮我们加载好了&lt;/p&gt;
&lt;h4&gt;DriverManager&lt;/h4&gt;
&lt;p&gt;用DriverManager替代Manager，好处是不用Properties以及扩展性好一点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;String user = &quot;root&quot;;
String password = &quot;654321&quot;;
DriverManager.registerDriver(driver);
Connection connect = DriverManager.getConnection(url, user, password);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;综上所述，我们的代码可以更改为如下（推荐使用）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//1.注册驱动-加载Driver类
Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);

//2.获取连接-得到Connection
String agreement = &quot;jdbc:mysql:&quot;;
String address = &quot;localhost&quot;;
String port = &quot;3306&quot;;
String dataBase = &quot;jdbc&quot;;
String url = agreement + &quot;//&quot; + address + &quot;:&quot; + port + &quot;/&quot; + dataBase;

String user = &quot;root&quot;;
String password = &quot;654321&quot;;
Connection connect = DriverManager.getConnection(url, user, password);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;甚至在驱动更高级的版本（5.1.7）中你甚至可以不用Driver加载，但还是建议写上，避免多个驱动混用混乱&lt;/p&gt;
&lt;h4&gt;最终推荐的方案&lt;/h4&gt;
&lt;p&gt;我们除了使用动态加载驱动，用DriverManager管理连接，我们还可以将我们的连接数据库写的更加灵活一点，写一个配置文件，让程序从配置文件中读取连接对象，用户密码等&lt;/p&gt;
&lt;p&gt;配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;agreement=jdbc:mysql:
address=localhost
port=3306
dataBase=jdbc
user=root
password=654321
driver=com.mysql.cj.jdbc.Driver
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Java代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test {
    @SuppressWarnings ({&quot;all&quot;})
    public static void main(String[] args) throws Exception{
        Properties properties = new Properties();
        properties.load(new FileInputStream(&quot;src\\mysql.properties&quot;));
        String user = properties.getProperty(&quot;user&quot;);
        String password = properties.getProperty(&quot;password&quot;);
        String driver = properties.getProperty(&quot;driver&quot;);

        String agreement = properties.getProperty(&quot;agreement&quot;);
        String address = properties.getProperty(&quot;address&quot;);
        String port = properties.getProperty(&quot;port&quot;);
        String dataBase = properties.getProperty(&quot;dataBase&quot;);

        Class.forName(driver);
        String url = agreement + &quot;//&quot; + address + &quot;:&quot; + port + &quot;/&quot; + dataBase;
        Connection connection = DriverManager.getConnection(url, user, password);
        Statement statement = connection.createStatement();
        String sql = &quot;select deptno,dname,loc from dept&quot;;
        ResultSet resultSet = statement.executeQuery(sql);

        while(resultSet.next()) {
            int deptno = resultSet.getInt(1);
            String dname = resultSet.getString(2);
            String loc = resultSet.getString(3);
            System.out.println(deptno + &quot; &quot; + dname + &quot; &quot; + loc);
        }
        resultSet.close();
        statement.close();
        connection.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;结果集&lt;/h3&gt;
&lt;p&gt;我们在使用JDBC执行查询语句的时候需要用结果集ResultSet来存储返回的结果&lt;/p&gt;
&lt;p&gt;ResultSet表示数据库结果集数据表，通常由执行查询数据库的语句生成，ResultSet对象保持一个光标指向其当前行的数据行&lt;/p&gt;
&lt;p&gt;最初，光标只想第一行之前，next方法将光标指向下一行，并且在没有行的时候返回false，可以使用while循环来遍历结果集&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//3.执行增删改查-执行sql语句
//创建一个Statement对象
Statement statement = connect.createStatement();
String sql = &quot;select ename,job,deptno from emp&quot;;
//使用executeQuery返回结果集
ResultSet result = statement.executeQuery(sql);
//通过while循环输出结果集
while(result.next()) {
    String ename = result.getString(1);
    String job = result.getString(2);
    int deptno = result.getInt(3);
    System.out.println(ename + &quot;\t&quot; + job + &quot;\t&quot; + deptno);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SMITH	CLERK		20
ALLEN	SALESMAN	30
WARD	SALESMAN	30
JOOES	MANAGER		20
MARTIN	SALESMAN	30
BLAKE	MANAGER		30
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其实结果集的底层是一个ArrayList，包含了一个对象数组包含了各行的数据&lt;/p&gt;
&lt;h2&gt;执行对象&lt;/h2&gt;
&lt;h3&gt;基本介绍&lt;/h3&gt;
&lt;p&gt;1.Statement对象用于执行静态SQL语句并返回其生成的结果对象&lt;/p&gt;
&lt;p&gt;2.在建立连接后，需要对数据库进行访问，执行命令或者是SQL语句可以通过Statement PreparedStatement CallableStatement（依次继承前者）来完成&lt;/p&gt;
&lt;p&gt;3.Statement对象执行SQL语句，存在SQL注入风险&lt;/p&gt;
&lt;p&gt;4.SQL注入是利用某些系统没有对用户输入的数据进行充分的检查，在用户输入数据中注入非法的SQL语句段或者命令，以此恶意攻击数据库&lt;/p&gt;
&lt;p&gt;5.要防范SQL注入只要用PreparedStatement取代Statement即可&lt;/p&gt;
&lt;h3&gt;SQL注入&lt;/h3&gt;
&lt;p&gt;在历史中曾有运用SQL注入来攻破数据库的案例，例如如下是一个用户登陆的案例，我们需要使用用户名称以及用户密码来查找出用户用以登录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from admin where name = &apos;user&apos; and pwd = &apos;password&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中target用我们用户输入的内容替换，正常的情况中输入正确的用户以及密码即可找到对应的用户，但是通过SQL注入我们输入的用户密码如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;user = 1&apos; or
password = or &apos;1&apos; = &apos;1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将用户以及密码替换到数据库语句中就会发生以下情况&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from admin where name = &apos;1&apos; or&apos; and pwd = &apos;or &apos;1&apos; = &apos;1&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中&apos;1&apos; = &apos;1&apos;显然是满足条件的，以此我们得到了所有用户的记录，以下是一个代码示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;System.out.print(&quot;输入用户名称：&quot;);
String inputName = scanner.nextLine();
System.out.print(&quot;输入用户密码：&quot;);
String inputPwd = scanner.nextLine();
String sql = &quot;select id,name,pwd from admin where name = &apos;&quot; + inputName + &quot;&apos; and pwd = &apos;&quot; + inputPwd + &quot;&apos;;&quot;;
System.out.println(sql);
//使用executeQuery返回结果集
ResultSet result = statement.executeQuery(sql);
//通过while循环输出结果集
while(result.next()) {
    int id = result.getInt(1);
    String name = result.getString(2);
    String pwd = result.getString(3);

    System.out.println(id + &quot;\t&quot; + name + &quot;\t&quot; + pwd);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入用户名称：1&apos; or
输入用户密码：or &apos;1&apos; = &apos;1
select id,name,pwd from admin where name = &apos;1&apos; or&apos; and pwd = &apos;or &apos;1&apos; = &apos;1&apos;;
2	user1	password1
3	user2	password2
4	user3	password3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者你想要查看一个指定的用户（密码随意）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入用户名称：user2&apos; -- 
输入用户密码：123
select id,name,pwd from admin where name = &apos;user2&apos; -- &apos; and pwd = &apos;123&apos;;
3	user2	password2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是非常危险的，这个时候我们就需要使用到新的PreparedStatement对象来防止SQL注入的发生&lt;/p&gt;
&lt;h3&gt;PreparedStatement&lt;/h3&gt;
&lt;p&gt;1.PreparedStatement执行的SQL语句中的参数用?来表示，调用PreparedStatement对象的setXxx()方法来设置这些参数，setXxx()方法有两个参数，第一个参数是要设置的SQL语句中的参数的索引，从1开始，第二个是设置SQL语句中的参数值&lt;/p&gt;
&lt;p&gt;2.调用executeQuery() 返回ResultSet对象&lt;/p&gt;
&lt;p&gt;3.调用executeUpdate() 来执行增删改操作&lt;/p&gt;
&lt;p&gt;通过这样的对象我们不用+进行sql的拼接，减少语法错误的概率，还可以解决sql注入的问题，大大减少了编译的次数，效率较高&lt;/p&gt;
&lt;p&gt;具体使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Prepared {
    public static void main(String[] args) throws Exception{
        Properties properties = new Properties();
        properties.load(new FileInputStream(&quot;src\\mysql.properties&quot;));
        String user = properties.getProperty(&quot;user&quot;);
        String password = properties.getProperty(&quot;password&quot;);
        String driver = properties.getProperty(&quot;driver&quot;);

        String agreement = properties.getProperty(&quot;agreement&quot;);
        String address = properties.getProperty(&quot;address&quot;);
        String port = properties.getProperty(&quot;port&quot;);
        String dataBase = properties.getProperty(&quot;dataBase&quot;);

        Class.forName(driver);
        String url = agreement + &quot;//&quot; + address + &quot;:&quot; + port + &quot;/&quot; + dataBase;
        Connection connection = DriverManager.getConnection(url, user, password);

        String sql = &quot;select deptno,dname,loc from dept where deptno = ?&quot;;
        //其中的？代表占用符号
        PreparedStatement statement = connection.prepareStatement(sql);
        //PreparedStatement是Java提供的接口，具体的实现类看数据库厂商如何实现
        statement.setInt(1, 10);
        ResultSet resultSet = statement.executeQuery();
        //执行查询时不写sql，因为创建preparedstatement时使用sql创建
        while(resultSet.next()) {
            int deptno = resultSet.getInt(1);
            String dname = resultSet.getString(2);
            String loc = resultSet.getString(3);
            System.out.println(deptno + &quot; &quot; + dname + &quot; &quot; + loc);
        }
        resultSet.close();
        statement.close();
        connection.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;10 ACCOUNTING NEW YORK
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;三者对比&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;特性&lt;/th&gt;
&lt;th&gt;Statement&lt;/th&gt;
&lt;th&gt;PreparedStatement&lt;/th&gt;
&lt;th&gt;CallableStatement&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;SQL预编译&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;防SQL注入&lt;/td&gt;
&lt;td&gt;❌&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;参数化查询&lt;/td&gt;
&lt;td&gt;❌&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;调用存储过程&lt;/td&gt;
&lt;td&gt;❌&lt;/td&gt;
&lt;td&gt;❌&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;性能&lt;/td&gt;
&lt;td&gt;低&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;使用频率&lt;/td&gt;
&lt;td&gt;低&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;td&gt;中&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;JDBC封装&lt;/h2&gt;
&lt;p&gt;在jdbc操作中其实获取链接和释放操作都是我们会经常用到的，每一次都重写一遍其实非常的浪费时间，我们这个时候就有必要封装一个JDBC的工具模块来供自己调用&lt;/p&gt;
&lt;h3&gt;封装示例&lt;/h3&gt;
&lt;p&gt;以下是一个封装示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class JDBCUtils {
    //定义相关属性
    private static final String user;
    private static final String password;
    private static final String driver;
    private static final String agreement;
    private static final String address;
    private static final String port;
    private static final String dataBase;

    static {
        Properties properties = new Properties();
        try {
            properties.load(new FileInputStream(&quot;src\\mysql.properties&quot;));
            user = properties.getProperty(&quot;user&quot;);
            password = properties.getProperty(&quot;password&quot;);
            driver = properties.getProperty(&quot;driver&quot;);
            agreement = properties.getProperty(&quot;agreement&quot;);
            address = properties.getProperty(&quot;address&quot;);
            port = properties.getProperty(&quot;port&quot;);
            dataBase = properties.getProperty(&quot;dataBase&quot;);
            Class.forName(driver);
        } catch (Exception e) {
            //在实际开发中往往转为一个运行时异常抛出
            throw new RuntimeException(e);
            //调用者可以选择捕获异常或者默认处理
        }
    }

    public static Connection getConnection() {
        String url = agreement + &quot;//&quot; + address + &quot;:&quot; + port + &quot;/&quot; + dataBase;
        try {
            return DriverManager.getConnection(url, user, password);
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    public static void close(ResultSet result, Statement statement, Connection connection) {
        try {
            if(result != null) {
                result.close();
            }
            if(statement != null) {
                statement.close();
            }
            if(connection != null) {
                connection.close();
            }
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;测试代码&lt;/h3&gt;
&lt;p&gt;接下来我们用测试代码进行调用测试&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Prepared {
    public static void main(String[] args){

        Connection connection = JDBCUtils.getConnection();
        String sql = &quot;select deptno,dname,loc from dept where deptno = ?&quot;;
        PreparedStatement statement = null;
        ResultSet resultSet = null;
        try {
            statement = connection.prepareStatement(sql);
            statement.setInt(1, 10);
            resultSet = statement.executeQuery();
            while(resultSet.next()) {
                int deptno = resultSet.getInt(1);
                String dname = resultSet.getString(2);
                String loc = resultSet.getString(3);
                System.out.println(deptno + &quot; &quot; + dname + &quot; &quot; + loc);
            }
        } catch (SQLException e) {
            throw new RuntimeException(e);
        } finally {
            JDBCUtils.close(resultSet, statement, connection);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样相较于前文中的全部代码不光简单了很多，而且异常处理也非常的合理&lt;/p&gt;
&lt;h2&gt;JDBC事务&lt;/h2&gt;
&lt;h3&gt;基本介绍&lt;/h3&gt;
&lt;p&gt;1.JDBC程序中当一个Connection对象创建时，默认情况下是自动提交事务，每次执行一个SQL语句时如果执行成功，就会像数据库中自动提交事务，不可以回滚&lt;/p&gt;
&lt;p&gt;2.JDBC程序中为了让多个SQL语句作为一个整体执行，需要使用事务，这里是事务acid中的原子性&lt;/p&gt;
&lt;p&gt;3.调用Connection的setAutoCommit(false) 可以取消自动提交事务&lt;/p&gt;
&lt;p&gt;4.在所有的SQL语句都执行成功后，调用commit方法进行提交事务&lt;/p&gt;
&lt;p&gt;5.在其中某个操作失败或者出现异常的时候，调用rollback方法进行回滚事务&lt;/p&gt;
&lt;h3&gt;代码示例&lt;/h3&gt;
&lt;p&gt;以下代码完成了账户中转账的操作，但是假设在第二条SQL语句执行失败的情况下，异常被捕获第二条语句的转账没有收到，就会少了100块钱&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Prepared {
    public static void main(String[] args){

        Connection connection = JDBCUtils.getConnection();
        String sql1 = &quot;update balance set money = money - 100 where id = 1&quot;;
        String sql2 = &quot;update balance set money = money + 100 where id = 2&quot;;

        PreparedStatement statement = null;
        ResultSet resultSet = null;
        try {
            statement = connection.prepareStatement(sql1);
            int row = statement.executeUpdate();
            System.out.println(row &amp;gt; 0 ? &quot;success&quot; : &quot;fail&quot;);

            statement = connection.prepareStatement(sql2);
            row = statement.executeUpdate();
            System.out.println(row &amp;gt; 0 ? &quot;success&quot; : &quot;fail&quot;);
            
        } catch (SQLException e) {
            throw new RuntimeException(e);
        } finally {
            JDBCUtils.close(resultSet, statement, connection);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个时候我们就需要运用到事务来解决&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Prepared {
    public static void main(String[] args){

        Connection connection = JDBCUtils.getConnection();
        String sql1 = &quot;update balance set money = money - 100 where id = 1&quot;;
        String sql2 = &quot;update balance set money = money + 100 where id = 3&quot;;

        PreparedStatement statement = null;
        ResultSet resultSet = null;
        try {
            connection.setAutoCommit(false);//设置为不自动提交
            statement = connection.prepareStatement(sql1);
            int row = statement.executeUpdate();
            if(row &amp;lt;= 0) {
                throw new SQLException();
            }

            statement = connection.prepareStatement(sql2);
            row = statement.executeUpdate();
            if(row &amp;lt;= 0) {
                throw new SQLException();
            }
            connection.commit();//提交事务

        } catch (SQLException e) {
            //当发生执行SQL语句的时候，我们可以在异常处理回滚
            try {
                connection.rollback();
                //当没有存档点的情况下我们回滚到事务开始时，即设置自动提交的地方
            } catch (SQLException ex) {
                throw new RuntimeException(ex);
            }
            throw new RuntimeException(e);
        } finally {
            JDBCUtils.close(resultSet, statement, connection);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样的话，即使我们的第二条语句执行了一个不存在的用户3，用户1账户的钱也不会消失，注意当row=0时主动抛出异常，以便catch处理回滚&lt;/p&gt;
</content:encoded></item><item><title>关于 Git</title><link>https://thrinisty.github.io/posts/git%E7%AC%94%E8%AE%B0%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86%E6%9C%AC%E5%9C%B0%E5%BA%93%E5%88%86%E6%94%AF%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/git%E7%AC%94%E8%AE%B0%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86%E6%9C%AC%E5%9C%B0%E5%BA%93%E5%88%86%E6%94%AF%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/</guid><description>Git 学习笔记（加强版本）代码管理，本地库，分支，团队协作</description><pubDate>Wed, 16 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;GIT&lt;/h1&gt;
&lt;p&gt;Mysql基础部分内容结束，本来打算直接进入JDBC的学习，但是一来我有点小累，学不动Java了，二来我的编译原理课程需要使用到Git，实习的公司也要求熟练运用Git，所以就先看看这一个部分的知识，整理笔记并实际运用，预计今天（15号）一个晚自习和明天把这一块知识拿下（熟练使用Git、Github、GitLab、Gitee）&lt;/p&gt;
&lt;p&gt;之前的博客中我也介绍了一下Git大体是个什么玩意，但是使用的是VsCode链接到的Github，而我现在学Java改用IDEA了，又需要重新配置一下才可以方便使用。&lt;/p&gt;
&lt;p&gt;找的课程也就4~5个小时，就当过一遍教程了，对不了解的代码分支，分支合并学习一下，以下是该课程涉及的一些知识点（代码推送、代码拉取、代码克隆、IDEA集成Github、分支合并）&lt;/p&gt;
&lt;p&gt;:::tip
课程推荐 【尚硅谷Git入门到精通全套教程（涵盖GitHub\Gitee码云\GitLab）】
:::&lt;/p&gt;
&lt;p&gt;&amp;lt;iframe
width=&quot;100%&quot;
height=&quot;468&quot;
src=&quot;//player.bilibili.com/player.html?bvid=BV1vy4y1s7k6&amp;amp;p=1&amp;amp;autoplay=false&quot;
scrolling=&quot;no&quot;
border=&quot;0&quot;
frameborder=&quot;no&quot;
framespacing=&quot;0&quot;
allowfullscreen=&quot;true&quot;&amp;gt;
&amp;lt;/iframe&amp;gt;&lt;/p&gt;
&lt;h2&gt;重要概念&lt;/h2&gt;
&lt;h3&gt;版本控制&lt;/h3&gt;
&lt;p&gt;版本控制是一种记录文件内容变化，以便将来查阅特定版本修订情况的系统&lt;/p&gt;
&lt;p&gt;其中最重要的就是可以记录文件修改历史，从而让用户能够查看历史版本，方便切换版本&lt;/p&gt;
&lt;p&gt;对于个人而言或许不太需要版本控制，但是如果一旦上升到公司集体，为了方便安全的对于代码进行修改（对于多个修改进行正确的合并），版本控制的使用就异常重要&lt;/p&gt;
&lt;h3&gt;分布式和集中式&lt;/h3&gt;
&lt;p&gt;对于早期的集中式管理系统，多个用户针对于中央服务器进行代码提交修改，这样做方便管理者来集中控制权限，但是如果中央服务器崩溃，项目就无法查看版本记录，而本地工作副本仅保存当前文件状态，无法形成有效的本地版本历史，而如今的分布式可以很好的解决这一点，通过拉取到本地，推送来统一进度，当中央发生故障的时候，任可以在自己的主机上做本地的版本控制&lt;/p&gt;
&lt;h3&gt;Git的工作机制&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../images/113.png&quot; alt=&quot;113&quot; /&gt;&lt;/p&gt;
&lt;p&gt;工作区：指的是本地存放代码的地方，也是直接编写代码的本地区域&lt;/p&gt;
&lt;p&gt;暂存区：是为了git识别，将工作区通过git add添加到的一个特定区域&lt;/p&gt;
&lt;p&gt;本地库：将暂存区的代码commit提交到本地库就会生成历史版本，无法删除记录（除非删除本地代码重新拉取云端的版本）&lt;/p&gt;
&lt;h3&gt;代码托管中心&lt;/h3&gt;
&lt;p&gt;代码托管中心是基于网络服务器的远程代码仓库，一般简单地称为远程库，在上述工作机制中，我们还可以把本地库运用push将本地库推送到远程库中，以下是一些常见的代码托管中心&lt;/p&gt;
&lt;p&gt;局域网 GitLab&lt;/p&gt;
&lt;p&gt;互联网 Github     Gitee 码云&lt;/p&gt;
&lt;h2&gt;本地库操作&lt;/h2&gt;
&lt;h3&gt;相关命令&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令名称&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;git config --global user.name 用户名称&lt;/td&gt;
&lt;td&gt;设置用户签名&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git config --global user.email 邮箱&lt;/td&gt;
&lt;td&gt;设置用户签名&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git init&lt;/td&gt;
&lt;td&gt;初始化本地库&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git status&lt;/td&gt;
&lt;td&gt;查看本地库状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git add 文件名&lt;/td&gt;
&lt;td&gt;添加到暂存区&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git commit -m &quot;日志信息&quot; 文件名&lt;/td&gt;
&lt;td&gt;提交到本地库&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git reflog&lt;/td&gt;
&lt;td&gt;查看历史记录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git reset --hard 版本号&lt;/td&gt;
&lt;td&gt;版本穿梭&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;Git操作&lt;/h3&gt;
&lt;h4&gt;设置用户签名&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;git config --global user.name thrinisty
git config --global user.email 714605471@qq.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;签名的作用是区分不同的操作者的身份，用户的签名信息在每一个版本的提交信息中能够看到，以确认本次提交是谁做的，Git首次安装必须要设置一下用户签名，否则无法提交代码&lt;/p&gt;
&lt;p&gt;注意，这里设置用户签名和将来登录Github的帐号没有任何的关系&lt;/p&gt;
&lt;h4&gt;初始化本地库&lt;/h4&gt;
&lt;p&gt;找到你要git提交的文件进入，输入以下指令创建空的git本地库&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git init
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;../images/114.png&quot; alt=&quot;114&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;查看本地库状态&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;git status
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;默认是在master分支下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;On branch master
No commits yet
Untracked files:
  (use &quot;git add &amp;lt;file&amp;gt;...&quot; to include in what will be committed)
        images/
        src/

nothing added to commit but untracked files present (use &quot;git add&quot; to track)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中的images和src还没有被添加到暂存区，没有被追踪&lt;/p&gt;
&lt;h4&gt;添加至暂存区&lt;/h4&gt;
&lt;p&gt;添加所有文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git add . 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;添加image文件夹&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git add image
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个时候我们也可以使用git status来查看新添加进入的文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/115.png&quot; alt=&quot;115&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;提交本地库&lt;/h4&gt;
&lt;p&gt;生成历史版本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git commit -m &quot;init commit&quot; [可选字段 默认提交所有暂存区中内容]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;../images/116.png&quot; alt=&quot;116&quot; /&gt;&lt;/p&gt;
&lt;p&gt;这个时候再次查看git本地库状态，看见所有在暂存区的内容被提交&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git status
On branch master
nothing to commit, working tree clean
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;查看版本信息&lt;/h4&gt;
&lt;p&gt;我们也可以通过一下的指令来查看版本信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git reflog
c3418c7 (HEAD -&amp;gt; master) HEAD@{0}: commit (initial): init commit
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;发现有一个提交过的版本名为init commit&lt;/p&gt;
&lt;p&gt;以下是一个更为详细的版本信息查看&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git log
commit c3418c789ad7bfb246a65f88f26f37764a011764 (HEAD -&amp;gt; master)
Author: thrinisty &amp;lt;714605471@qq.com&amp;gt;
Date:   Wed Apr 16 14:57:49 2025 +0800

	init commit
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;修改文件&lt;/h4&gt;
&lt;p&gt;修改文件之后我们需要将修改的文件再次添加到暂存区，以及提交到本地库&lt;/p&gt;
&lt;p&gt;例如我们在images文件夹下新增了一张图片&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git status
On branch master
Untracked files:
  (use &quot;git add &amp;lt;file&amp;gt;...&quot; to include in what will be committed)
        images/2.jpg

nothing added to commit but untracked files present (use &quot;git add&quot; to track)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们就需要重新将这张图片存储到到暂存区&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git status
On branch master
Changes to be committed:
  (use &quot;git restore --staged &amp;lt;file&amp;gt;...&quot; to unstage)
        new file:   images/2.jpg
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再重新提交到本地库，从而生成第二个版本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git commit -m &quot;New picture&quot;
[master 8c69e8c] New picture
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 images/2.jpg
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在我们再查看版本信息，就可以看到第二次提交&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git reflog
8c69e8c (HEAD -&amp;gt; master) HEAD@{0}: commit: New picture
c3418c7 HEAD@{1}: commit (initial): init commit
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;版本切换&lt;/h4&gt;
&lt;p&gt;Git切换版本，底层实际上就是移动的Head指针&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git reset --hard c3418c7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个时候我们的版本指针指向的就是第一次提交的版本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;c3418c7 (HEAD -&amp;gt; master) HEAD@{0}: reset: moving to c3418c7
8c69e8c HEAD@{1}: commit: New picture
c3418c7 (HEAD -&amp;gt; master) HEAD@{2}: commit (initial): init commit
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而我们添加的工作区中的第二次新添加的图片也会消失不见&lt;/p&gt;
&lt;p&gt;当然我们也可以版本穿梭回去&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git reset --hard 8c69e8c
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们工作区中的图片就会被添加回来&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/117.png&quot; alt=&quot;117&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;分支&lt;/h2&gt;
&lt;p&gt;在版本控制过程中，同时推进多个任务，为每个任务，我们就可以创建每个任务的单独分支。使用分支意味着程序员可以把自己的工作从开发主线上分离开来，开发自己分支的时候，不会影响到主线分支的运行&lt;/p&gt;
&lt;p&gt;而对于初学者而言，分支可以简单理解为副本，一个分支就是一个单独的副本（分支的底层的实现也是通过指针完成）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/118.png&quot; alt=&quot;118&quot; /&gt;&lt;/p&gt;
&lt;p&gt;分支优点：同时并行推进多个功能的开发，提高开发效率&lt;/p&gt;
&lt;p&gt;在各个分支的开发过程中，如果某一个分支开发失败，不会对其他分支有任何影响，失败的分支重新删除即可&lt;/p&gt;
&lt;h3&gt;分支相关指令&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令名称&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;git branch 分支名&lt;/td&gt;
&lt;td&gt;创建分支&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git branch -v&lt;/td&gt;
&lt;td&gt;查看分支&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git checkout 分支名&lt;/td&gt;
&lt;td&gt;切换分支&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git merge 分支名&lt;/td&gt;
&lt;td&gt;把指定的分支合并到当前分支上&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;基本使用&lt;/h3&gt;
&lt;p&gt;我们有的时候需要对于工作代码进行热修补，我们可以创建一个hot-fix分支，切换到分支，在分支上对于代码进行修改，完成之后切换到master分支下就可以使用git merge进行合并&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git branch hot-fix
git checkout hot-fix
相关的热修复
git checkout master
git merge hot-fix
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后的本地库状态&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git reflog
37195a2 (HEAD -&amp;gt; master, hot-fix) HEAD@{0}: merge hot-fix: Fast-forward
8c69e8c HEAD@{1}: checkout: moving from hot-fix to master
37195a2 (HEAD -&amp;gt; master, hot-fix) HEAD@{2}: commit: commit 1.jpg
8c69e8c HEAD@{3}: checkout: moving from master to hot-fix
8c69e8c HEAD@{4}: reset: moving to 8c69e8c
c3418c7 HEAD@{5}: reset: moving to c3418c7
8c69e8c HEAD@{6}: commit: New picture
c3418c7 HEAD@{7}: commit (initial): init commit
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;合并冲突&lt;/h3&gt;
&lt;p&gt;以上的例子是在master没有修改的情况下完成的合并，所以可以合并成功，在企业中我们在合并分支的时候往往遇到冲突&lt;/p&gt;
&lt;p&gt;合并分支的时候，两个分支在同一个文件的同一个位置有两套完全不同的修改，而Git无法替我们决定使用哪一个，必须要认为决定新代码内容&lt;/p&gt;
&lt;p&gt;例如我们在master中创建了一个1.txt 然后创建一个another分支，在两个分支下分别修改这个1.txt，分别提交，尝试在master中合并another，发现没有办法正常自动合并&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git merge another
Auto-merging 1.txt.txt
CONFLICT (content): Merge conflict in 1.txt.txt
Automatic merge failed; fix conflicts and then commit the result.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而用git status指令查看，发现了1.txt合并冲突&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;On branch master
You have unmerged paths.
  (fix conflicts and run &quot;git commit&quot;)
  (use &quot;git merge --abort&quot; to abort the merge)

Unmerged paths:
  (use &quot;git add &amp;lt;file&amp;gt;...&quot; to mark resolution)
        both modified:   1.txt.txt

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而打开冲突的文件，会发现git帮我们完成了冲突的标注&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEAD
master中的修改
=======
分支中的修改
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; another
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们需要手动合并&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;master中的修改
分支中的修改
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要重新添加提交&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git add .
git commit -m &quot;merge test&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;71460@thrinisty MINGW64 ~/多用户通讯系统 (master|MERGING)
$ git commit -m &quot;merge test&quot;
[master 0f34b4c] merge test

71460@thrinisty MINGW64 ~/多用户通讯系统 (master)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;发现两个分支合并成功，其实无论master还是another都是版本记录的指针，而所在的分支，其实是由Head决定的，所以创建分支的本质就是多创建一个指针，切换Head就是切换分支&lt;/p&gt;
&lt;h2&gt;团队协作&lt;/h2&gt;
&lt;p&gt;我们在实际开发的过程中不光有本地的仓库，还应该将代码同步到云端（代码托管平台）&lt;/p&gt;
&lt;p&gt;远程仓库命令&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令名称&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;git remote -v&lt;/td&gt;
&lt;td&gt;查看当前所有远程地址别名&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git remote add 别名 远程地址&lt;/td&gt;
&lt;td&gt;起一个别名&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git push 别名 分支&lt;/td&gt;
&lt;td&gt;推送本地分支上的内容到远程仓库&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git clone 远程地址&lt;/td&gt;
&lt;td&gt;将远程仓库的内容克隆到本地&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git pull 别名 远程分支名&lt;/td&gt;
&lt;td&gt;将远程仓库对于分支最新内容拉取与本地分支直接合并&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;远程仓库操作&lt;/h3&gt;
&lt;h4&gt;创建远程仓库&lt;/h4&gt;
&lt;p&gt;在github创建一个远程仓库名为Multi-user-communication-system（举例）&lt;/p&gt;
&lt;p&gt;其中 https://github.com/thrinisty/Multi-user-communication-system.git&lt;/p&gt;
&lt;p&gt;是我们的仓库链接，我们可以对于这个链接起一个别名system&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git remote add system 
https://github.com/thrinisty/Multi-user-communication-system.git
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;推送本地仓库到远程仓库&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;git push system master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个时候我们就将代码推送到了远程仓库&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/119.png&quot; alt=&quot;119&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;拉取代码&lt;/h4&gt;
&lt;p&gt;如果需要拉取云端的代码对本地的代码进行合并（请注意保持本地库的代码是最新的状态）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git pull system master
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;git pull system master
From https://github.com/thrinisty/Multi-user-communication-system
 * branch            master     -&amp;gt; FETCH_HEAD
Already up to date.
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;克隆仓库&lt;/h4&gt;
&lt;p&gt;如果没有本地库代码，我们还可以使用git clone完成项目的克隆，别名默认为origin&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone https://github.com/thrinisty/Multi-user-communication-system
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;团队内协作&lt;/h3&gt;
&lt;p&gt;在克隆的本地仓库可以用另外一个人的帐号，进行推送，但是需要赋予相关的权限，需要将这个人的账号添加进入团队&lt;/p&gt;
&lt;h4&gt;添加团队人员&lt;/h4&gt;
&lt;p&gt;在仓库的拥有者中仓库设置的Collaborators可以选取添加仓库的相关人员，而添加的相关人员就会有push代码的权限&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/120.png&quot; alt=&quot;120&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;团队成员修改提交&lt;/h4&gt;
&lt;p&gt;之后团队内成员可以拉取合并代码，并修改提交，参与到项目的研发中&lt;/p&gt;
&lt;h3&gt;跨团队协作&lt;/h3&gt;
&lt;p&gt;有的时候我们需要找一个外来人员更改代码，但是我们又不想要让这个外来人员进入团队，我们就需要跨团队协作&lt;/p&gt;
&lt;p&gt;这个时候外来人员可以通过项目链接选择使用fork看到代码，修改代码，提交修改，但是只是修改自己的本地仓库&lt;/p&gt;
&lt;p&gt;外来人员想要将修改的代码合并到对应的项目中可以使用pull request发送请求，而仓库的管理人员就可以审核申请，之后还可以查看修改，如果没有问题就可以确认合并。&lt;/p&gt;
&lt;h2&gt;IDEA集成&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Github&lt;/strong&gt;  &lt;strong&gt;Gitee&lt;/strong&gt;  &lt;strong&gt;GitLab&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这部分的内容照着尚硅谷的B站课程过一遍就好，一般都记得住，不会用的时候再去复习一下就好，用的多就会了，没必记录笔记&lt;/p&gt;
&lt;p&gt;在公司中代码保护非常的常见，之前我在讯飞得生产实习就有明确要求只准许使用公司内网连接，网络实时监控，不允许向网络上提交代码相关的内容&lt;/p&gt;
&lt;p&gt;而一个项目的开发中代码的保护也是很重要，这个时候就需要使用到GitLab自建代码托管平台，在局域网是进行代码管理&lt;/p&gt;
&lt;h2&gt;结语&lt;/h2&gt;
&lt;p&gt;Git到这里告一段落，明天开始JDBC的学习，计划两天完成，目的是掌握基础语法，JDBC大体结构，JDBC实战项目暂时不打算做了，得快点把概念和实际操作过熟练了，计划之后学完JDBC的高层框架（Mybatis）后实战运用，就不用底层的JDBC做项目了&lt;/p&gt;
</content:encoded></item><item><title>MySQL笔记</title><link>https://thrinisty.github.io/posts/mysql%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E4%B9%A0%E9%A2%98%E8%AF%BE/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/mysql%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E4%B9%A0%E9%A2%98%E8%AF%BE/</guid><description>习题练习</description><pubDate>Tue, 15 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;MySQL习题&lt;/h1&gt;
&lt;p&gt;我们系统的学完了MySQL相关知识，我们现在来用例题巩固一下我们的知识&lt;/p&gt;
&lt;h2&gt;练习一&lt;/h2&gt;
&lt;p&gt;1.显示所有部门的名称&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select deptno,dname from dept;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.显示所有雇员名以及全年收入（12*薪水 + 奖金）取名为年收入&lt;/p&gt;
&lt;p&gt;这里道题注意null+数字为空，需要使用判断语句处理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename, (sal*12 + if(comm is null,0,comm))
as&apos;年收入&apos; from emp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.显示工资超过2850雇员的姓名以及工资&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,sal from emp where sal &amp;gt; 2850;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.显示工资不再1500到2850之间雇员的姓名以及工资&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,sal from emp where sal &amp;gt; 2850 and sal &amp;lt; 1500;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.显示编号为7796的雇员名称以及所在部门编号&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,deptno from emp where empno=7796;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;6.显示部门在20，30中工资超过1500的雇员名以及工资&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,sal from emp where sal &amp;gt; 1500 
and deptno in(20,30);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;7.显示无管理者的雇员名称以及岗位&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,job from emp where mgr is null;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;8.显示在1991-2-1日到1991-5-1日之间雇佣的员工名，岗位以及雇佣日期，并以雇佣日期降序排序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,job,hiredate from emp 
where hiredate between 1991-02-01 
and 1991-05-01 
order by hiredate desc;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;练习二&lt;/h2&gt;
&lt;p&gt;1.选出部门30中的所有员工&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp where deptno = 30;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.列出所有CLERK的姓名，编号和部门编号&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename, empno, deptno from emp where job = &apos;CLERK&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.找出佣金高于平均薪水60%的员工&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename from emp 
where sal&amp;gt;(0.6*(select avg(sal) from emp));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.找出部门30中所有MANNAGER和部门20中所有CLERK的详细资料&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp 
where(deptno = 20 and job = &apos;CLERK&apos;) 
or (deptno = 30 and job = &apos;MANNAGER&apos;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp 
where deptno = 20 and job = &apos;CLERK&apos; 
union select * from emp 
where deptno = 30 and job = &apos;MANNAGER&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.查询20部门中既不是MANAGER又不是CLERK而薪水小于等于2000的所有员工&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp where deptno = 30 
and sal &amp;lt;= 2000 and (job &amp;lt;&amp;gt; &apos;MANAGER&apos; and job &amp;lt;&amp;gt; &apos;CLERK&apos;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;6.找出不收奖金或奖金低于100的员工&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp where comm is null or ifnull(comm,0)&amp;lt;100;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;7.找出每月倒数第三天受雇的员工&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp where last_day(hiredate) - 2 = hiredate;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;8.找出至今工作12年以上的员工&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp where date_add(hiredate, interval 12 year) &amp;lt; now();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;9.以首字母小写的方式显示所有员工的姓名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select concat(
lcase(substring(ename,1,1))
,substring(ename,2)) from emp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;10.显示名字长度为5的员工&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp where length(ename)=5;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;练习三&lt;/h2&gt;
&lt;p&gt;1.显示不带有R的员工姓名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp where ename not like &apos;%R%&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.显示所有员工姓名的前三个字符&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select left(ename,3) from emp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.显示所有的员工姓名，a用A替换&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select replace(ename,&apos;A&apos;,&apos;a&apos;) from emp;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;练习四&lt;/h2&gt;
&lt;p&gt;1.列出一个至少有一个员工的所有部门&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select distinct dname from dept,emp 
where dept.deptno = emp.deptno;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.列出薪水比smith多的所有员工&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp where sal &amp;gt; (select sal from emp where ename = &apos;SMITH&apos;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.列出受雇日期晚于其直接上级的所有员工&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select emy.* from emp as emy,emp as boss 
where emy.hiredate &amp;gt; boss.hiredate 
and emy.mgr = boss.empno;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.列出部门名称和这些部门的员工信息，同时列出没有员工的部门&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select dname,emp.* from dept left join emp 
on dept.deptno = emp.deptno;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.列出所有CLERK的姓名以及部门的名称&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select dname,emp.ename from dept left join emp 
on dept.deptno = emp.deptno where job = &apos;CLERK&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;6.列出最低薪水大于1500的各种工作&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select min(sal)as min_sal,job from emp 
group by job 
having min_sal &amp;gt; 1500;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;7.列出部门在SALES工作的员工名称&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename from emp,dept 
where emp.deptno = dept.deptno and dname = &apos;SALES&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;练习五&lt;/h2&gt;
&lt;p&gt;1.列出与SMITH从事相同工作的所有员工&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp 
where job = (select job from emp where ename = &apos;SMITH&apos;) 
and ename &amp;lt;&amp;gt; &apos;SMITH&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.列出薪水高于在部门30工作的所有员工的薪水的员工姓名和薪水&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,sal from emp where sal&amp;gt;all(select sal from emp where deptno = 30);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.列出在每个部门工作的员工数量，平均工资&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select dname,count(emp.deptno),avg(sal) from dept 
left join emp on dept.deptno = emp.deptno 
group by dname;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.列出所有部门的详细信息以及部门人数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select dept.*,temp.con from dept left join 
(select count(*) as con,deptno 
 from dept group by deptno)temp 
 on dept.deptno = temp.deptno;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.列出MANAGER的最低工资&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select min(sal) from emp where job = &apos;MANAGER&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;综合练习&lt;/h2&gt;
&lt;p&gt;设学校环境如下：一个系有若干个专业，每个专业一年只招一个班，每个班有若干个学生，先要建立于系、班级、学生数据库&lt;/p&gt;
&lt;p&gt;关系模式如下：&lt;/p&gt;
&lt;p&gt;班级class（班号classid，课程名subject，系名deptname，入学年份time，人数num）&lt;/p&gt;
&lt;p&gt;学生student（学号studentid，姓名name，年龄age，班号classid）&lt;/p&gt;
&lt;p&gt;系department（系号departmentid，系名deptname）&lt;/p&gt;
&lt;h3&gt;建表&lt;/h3&gt;
&lt;p&gt;定义每个表的主外码&lt;/p&gt;
&lt;p&gt;deptname唯一约束&lt;/p&gt;
&lt;p&gt;学生姓名不可以为空&lt;/p&gt;
&lt;p&gt;班级class&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create table class(
`classid` int primary key,
`subject` varchar(32),
`deptname` varchar(32),
`time` int,
`num` int
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;学生student&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create table student(
`studentid` int,
`name` varchar(32) not null default &apos;&apos;,
`age` int,
`classid` int,
primary key(`studentid`),
foreign key(`classid`) references class(classid)
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;系department&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create table department(
`departmentid` int primary key,
`deptname` varchar(32) unique not null
);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;插入数据&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;-- 插入系部数据
INSERT INTO department VALUES
(1, &apos;计算机科学系&apos;),
(2, &apos;电子工程系&apos;),
(3, &apos;机械工程系&apos;),
(4, &apos;外国语学院&apos;),
(5, &apos;经济管理学院&apos;);

-- 插入班级数据
INSERT INTO class VALUES
(101, &apos;数据结构&apos;, &apos;计算机科学系&apos;, 64, 45),
(102, &apos;数据库原理&apos;, &apos;计算机科学系&apos;, 48, 40),
(201, &apos;电路分析&apos;, &apos;电子工程系&apos;, 56, 38),
(202, &apos;数字电子技术&apos;, &apos;电子工程系&apos;, 48, 42),
(301, &apos;机械制图&apos;, &apos;机械工程系&apos;, 64, 36),
(401, &apos;英语语言学&apos;, &apos;外国语学院&apos;, 32, 28),
(501, &apos;微观经济学&apos;, &apos;经济管理学院&apos;, 48, 50);

-- 插入学生数据
INSERT INTO student VALUES
(1001, &apos;张三&apos;, 20, 101),
(1002, &apos;李四&apos;, 21, 101),
(1003, &apos;王五&apos;, 19, 102),
(1004, &apos;赵六&apos;, 20, 102),
(1005, &apos;钱七&apos;, 22, 201),
(1006, &apos;孙八&apos;, 20, 201),
(1007, &apos;周九&apos;, 21, 202),
(1008, &apos;吴十&apos;, 19, 301),
(1009, &apos;郑十一&apos;, 20, 401),
(1010, &apos;王十二&apos;, 21, 501);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;查询&lt;/h3&gt;
&lt;p&gt;完成如下查询&lt;/p&gt;
&lt;p&gt;1.找出所有姓李的学生&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from student where name like &apos;李%&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.列出开设超过一个课程的系的名称&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select deptname,count(*)as class_count 
from class group by deptname 
having class_count &amp;gt; 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+--------------+-------------+
| deptname     | class_count |
+--------------+-------------+
| 计算机科学系  |           2 |
| 电子工程系    |           2 |
+--------------+-------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.列出人数大于等于50，系的编号和名字&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select department.*,temp.sum_num from department,(select deptname,sum(num) as sum_num from class group by deptname having sum_num &amp;gt;= 50)temp where temp.deptname = department.deptname;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+--------------+--------------+---------+
| departmentid | deptname     | sum_num |
+--------------+--------------+---------+
|            2 | 电子工程系   | 80       |
|            5 | 经济管理学院 | 50       |
|            1 | 计算机科学系 | 85       |
+--------------+--------------+---------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;移除学生&lt;/h3&gt;
&lt;p&gt;我们现在需要移除一名张三学生，考虑的地方有以下两点，使张三所在班级的人数减一，再将张三从student表中移除，而这个过程我们要由事务来完成&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;start transaction;
update class set num = num-1 where classid = (select classid from student where name = &apos;张三&apos;);
delete from student where name = &apos;张三&apos;;
commit;
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>MySQL笔记</title><link>https://thrinisty.github.io/posts/mysql%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E7%B4%A2%E5%BC%95%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E8%A7%86%E5%9B%BE%E7%AE%A1%E7%90%86/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/mysql%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E7%B4%A2%E5%BC%95%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E8%A7%86%E5%9B%BE%E7%AE%A1%E7%90%86/</guid><description>索引，事务，隔离级别，存储引擎，视图，管理</description><pubDate>Mon, 14 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;MySQL&lt;/h1&gt;
&lt;h2&gt;自增长&lt;/h2&gt;
&lt;p&gt;我们再插入记录的时候有的时候需要有的数据从1开始自动增长，我们这个时候就要运用到自增长&lt;/p&gt;
&lt;p&gt;基本使用方式：在定义的时候设置auto_increment字段&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;字段名称 整形 primary key auto_increment
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;插入记录的时候填入null&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE dept ( 
`deptno` INT primary key auto_increment,
`dname` VARCHAR ( 30 ), 
`loc` VARCHAR ( 30 ) 
);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;insert into dept values(null, &apos;ddd&apos;, &apos;beijing&apos;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你需要自增需要从10开始，你也可以修改auto_increment设置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ALTER TABLE dept AUTO_INCREMENT = 10;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;插入数据的时候子增值字段也可以不使用null，而插入一个具体的值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;insert into dept values(50, &apos;ddd&apos;, &apos;beijing&apos;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;补充：设置自增步长&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-- 1. 首先设置全局自增步长
SET @@auto_increment_increment = 10;

-- 2. 然后修改表的自增值
ALTER TABLE dept AUTO_INCREMENT = 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;索引&lt;/h2&gt;
&lt;p&gt;索引可以在添加一定的代价后(占据更大大空间)，极大地增加查询（90%）的速度，而对于增删改（10%）会有一定的速率影响&lt;/p&gt;
&lt;h3&gt;基本使用方式&lt;/h3&gt;
&lt;p&gt;添加索引&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE [UNIQUE] INDEX 索引名称 on 表名(字段);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;alter table 表名 add index 索引名称(字段);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除索引&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;drop index 索引名称 on 表名;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除主键索引&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;alter table dept drop primary key;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;索引的类型&lt;/h3&gt;
&lt;p&gt;1.主键索引，主键自动的为主键添加索引（primary key）&lt;/p&gt;
&lt;p&gt;2.唯一索引（unique），在创建表的时候，添加为唯一索引&lt;/p&gt;
&lt;p&gt;3.普通索引（index）&lt;/p&gt;
&lt;p&gt;4.全文索引（fulltext）在实际使用的时候一般不使用自带的全文索引往往切换为Solr或者ElasticSearch&lt;/p&gt;
&lt;p&gt;显示来自于dept的索引&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;show index from dept;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;show keys from dept;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;show indexes from dept;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;练习&lt;/h3&gt;
&lt;p&gt;为以下的表格添加主键索引&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create table `order` (
`id` int,
`name` varchar(32),
`p_name` varchar(32),
`count` int
)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;alter table `order` add unique index id_index (id);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;create index id_index on `order`(id);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;创建索引规则&lt;/h3&gt;
&lt;p&gt;1.较为频繁作为查询条件字段应该创建索引&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;例如：一个学校中的学生id
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.唯一性太差的字段不适合单独创建索引，即使查询频繁&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;例如：学生的性别
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.更新非常频繁的字段不适合创建索引&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;例如：学生账号的登录次数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.不会出现在where子句中的字段不该创建索引&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;例如：学生信息表中的详细的家庭住址
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;事务&lt;/h2&gt;
&lt;h3&gt;什么是事务？&lt;/h3&gt;
&lt;p&gt;事务用于保证数据的一致性，它由一组相关的dml语句组成，改组的dml语句要么全部执行，要么全部失败，例如在转账的时候就需要使用事务来处理，以保证数据的一致性&lt;/p&gt;
&lt;p&gt;事务和锁&lt;/p&gt;
&lt;p&gt;当执行事务操作的时候，mysql会在表上加锁，防止其他用户修改表的数据，这对于用户而言非常重要&lt;/p&gt;
&lt;h3&gt;引用示例&lt;/h3&gt;
&lt;p&gt;我们现在有一个运用场景，有如下的一张表格代表两个用户的银行账户信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create table balance (
`id` int primary key,
`name` varchar(32),
`money` double
)

insert into balance values
(100,&apos;tom&apos;,3000.00),
(200,&apos;king&apos;,6000);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们现在有如下需求：&lt;/p&gt;
&lt;p&gt;将tom的100块钱转移到king的账户下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;update balance set money = money-100 where id=100;
update balance set money = money+100 where id=200;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是假如我们的数据库运行出现问题：第一条转账语句成功但是第二条失败，则tom转出的100块钱就凭空消失了，这个时候我们就需要运用到事务操作，将两条语句当为一个整体执行（要么全部执行成功，要么失败）&lt;/p&gt;
&lt;h3&gt;事务基本操作&lt;/h3&gt;
&lt;h4&gt;start transaction&lt;/h4&gt;
&lt;p&gt;开始一个事务&lt;/p&gt;
&lt;h4&gt;savepoint&lt;/h4&gt;
&lt;p&gt;保存点名--设置保存点&lt;/p&gt;
&lt;h4&gt;rollback to&lt;/h4&gt;
&lt;p&gt;保存点名--回退事务&lt;/p&gt;
&lt;h4&gt;rollback&lt;/h4&gt;
&lt;p&gt;回退全部的事务&lt;/p&gt;
&lt;h4&gt;commit&lt;/h4&gt;
&lt;p&gt;提交事务，所有的操作生效，不可以回退&lt;/p&gt;
&lt;p&gt;我们现在回到我们的实际案例上面&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;start transaction; --设置了事物的开始

savepoint a;  --保存点a
update balance set money = money-100 where id=100;--dml

savepoint b;  --保存点a
update balance set money = money+100 where id=200;--dml

ROLLBACK;  --回滚
commit;  --提交
select * from balance;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行这样一段代码的话，数据不会被更改，因为进行了回滚，如果删除回滚在进行提交，执行成功，tom的100元给到了king&lt;/p&gt;
&lt;p&gt;回退事务：当执行回退事物的时候，通过指定的保存点就可以回退到指定的点&lt;/p&gt;
&lt;p&gt;提交事务：使用commit进行提交，执行了commit后就会确认事务的变化，结束事务，删除保存点，释放锁，数据生效。当使用commit语句结束事务以后，其他的会话可以查看到事物变化后的新数据&lt;/p&gt;
&lt;h3&gt;注意事项&lt;/h3&gt;
&lt;p&gt;1.如果不开始事务，默认情况下，dml操作是自动提交的，不可以进行回滚&lt;/p&gt;
&lt;p&gt;2.如果开始一个事务，没有创建保存点，可以执行rollback操作，默认回滚到事务开始的状态&lt;/p&gt;
&lt;p&gt;3.可以在事务还没有提交的时候，创建多个保存点&lt;/p&gt;
&lt;p&gt;4.可以在事务还没有提交的时候，选择回退到哪个保存点&lt;/p&gt;
&lt;p&gt;5.mysql事务机制需要innodb存储引擎，myisam不可以使用事务机制&lt;/p&gt;
&lt;h3&gt;事务的acid特性&lt;/h3&gt;
&lt;p&gt;（atomicity）原子性：原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生&lt;/p&gt;
&lt;p&gt;（consistency）一致性：事务必须使数据库从一个一致性状态变换到另一个一致性状态&lt;/p&gt;
&lt;p&gt;（isolation）隔离性：事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离&lt;/p&gt;
&lt;p&gt;（durability）持久性：持久性是指一个事务一旦被提交，他对于数据库中的数据的改变就是永久的，接下来即使数据库发生故障可而不应该对其有任何的影响&lt;/p&gt;
&lt;h2&gt;隔离级别&lt;/h2&gt;
&lt;p&gt;脏读：当一个事务读取另一个事务尚未提交的修改时，产生脏读&lt;/p&gt;
&lt;p&gt;不可重复读：同一查询在同一事物中多次进行，由于其他提交事务所做的修改或者删除，每次返回结果不同的结果集，产生不可重复读&lt;/p&gt;
&lt;p&gt;幻读：同一查询在同一事物中多次进行，由于其他提交事务的插入操作，每次返回不同的结果集，产生了幻读&lt;/p&gt;
&lt;h3&gt;事务隔离表格&lt;/h3&gt;
&lt;p&gt;事务隔离级别：MySQL隔离级别定义了事物与事务之间的隔离程度&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;隔离级别&lt;/th&gt;
&lt;th&gt;丢失修改&lt;/th&gt;
&lt;th&gt;脏读&lt;/th&gt;
&lt;th&gt;不可重复读&lt;/th&gt;
&lt;th&gt;幻读&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;读未提交&lt;/td&gt;
&lt;td&gt;不会发生&lt;/td&gt;
&lt;td&gt;可能发生&lt;/td&gt;
&lt;td&gt;可能发生&lt;/td&gt;
&lt;td&gt;可能发生&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;读已提交&lt;/td&gt;
&lt;td&gt;不会发生&lt;/td&gt;
&lt;td&gt;不会发生&lt;/td&gt;
&lt;td&gt;可能发生&lt;/td&gt;
&lt;td&gt;可能发生&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;可重复读&lt;/td&gt;
&lt;td&gt;不会发生&lt;/td&gt;
&lt;td&gt;不会发生&lt;/td&gt;
&lt;td&gt;不会发生&lt;/td&gt;
&lt;td&gt;可能发生&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;可串行化&lt;/td&gt;
&lt;td&gt;不会发生&lt;/td&gt;
&lt;td&gt;不会发生&lt;/td&gt;
&lt;td&gt;不会发生&lt;/td&gt;
&lt;td&gt;不会发生&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;Mysql中解决幻读&lt;/h3&gt;
&lt;p&gt;Mysql中的默认隔离级别是可重复读，但是在使用innodb引擎的时候不会发生幻读，原因如下&lt;/p&gt;
&lt;p&gt;InnoDB 存储引擎通过多版本并发控制(MVCC, Multi-Version Concurrency Control)机制，在&quot;可重复读&quot;(Repeatable Read)隔离级别下有效解决了幻读问题。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;普通SELECT操作(快照读)
通过ReadView判断哪些版本对当前事务可见
总是读取事务开始时的一致性快照
其他事务的插入操作不会影响当前事务的查询结果

当前读操作
对于SELECT ... FOR UPDATE、UPDATE、DELETE等操作：
InnoDB会加Next-Key Lock(记录锁+间隙锁)
防止其他事务在查询范围内插入新记录
从而彻底解决幻读问题
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;START TRANSACTION;
SELECT * FROM t WHERE id &amp;gt; 1; -- 看到3,5
-- 此时事务B插入id=4并提交
SELECT * FROM t WHERE id &amp;gt; 1; -- 仍然只看到3,5(快照读)
SELECT * FROM t WHERE id &amp;gt; 1 FOR UPDATE; -- 会看到3,4,5(当前读)
COMMIT;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在可重复读隔离级别下，普通SELECT不会看到事务B插入的id=4，而加锁的SELECT会看到并锁定这些记录。&lt;/p&gt;
&lt;h3&gt;读已提交和可重复读&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;特性&lt;/th&gt;
&lt;th&gt;读已提交(Read Committed)&lt;/th&gt;
&lt;th&gt;可重复读(Repeatable Read)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;数据可见性规则&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;总是看到最新已提交的数据&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;看到事务开始时的数据快照&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;锁机制&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;语句级锁(执行完立即释放)&lt;/td&gt;
&lt;td&gt;事务级锁(保持到事务结束)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;不可重复读&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;可能发生&lt;/td&gt;
&lt;td&gt;不会发生&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;性能&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;较高&lt;/td&gt;
&lt;td&gt;中等&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;可重复读和可串行化&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;特性&lt;/th&gt;
&lt;th&gt;可重复读(Repeatable Read)&lt;/th&gt;
&lt;th&gt;可串行化(Serializable)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;并发控制原理&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;MVCC(多版本并发控制)为主&lt;/td&gt;
&lt;td&gt;严格的二阶段封锁协议&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;读取行为&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;快照读(非锁定读)&lt;/td&gt;
&lt;td&gt;所有读自动转为锁定读(S锁)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;写入行为&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;需要时加X锁&lt;/td&gt;
&lt;td&gt;总是加X锁&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;锁范围&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;仅锁定实际访问的行和间隙&lt;/td&gt;
&lt;td&gt;更大范围的锁(更保守)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;性能&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;高并发，读不阻塞写&lt;/td&gt;
&lt;td&gt;低并发，读写相互阻塞&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;常用代码&lt;/h3&gt;
&lt;h4&gt;查看隔离级别&lt;/h4&gt;
&lt;p&gt;可以通过以下代码查看数据库设置的隔离级别&lt;/p&gt;
&lt;p&gt;MySQL 5.7及之前版本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select @@tx_isolation;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;MySQL 8.0及之后版本&lt;/p&gt;
&lt;p&gt;查看系统当前隔离级别&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT @@transaction_isolation;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+-------------------------+
| @@transaction_isolation |
+-------------------------+
| REPEATABLE-READ         |
+-------------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可见Mysql的默认隔离级别为可重复读&lt;/p&gt;
&lt;h4&gt;设置隔离级别&lt;/h4&gt;
&lt;p&gt;设置当前会话隔离级别&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SET SESSION TRANSACTION ISOLATION LEVEL 隔离级别;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置系统当前隔离级别&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SET global TRANSACTION ISOLATION LEVEL 隔离级别;
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;读未提交&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;SET SESSION TRANSACTION ISOLATION LEVEL read uncommitted;
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;读已提交&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;SET SESSION TRANSACTION ISOLATION LEVEL read committed;
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;可重复读&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;SET SESSION TRANSACTION ISOLATION LEVEL repeatable read;
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;可串行化&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;SET SESSION TRANSACTION ISOLATION LEVEL serializable;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;存储引擎&lt;/h2&gt;
&lt;p&gt;1.MySQL的表类型由存储引擎决定，主要包括MYISAM，InnoDB，Memory&lt;/p&gt;
&lt;p&gt;2.MySQL数据表只要支持六种类型：CSV，Memory，ARCHIVE，MRG_MYISAM，MYISAM，InnoDB&lt;/p&gt;
&lt;p&gt;3.这两种存储又分为两种：一类是事务安全型，例如InnoDB，其余为第二类，称为非事务安全型&lt;/p&gt;
&lt;p&gt;在MySQL中可以使用如下的指令查看存储引擎&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SHOW ENGINES;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;引擎比较&lt;/h3&gt;
&lt;p&gt;接下来来比较InnoDB、Myisam、Memory、Archive之间的优缺点：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;特性&lt;/th&gt;
&lt;th&gt;InnoDB&lt;/th&gt;
&lt;th&gt;MyISAM&lt;/th&gt;
&lt;th&gt;Memory&lt;/th&gt;
&lt;th&gt;Archive&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;事务支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;锁定级别&lt;/td&gt;
&lt;td&gt;行级锁&lt;/td&gt;
&lt;td&gt;表锁&lt;/td&gt;
&lt;td&gt;表锁&lt;/td&gt;
&lt;td&gt;行锁(仅插入)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;外键支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;存储位置&lt;/td&gt;
&lt;td&gt;磁盘&lt;/td&gt;
&lt;td&gt;磁盘&lt;/td&gt;
&lt;td&gt;内存&lt;/td&gt;
&lt;td&gt;磁盘&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;压缩能力&lt;/td&gt;
&lt;td&gt;中等&lt;/td&gt;
&lt;td&gt;低&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;极高&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;崩溃恢复&lt;/td&gt;
&lt;td&gt;优秀&lt;/td&gt;
&lt;td&gt;差&lt;/td&gt;
&lt;td&gt;无(数据丢失)&lt;/td&gt;
&lt;td&gt;中等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;全文索引&lt;/td&gt;
&lt;td&gt;5.6+支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;适用场景&lt;/td&gt;
&lt;td&gt;高并发OLTP&lt;/td&gt;
&lt;td&gt;读密集型&lt;/td&gt;
&lt;td&gt;临时/缓存&lt;/td&gt;
&lt;td&gt;归档存储&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;小结&lt;/h3&gt;
&lt;p&gt;1.MyISAM不支持事务、也不支持外键、但是访问速度极快、对于事物完整性没有要求&lt;/p&gt;
&lt;p&gt;2.InnoDB存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全、但是相比于MyISAM存储引擎，InnoDB写的处理效率差一些并且会占用更多的从磁盘空间以保留数据和索引&lt;/p&gt;
&lt;p&gt;3.Memory存储引擎使用存在内存中的内容来创建表，每个Memory表只实际对应一个磁盘文件，该类型的表访问速度极快，因为数据是存放在内存中的，并且默认使用了Hash索引，但是MySQL服务关闭，表中的数据就会丢失，表的结构还在&lt;/p&gt;
&lt;h3&gt;使用案例&lt;/h3&gt;
&lt;p&gt;修改存储引擎&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;alter talble 表名 engine = 存储引擎;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;alter table balance engine = innodb;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建一个MyISAM存储引擎的表，无法使用事务&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create table balance (
`id` int primary key,
`name` varchar(32),
`money` double
) ENGINE MYISAM;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建一个Memory存储引擎的表，支持Hash索引，执行速度很快&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create table balance (
`id` int primary key,
`name` varchar(32),
`money` double
) ENGINE Memory;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;1.如果应用不需要事务，处理的只是基本的增删改查，那么MyISAM是绝佳的选择，速度快&lt;/p&gt;
&lt;p&gt;2.需要事务支持，就选择InnoDB&lt;/p&gt;
&lt;p&gt;3.Memory存储引擎将数据存在内存中，由于没有磁盘的IO等待，速度非常快，但数据不持久&lt;/p&gt;
&lt;h2&gt;视图&lt;/h2&gt;
&lt;p&gt;我们有的时候需要将表中的某几个字段显示使用（有权限需要，不能够每个人都使用select查询整一张表格），我们可以将这几个字段拿出来做成一个视图，还可以将视图的查看权限赋予某个用户&lt;/p&gt;
&lt;h3&gt;基本概念&lt;/h3&gt;
&lt;p&gt;视图是一个虚拟表，其内容由查询定义，同真实的表一样，视图包含列，数据来自于对应的真实表（基表）&lt;/p&gt;
&lt;p&gt;1.视图是根据基表（可以多个基表）来创建的，视图是虚拟的表&lt;/p&gt;
&lt;p&gt;2.视图也有列，数据来自于基表&lt;/p&gt;
&lt;p&gt;3.通过修改视图可以修改基表的数据&lt;/p&gt;
&lt;p&gt;4.基表的改变也会影响到视图的数据&lt;/p&gt;
&lt;h3&gt;基本使用&lt;/h3&gt;
&lt;p&gt;创建视图&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create view 视图名称 as select语句;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;更新视图&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;alter view 视图名称 as select语句;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;显示视图是如何创建的（select语句）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;show create view 视图名;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除视图&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;drop view 视图1,视图2...;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们要对于员工表创建一个名为emp_view的视图（数据包含empno,ename,job,deptno）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create view emp_view as 
select empno,ename,job,deptno from emp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们现在来查看一下这个视图&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp_view;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+-------+--------+----------+--------+
| empno | ename  | job      | deptno |
+-------+--------+----------+--------+
|  7396 | SMITH  | CLERK    |     20 |
|  7499 | ALLEN  | SALESMAN |     30 |
|  7596 | WARD   | SALESMAN |     30 |
|  7696 | JOOES  | MANAGER  |     20 |
|  7796 | MARTIN | SALESMAN |     30 |
|  7896 | BLAKE  | MANAGER  |     30 |
+-------+--------+----------+--------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除视图&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;drop view emp_view;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例题：针对emp，dept，salgrade 三张表格创建一个emp_view视图，可以显示雇员编号，雇员名称，雇员部门名称，薪水级别&lt;/p&gt;
&lt;p&gt;相关的select语句&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select empno,ename,dname,grade from emp, dept, salgrade 
where emp.deptno = dept.deptno
and sal between losal and hisal;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;制作视图&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create view emp_view as
select empno,ename,dname,grade from emp, dept, salgrade 
where emp.deptno = dept.deptno
and sal between losal and hisal;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;视图细节&lt;/h3&gt;
&lt;p&gt;1.创建视图后，到数据库看，对应的视图只有一个视图结构文件(视图名.frm)&lt;/p&gt;
&lt;p&gt;2.视图和基表的修改相互影响&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;update emp_view set deptno = 40 where ename=&apos;SMITH&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;update emp set deptno = 20 where ename=&apos;SMITH&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.视图中可以再次使用视图&lt;/p&gt;
&lt;h3&gt;使用场景&lt;/h3&gt;
&lt;p&gt;安全：一些数据表有着重要的信息，某些字段需要保密，不可以让用户直接看到，这个时候我们就可以创建一个视图，在这个视图中保留安全的字段，而不包含保密的字段&lt;/p&gt;
&lt;p&gt;性能：关系数据库常常会分表存储，使用外键建立这一些表的关系，这个时候，数据库查询通常会用到join连接，这么做不但麻烦，效率也比较低，如果建立一个视图，将相关表的字段组合在一起，就可以避免使用join查询数据&lt;/p&gt;
&lt;p&gt;灵活：如果系统中有一张旧的表，这张表由于设计的问题，即将被废弃，然而，很多表都是基于这一张表，不方便修改，这个时候就可以建立一张视图，视图中的数据直接映射到新建的表，这样就可以做很少的改动，也达到了升级数据表的目的&lt;/p&gt;
&lt;h2&gt;Mysql管理&lt;/h2&gt;
&lt;h3&gt;user表&lt;/h3&gt;
&lt;p&gt;mysql中的用户，都存储在系统数据库mysql中的user表&lt;/p&gt;
&lt;p&gt;其中有一些重要的字段&lt;/p&gt;
&lt;p&gt;host：允许登录的位置，localhost表示该用户只允许本机登录，也可以指定ip&lt;/p&gt;
&lt;p&gt;user：用户名称&lt;/p&gt;
&lt;p&gt;authentication_string：密码，通过mysql的password()函数加密后的密码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select host,user,authentication_string from user;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+-----------+------------------+------------------------------------------------------------------------+
| host      | user             | authentication_string                                                  |
+-----------+------------------+------------------------------------------------------------------------+
| localhost | mysql.infoschema | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED |
| localhost | mysql.session    | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED |
| localhost | mysql.sys        | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED |
| localhost | root             | $A$005$ xgY]U4ieS
8Q+#hB9QVmRfma9kzzSPEIJ1FgvgP7VMuobh4V.rZD0mc7FD  |
+-----------+------------------+------------------------------------------------------------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;用户管理&lt;/h3&gt;
&lt;p&gt;当做项目开发的时候，Mysql数据库管理人员可以根据不同的开发人员，赋给相应的Mysql操作权限，供人员使用&lt;/p&gt;
&lt;h4&gt;创建用户&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;create user &apos;thrinisty&apos; @&apos;localhost&apos; identified by &apos;123456&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;select host,user from user;
+-----------+------------------+
| host      | user             |
+-----------+------------------+
| localhost | mysql.infoschema |
| localhost | mysql.session    |
| localhost | mysql.sys        |
| localhost | root             |
| localhost | thrinisty        |
+-----------+------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们在Navicat中可以用新的用户连接数据库&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/111.png&quot; alt=&quot;111&quot; /&gt;&lt;/p&gt;
&lt;p&gt;可以看到我们新用户表和root用户的表不太一样&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/112.png&quot; alt=&quot;112&quot; /&gt;&lt;/p&gt;
&lt;p&gt;这是因为不同的数据库用户，登录到DBMS，根据相应的权限，可以操作的数据库，数据对象（表、视图、触发器）都不一样&lt;/p&gt;
&lt;h4&gt;删除用户&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;drop user &apos;用户名&apos; @&apos;允许登录的位置&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;修改密码&lt;/h4&gt;
&lt;p&gt;注意以下修改方式是5.7.5版本以下的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;set password = password(&apos;密码&apos;);--修改自身密码
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;set password for &apos;用户名&apos; @&apos;登录位置&apos; = password(&apos;密码&apos;);
--修改他人的密码，需要有用户密码的权限
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我用的8.0版本需要使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ALTER USER USER() IDENTIFIED BY &apos;654321&apos;;--修改自身密码
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;ALTER USER &apos;username&apos;@&apos;hostname&apos; IDENTIFIED BY &apos;654321&apos;;
--修改他人的密码，需要有用户密码的权限
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;权限管理&lt;/h3&gt;
&lt;p&gt;MySQL中有非常多的权限可以赋予用户，我们来使用以下常见的权限&lt;/p&gt;
&lt;h4&gt;常见的权限&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;全选&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;GRANT OPTION&lt;/td&gt;
&lt;td&gt;允许授予权限&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ALL PRIVIEGES&lt;/td&gt;
&lt;td&gt;设置除GRANT OPTTION之外的简单权限&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ALTER&lt;/td&gt;
&lt;td&gt;允许使用 ALTER TABLE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CREATE&lt;/td&gt;
&lt;td&gt;允许使用 CREATE TABLE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CREATE USER&lt;/td&gt;
&lt;td&gt;允许使用增删改用户、移除所有权限&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CREATE VIEW&lt;/td&gt;
&lt;td&gt;允许使用CREATE VIEW&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DELETE&lt;/td&gt;
&lt;td&gt;允许使用DELETE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DROP&lt;/td&gt;
&lt;td&gt;允许使用DROP TABLE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;INDEX&lt;/td&gt;
&lt;td&gt;允许创建删除索引&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;INSERT&lt;/td&gt;
&lt;td&gt;允许使用INSERT插入&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SELECT&lt;/td&gt;
&lt;td&gt;允许使用查询&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SHOW DATABASES&lt;/td&gt;
&lt;td&gt;允许显示所有数据库&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;USAGE&lt;/td&gt;
&lt;td&gt;无权限&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;基本语法&lt;/h4&gt;
&lt;p&gt;赋权指令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;grant 权限列表 on 库.对象名 to 
&apos;用户名&apos;@&apos;登录位置&apos; [identified by &apos;密码&apos;];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;回收权限&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;revoke 权限列表 on 库.对象名 from 
&apos;用户名&apos;@&apos;登录位置&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;刷新权限&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FLUSH PRIVILEGES;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;赋给thrinisty全部表全部对象的all权限&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;grant all on *.* to &apos;thrinisty&apos;@&apos;localhost&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;管理细节&lt;/h3&gt;
&lt;p&gt;1.在创建用户的时候，如果不指定host，则为%，表示所有ip都有链接的权限&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create user jack;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.在删除用户的时候，如果host不是%，需要明确指定‘用户’@‘host值’&lt;/p&gt;
</content:encoded></item><item><title>MySQL笔记</title><link>https://thrinisty.github.io/posts/mysql%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A2%9E%E5%BC%BA%E6%9F%A5%E8%AF%A2%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%E5%A4%96%E8%BF%9E%E6%8E%A5%E5%AD%90%E6%9F%A5%E8%AF%A2%E7%BA%A6%E6%9D%9F/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/mysql%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A2%9E%E5%BC%BA%E6%9F%A5%E8%AF%A2%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%E5%A4%96%E8%BF%9E%E6%8E%A5%E5%AD%90%E6%9F%A5%E8%AF%A2%E7%BA%A6%E6%9D%9F/</guid><description>增强查询，多表查询，外连接，子查询，约束</description><pubDate>Sun, 13 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;MySQL&lt;/h1&gt;
&lt;h2&gt;MySQL表查询&lt;/h2&gt;
&lt;p&gt;在实际开发的过程中，我们需要用到的查询不只有前面的简单查询，我们还需要学习一些更为符合实际的查询方式，如日期查询，多表查询等&lt;/p&gt;
&lt;h3&gt;相关表格&lt;/h3&gt;
&lt;p&gt;我们先来建立几个表格，填入响应数据&lt;/p&gt;
&lt;h4&gt;员工表emp&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE emp (
	`empno` INT,
	`ename` VARCHAR ( 30 ),
	`job` VARCHAR ( 20 ),
	`mgr` INT,
	`hiredate` DATE,
	`sal` DOUBLE,
	`comm` DOUBLE,
`deptno` INT 
);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;INSERT INTO emp
VALUES
	( 7396, &apos;SMITH&apos;, &apos;CLERK&apos;, 7902, &apos;1990-12-17&apos;, 800.00, NULL, 20 ),
	( 7499, &apos;ALLEN&apos;, &apos;SALESMAN&apos;, 7902, &apos;1991-02-20&apos;, 1600.00, 300.00, 30 ),
	( 7596, &apos;WARD&apos;, &apos;SALESMAN&apos;, 7896, &apos;1993-02-07&apos;, 1250.00, 500.00, 30 ),
	( 7696, &apos;JOOES&apos;, &apos;MANAGER&apos;, 7839, &apos;1980-02-01&apos;, 2975.00, NULL, 20 ),
	( 7796, &apos;MARTIN&apos;, &apos;SALESMAN&apos;, 7698, &apos;1999-04-17&apos;, 1250.00, 1400.00, 30 ),
	( 7896, &apos;BLAKE&apos;, &apos;MANAGER&apos;, 7839, &apos;1990-12-17&apos;, 2850.00, NULL, 30 );
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;工作部门表dept&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE dept ( 
`deptno` INT, 
`dname` VARCHAR ( 30 ), 
`loc` VARCHAR ( 30 ) 
);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;INSERT INTO dept
VALUES
	( 10, &apos;ACCOUNTING&apos;, &apos;NEW YORK&apos; ),
	( 20, &apos;RESEARCH&apos;, &apos;DALLAS&apos; ),
	( 30, &apos;SALES&apos;, &apos;CHICAGO&apos; ),
	( 40, &apos;OPERATIONS&apos;, &apos;BOSTON&apos; );
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;薪水表格salgrade&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE salgrade ( 
    `grade` INT, 
    `losal` DOUBLE, 
    `hisal` DOUBLE 
);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;INSERT INTO salgrade
VALUES
	( 1, 700.00, 1200.00 ),
	( 2, 1200.00, 1400.00 ),
	( 3, 1400.00, 3000.00 ),
	( 4, 3000.00, 9000.00 );
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;查询加强&lt;/h3&gt;
&lt;h4&gt;where筛选日期&lt;/h4&gt;
&lt;p&gt;查找1992.1.1后入职的员工&lt;/p&gt;
&lt;p&gt;需要至于格式01-01&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,hiredate from emp where hiredate &amp;gt; &apos;1992-01-01&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+--------+------------+
| ename  | hiredate   |
+--------+------------+
| WARD   | 1993-02-07 |
| MARTIN | 1999-04-17 |
+--------+------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;like模糊查询&lt;/h4&gt;
&lt;p&gt;​	%：表示0到多个任意字符&lt;/p&gt;
&lt;p&gt;​	_ ：表示单个任意字符&lt;/p&gt;
&lt;p&gt;如何显示首字符为s的员工共姓名和工资&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,sal from emp where ename like &apos;s%&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+-------+-----+
| ename | sal |
+-------+-----+
| SMITH | 800 |
+-------+-----+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如何显示第三个字符为大写o的所有员工姓名和工资&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,sal from emp where ename like &apos;__o%&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+-------+------+
| ename | sal  |
+-------+------+
| JOOES | 2975 |
+-------+------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;order by排序&lt;/h4&gt;
&lt;p&gt;从工资低到高显示员工&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp order by sal asc;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+-------+--------+----------+------+------------+------+------+--------+
| empno | ename  | job      | mgr  | hiredate   | sal  | comm | deptno |
+-------+--------+----------+------+------------+------+------+--------+
|  7396 | SMITH  | CLERK    | 7902 | 1990-12-17 |  800 | NULL |     20 |
|  7596 | WARD   | SALESMAN | 7902 | 1993-02-07 | 1250 |  500 |     30 |
|  7796 | MARTIN | SALESMAN | 7698 | 1999-04-17 | 1250 | 1400 |     30 |
|  7499 | ALLEN  | SALESMAN | 7902 | 1991-02-20 | 1600 |  300 |     30 |
|  7896 | BLAKE  | MANAGER  | 7839 | 1990-12-17 | 2850 | NULL |     30 |
|  7696 | JOOES  | MANAGER  | 7839 | 1980-02-01 | 2975 | NULL |     20 |
+-------+--------+----------+------+------------+------+------+--------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;按照部门编号升序，员工工资降序排序（中间用，隔开）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp order by deptno asc , sal desc;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+-------+--------+----------+------+------------+------+------+--------+
| empno | ename  | job      | mgr  | hiredate   | sal  | comm | deptno |
+-------+--------+----------+------+------------+------+------+--------+
|  7696 | JOOES  | MANAGER  | 7839 | 1980-02-01 | 2975 | NULL |     20 |
|  7396 | SMITH  | CLERK    | 7902 | 1990-12-17 |  800 | NULL |     20 |
|  7896 | BLAKE  | MANAGER  | 7839 | 1990-12-17 | 2850 | NULL |     30 |
|  7499 | ALLEN  | SALESMAN | 7902 | 1991-02-20 | 1600 |  300 |     30 |
|  7596 | WARD   | SALESMAN | 7902 | 1993-02-07 | 1250 |  500 |     30 |
|  7796 | MARTIN | SALESMAN | 7698 | 1999-04-17 | 1250 | 1400 |     30 |
+-------+--------+----------+------+------------+------+------+--------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;分页查询&lt;/h4&gt;
&lt;p&gt;在实际开发中我们数据量往往很大，我们会用到分页来进行查询，这里介绍一个关键字limit&lt;/p&gt;
&lt;p&gt;基本语法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ... limit start, rows
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;表示从start + 1 行开始取，取出rows行，例如上述的例子中，我们需要取出前5行结果使用如下的语句即可，从第1行开始取5行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp order by deptno asc , sal desc limit 0, 5;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们是实际中使用我们就可以运用limit限制每一次查询的范围&lt;/p&gt;
&lt;p&gt;要将一个大表范围若干个小表可以这么做&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp order by deptno asc , sal desc limit 0, 4;
select * from emp order by deptno asc , sal desc limit 4, 4;
select * from emp order by deptno asc , sal desc limit 8, 4;
...
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;group by分组&lt;/h4&gt;
&lt;p&gt;我们有如下的几个题目&lt;/p&gt;
&lt;p&gt;1.显示每种岗位的雇员总数，平均工资&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select count(*), avg(sal), job from emp group by job;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.显示雇员的总数，以及获得补助的雇员数&lt;/p&gt;
&lt;p&gt;这里输入comm，comm字段为空则不参与统计&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select count(*), count(comm) from emp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果我们扩展一下&lt;/p&gt;
&lt;p&gt;没有获得补助的员工&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select count(*), count(*)-count(comm) from emp;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;select count(*), count(if(comm is null, 1, null)) from emp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.显示管理者的总人数&lt;/p&gt;
&lt;p&gt;先count再去重&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select count(distinct mgr) from emp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.显示雇员工资的最大差值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select max(sal)-min(sal) from emp;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;多子句查询&lt;/h4&gt;
&lt;p&gt;顺序：如果一个select语句同时包含了group by，having，limit，order by，那么它们的顺序应该为：group by，having，order by，limit&lt;/p&gt;
&lt;p&gt;例如统计各个部门的平均工资，并且是大于1000的，按照平均工资从高到低排序，取出前两行记录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select avg(sal),deptno from emp 
group by deptno 
having avg(sal)&amp;gt;1000 
order by avg(sal) desc 
limit 0, 2;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其实更建议使用as重命名，可以增快速度&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select avg(sal) as asql, deptno from emp 
group by deptno 
having asql&amp;gt;1000 
order by asql desc 
limit 0, 2;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+----------+--------+
| avg(sal) | deptno |
+----------+--------+
|   1887.5 |     20 |
|   1737.5 |     30 |
+----------+--------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;多表查询&lt;/h3&gt;
&lt;p&gt;多表查询是指基于两个和两个以上的表的查询，在实际的应用中，查询单个表可能不能满足需求&lt;/p&gt;
&lt;p&gt;例如说显示雇员名，雇员工资，所在部门的名字，就需要员工表和工作部门表&lt;/p&gt;
&lt;h4&gt;多表笛卡尔集&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;select * from emp, dept;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可见笛卡尔集需要将两种表做笛卡尔积（在不加条件的结果非常夸张）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+-------+--------+----------+------+------------+------+------+--------+--------+------------+----------+
| empno | ename  | job      | mgr  | hiredate   | sal  | comm | deptno | deptno | dname      | loc      |
+-------+--------+----------+------+------------+------+------+--------+--------+------------+----------+
|  7396 | SMITH  | CLERK    | 7902 | 1990-12-17 |  800 | NULL |     20 |     40 | OPERATIONS | BOSTON   |
|  7396 | SMITH  | CLERK    | 7902 | 1990-12-17 |  800 | NULL |     20 |     30 | SALES      | CHICAGO  |
|  7396 | SMITH  | CLERK    | 7902 | 1990-12-17 |  800 | NULL |     20 |     20 | RESEARCH   | DALLAS   |
|  7396 | SMITH  | CLERK    | 7902 | 1990-12-17 |  800 | NULL |     20 |     10 | ACCOUNTING | NEW YORK |
|  7499 | ALLEN  | SALESMAN | 7902 | 1991-02-20 | 1600 |  300 |     30 |     40 | OPERATIONS | BOSTON   |
|  7499 | ALLEN  | SALESMAN | 7902 | 1991-02-20 | 1600 |  300 |     30 |     30 | SALES      | CHICAGO  |
|  7499 | ALLEN  | SALESMAN | 7902 | 1991-02-20 | 1600 |  300 |     30 |     20 | RESEARCH   | DALLAS   |
|  7499 | ALLEN  | SALESMAN | 7902 | 1991-02-20 | 1600 |  300 |     30 |     10 | ACCOUNTING | NEW YORK |
|  7596 | WARD   | SALESMAN | 7902 | 1993-02-07 | 1250 |  500 |     30 |     40 | OPERATIONS | BOSTON   |
|  7596 | WARD   | SALESMAN | 7902 | 1993-02-07 | 1250 |  500 |     30 |     30 | SALES      | CHICAGO  |
|  7596 | WARD   | SALESMAN | 7902 | 1993-02-07 | 1250 |  500 |     30 |     20 | RESEARCH   | DALLAS   |
|  7596 | WARD   | SALESMAN | 7902 | 1993-02-07 | 1250 |  500 |     30 |     10 | ACCOUNTING | NEW YORK |
|  7696 | JOOES  | MANAGER  | 7839 | 1980-02-01 | 2975 |  100 |     20 |     40 | OPERATIONS | BOSTON   |
|  7696 | JOOES  | MANAGER  | 7839 | 1980-02-01 | 2975 |  100 |     20 |     30 | SALES      | CHICAGO  |
|  7696 | JOOES  | MANAGER  | 7839 | 1980-02-01 | 2975 |  100 |     20 |     20 | RESEARCH   | DALLAS   |
|  7696 | JOOES  | MANAGER  | 7839 | 1980-02-01 | 2975 |  100 |     20 |     10 | ACCOUNTING | NEW YORK |
|  7796 | MARTIN | SALESMAN | 7698 | 1999-04-17 | 1250 | 1400 |     30 |     40 | OPERATIONS | BOSTON   |
|  7796 | MARTIN | SALESMAN | 7698 | 1999-04-17 | 1250 | 1400 |     30 |     30 | SALES      | CHICAGO  |
|  7796 | MARTIN | SALESMAN | 7698 | 1999-04-17 | 1250 | 1400 |     30 |     20 | RESEARCH   | DALLAS   |
|  7796 | MARTIN | SALESMAN | 7698 | 1999-04-17 | 1250 | 1400 |     30 |     10 | ACCOUNTING | NEW YORK |
|  7896 | BLAKE  | MANAGER  | 7839 | 1990-12-17 | 2850 | NULL |     30 |     40 | OPERATIONS | BOSTON   |
|  7896 | BLAKE  | MANAGER  | 7839 | 1990-12-17 | 2850 | NULL |     30 |     30 | SALES      | CHICAGO  |
|  7896 | BLAKE  | MANAGER  | 7839 | 1990-12-17 | 2850 | NULL |     30 |     20 | RESEARCH   | DALLAS   |
|  7896 | BLAKE  | MANAGER  | 7839 | 1990-12-17 | 2850 | NULL |     30 |     10 | ACCOUNTING | NEW YORK |
+-------+--------+----------+------+------------+------+------+--------+--------+------------+----------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当不加限制的情况下，两张表的查询规则：&lt;/p&gt;
&lt;p&gt;把第一张表的每一条记录和第二张表的每一条记录组合，返回结果是两张表的所有列，一共返回的记录数是第一张表的行数和第二张表的行数的乘积，而组成的表称为笛卡尔集&lt;/p&gt;
&lt;p&gt;我们需要使用where对于笛卡尔集进行过滤，需要进行分析&lt;/p&gt;
&lt;p&gt;当两张表的deptno编号相等的时候才是我们需要的结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp, dept where emp.deptno=dept.deptno;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+-------+--------+----------+------+------------+------+------+--------+--------+----------+---------+
| empno | ename  | job      | mgr  | hiredate   | sal  | comm | deptno | deptno | dname    | loc     |
+-------+--------+----------+------+------------+------+------+--------+--------+----------+---------+
|  7396 | SMITH  | CLERK    | 7902 | 1990-12-17 |  800 | NULL |     20 |     20 | RESEARCH | DALLAS  |
|  7499 | ALLEN  | SALESMAN | 7902 | 1991-02-20 | 1600 |  300 |     30 |     30 | SALES    | CHICAGO |
|  7596 | WARD   | SALESMAN | 7902 | 1993-02-07 | 1250 |  500 |     30 |     30 | SALES    | CHICAGO |
|  7696 | JOOES  | MANAGER  | 7839 | 1980-02-01 | 2975 |  100 |     20 |     20 | RESEARCH | DALLAS  |
|  7796 | MARTIN | SALESMAN | 7698 | 1999-04-17 | 1250 | 1400 |     30 |     30 | SALES    | CHICAGO |
|  7896 | BLAKE  | MANAGER  | 7839 | 1990-12-17 | 2850 | NULL |     30 |     30 | SALES    | CHICAGO |
+-------+--------+----------+------+------------+------+------+--------+--------+----------+---------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;笛卡尔例题&lt;/h4&gt;
&lt;p&gt;显示雇员名，雇员工资，所在部门的名字&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,sal,dname from emp, dept where emp.deptno=dept.deptno;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+--------+------+----------+
| ename  | sal  | dname    |
+--------+------+----------+
| SMITH  |  800 | RESEARCH |
| ALLEN  | 1600 | SALES    |
| WARD   | 1250 | SALES    |
| JOOES  | 2975 | RESEARCH |
| MARTIN | 1250 | SALES    |
| BLAKE  | 2850 | SALES    |
+--------+------+----------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而在选取重复列的时候，需要指定是哪一个表的列&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,sal,dname,emp.deptno from emp, dept where emp.deptno=dept.deptno;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+--------+------+----------+--------+
| ename  | sal  | dname    | deptno |
+--------+------+----------+--------+
| SMITH  |  800 | RESEARCH |     20 |
| ALLEN  | 1600 | SALES    |     30 |
| WARD   | 1250 | SALES    |     30 |
| JOOES  | 2975 | RESEARCH |     20 |
| MARTIN | 1250 | SALES    |     30 |
| BLAKE  | 2850 | SALES    |     30 |
+--------+------+----------+--------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;显示部门编号为20的部门名称，员工名，工资&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,sal,dname,emp.deptno 
from emp,dept 
where emp.deptno = dept.deptno 
and emp.deptno = 20;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+-------+------+----------+--------+
| ename | sal  | dname    | deptno |
+-------+------+----------+--------+
| SMITH |  800 | RESEARCH |     20 |
| JOOES | 2975 | RESEARCH |     20 |
+-------+------+----------+--------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;显示各个员工的姓名，工资，以及工资级别&lt;/p&gt;
&lt;p&gt;我们先选好需要的表格是emp表和salgrade表，我们这一道题的要点在于过滤条件该如何筛选&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,sal,grade from emp, salgrade;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+--------+------+-------+
| ename  | sal  | grade |
+--------+------+-------+
| SMITH  |  800 |     4 |
| SMITH  |  800 |     3 |
| SMITH  |  800 |     2 |
| SMITH  |  800 |     1 |
| ALLEN  | 1600 |     4 |
| ALLEN  | 1600 |     3 |
| ALLEN  | 1600 |     2 |
| ALLEN  | 1600 |     1 |
| WARD   | 1250 |     4 |
| WARD   | 1250 |     3 |
| WARD   | 1250 |     2 |
| WARD   | 1250 |     1 |
| JOOES  | 2975 |     4 |
| JOOES  | 2975 |     3 |
| JOOES  | 2975 |     2 |
| JOOES  | 2975 |     1 |
| MARTIN | 1250 |     4 |
| MARTIN | 1250 |     3 |
| MARTIN | 1250 |     2 |
| MARTIN | 1250 |     1 |
| BLAKE  | 2850 |     4 |
| BLAKE  | 2850 |     3 |
| BLAKE  | 2850 |     2 |
| BLAKE  | 2850 |     1 |
+--------+------+-------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运用between and语句即可完成，判断sal位于最高工资和最低工资之间即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,sal,grade from emp, salgrade 
where sal between losal and hisal;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+--------+------+-------+
| ename  | sal  | grade |
+--------+------+-------+
| SMITH  |  800 |     1 |
| ALLEN  | 1600 |     3 |
| WARD   | 1250 |     2 |
| JOOES  | 2975 |     3 |
| MARTIN | 1250 |     2 |
| BLAKE  | 2850 |     3 |
+--------+------+-------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;自连接&lt;/h4&gt;
&lt;p&gt;是指的是同一张表的连接查询&lt;/p&gt;
&lt;p&gt;显示公司员工和它上级的名字&lt;/p&gt;
&lt;p&gt;这个时候我们就需要使用到表的自连接，将员工和上级放在同一行中筛选完成（还需要有一个别名）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp empee, emp boss;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样就可以将同一张表连接起来，我们再去写过滤条件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select empee.ename,boss.ename  
from emp empee, emp boss 
where empee.mgr = boss.empno;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+-------+-------+
| ename | ename |
+-------+-------+
| WARD  | BLAKE |
+-------+-------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;子查询&lt;/h3&gt;
&lt;p&gt;子查询是指嵌入在其他sql语句中的select语句，也成为嵌套查询&lt;/p&gt;
&lt;p&gt;单行子查询：只返回一行数据的子查询语句&lt;/p&gt;
&lt;p&gt;多行子查询：返回多行数据的子查询语句（in）&lt;/p&gt;
&lt;p&gt;单行子查询例题&lt;/p&gt;
&lt;p&gt;如何显示于SMITH同一部门的所有员工&lt;/p&gt;
&lt;p&gt;我们首先需要得到SMITH的部门号，再通过部门号筛选&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select deptno from emp where ename = &apos;SMITH&apos;;//20
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;select * from emp where deptno = 20;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们可以把第一个查询嵌入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp 
where deptno = (
	select deptno 
    from emp 
    where ename = &apos;SMITH&apos;
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即可完成&lt;/p&gt;
&lt;p&gt;多行子查询例题&lt;/p&gt;
&lt;p&gt;查询和部门20的工作相同的雇员的名字、岗位、部门号，但是不包含20自己的&lt;/p&gt;
&lt;p&gt;第一步：查询20号部门有哪一些工作岗位（还需要去重）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select distinct job from emp where deptno = 20;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+---------+
| job     |
+---------+
| CLERK   |
| MANAGER |
+---------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二步：运用job的工作字段进行查询筛选&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,job,sal,deptno from emp 
where job in(&apos;CLERK&apos;,&apos;MANAGER&apos;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第三步：不包含20号部门&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,job,sal,deptno from emp 
where job in(&apos;CLERK&apos;,&apos;MANAGER&apos;) and deptno&amp;lt;&amp;gt;20;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;综合嵌套一下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,job,sal,deptno from emp 
where job in(
	select distinct job 
	from emp 
	where deptno = 20) 
and deptno&amp;lt;&amp;gt;20;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;子查询临时表&lt;/h4&gt;
&lt;p&gt;查询ecshop中各个类别中，价格最高的商品&lt;/p&gt;
&lt;p&gt;先得到各个类别中价格最高的商品&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select cat_id, max(shop_price) from ecsshop
group by cat_id;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们可以将这个表格和ecsshop表进行连接，在设置过滤条件即可完成要求&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ecshop.cat_id, ecshop.goods_name 
from ecshop,(
select cat_id, max(shop_price) as max_price
from ecshop
group by cat_id)temp
where ecshop.cat_id=temp.cat_id 
and ecshop.shop_price=temp.max_price;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;all和any操作符&lt;/h4&gt;
&lt;p&gt;all&lt;/p&gt;
&lt;p&gt;所有的字段都满足&lt;/p&gt;
&lt;p&gt;显示比部门30的所有员工的工资高的员工姓名、工资、部门号&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,sal,deptno from emp 
where sal&amp;gt;
all(
    select sal 
    from emp 
    where deptno = 30);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以运用max查询最大的薪水，再通过判断条件筛选&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,sal,deptno from emp 
where sal&amp;gt;
(select max(sal) 
 from emp 
 where deptno = 30);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;any&lt;/p&gt;
&lt;p&gt;有一个字段满足条件即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,sal,deptno from emp 
where sal&amp;gt;
any(
    select sal 
    from emp 
    where deptno = 30);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以改为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,sal,deptno from emp 
where sal&amp;gt;
(select min(sal) 
 from emp 
 where deptno = 30);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;多列子查询&lt;/h4&gt;
&lt;p&gt;多列子查询指的是查询返回多个列数据的子查询语句&lt;/p&gt;
&lt;p&gt;例如查询于SMITH部门，岗位完全相同的所有雇员&lt;/p&gt;
&lt;p&gt;第一步：查询SMITH所在的部门以及岗位&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select deptno,job from emp where ename=&apos;SMITH&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+--------+-------+
| deptno | job   |
+--------+-------+
|     20 | CLERK |
+--------+-------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二步：将上述的查询结果当作查询使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename, deptno, job from emp 
where deptno=20 
and job=&apos;CLERK&apos;
and ename&amp;lt;&amp;gt;&apos;SMITH&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;综合嵌套(运用（）来进行相应的字段匹配)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename, deptno, job from emp 
where (deptno, job) = (
	select deptno,job from emp 
    where ename=&apos;SMITH&apos;
)
and ename&amp;lt;&amp;gt;&apos;SMITH&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;相关例题&lt;/h4&gt;
&lt;p&gt;例题一：&lt;/p&gt;
&lt;p&gt;查找每个部门工资高于本部门平均工资人的资料&lt;/p&gt;
&lt;p&gt;第一步：查询部门的平均工资&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select deptno, avg(sal) from emp group by deptno;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二步：将查询的结果表和员工表进行拼接，再进行筛选&lt;/p&gt;
&lt;p&gt;(这里的emp.*代表选出emp表的所有字段)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select emp.* from emp,(
	select deptno, avg(sal)as avg_sal
	from emp group by deptno
)temp where emp.deptno=temp.deptno 
and emp.sal&amp;gt;temp.avg_sal;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例题二：&lt;/p&gt;
&lt;p&gt;查询每个部门工资最高的人的详细资料&lt;/p&gt;
&lt;p&gt;第一步：查询部门的最高工资&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select deptno, max(sal) from emp group by deptno;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二步：将查询的结果表和员工表进行拼接，再进行筛选&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select emp.* from emp,(
	select deptno, max(sal)as avg_sal
	from emp group by deptno
)temp where emp.deptno=temp.deptno 
and emp.sal=temp.avg_sal;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例题三：&lt;/p&gt;
&lt;p&gt;查询每个部门的信息（包括：部门名，编号，地址）和人员数量&lt;/p&gt;
&lt;p&gt;思路：我们的信息来自于dept表，而人员数量需要构建临时表格&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select count(*),deptno from emp group by deptno;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+----------+--------+
| count(*) | deptno |
+----------+--------+
|        2 |     20 |
|        4 |     30 |
+----------+--------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;和部门信息表格拼接&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select dept.*, countp 
from dept,(
	select deptno,count(*)as countp 
	from emp 
    group by deptno)temp 
where dept.deptno=temp.deptno;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+--------+----------+---------+--------+
| deptno | dname    | loc     | countp |
+--------+----------+---------+--------+
|     20 | RESEARCH | DALLAS  |      2 |
|     30 | SALES    | CHICAGO |      4 |
+--------+----------+---------+--------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;表复制&lt;/h3&gt;
&lt;h4&gt;自我复制数据&lt;/h4&gt;
&lt;p&gt;有的时候，为了对于某个sql语句进行效率测试，我们需要海量的数据，可以使用此法为表创建海量的数据&lt;/p&gt;
&lt;p&gt;例如创建这一张表&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create table my_table(	
	id int,
    `name` varchar(32),
	sal double,
	job varchar(32),
	deptno int
	);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们先将emp表中的内容复制到创建的新表中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;insert into my_table(id,`name`,sal,job,deptno)
select empno,ename,sal,job,deptno from emp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;自我复制：每一次都会将表中的内容复制添加到自己的表中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;insert into my_table
select * from my_table;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;去除表中的重复数据&lt;/h4&gt;
&lt;p&gt;可以通过like创建一个新表，格式和旧表一样&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create table table2 like table1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;思路：&lt;/p&gt;
&lt;p&gt;1.创建一张临时表mytemp,该表数据结构和my_table一样&lt;/p&gt;
&lt;p&gt;2.把my_temp的记录通过distinct关键字处理复制&lt;/p&gt;
&lt;p&gt;3.清除掉原先表my_table的记录&lt;/p&gt;
&lt;p&gt;4.将my_temp的记录复制到my_table&lt;/p&gt;
&lt;p&gt;5.drop删除临时表my_temp&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create table my_temp like my_table;

insert into my_temp
select distinct * from my_table;

delete from my_table;

insert into my_table
select * from my_temp;

drop table my_temp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者你直接删除原先的my_table表，再将my_temp表格更改名称为my_table&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rename table my_temp to my_table;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;合并查询&lt;/h3&gt;
&lt;h4&gt;union&lt;/h4&gt;
&lt;p&gt;在实际使用的时候，有的时候我们需要合并多个select语句查询到的结果，我们会用到union操作&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select... union select...;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例如我们查询职业名称为clerk和部门号为20的并集&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp where job=&apos;clerk&apos; 
union select * from emp where deptno=20;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;union all&lt;/h4&gt;
&lt;p&gt;如果你添加了all，则不会去除重复内容&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp where job=&apos;clerk&apos; 
union all select * from emp where deptno=20;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;外连接&lt;/h3&gt;
&lt;h4&gt;问题引出&lt;/h4&gt;
&lt;p&gt;还记得之前我们的多表查询嘛，我们在合并表的时候会求多表的笛卡尔集&lt;/p&gt;
&lt;p&gt;我们有一个要求如下：列出部门名称和这些部门的员工名称和工作，同时要求显示出那些没有员工的部门名&lt;/p&gt;
&lt;p&gt;我们如果用笛卡尔积的话查询结果如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select dname,ename,job 
from emp,dept 
where emp.deptno=dept.deptno;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+----------+--------+----------+
| dname    | ename  | job      |
+----------+--------+----------+
| RESEARCH | SMITH  | CLERK    |
| RESEARCH | JOOES  | MANAGER  |
| SALES    | ALLEN  | SALESMAN |
| SALES    | WARD   | SALESMAN |
| SALES    | MARTIN | SALESMAN |
| SALES    | BLAKE  | MANAGER  |
+----------+--------+----------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是事实上我们的部门中还有其他的部门没有显示出来&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+--------+------------+----------+
| deptno | dname      | loc      |
+--------+------------+----------+
|     10 | ACCOUNTING | NEW YORK |
|     20 | RESEARCH   | DALLAS   |
|     30 | SALES      | CHICAGO  |
|     40 | OPERATIONS | BOSTON   |
+--------+------------+----------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是因为员工表的部门号没有10、40无法匹配到部门表，我们要实现显示出那些没有员工的部门，我们需要外连接，我们创建如下的表作演示&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE stu (
`id` INT,
`name` VARCHAR ( 32 ));

INSERT INTO stu
VALUES
	( 1, &apos;Jack&apos; ),
	( 2, &apos;Tom&apos; ),
	( 3, &apos;Kity&apos; ),
	( 4, &apos;nono&apos; );
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE exam (
`id` INT,
`grade` INT);

INSERT INTO exam
VALUES
	( 1, 56 ),
	( 2, 76 ),
	( 11, 8 );
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用where条件筛选后&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from stu,exam where stu.id=exam.id;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+----+------+----+-------+
| id | name | id | grade |
+----+------+----+-------+
|  1 | Jack |  1 |    56 |
|  2 | Tom  |  2 |    76 |
+----+------+----+-------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可见是没有11号id和4号id的行记录的，因为id不是左右两表都有&lt;/p&gt;
&lt;h4&gt;左外连接&lt;/h4&gt;
&lt;p&gt;左侧的表完全显示（如果没有成绩也要显示姓名与id）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from stu left join exam on stu.id=exam.id;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+----+------+------+-------+
| id | name | id   | grade |
+----+------+------+-------+
|  1 | Jack |    1 |    56 |
|  2 | Tom  |    2 |    76 |
|  3 | Kity | NULL | NULL  |
|  4 | nono | NULL | NULL  |
+----+------+------+-------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;右外连接&lt;/h4&gt;
&lt;p&gt;又侧的表完全显示（如果没有姓名也要显示成绩与id）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from stu right join exam on stu.id=exam.id;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+------+------+----+-------+
| id   | name | id | grade |
+------+------+----+-------+
|    1 | Jack |  1 |    56 |
|    2 | Tom  |  2 |    76 |
| NULL | NULL | 11 |     8 |
+------+------+----+-------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;例题&lt;/h4&gt;
&lt;p&gt;回到我们的例题：列出部门名称和这些部门的员工名称和工作，同时要求显示出那些没有员工的部门名&lt;/p&gt;
&lt;p&gt;左外连接实现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select dept.deptno,dname,ename,job 
from dept left join emp 
on dept.deptno=emp.deptno; 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+--------+------------+--------+----------+
| deptno | dname      | ename  | job      |
+--------+------------+--------+----------+
|     10 | ACCOUNTING | NULL   | NULL     |
|     20 | RESEARCH   | JOOES  | MANAGER  |
|     20 | RESEARCH   | SMITH  | CLERK    |
|     30 | SALES      | BLAKE  | MANAGER  |
|     30 | SALES      | MARTIN | SALESMAN |
|     30 | SALES      | WARD   | SALESMAN |
|     30 | SALES      | ALLEN  | SALESMAN |
|     40 | OPERATIONS | NULL   | NULL     |
+--------+------------+--------+----------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;右外连接实现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select dept.deptno,dname,ename,job 
from emp right join dept 
on dept.deptno=emp.deptno; 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+--------+------------+--------+----------+
| deptno | dname      | ename  | job      |
+--------+------------+--------+----------+
|     10 | ACCOUNTING | NULL   | NULL     |
|     20 | RESEARCH   | JOOES  | MANAGER  |
|     20 | RESEARCH   | SMITH  | CLERK    |
|     30 | SALES      | BLAKE  | MANAGER  |
|     30 | SALES      | MARTIN | SALESMAN |
|     30 | SALES      | WARD   | SALESMAN |
|     30 | SALES      | ALLEN  | SALESMAN |
|     40 | OPERATIONS | NULL   | NULL     |
+--------+------------+--------+----------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;MySQL中的约束&lt;/h2&gt;
&lt;p&gt;何为约束？&lt;/p&gt;
&lt;p&gt;约束是用于确保数据库数据满足特定的商业规则，而再mysql中约束包括not null、unique、primary key、foreign key、check五种&lt;/p&gt;
&lt;h3&gt;primary key&lt;/h3&gt;
&lt;p&gt;primary key：用于唯一的标示表行的数据，当定义主键约束之后，该列不可以重复，以下是一个案例&lt;/p&gt;
&lt;p&gt;创建一个主键为id表，向其中插入数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE primary_test (
	`id` INT PRIMARY KEY,
	`name` VARCHAR ( 32 ),
	`email` VARCHAR ( 32 ) 
)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;insert into primary_test values
(1,&apos;jack&apos;,&apos;jack@qq.com&apos;),
(2,&apos;marry&apos;,&apos;marry@gmail.com&apos;),
(3,&apos;lory&apos;,&apos;lory@163.com&apos;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们现在加一条语句，id为1（之前加过id为1的记录）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;insert into primary_test values(1,&apos;jerry&apos;,&apos;jerry@qq.com&apos;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;报错&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; 1062 - Duplicate entry &apos;1&apos; for key &apos;primary_test.PRIMARY&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;主键的细节&lt;/p&gt;
&lt;p&gt;1.一张表最多只能有一个主键，但可以是复合主键&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE primary_test2 (
	`id` INT ,
	`name` VARCHAR ( 32 ),
	`email` VARCHAR ( 32 ) ,
	 primary key(`id`,`name`)
) ;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.主键的指定方式有两种，第一种是直接在字段名 类型后加上primary key，第二种是在表的定义最后加上primary key(列名)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE primary_test4 (
	`id` INT ,
	`name` VARCHAR ( 32 ),
	`email` VARCHAR ( 32 ) ,
	 primary key(`id`)
) ;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.使用desc可以查看主键情况&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+-------+-------------+------+-----+---------+-------+
| Field | Type        | Null | Key | Default | Extra |
+-------+-------------+------+-----+---------+-------+
| id    | int         | NO   | PRI | NULL    |       |
| name  | varchar(32) | YES  |     | NULL    |       |
| email | varchar(32) | YES  |     | NULL    |       |
+-------+-------------+------+-----+---------+-------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.主键不可以重复且不能为空&lt;/p&gt;
&lt;h3&gt;not null&lt;/h3&gt;
&lt;p&gt;非空约束，当列上定义了not null，那么插入数据的时候必须要提供数据&lt;/p&gt;
&lt;h3&gt;unique&lt;/h3&gt;
&lt;p&gt;唯一约束&lt;/p&gt;
&lt;p&gt;1.当定义了唯一约束的时候，该列的值不可以重复&lt;/p&gt;
&lt;p&gt;2.一张表可以有多个unique字段&lt;/p&gt;
&lt;p&gt;3.当unique没有添加非空约束，则unique字段可以有多个null&lt;/p&gt;
&lt;h3&gt;foreign key&lt;/h3&gt;
&lt;p&gt;外键&lt;/p&gt;
&lt;p&gt;用于定义主表和从表之间的关系：外键约束要定义在从表上，主表则必须要拥有主键约束或者是unique约束，当定义外键约束后，要求外键列数据必须要在主表的主键列存在或者是null&lt;/p&gt;
&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;p&gt;例如我们有一个学生表其中有id和class_id，还有一个班级表，有属性id，如果我们要求，每个学生所在的班级号class_id是存在于班级表的，就可以把class_id做成外键约束（班级表为主表，而学生表为从表）&lt;/p&gt;
&lt;p&gt;当我们插入一个学生它的班级编号不存在于班级表，则插入失败&lt;/p&gt;
&lt;p&gt;当我们学生表有一个学生他的班级编号存在班级表，则删除对应的班级表id会删除失败&lt;/p&gt;
&lt;p&gt;班级表（主表）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE my_class (
	`id` INT primary key,
	`name` VARCHAR ( 32 ),
	`add` VARCHAR ( 32 ) 
) ;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;学生表（从表）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE my_stu (
	`id` INT primary key,
	`name` VARCHAR (32) NOT NULL,
	`class_id` int,
	foreign key(class_id) references my_class(id)
) ;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;外键细节&lt;/p&gt;
&lt;p&gt;1.外键指向的表字段，要求为primary key或者是unique&lt;/p&gt;
&lt;p&gt;2.表的类型是innodb，这样的表才支持外键&lt;/p&gt;
&lt;p&gt;3.外键字段的类型要求和主键字段类型一致&lt;/p&gt;
&lt;p&gt;4.外键字段的值必须要求在主键字段中出现过，或者为null&lt;/p&gt;
&lt;p&gt;5.一旦建立主外键的关系，数据就不可以随意删除了&lt;/p&gt;
&lt;h3&gt;check&lt;/h3&gt;
&lt;p&gt;用于强制行数据必须满足条件，注意在mysql 5.7，这里插入不符合check的数据会成功（只是会提示）8.0是会生效的&lt;/p&gt;
&lt;p&gt;假设sal列上定义了check约束，并要求sql列值在1000-2000之间，性别为两个，那么如果插入的记录如果不满足相关条件就会提示报错&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE test (
	`id` INT primary key,
	`name` VARCHAR (32) NOT NULL,
	`sex` VARCHAR(10) CHECK (`sex` IN(&apos;man&apos;,&apos;woman&apos;)),
	`sal` double CHECK (`sal`&amp;gt;1000 and `sal`&amp;lt;2000)
) ;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;表设计&lt;/h3&gt;
&lt;p&gt;现有一个商店的数据库shop_database，记录客户以及其购物情况，有以下的三个表组成&lt;/p&gt;
&lt;p&gt;goods商品表：&lt;/p&gt;
&lt;p&gt;商品号goods_id  商品名称goods_name  价格price  商品类别category 供货商provider&lt;/p&gt;
&lt;p&gt;customer顾客表：&lt;/p&gt;
&lt;p&gt;客户号customer_id  姓名name  住址address  邮箱email  性别sex  身份证id&lt;/p&gt;
&lt;p&gt;purchase购买表：&lt;/p&gt;
&lt;p&gt;订单号order_id  客户号customer_id  商品号goods_id  购买数量nums&lt;/p&gt;
&lt;p&gt;要求如下：&lt;/p&gt;
&lt;p&gt;1.合理定义主键、外键&lt;/p&gt;
&lt;p&gt;2.客户姓名不可以为空值&lt;/p&gt;
&lt;p&gt;3.电子邮箱不可以为重复&lt;/p&gt;
&lt;p&gt;4.客户的性别约束‘男’|‘女’&lt;/p&gt;
&lt;p&gt;5.价格在1.0——9999.99之间&lt;/p&gt;
&lt;p&gt;goods&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create table goods(
goods_id int primary key,
goods_name varchar(30) not null default &apos;&apos;,
price decimal(10,2)not null 
    check(price between 1.0 and 9999.99),
category int not null default &apos;&apos;,
provider varchar(30)
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;customer&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create table customer(
customer_id int primary key,
name varchar(30) not null,
address varchar(30),
email varchar(30),
sex varchar(10) check(sex IN(&apos;男&apos;,&apos;女&apos;)),
id decimal(20,0) unique
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;purchase&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create table purchase(
order_id int primary key,
customer_id int not null,
goods_id int not null,
nums int,
FOREIGN key(customer_id) REFERENCES customer(customer_id),
FOREIGN key(goods_id) REFERENCES goods(goods_id)
);
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>MySQL笔记</title><link>https://thrinisty.github.io/posts/mysql%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E4%BF%AE%E6%94%B9%E8%A1%A8crud%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/mysql%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E4%BF%AE%E6%94%B9%E8%A1%A8crud%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</guid><description>修改表，CRUD，常用函数</description><pubDate>Fri, 11 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;MySQL笔记&lt;/h1&gt;
&lt;h2&gt;修改表&lt;/h2&gt;
&lt;p&gt;我们修改表可以通过图形化界面进行修改，这一般比较方便，但是有一些限制，例如需要批量修改，条件限制的情况，我们也需要学会通过指令来对于表进行操作&lt;/p&gt;
&lt;h3&gt;添加列&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;ALTER TABLE table_name ADD(column datatype [DEFAULT expr]
, column datatype [DEFAULT expr]...);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;修改列&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;ALTER TABLE table_name MODIFY(column datatype [DEFAULT expr]
, column datatype [DEFAULT expr]...);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;删除列&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;ALTER TABLE table_name DROP(column);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;重命名表&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;RENAME TABLE `oldTable` TO `newTable`;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;查看表结构&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;desc newtable;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+------------+-------------+------+-----+---------+-------+
| Field      | Type        | Null | Key | Default | Extra |
+------------+-------------+------+-----+---------+-------+
| id         | int         | YES  |     | NULL    |       |
| name       | varchar(20) | YES  |     | NULL    |       |
| sex        | char(1)     | YES  |     | NULL    |       |
| birthday   | date        | YES  |     | NULL    |       |
| entry_date | datetime    | YES  |     | NULL    |       |
| job        | varchar(20) | YES  |     | NULL    |       |
| Salary     | double      | YES  |     | NULL    |       |
| resume     | text        | YES  |     | NULL    |       |
+------------+-------------+------+-----+---------+-------+
8 rows in set (0.09 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;修改表字符集&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;ALTER TABLE table_name character set utf8;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;例题&lt;/h3&gt;
&lt;p&gt;1.在创建的员工表上增加一个image列，varchar类型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ALTER TABLE employ ADD `image` VARCHAR ( 30 );
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.修改job列，使其长度为60&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ALTER TABLE employ MODIFY `job` VARCHAR ( 60 );
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.删除sex列&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ALTER TABLE employ DROP `sex`;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.将表名更改为employee&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rename table employ to employee;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.修改表的字符集为utf8&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ALTER TABLE employee CHARACTER SET utf8;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;6.将列名name修改为user_name&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ALTER TABLE employee CHANGE `name` user_name VARCHAR(32); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们在修改列属性的时候可以加一些规则，例如不为空，默认为&apos;null&apos;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ALTER TABLE employee MODIFY `user_name` VARCHAR(32) NOT NULL DEFAULT &apos;null&apos;; 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;CRUD&lt;/h2&gt;
&lt;p&gt;create read update delete 增删改查&lt;/p&gt;
&lt;p&gt;我们在之前也曾用到过这一些语句，现在我们系统的来进行学习CRUD&lt;/p&gt;
&lt;h3&gt;Insert（增）&lt;/h3&gt;
&lt;h4&gt;基本使用&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;INSERT INTO table_name [(column, column, ...)] VALUES (value, value, ...)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例如&lt;/p&gt;
&lt;p&gt;创建一张商品表(id int , goods_name varchar(10), price double)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE goods(
`id` int,
`goods_name` varchar(10),
`price` double);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中添加两条数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;INSERT INTO goods VALUES (1, &apos;牙刷&apos;, 10.0);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;INSERT INTO goods (id, goods_name) VALUES (2, &apos;牙膏&apos;);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; select * from goods;

+----+------------+-------+
| id | goods_name | price |
+----+------------+-------+
|  1 | 牙刷       |    10 |
|  2 | 牙膏       | NULL  |
+----+------------+-------+
2 rows in set (0.08 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;注意细节&lt;/h4&gt;
&lt;p&gt;1.插入的数据应该与字段的数据类型相同&lt;/p&gt;
&lt;p&gt;2.数据的长度因该在列的规定范围内&lt;/p&gt;
&lt;p&gt;3.value中列出的数据位置必须于被加入的列的排列位置对应&lt;/p&gt;
&lt;p&gt;4.字符和日期类型数据需要包含在单引号中&lt;/p&gt;
&lt;p&gt;5.列允许插入空值（前期是字段不是NOT NULL）&lt;/p&gt;
&lt;p&gt;6.插入的记录可以有多条，在后续加（），（）即可&lt;/p&gt;
&lt;p&gt;7.如果是表中的所有字段添加数据的时候，可以不写字段名称&lt;/p&gt;
&lt;p&gt;8.默认值的使用，当不给某个字段值的时候，如果有默认值就会添加，否则填入null，如果NOT NULL则报错&lt;/p&gt;
&lt;h3&gt;Update（改）&lt;/h3&gt;
&lt;h4&gt;基本使用&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;UPDATE table_name SET col_name1 = expr1 [col_name2 = expr2] [WHERE where_definition]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以下是一个使用案例&lt;/p&gt;
&lt;p&gt;1.将所有的员工薪水修改为5000元&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;UPDATE employee SET Salary = 5000;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.将力宏的薪水修改为3000元&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;UPDATE employee SET Salary = 3000 WHERE `user_name`=&apos;力宏&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.将lory的薪水上调1000元&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;UPDATE employee SET Salary = Salary + 1000 WHERE `user_name`=&apos;lory&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;使用细节&lt;/h4&gt;
&lt;p&gt;1.UPDATE语法可以指定用新值更新原有表行中的各列&lt;/p&gt;
&lt;p&gt;2.SET子句指定要修改那些列和赋予的哪些值&lt;/p&gt;
&lt;p&gt;3.WHERE子句指定应该更新哪些行，如果没有，则更新所有的行&lt;/p&gt;
&lt;p&gt;4.如果需要修改多个字段，可以通过set 字段1= value，set 字段2= value...完成，例如如下代码，就顺便进行了id++&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;UPDATE employee SET Salary = Salary + 1000, id = id + 1 WHERE `user_name`=&apos;lory&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Delete（删）&lt;/h3&gt;
&lt;h4&gt;基本使用&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;DELETE FROM table_name [WHERE where_definition];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;案例&lt;/p&gt;
&lt;p&gt;1.删除用户名为力宏的记录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DELETE FROM employee WHERE `user_name`=&apos;力宏&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.删除表中的所有记录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DELETE FROM employee;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;使用细节&lt;/h4&gt;
&lt;p&gt;1.如果不加WHERE子句，就会删除表中所有的记录&lt;/p&gt;
&lt;p&gt;2.DELETE语句不可以删除某一列的值（可以使用update更新字段为null）&lt;/p&gt;
&lt;p&gt;3.使用DELETE语句尽可以删除表的记录，不可以删除表本身，需要使用DROP删除表&lt;/p&gt;
&lt;h3&gt;Select（查）&lt;/h3&gt;
&lt;p&gt;算是数据库的一个重点&lt;/p&gt;
&lt;h4&gt;基本使用&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;SELECT [DISTINCT] * | [column1, colum2, ...] FROM table_name [WHERE where_definition];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中DISTANCT可选，表示是否去除重复数据&lt;/p&gt;
&lt;p&gt;1.查询所有的员工&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from employee;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+----+-----------+------+--------+
| id | user_name | job  | Salary |
+----+-----------+------+--------+
|  1 | 李明      | NULL |   2000 |
|  1 | 李明      | NULL |   2000 |
|  2 | 王丽      | NULL |   2000 |
|  3 | 丽华      | NULL |  20003 |
|  4 | 李儒      | NULL |   2000 |
|  5 | 小明      | NULL |   2000 |
|  6 | lory      | NULL |  20003 |
+----+-----------+------+--------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.查询非重复的员工（每个字段都相同）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select distinct * from employee;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+----+-----------+------+--------+
| id | user_name | job  | Salary |
+----+-----------+------+--------+
|  1 | 李明      | NULL |   2000 |
|  2 | 王丽      | NULL |   2000 |
|  3 | 丽华      | NULL |  20003 |
|  4 | 李儒      | NULL |   2000 |
|  5 | 小明      | NULL |   2000 |
|  6 | lory      | NULL |  20003 |
+----+-----------+------+--------+
6 rows in set (0.07 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.SELECT语句可以进行一些运算&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT * | (column1 | expression, column2 | expression, ...)FROME table_name;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例如在查询科目成绩时可以指定查询的一列为其他的几列相加&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT (english + math + chinese) as `grades` from table_name;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.SELECT可以使用as语句取别名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT column_name as other_name from table_name;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;SELECT `user_name` as `name`, `Salary` as `money` FROM `employee`
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+------+-------+
| name | money |
+------+-------+
| 李明 |  2000 |
| 李明 |  2000 |
| 王丽 |  2000 |
| 丽华 | 20003 |
| 李儒 |  2000 |
| 小明 |  2000 |
| lory | 20003 |
+------+-------+
7 rows in set (0.07 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.和改删一样，SELECT一样可以运用WHERE过滤&lt;/p&gt;
&lt;p&gt;常见的运算符&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;运算符&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&amp;gt;  &amp;lt;  &amp;lt;=  &amp;gt;=  =  &amp;lt;&amp;gt;&lt;/td&gt;
&lt;td&gt;大于 小于 大于等于 小于等于 等于 不等于&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BETWEEN...AND...&lt;/td&gt;
&lt;td&gt;显示在某一区间内的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;IN(set)&lt;/td&gt;
&lt;td&gt;显示在in列表中的值，如in(100，200)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[NOT] LIKE &apos;张pattern&apos;&lt;/td&gt;
&lt;td&gt;模糊查询&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;IS NULL&lt;/td&gt;
&lt;td&gt;判断是否为空&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;and&lt;/td&gt;
&lt;td&gt;并&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;or&lt;/td&gt;
&lt;td&gt;或&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;not&lt;/td&gt;
&lt;td&gt;非&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;6.使用order by设置排序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT  * | [column1, colum2, ...] FROM table_name 
ORDER BY column1 asc|desc;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;排序的列可以是表中的列名，也可以select语句中指定的列名&lt;/p&gt;
&lt;p&gt;Asc升序 Desc降序&lt;/p&gt;
&lt;p&gt;ORDER BY 子句应该位于SELECT语句的末尾&lt;/p&gt;
&lt;p&gt;7.group by + having&lt;/p&gt;
&lt;p&gt;使用group by子句对列进行分组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT column1, colum2, ... FROM table_name 
group by column;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用having子句对分组后的结果过滤&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT column1, colum2, ... FROM table_name 
group by column1 having ...;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用案例&lt;/p&gt;
&lt;p&gt;1.显示每个部门的平均工资和最高工资&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT AVG(sal), MAX(sal), deptno FROM emp GROUP BY deptno;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.显示每个部门的每种岗位的平均工资和最低工资&lt;/p&gt;
&lt;p&gt;可以先显示每个部门的平均工资和最低工资&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT AVG(sal), MIN(sal), deptno FROM emp GROUP BY deptno;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还需要再添加一个分组的标准&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT AVG(sal), MIN(sal), deptno, job FROM emp GROUP BY deptno, job;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.显示平均工资低于2000的部门号和他的平均工资&lt;/p&gt;
&lt;p&gt;先显示各个部门的平均工资和部门号&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT AVG(sal), deptno FROM emp 
GROUP BY deptno;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后运用having进行过滤实现平均工资小于2000&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT AVG(sal) as avg_sal, deptno FROM emp 
GROUP BY deptno
HAVING avg_sal &amp;lt; 2000;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以下是SELECT使用例题：&lt;/p&gt;
&lt;p&gt;1.对数学成绩排序后输出[升序]&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT * FROM student ORDER BY `math` asc;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.对总分按照降序排序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT `name` , (`math`+`english`+`chinese`) as grade FROM student ORDER BY grade desc;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.对姓李的学生按照成绩排序输出[升序]&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT * FROM student WHERE `name` LIKE &apos;李%&apos; ORDER BY (`math`+`english`+`chinese`)  asc;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;例题&lt;/h4&gt;
&lt;p&gt;1.查询math大于60并且id大于90的学生成绩&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT * FROM student WHERE `math` &amp;gt; 60 and id &amp;gt; 90;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.查询英语成绩大于语文成绩的同学&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT * FROM student WHERE `math` &amp;gt; `chinese`;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.查询总分大于200分并且数学成绩小于语文成绩的韩姓同学&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT * FROM student WHERE (`math`+`chinese`+`english`)&amp;gt;200 and `math`&amp;lt;`chinese` and user_name LIKE &apos;韩%&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.查询英语成绩在80-90分的同学(闭区间)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT * FROM student WHERE `english` BETWEEN 80 AND 90;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.查询数学分数为89，90，91的同学&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT * FROM student WHERE `english` IN(89,90,91);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;重要的函数&lt;/h2&gt;
&lt;h3&gt;Count&lt;/h3&gt;
&lt;p&gt;统计函数&lt;/p&gt;
&lt;h4&gt;基本使用&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;SELECT COUNT(*) | COUNT(column) FROM table_name [WHERE where_definition];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;count(*)和count(column)区别&lt;/p&gt;
&lt;p&gt;count(*)返回满足条件记录的行数&lt;/p&gt;
&lt;p&gt;count(column)统计满足条件的某列有多少的，但排除对应列为null的情况&lt;/p&gt;
&lt;h4&gt;使用案例&lt;/h4&gt;
&lt;p&gt;1.统计班级里一共有几个学生&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select count(*) from student where `grade`
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+----------+
| count(*) |
+----------+
|        7 |
+----------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.统计总分大于300的学生个数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select count(*) from student where `grade` &amp;gt; 300;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+----------+
| count(*) |
+----------+
|        4 |
+----------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;SUM&lt;/h3&gt;
&lt;p&gt;合计函数&lt;/p&gt;
&lt;p&gt;Sum函数返回满足where条件的行的和---一般使用在数值列&lt;/p&gt;
&lt;h4&gt;基本使用&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;SELECT SUM(column) FROM table_name [WHERE where_definition];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;仅对数值起作用&lt;/p&gt;
&lt;h4&gt;使用案例&lt;/h4&gt;
&lt;p&gt;1.统计一个班数学总成绩&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT SUM(math) FROM student;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.统计一个班语文、英语、数学各科的总成绩&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT SUM(math),SUM(english),SUM(chinese) FROM student;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.统计一个班语文、英语、数学各科和的总成绩&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT SUM(math + english + chinese) FROM student;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.统计一个班级语文的平均分&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT SUM(chinese)/COUNT(*) FROM student;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者我们也可以使用AVG统计函数求平均值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT AVG(chinese) FROM student;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;AVG&lt;/h3&gt;
&lt;h4&gt;基本使用&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;SELECT AVG(column) FROM table_name [WHERE where_definition];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用案例如上，不再过多赘述&lt;/p&gt;
&lt;h3&gt;MAX/MIN&lt;/h3&gt;
&lt;p&gt;数值范围在统计中特别有用&lt;/p&gt;
&lt;h4&gt;基本使用&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;SELECT MAX/MIN(column) FROM table_name [WHERE where_definition];
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;使用案例&lt;/h4&gt;
&lt;p&gt;1.求班级最高分&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT MAX(math + english + chinese)，MIN(math + english + chinese) FROM student;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.求出班级数学最高分&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT MAX(math)，MIN(math) FROM student;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;字符串函数&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;字符串函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;CHARSET(str)&lt;/td&gt;
&lt;td&gt;返回字串字符集&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CONCAT(str2 [,...])&lt;/td&gt;
&lt;td&gt;连接字串&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;INSTR(string, substring)&lt;/td&gt;
&lt;td&gt;返回substring在string中出现的位置，没有则返回0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UCASE(str2)&lt;/td&gt;
&lt;td&gt;转为大写&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LCASE(str2)&lt;/td&gt;
&lt;td&gt;转为小写&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LEFT(str2, length)&lt;/td&gt;
&lt;td&gt;从str2中的左边起取length个字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LENGTH(string)&lt;/td&gt;
&lt;td&gt;string长度[按照字节]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;REPLACE(str, search_str, replace_str)&lt;/td&gt;
&lt;td&gt;在str中用字符串替换&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;STRCMP(str1,str2)&lt;/td&gt;
&lt;td&gt;逐个字符比较两个字符串大小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SUBSTRING(str, position [length])&lt;/td&gt;
&lt;td&gt;从str的position开始，取length个字符，不写则取完&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LTRIM(str2) RTRIM(str2)&lt;/td&gt;
&lt;td&gt;去除前端空格去除后端空格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;trim&lt;/td&gt;
&lt;td&gt;去除左右两边空格&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;基本使用&lt;/h4&gt;
&lt;p&gt;CHARSET(str)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT CHARSET(name) FROM emp;
//返回字符集（utf8）
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;CONCAT(str2 [,...])&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT CONCAT(name, &apos;job is&apos;, job) as name_job FROM emp;
//字符串拼接
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;INSTR(string, substring)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT INSTR(string, &apos;target&apos;) FROM DUAL;--其中DUAL是亚元表
//返回出现位置
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;UCASE(str2) LCASE(str2)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT UCASE(name) FROM emp;//转为大写
SELECT LCASE(name) FROM emp;//转为小写
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;LEFT(str2, length) RIGHT(str2, length)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT LEFT(name, 2) FROM emp;//从左取2个字符
SELECT RIGHT(name, 2) FROM emp;//从右取2个字符
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;LENGTH(string)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT LENGTH(name) FROM emp;//返回名字长度
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;REPLACE(str, search_str, replace_str)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT REPLACE(name, &apos;a&apos;, &apos;b&apos;) FROM emp;
//将名字中的a替换为b
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;STRCMP(str1,str2)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT STRCMP(str1,str2) FROM DUAL;
//比较字符串大小 小于返回-1 大于返回1 等于返回0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;SUBSTRING(str, position [length])&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT SUBSTRING(name, 1, 2) FROM emp;
//从第一个位置开始取两个字符
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;LTRIM(str2)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT LTRIM(&apos; 名字&apos;) FROM DUAL;//&apos;名字&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;例题&lt;/h4&gt;
&lt;p&gt;以首字母小写的方式显示所有员工emp表的名字&lt;/p&gt;
&lt;p&gt;取出第一个字符转为小写然后和后面的字符拼接&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT CONCAT(LCASE(LEFT(name, 1)),
SUBSTRING(name,2,LENGTH(name))) FROM emp;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;数学函数&lt;/h3&gt;
&lt;p&gt;有很多，我挑几个常用的&lt;/p&gt;
&lt;h4&gt;ABS(num)&lt;/h4&gt;
&lt;p&gt;绝对值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT ABS(-1) FROM DUAL;//1
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;CEILING(number)&lt;/h4&gt;
&lt;p&gt;向上取整，得到比number大的最小整数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT CEILING(1.34) FROM DUAL;//2
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;FLOOR(number)&lt;/h4&gt;
&lt;p&gt;向下取整，得到比number小的最大整数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT FLOOR(1.34) FROM DUAL;//1
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;RAND([seed])&lt;/h4&gt;
&lt;p&gt;随机数范围为[0,1,0]&lt;/p&gt;
&lt;p&gt;不加种子返回的数每次都不同&lt;/p&gt;
&lt;p&gt;种子指定后返回的数不变&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT RAND(6) FROM DUAL;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;日期相关函数&lt;/h3&gt;
&lt;p&gt;对于日期而言也有非常多的相关函数，有点小多，在这里不过多介绍，即查即用&lt;/p&gt;
&lt;h3&gt;加密函数于系统函数&lt;/h3&gt;
&lt;h4&gt;USER()&lt;/h4&gt;
&lt;p&gt;显示登录到mysql有哪些用户以及登陆的IP&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select user() from dual;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+----------------+
| user()         |
+----------------+
| root@localhost |
+----------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;DATABASE()&lt;/h4&gt;
&lt;p&gt;查询使用数据库名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select DATABASE() from dual;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+------------+
| DATABASE() |
+------------+
| dbtest     |
+------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;MD5(str)&lt;/h4&gt;
&lt;p&gt;为字符串计算出一个MD5 32的字符串，常用为用户密码加密(32位)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select MD5(&apos;密码&apos;) from dual;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+----------------------------------+
| MD5(&apos;密码&apos;)                      |
+----------------------------------+
| a8105204604a0b11e916f3879aae3b0b |
+----------------------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;UPDATE user SET `password`=MD5(654321);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;PASSWORD(str)&lt;/h4&gt;
&lt;p&gt;加密函数，是MySQL使用的加密方式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from mysql.user
//其中的$A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED就是加密后的密码
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;流程控制函数&lt;/h3&gt;
&lt;h4&gt;IF(expr1,expr2,expr3)&lt;/h4&gt;
&lt;p&gt;如果表达式1为真，返回expr2，否则返回expr3&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT IF(TRUE, &apos;BEIJING&apos;, &apos;SHANGHAI&apos;) FROM DUAL;//BEIJING
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;IFNULL(expr1,expr2)&lt;/h4&gt;
&lt;p&gt;如果表达式1为NULL，返回expr1，否则返回expr2&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT IFNULL(&apos;BEIJING&apos;, &apos;SHANGHAI&apos;) FROM DUAL;//BEIJING
SELECT IFNULL(&apos;NULL&apos;, &apos;SHANGHAI&apos;) FROM DUAL;//SHANGHAI
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;多分支函数&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;SELECT CASE 
WHEN expr1 THEN expr2 
WHEN expr3 THEN expr4 
ELSE expr5
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;SELECT CASE 
WHEN FALSE THEN expr2 
WHEN TRUE THEN expr4 
ELSE expr5 END
//返回expr2
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;例题&lt;/h4&gt;
&lt;p&gt;查询emp表，如果comm是null，就显示0.0&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT name, IF(comm IS NULL, 0.0, comm) FROM emp;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;SELECT name, IFNULL(comm, 0.0) FROM emp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果emp表的job是CLERK则显示职员，如果是MANAGER则显示经理，如果是SALESMAN就显示销售人员，其他正常显示&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT name, (
SELECT CASE 
WHEN job=&apos;CLERK&apos; THEN &apos;职员&apos; 
WHEN job=&apos;MANAGER&apos; THEN &apos;经理&apos; 
WHEN job=&apos;SALESMAN&apos; THEN &apos;销售人员&apos; 
ELSE job END) AS &apos;job&apos;
FROM emp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上就是MySQL的基本语句，查询的基础部分，和一些常见的函数，我们明天会进入增强查询（多表查询）&lt;/p&gt;
</content:encoded></item><item><title>MySQL笔记</title><link>https://thrinisty.github.io/posts/mysql%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/mysql%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D/</guid><description>基本使用，数据类型，备份恢复</description><pubDate>Thu, 10 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;MySQL&lt;/h1&gt;
&lt;p&gt;​	经过40天的Java学习，我系统性的学习了Java相关知识点，了解了各个知识点背后的源码逻辑，可以用Java语言实现各类算法，以及解决实际问题，独立的设计，编写相关项目。&lt;/p&gt;
&lt;p&gt;​	而从今天开始我将开始数据库的学习，预计5天完成MySQL数据库基本操作的学习，之后运用JDBC完成一个实战项目&lt;/p&gt;
&lt;p&gt;​	我在之前选修数据库课程的时候，只是停留在理论上，对于知识的理解也只是限于应付考试，为了更好的理解数据库以及更好的使用数据库，我决定再次回顾相关知识点，并且整理笔记&lt;/p&gt;
&lt;h2&gt;MySQL的基本使用&lt;/h2&gt;
&lt;p&gt;关于MySQL的安装我就不过多赘述，因为之前也安装过了，详见各大网站上的安装使用教程照着安装即可&lt;/p&gt;
&lt;h3&gt;MySQL启动服务&lt;/h3&gt;
&lt;p&gt;在我这里因为安装的时候设置为开机自动启用，所以不用执行该指令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;net start mysql
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同样的如果需要停止服务&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;net stop mysql
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以通过以下的指令查看数据库服务是否启用（root）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sc query MySQL80
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;显示MySQL80在运行状态&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SERVICE_NAME: MySQL80
        TYPE               : 10  WIN32_OWN_PROCESS
        STATE              : 4  RUNNING
                                (STOPPABLE, PAUSABLE, ACCEPTS_SHUTDOWN)
        WIN32_EXIT_CODE    : 0  (0x0)
        SERVICE_EXIT_CODE  : 0  (0x0)
        CHECKPOINT         : 0x0
        WAIT_HINT          : 0x0
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;MySQL数据库的本地连接&lt;/h3&gt;
&lt;p&gt;-h 表示连接的主机 localhost为本地主机&lt;/p&gt;
&lt;p&gt;-P 代表的是连接端口&lt;/p&gt;
&lt;p&gt;-u 代表的是登录用户名称&lt;/p&gt;
&lt;p&gt;-p654321 （输入登录密码，p后不加空格）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql -h localhost -P 3306 -u root -p654321
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果我们需要对于账户和密码进行修改我们可以在链接到数据库后，使用如下的指令对于账户的密码进行修改（654321）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;你的新密码&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其实我们的登录账户名称和账户密码也会被存放在数据库中，我们上述的指令就是对于存放密码的数据库表进行更改操作&lt;/p&gt;
&lt;h2&gt;数据库的三层结构&lt;/h2&gt;
&lt;p&gt;1.所谓安装Mysql数据库，就是在主机上安装一个数据管理系统（DBMS），这个管理程序可以创建多个数据库&lt;/p&gt;
&lt;p&gt;2.一个数据库中可以创建多个表，用以保存数据&lt;/p&gt;
&lt;p&gt;3.数据库管理系统，数据库，表之间的关系（三层结构）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/109.png&quot; alt=&quot;109&quot; /&gt;&lt;/p&gt;
&lt;p&gt;数据库和表本质上是文件，存放在内存中&lt;/p&gt;
&lt;p&gt;表中的一行称之为一条记录，而在Java中一条记录使用一个对象来表示&lt;/p&gt;
&lt;h1&gt;SQL语句分类&lt;/h1&gt;
&lt;p&gt;DDL：数据定义语句（create 表，库.......）&lt;/p&gt;
&lt;p&gt;DML：数据操作语句（增删改查）&lt;/p&gt;
&lt;p&gt;DQL：数据查询语句（select）&lt;/p&gt;
&lt;p&gt;DCL：数据控制语句（管理数据库：如grant revoke）&lt;/p&gt;
&lt;h2&gt;创建数据库&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;CREATE DATABASE [IF NOT EXISTS] db_name
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;例题&lt;/h3&gt;
&lt;p&gt;1.创建一个名为lory_db01的数据库&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create database lory_db01;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除数据库&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;drop database lory_db01;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.创建一个使用utf-8字符集的lory_db02的数据库&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create database lory_db02 character set utf8;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.创建一个使用utf-8字符集并带校对规则的lory_db03的数据库(区分大小写utf8_bin)默认不区分大小写&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create database lory_db03 character set utf8 collate utf8_bin;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;区分大小与否&lt;/h3&gt;
&lt;p&gt;不区分大小写的情况下使用查询语句&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; select * from students where name = &apos;b&apos;;
+----+------+
| id | name |
+----+------+
| B  | B    |
| d  | b    |
+----+------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;区分大小写的情况下（利用COLLARTE指定）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; SELECT * FROM students WHERE name COLLATE utf8mb4_bin = &apos;b&apos;;
+----+------+
| id | name |
+----+------+
| d  | b    |
+----+------+
1 row in set (0.04 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;查询数据库&lt;/h2&gt;
&lt;h3&gt;显示数据库语句&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;show databases;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; show databases;
+--------------------+
| Database           |
+--------------------+
| dbtest             |
| information_schema |
| mysql              |
| performance_schema |
| sakila             |
| student            |
| sys                |
| test               |
| world              |
+--------------------+
9 rows in set (0.06 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;显示数据库创建语句&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;show create database db_name;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; show create database student;

| Database | Create Database                       
| student  | CREATE DATABASE `student` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci */ /*!80016 DEFAULT ENCRYPTION=&apos;N&apos; */ |

1 row in set (0.05 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;数据库删除语句&lt;/h3&gt;
&lt;p&gt;[ ]中内容可选&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;drop database [IF EXISTS] db_name;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;备份与恢复&lt;/h2&gt;
&lt;p&gt;备份是实际工作中非常重要的部分，我们无论是要进行数据库转移还是损坏后的恢复，都需要使用到备份和恢复数据库&lt;/p&gt;
&lt;h3&gt;备份数据库相关指令&lt;/h3&gt;
&lt;h4&gt;备份&lt;/h4&gt;
&lt;p&gt;mysqldump&lt;/p&gt;
&lt;p&gt;(注意是在dos命令行中执行而不是数据库命令行界面)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysqldump -u root -p**** -B DB_1 DB_2 ... &amp;gt; File.sql
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;C:\Windows\System32&amp;gt; mysqldump -u root -p654321 -B dbtest &amp;gt; d:\\test.sql
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行后在对应的路径下有一个备份文件，文件中其中存放了一些SQL语句，通过重新执行这些语句我们就可以恢复数据库中的内容（还有一些其他的信息）&lt;/p&gt;
&lt;h4&gt;恢复&lt;/h4&gt;
&lt;p&gt;source&lt;/p&gt;
&lt;p&gt;(注意在数据库命令行中执行)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;source d:/test.sql;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然你也可以将sql备份文件中的SQL语句直接执行&lt;/p&gt;
&lt;h3&gt;备份数据库表&lt;/h3&gt;
&lt;h4&gt;备份&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;mysqldump -u root -p db_01 table_1 table_2 ... &amp;gt; File.sql
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;恢复&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;source d:/test.sql;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;创建数据库表&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;create table table_name
(
	fieldname1 datatype,
	fieldname2 datatype,
	fieldname3 datatype,
)character set 字符集 collate 校对规则 engine 存储引擎
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;field：指定列名  datatype：指定字段类型  character set：不指定则默认为所在数据库字符集	collate：如不指定默认为所在数据库校对规则 engine（讲解待定）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE student1 (
    id INT,
    name VARCHAR(255),
    password VARCHAR(255)
)
CHARACTER SET utf8mb4 
COLLATE utf8mb4_bin 
ENGINE=InnoDB;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;MySQL列类型&lt;/h1&gt;
&lt;h2&gt;类型总览&lt;/h2&gt;
&lt;h3&gt;数值类型&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;数据类型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;BIT(M)&lt;/td&gt;
&lt;td&gt;位类型，M指定位数（1-64）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TINYINY [UNSIGNED]&lt;/td&gt;
&lt;td&gt;占一个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SAMLLINT [UNSIGNED]&lt;/td&gt;
&lt;td&gt;占两个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MEDIUMINT [UNSIGNED]&lt;/td&gt;
&lt;td&gt;占三个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;INT [UNSIGENED]&lt;/td&gt;
&lt;td&gt;INT类型，占4个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BIGINT [UNSIGHNED]&lt;/td&gt;
&lt;td&gt;占8个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FLOAT [UNSIGHNED]&lt;/td&gt;
&lt;td&gt;浮点型占4个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DOUBLE [UNSIGHED]&lt;/td&gt;
&lt;td&gt;浮点型占8个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DECIMAL(M,D)&lt;/td&gt;
&lt;td&gt;定点数M指定长度，D表示小数点位数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;文本、二进制类型&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;数据类型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;CHAR(size) char(20)&lt;/td&gt;
&lt;td&gt;固定长度字符串，最大255&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;VARCHAR(size)&lt;/td&gt;
&lt;td&gt;可变长度字符串，0-65535&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BLOB LONGBLOB&lt;/td&gt;
&lt;td&gt;二进制数据 BLOB （2^16）LONGBLOB（2^32）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TEXT LONGTEXT&lt;/td&gt;
&lt;td&gt;文本Text （2^16）LONGTEXT（2^32）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;时间日日期类型&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;数据类型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;DATE/DATETIME/TimeStamp&lt;/td&gt;
&lt;td&gt;日期类型（YYYY-MM-DD）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;TimeStamp表示时间戳，可用于自定记录insert、updata操作的时间&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/110.png&quot; alt=&quot;110&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;Mysql常用数据类型&lt;/h2&gt;
&lt;p&gt;其中用的比较多的有以下几个&lt;/p&gt;
&lt;p&gt;int double decimal char varchar text datatime&lt;/p&gt;
&lt;p&gt;在实际使用的时候，在满足要求的情况下尽量用小的数据类型&lt;/p&gt;
&lt;h3&gt;整形&lt;/h3&gt;
&lt;h4&gt;TINYINT&lt;/h4&gt;
&lt;p&gt;以tinyint为例，支持-128~127，或者添加无符号参数支持0-255&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE test(id TINYINT);
CREATE TABLE test(id TINYINT unsigned);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;BIT&lt;/h4&gt;
&lt;p&gt;1.bit(m) m在1-64&lt;/p&gt;
&lt;p&gt;2.添加数据范围按照给定的位数确定，2的m次方&lt;/p&gt;
&lt;p&gt;3.显示的时候按照bit&lt;/p&gt;
&lt;p&gt;4.查询时任然可以按照数来查询&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE test01(id BIT(8));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;插入数据以位的形式存储显示&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;INSERT INTO test01 VALUES(13);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;00001101
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;浮点型&lt;/h3&gt;
&lt;h4&gt;DECIMAL&lt;/h4&gt;
&lt;p&gt;1.FLOAT/DOUBLE于JAVA一样，单精度浮点数以及双精度&lt;/p&gt;
&lt;p&gt;2.DECIMAL可以支持更加精确的小数位，M为小数位数总数，D是小数点后面的位数&lt;/p&gt;
&lt;p&gt;3.如果D为0，则没有小数点和小数部分，M最大为65，D最大为30，如果D省略，默认为0，若M省略，默认为10&lt;/p&gt;
&lt;p&gt;4.如果希望精度较高推荐使用decimal&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DECIMAL[M,D][UNSIGNED]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE test02(num1 DECIMAL(30,20), num2 FLOAT);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;INSERT INTO test02 VALUES(88.1324, 133);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;字符串&lt;/h3&gt;
&lt;h4&gt;CHAR(size)&lt;/h4&gt;
&lt;p&gt;固定长度字符串，最大为255字符&lt;/p&gt;
&lt;h4&gt;VARCHAR(size)&lt;/h4&gt;
&lt;p&gt;可变长度字符串，最大为65532字节（utf-8编码最大21844字符 1-3个字节用于记录大小）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE test03(num1 VARCHAR(21844), num2 CHAR(255));
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;INSERT INTO test03 VALUES(&apos;helloworld&apos;, &apos;你好&apos;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;子字符串使用细节&lt;/h4&gt;
&lt;p&gt;1.char(m)和.varchar(m) m表示的是字符数，无论中英文都最多放m个&lt;/p&gt;
&lt;p&gt;2.char(4)是固定长度，即使插入aa，也会占据4个字符的空间，而varchar(4)是变长，会按照实际占用的空间分配，除此之外还需要1-3个字节存放记录内容长度&lt;/p&gt;
&lt;p&gt;3.如何选择：如果数据是定长的，例如手机，邮编等就用char，如果是不确定的就用varchar，例如留言，文章等，而在查询速度的上而言char的速度快于varchar&lt;/p&gt;
&lt;p&gt;4.在存放文本的时候也可以使用Text数据类型（更利于空间使用例如英文占一个字节，而中文占用三个字节），可以将TEXT列视为VAECHAR列，注意TEXT不可以有默认值，大小为0-2的16次，还需要更多的时候可以选择MEDIUMTEXT 或者 LONGTEXT&lt;/p&gt;
&lt;h3&gt;日期类型&lt;/h3&gt;
&lt;h4&gt;基本使用&lt;/h4&gt;
&lt;p&gt;时间戳可以设置为更新时的当前时间，这里没有加&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE test04 ( birthday DATE, job_time DATETIME, login_time TIMESTAMP );
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;INSERT INTO test04(birthday, job_time) VALUES(&apos;2022-2-22&apos;, &apos;2022-2-22 10:10:10&apos;);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+------------+---------------------+------------+
| birthday   | job_time            | login_time |
+------------+---------------------+------------+
| 2022-02-22 | 2022-02-22 10:10:10 | NULL       |
+------------+---------------------+------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以下是一个自动更新的例子&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE test05 (
  birthday DATE,
  job_time DATETIME,
  login_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+------------+---------------------+---------------------+
| birthday   | job_time            | login_time          |
+------------+---------------------+---------------------+
| 2022-02-22 | 2022-02-22 10:10:10 | 2025-04-11 15:35:43 |
| 2022-02-22 | 2022-02-22 10:10:10 | 2025-04-11 15:35:44 |
| 2022-02-22 | 2022-02-22 10:10:10 | 2025-04-11 15:35:45 |
| 2022-02-22 | 2022-02-22 10:10:10 | 2025-04-11 15:35:45 |
+------------+---------------------+---------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;创建表例题&lt;/h3&gt;
&lt;p&gt;创建一个员工表，选取适当的数据类型&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;字段&lt;/th&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;id&lt;/td&gt;
&lt;td&gt;整形&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;name&lt;/td&gt;
&lt;td&gt;字符型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sex&lt;/td&gt;
&lt;td&gt;字符型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;birthday&lt;/td&gt;
&lt;td&gt;日期型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;entry_date&lt;/td&gt;
&lt;td&gt;日期型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;job&lt;/td&gt;
&lt;td&gt;字符型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Salary&lt;/td&gt;
&lt;td&gt;小数型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;resume&lt;/td&gt;
&lt;td&gt;文本型&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;创建表格&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE `empty`(
	id INT,
	`name` VARCHAR ( 20 ),
	sex CHAR ( 1 ),
	birthday DATE,
	entry_date DATETIME,
	job VARCHAR ( 20 ),
	Salary DOUBLE,
	`resume` TEXT 
);
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Java笔记</title><link>https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%8F%8D%E5%B0%84/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%8F%8D%E5%B0%84/</guid><description>反射（重中之重，框架学习的前置）</description><pubDate>Tue, 08 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Java笔记&lt;/h1&gt;
&lt;h2&gt;反射&lt;/h2&gt;
&lt;p&gt;reflection&lt;/p&gt;
&lt;h3&gt;引出反射&lt;/h3&gt;
&lt;p&gt;我们需要怎样才可以读出配置文件的内容，并调用配置文件的方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置文件&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;classPath = com.reflection.Cat
method = hi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;目标类文件&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.reflection;


public class Cat {
    public void hi() {
        System.out.println(&quot;hi&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;问题实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一点很容易，我们通过创建properties在进行加载，就可以很容易的得到配置中的内容&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class ReflectionQuestion {
    public static void main(String[] args) throws IOException {
        String filePath = &quot;src\\re.properties&quot;;
        Properties properties = new Properties();
        properties.load(new FileInputStream(filePath));
        String classPath = properties.getProperty(&quot;classPath&quot;);
        String method = properties.getProperty(&quot;method&quot;);
        System.out.println(classPath + &quot; &quot; + method);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是我们要怎样取创建配置文件中的对象，和调用对应的方法呢？&lt;/p&gt;
&lt;p&gt;我们暂时还没有在不通过在不修改源码的情况下控制程序的办法，在这里我们就需要使用到反射机制来解决，以下是一个快速入门&lt;/p&gt;
&lt;h3&gt;快速入门&lt;/h3&gt;
&lt;p&gt;我们需要以下的几个步骤&lt;/p&gt;
&lt;p&gt;1.加载类，返回Class类型的对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//加载类运用一个Class的对象接收类的路径
Class cls = Class.forName(classPath);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.通过类得到你加载的类Cat对象实例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//通过Class对象的实例调用newInstance获取到对应类路径下对象的实例
//（编译类型是一个Object）（运行类型是对应的类型）
Object obj = cls.newInstance();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.通过类对象调用getMethod方法得到对应参数名称的方法，存在Method对象中（将方法视为一个对象）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//通过cls类调用方法getMethod获取方法
Method method01 = cls.getMethod(method);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.最后通过方法对象调用invoke传入对象,完成调用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//最后通过方法对象调用invoke传入对象,完成调用
method01.invoke(obj);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;完整代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以实现不修改源码的基础上修改程序的内部逻辑&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class ReflectionQuestion {
    public static void main(String[] args) throws Exception {
        String filePath = &quot;src\\re.properties&quot;;
        Properties properties = new Properties();
        properties.load(new FileInputStream(filePath));
        String classPath = properties.getProperty(&quot;classPath&quot;);
        String method = properties.getProperty(&quot;method&quot;);

        Class cls = Class.forName(classPath);
        Object targetClass = cls.newInstance();
        Method targetMethod = cls.getMethod(method);
        targetMethod.invoke(targetClass);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class com.reflection.Cat
hi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;修改测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过修改配置文件，创建一个狗类，调用其中的say方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置文件&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;classPath = com.reflection.Dog
method = say
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;狗类&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.reflection;
public class Dog {
    public void say () {
        System.out.println(&quot;大狗大狗叫叫叫~~&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;运行结果&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;大狗大狗叫叫叫~~
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;反射机制原理&lt;/h3&gt;
&lt;h4&gt;&lt;strong&gt;原理&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;1.反射机制允许程序在程序执行期间借助Reflection API获取任何类的内部信息（包括成员变量，构造器，成员方法），并能够操作对象的属性以及方法（反射在设计模式和底层框架都会用的到&lt;/p&gt;
&lt;p&gt;2.加载完类后，堆中产生了一个Class类型的对象（一个类只有一个Class对象），这个对象包含了类的完整结构信息，通过这个对象得到类的结构。而这个对象就像是一面镜子，透过这个镜子可以看到类的结构（所以称之为反射）&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;反射机制原理图&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;../images/107.png&quot; alt=&quot;107&quot; /&gt;&lt;/p&gt;
&lt;p&gt;反射（Reflection）的核心来源是 Java 的 Class 对象，这个对象是程序在 Class 类阶段（加载阶段） 通过 &lt;code&gt;ClassLoader&lt;/code&gt; 类加载器，加载后创建的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在底层编译时&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;类加载器（&lt;code&gt;ClassLoader&lt;/code&gt;）会将字节码文件加载到 JVM 中，并转换为 &lt;strong&gt;Class 类对象&lt;/strong&gt;，其中包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;字段信息（Field[] fields）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;构造器信息（Constructor[] cons）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;方法信息（Method[] ms）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;这些信息是 Java 反射的基础&lt;/strong&gt;，通过 &lt;code&gt;Class&lt;/code&gt; 对象，Java 代码可以动态地获取类的详细结构，并在运行时操作类的成员（方法、变量等）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对用户而言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Java 允许开发者使用反射机制操作 Class 对象&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;反射的方式：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过 &lt;code&gt;Class&lt;/code&gt; 对象获取类的信息（字段、方法、构造器）。&lt;/li&gt;
&lt;li&gt;通过 &lt;code&gt;Field&lt;/code&gt; 访问类的字段。&lt;/li&gt;
&lt;li&gt;通过 &lt;code&gt;Method&lt;/code&gt; 调用类的方法。&lt;/li&gt;
&lt;li&gt;通过 &lt;code&gt;Constructor&lt;/code&gt; 创建对象实例。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;反射的优缺点&lt;/h4&gt;
&lt;p&gt;1.优点：可以动态的创建和使用对象（也是框架的底层核心），使用灵活，没有反射机制，框架就会失去底层支持&lt;/p&gt;
&lt;p&gt;2.使用反射基本是解释执行，对执行速度有影响（和传统方式时间差距很大）&lt;/p&gt;
&lt;p&gt;有一个setAccessible方法可以操作访问安全检查的开关以此来提升反射的效率&lt;/p&gt;
&lt;h3&gt;反射相关的类&lt;/h3&gt;
&lt;h4&gt;Class&lt;/h4&gt;
&lt;p&gt;代表一个类，Class对象表示在某个类加载后在堆中的对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Class cls = Class.forName(classPath);
//创建Class对象
Object obj = cls.newInstance();
//通过Class对象获取对应实例
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1.Class也是类，继承于Object类&lt;/p&gt;
&lt;p&gt;2.Class类对象不是new实例化出来的，而是系统创建的&lt;/p&gt;
&lt;p&gt;3.对于某个类的Class类对象，在内存中只有一份，因为类只加载一次&lt;/p&gt;
&lt;p&gt;4.每个类的实例都会记得自己是由哪一个Class实例所生成的&lt;/p&gt;
&lt;p&gt;5.通过Class对象可以完整的得到一个类的完整结构（API调用）&lt;/p&gt;
&lt;p&gt;6.Class对象是存放在堆中的&lt;/p&gt;
&lt;p&gt;7.类的字节码二进制数据，是放在方法区的，称之为类的元数据（包括方法代码，变量名，方法名，访问权限等）&lt;/p&gt;
&lt;h4&gt;Method&lt;/h4&gt;
&lt;p&gt;代表类的方法，Method对象表示某个类的方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Method method01 = cls.getMethod(method);
//获取方法对象
method01.invoke(obj);
//通过invoke传入类对象实例调用方法
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;Field&lt;/h4&gt;
&lt;p&gt;代表类的成员变量，Field对象表示某个类的成员变量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Field nameField = cls.getField(&quot;name&quot;);
//获取成员变量对象
System.out.println(nameField.get(obj));
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;Constructor&lt;/h4&gt;
&lt;p&gt;代表类的构造方法，Constructor对象表示某个类的构造器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Constructor constructor1 = cls.getConstructor();
//不带参数的构造器
System.out.println(constructor1);

Constructor constructor2 = cls.getConstructor(String.class);
//带参数的构造器需要传入String类的Class对象
System.out.println(constructor2);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然也可以调用构造器对象构造类的对象实例&lt;/p&gt;
&lt;h3&gt;Class常用方法(入门)&lt;/h3&gt;
&lt;h4&gt;forName&lt;/h4&gt;
&lt;p&gt;获取类的对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Class&amp;lt;?&amp;gt; cls = Class.forName(&quot;com.reflection.Cat&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Class cls = Class.forName(&quot;com.reflection.Cat&quot;);
System.out.println(cls);//class com.reflection.Cat
System.out.println(cls.getClass());//class java.lang.Class
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;前一个输出是哪一个类的Class对象，后一个输出类对象&lt;/p&gt;
&lt;h4&gt;getPackage&lt;/h4&gt;
&lt;p&gt;获取类的包名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;System.out.println(cls.getPackage());
//package com.reflection
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;getName&lt;/h4&gt;
&lt;p&gt;获取类的全路径&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;System.out.println(cls.getName());
//com.reflection.Cat
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;newInstance&lt;/h4&gt;
&lt;p&gt;通过类实例创建对应类的实例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Object obj = cls.newInstance();
Cat cat = (Cat)obj;
cat.hi();
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;getField&lt;/h4&gt;
&lt;p&gt;获取类的属性（无法获取私有属性）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Field field = cls.getField(&quot;name&quot;);
System.out.println(field.get(obj));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;获取所有属性&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Field[] fields = cls.getFields();
for(Field field : fields) {
    System.out.println(field.get(obj));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;set&lt;/h4&gt;
&lt;p&gt;设置类属性的值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Object obj = cls.newInstance();
Field field = cls.getField(&quot;name&quot;);
field.set(obj, &quot;来福&quot;);
System.out.println(field.get(obj));
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;获取Class对象方式&lt;/h3&gt;
&lt;p&gt;在编程的时候一共可以有六种方式可供程序员使用获取Class对象&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;代码阶段&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;forName&lt;/p&gt;
&lt;p&gt;使用前提：已知一个类的全类名，且类在类的路径下，可以通过Class的静态方法forName获取（可能会抛出ClassNotFound异常）&lt;/p&gt;
&lt;p&gt;应用场景：多用于配置文件，获取类全路径，加载类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Class&amp;lt;?&amp;gt; cls = Class.forName(&quot;com.reflection.Cat&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;strong&gt;加载阶段&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;类.class&lt;/p&gt;
&lt;p&gt;从类加载器中获取&lt;/p&gt;
&lt;p&gt;使用前提：已知具体的类，通过类的class方法获取，该方式是最为可靠的，程序性能最高&lt;/p&gt;
&lt;p&gt;应用场景：多用于参数传递，比如通过反射得到对应构造器对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Class cls = Cat.class;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;strong&gt;运行阶段&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;对象.getClass&lt;/p&gt;
&lt;p&gt;使用前提：某一个类的实例已经存在，通过该实例的getClass方法获取Class对象&lt;/p&gt;
&lt;p&gt;应用场景：通过创建好的对象获取Class对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Cat cat = new Cat();
Class cls = cat.getClass();
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;strong&gt;通过类加载器&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;调用类加载器的loadClass方法获取&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ClassLoader classLoader = cat.getClass().getClassLoader();
Class&amp;lt;?&amp;gt; cls = classLoader.loadClass();
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;strong&gt;基本数据类型类对象&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;数据类型.class&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Class&amp;lt;Integer&amp;gt; cls = int.class;
System.out.println(cls);//int 这里隐含了自动拆装箱
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;strong&gt;包装型类对象&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;调用包装类的静态属性TYPE获取&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Class&amp;lt;?&amp;gt; cls = Integer.TYPE;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;类加载&lt;/h2&gt;
&lt;p&gt;反射机制是Java实现动态语言的关键，也就是通过反射实现动态加载&lt;/p&gt;
&lt;h3&gt;动态加载与静态加载&lt;/h3&gt;
&lt;h4&gt;静态加载&lt;/h4&gt;
&lt;p&gt;编译时加载相关的类，如果没有则报错，依赖性较高&lt;/p&gt;
&lt;h4&gt;动态加载&lt;/h4&gt;
&lt;p&gt;运行时加载需要的类，如果没有用到缺失的类，就不会报错，降低了依赖性&lt;/p&gt;
&lt;h4&gt;代码示例&lt;/h4&gt;
&lt;p&gt;以下是一个动态加载的代码示例：&lt;/p&gt;
&lt;p&gt;例如我有一个Cat类，一个House类，但是实际上只有Cat类是在代码中声明，我们利用静态加载一个Cat 和一个House类，代码不通过编译&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Cat cat = new Cat();
House house = new House();//编译报错，没有House类
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是我们可以通过类加载实现动态加载，只有在运行的时候没有获取到对应的类时候才会发出运行时错误&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Class01 {
    public static void main(String[] args) throws Exception {
        Scanner scanner = new Scanner(System.in);
        char key = scanner.next().charAt(0);
        switch (key) {
            case 1:
                Class cls = Class.forName(&quot;com.reflection.Cat&quot;);
                Object obj1 = cls.newInstance();
                break;
            case 2:
                Class cls2 = Class.forName(&quot;com.reflection.House&quot;);
                Object obj2 = cls2.newInstance();
                break;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在输入2的时候报错&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;java.lang.ClassNotFoundException: com.reflection.House
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;类加载的流程图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../images/108.png&quot; alt=&quot;108&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;加载阶段（由JVM控制）&lt;/h4&gt;
&lt;p&gt;JVM机将字节码从不同的数据源（class文件、jar包，网络）转化为二进制字节流加载到内存中，并且生成代表该类的java.lang.Class对象&lt;/p&gt;
&lt;h4&gt;连接阶段（由JVM控制）&lt;/h4&gt;
&lt;h5&gt;验证&lt;/h5&gt;
&lt;p&gt;确保Class字节流中的信息符合当前虚拟机的要求，并且不会危害虚拟机的安全（这个阶段是可以手动关闭的）&lt;/p&gt;
&lt;p&gt;在编译运行的时候：使用-Xverify:none参数关闭大部分的类验证措施，以缩短虚拟机类加载的时间&lt;/p&gt;
&lt;h5&gt;准备&lt;/h5&gt;
&lt;p&gt;JVM在该阶段对静态变量，分配内存，并默认初始化（0，null，false等），这些变量所使用的内存都在方法区中进行分配&lt;/p&gt;
&lt;p&gt;以一个类来举例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class A {
	public int n1 = 10;
	//n1是实例属性，不是静态变量，在准备阶段是不会分配内存的
	public static int n2 = 20;
	//n2是静态变量，分配内存，初始化为0，在后续才会进行赋值
	public static final int n3 = 30;
	//n3是一个常量，分配内存，初始直接进行赋值30
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;解析阶段&lt;/h5&gt;
&lt;p&gt;虚拟机将常量池中的符号引用替换为直接引用的过程&lt;/p&gt;
&lt;h4&gt;初始化（由程序员控制）&lt;/h4&gt;
&lt;p&gt;1.到初始化阶段才开始执行类中定义的Java程序代码，此阶段执行的是&amp;lt;clinit&amp;gt;()方法的过程&lt;/p&gt;
&lt;p&gt;2.&amp;lt;clinit&amp;gt;()方法是由编译器按语句在源代码中出现的顺序，以此自动收集类中所有静态变量的复制动作，和静态代码块中的语句，并进行合并&lt;/p&gt;
&lt;p&gt;3.虚拟机会保证一个类的&amp;lt;clinit&amp;gt;()方法在多线程环境中被正确的加锁，同步，如果多个线程去同时初始化一个类，那么只会有一个线程去执行这个类的&amp;lt;clinit&amp;gt;()方法，其他线程都需要阻塞等待&lt;/p&gt;
&lt;p&gt;正是通过3的线程加锁，才保证了某一个类的对象在堆中只存在一个&lt;/p&gt;
&lt;p&gt;在代码编写的时候：有一个setAccessible（爆破）方法可以操作访问安全检查的开关以此来提升反射的效率&lt;/p&gt;
&lt;h2&gt;获取类信息&lt;/h2&gt;
&lt;h3&gt;相关方法&lt;/h3&gt;
&lt;p&gt;现有一个类Person&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Deprecated
public class Person extends AA implements IL{
    public int pub = 0;
    int def = 0;
    private int pri = 0;

    public Person() {}

    public Person(int pub, int def, int pri) {
        this.pub = pub;
        this.def = def;
        this.pri = pri;
    }

    public void say(){}
    void hi(){}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;Class类&lt;/h4&gt;
&lt;h5&gt;getName&lt;/h5&gt;
&lt;p&gt;获取全类名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Class cls = Class.forName(&quot;com.reflection.Person&quot;);
System.out.println(cls.getName());
//com.reflection.Person
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;getSimpleName&lt;/h5&gt;
&lt;p&gt;获取简单类名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Class cls = Class.forName(&quot;com.reflection.Person&quot;);
System.out.println(cls.getSimpleName());//Person
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;getFields&lt;/h5&gt;
&lt;p&gt;获取所有public修饰的属性，包含本类以及父类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Field[] fields = cls.getFields();
for(Field field : fields) {
    System.out.println(field);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public int com.reflection.Person.pub
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;getDeclaredFields&lt;/h5&gt;
&lt;p&gt;获取本类中所有属性&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Field[] fields = cls.getDeclaredFields();
for(Field field : fields) {
    System.out.println(field);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public int com.reflection.Person.pub
int com.reflection.Person.def
private int com.reflection.Person.pri
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;getMethods&lt;/h5&gt;
&lt;p&gt;获取本类中由public修饰的所有方法，包含本类以及父类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    Class cls = Class.forName(&quot;com.reflection.Person&quot;);
    Method[] methods = cls.getMethods();
    for(Method method : methods) {
        System.out.println(method.getName());
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;say
wait
wait
wait
equals
toString
hashCode
getClass
notify
notifyAll
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;getDeclaredMethods&lt;/h5&gt;
&lt;p&gt;获取本类中所有方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Class cls = Class.forName(&quot;com.reflection.Person&quot;);
Method[] methods = cls.getDeclaredMethods();
for(Method method : methods) {
    System.out.println(method);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;void com.reflection.Person.hi()
public void com.reflection.Person.say()
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;getConstructors&lt;/h5&gt;
&lt;p&gt;获取public修饰的构造器，包含本类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Class cls = Class.forName(&quot;com.reflection.Person&quot;);
Constructor[] connstructors = cls.getConstructors();
for(Constructor connstructor : connstructors) {
    System.out.println(connstructor);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public com.reflection.Person()
public com.reflection.Person(int,int,int)
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;getDeclaredConstructors&lt;/h5&gt;
&lt;p&gt;获取本类所有的构造器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public com.reflection.Person()
public com.reflection.Person(int,int,int)
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;getPackage&lt;/h5&gt;
&lt;p&gt;以Package的形式返回包信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Class cls = Class.forName(&quot;com.reflection.Person&quot;);
System.out.println(cls.getPackage());
//package com.reflection
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;getSuperclass&lt;/h5&gt;
&lt;p&gt;以Class的形式返回父类的信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void main(String[] args) throws Exception {
    Class cls = Class.forName(&quot;com.reflection.Person&quot;);
    System.out.println(cls.getSuperclass());
    //class com.reflection.AA
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;getInterfaces&lt;/h5&gt;
&lt;p&gt;以Class的形式返回接口信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Class01 {
    public static void main(String[] args) throws Exception {
        Class cls = Class.forName(&quot;com.reflection.Person&quot;);
        Class[] interfaces = cls.getInterfaces();
        for(Class anInterface : interfaces)
        System.out.println(anInterface);
        //interface com.reflection.IL
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;getAnnotations&lt;/h5&gt;
&lt;p&gt;以Annotation数组的形式返回注解信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void main(String[] args) throws Exception {
    Class cls = Class.forName(&quot;com.reflection.Person&quot;);
    Annotation[] annotations = cls.getAnnotations();
    for(Annotation annotation : annotations)
    System.out.println(annotation);
    //@java.lang.Deprecated()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;Filed类&lt;/h4&gt;
&lt;h5&gt;getModifiers&lt;/h5&gt;
&lt;p&gt;以int形式返回修饰符&lt;/p&gt;
&lt;p&gt;默认修饰符0  ，public 1 ， private 2 ， protected 4 ，static 8 ，final 16 public+static 9（1 + 8）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Field field = cls.getField(&quot;pub&quot;);
//注意通过getField只能获取public修饰的属性
System.out.println(field.getModifiers());//1 (public)
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;getType&lt;/h5&gt;
&lt;p&gt;以Class形式返回类型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Class&amp;lt;?&amp;gt; cls = Class.forName(&quot;com.reflection.Person&quot;);
Field field = cls.getField(&quot;pub&quot;);
System.out.println(field.getType());//int
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;getName&lt;/h5&gt;
&lt;p&gt;返回属性名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Class&amp;lt;?&amp;gt; cls = Class.forName(&quot;com.reflection.Person&quot;);
Field field = cls.getField(&quot;pub&quot;);
System.out.println(field.getName());//pub
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;Method类&lt;/h4&gt;
&lt;h5&gt;getModifiers&lt;/h5&gt;
&lt;p&gt;以int形式返回修饰符&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Class&amp;lt;?&amp;gt; cls = Class.forName(&quot;com.reflection.Person&quot;);
Method method = cls.getMethod(&quot;say&quot;);
System.out.println(method.getModifiers());//1
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;getReturnType&lt;/h5&gt;
&lt;p&gt;以Class形式返回类型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Class&amp;lt;?&amp;gt; cls = Class.forName(&quot;com.reflection.Person&quot;);
Method method = cls.getMethod(&quot;say&quot;);
System.out.println(method.getReturnType());//void
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;getName&lt;/h5&gt;
&lt;p&gt;返回方法名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Class&amp;lt;?&amp;gt; cls = Class.forName(&quot;com.reflection.Person&quot;);
Method method = cls.getMethod(&quot;say&quot;);
System.out.println(method.getName());//say
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;getParameterTypes&lt;/h5&gt;
&lt;p&gt;以Class数组返回参数类型数组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Class&amp;lt;?&amp;gt; cls = Class.forName(&quot;com.reflection.Person&quot;);
Method method = cls.getMethod(&quot;say&quot;);
Class&amp;lt;?&amp;gt;[] parameterTypes = method.getParameterTypes();
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;Constructor类&lt;/h4&gt;
&lt;p&gt;和Method类基本一致，没有getReturnType方法（没有返回值）&lt;/p&gt;
&lt;h2&gt;反射爆破&lt;/h2&gt;
&lt;h3&gt;反射爆破创建实例&lt;/h3&gt;
&lt;p&gt;有以下几个构造器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public Person() {}

public Person(int pub) {
    this.pub = pub;
}

public Person(int pub, int def, int pri) {
    this.pub = pub;
    this.def = def;
    this.pri = pri;
}

private Person(int pub, int def) {
    this.pub = pub;
    this.def = def;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;大体分为两种方式&lt;/p&gt;
&lt;p&gt;方式一：调用类中pulic修饰的无参构造器&lt;/p&gt;
&lt;p&gt;方式二：调用类中的指定构造器&lt;/p&gt;
&lt;h4&gt;Constructor类相关方法&lt;/h4&gt;
&lt;h5&gt;setAccessible&lt;/h5&gt;
&lt;p&gt;是Java程序设计者留的后门，可以破解私有构造器的限制&lt;/p&gt;
&lt;p&gt;爆破（暴力破解）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;constructor.setAccessible(true);
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;newInstance&lt;/h5&gt;
&lt;p&gt;调用构造器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; Object obj = constructor.newInstance(10);//通过构造器创建对象
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;Class类相关方法&lt;/h4&gt;
&lt;h5&gt;newInstance&lt;/h5&gt;
&lt;p&gt;调用类中的无参构造器，获取对应类的对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Object obj = cls.newInstance();
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;getConstructor&lt;/h5&gt;
&lt;p&gt;根据参数列表，获取对应的构造器对象（获取public构造器对象）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Constructor&amp;lt;?&amp;gt; constructor = cls.getConstructor(int.class);//获取到公有的构造器
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;getDecalaredConstructor&lt;/h5&gt;
&lt;p&gt;根据参数列表，获取对应的构造器对象（获取本类所有的构造器对象）&lt;/p&gt;
&lt;p&gt;用普通的方式无法通过private修饰的构造器创建对象实例，但是通过反射可以实现&lt;/p&gt;
&lt;p&gt;但是后续调用私有构造器需要爆破（暴力破解private）（单独使用newInstance会发生运行错误）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Constructor&amp;lt;?&amp;gt; constructor = cls.getDeclaredConstructor(int.class,int.class);//获取到所有的构造器
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;通过爆破使用私有构造器&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;Constructor&amp;lt;?&amp;gt; constructor = cls.getDeclaredConstructor(int.class,int.class);//获取到所有的构造器
constructor.setAccessible(true);
Object obj = constructor.newInstance(10, 29);//通过构造器创建对象
System.out.println(obj);//pub 10 def 29 pri 0
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;反射爆破操作属性&lt;/h3&gt;
&lt;h4&gt;访问属性的相关方法&lt;/h4&gt;
&lt;h5&gt;获取Field对象&lt;/h5&gt;
&lt;p&gt;Field f = class对象.getDeclaredField(属性名称)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Field field = cls.getDeclaredField(&quot;pri&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;爆破&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;field.setAccessible(true);
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;访问&lt;/h5&gt;
&lt;p&gt;设置属性值&lt;/p&gt;
&lt;p&gt;f.set(obj, 值)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;field.set(obj, 100);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;获取属性值&lt;/p&gt;
&lt;p&gt;f.get(obj)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;field.get(obj)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果是静态属性，则set和get中的obj参数可以写为null&lt;/p&gt;
&lt;h4&gt;private修饰的属性值&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class Class01 {
    public static void main(String[] args) throws Exception {
        Class&amp;lt;?&amp;gt; cls = Class.forName(&quot;com.reflection.Person&quot;);
        Constructor&amp;lt;?&amp;gt; constructor = cls.getDeclaredConstructor(int.class, int.class, int.class);
        //获取到所有的构造器

        Object obj = constructor.newInstance(10, 29, 101);//通过构造器创建对象
        Field field = cls.getDeclaredField(&quot;pri&quot;);
        field.setAccessible(true);
        field.set(obj, 100);
        System.out.println(field.get(obj));//100
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;反射爆破操作方法&lt;/h3&gt;
&lt;h4&gt;访问方法相关方法&lt;/h4&gt;
&lt;h5&gt;getDeclaredMethod&lt;/h5&gt;
&lt;p&gt;获取类所有的方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Method method = cls.getDeclaredMethod(&quot;hi&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;setAccessible&lt;/h5&gt;
&lt;p&gt;设置方法爆破&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;method.setAccessible(true);
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;invoke&lt;/h5&gt;
&lt;p&gt;传入class类对象实例调用方法&lt;/p&gt;
&lt;p&gt;如果是静态方法传入null即可&lt;/p&gt;
&lt;p&gt;invoke方法参数后是一个可变参数，可供传入参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Object returnValue = method.invoke(obj);//静态方法hi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在反射中如果有返回值统一返回Object类型的值&lt;/p&gt;
&lt;h4&gt;通过反射调用private方法&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class Class01 {
    public static void main(String[] args) throws Exception {
        Class&amp;lt;?&amp;gt; cls = Class.forName(&quot;com.reflection.Person&quot;);
        Constructor&amp;lt;?&amp;gt; constructor = cls.getDeclaredConstructor(int.class, int.class, int.class);//获取到所有的构造器

        Object obj = constructor.newInstance(10, 29, 101);//通过构造器创建对象
        Method method = cls.getDeclaredMethod(&quot;hi&quot;);
        method.setAccessible(true);
        method.invoke(obj);//静态方法hi
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;课后习题&lt;/h1&gt;
&lt;h2&gt;例题一&lt;/h2&gt;
&lt;p&gt;1.定义PrivateTest类，由私有属性name，属性值为hellokitty&lt;/p&gt;
&lt;p&gt;2.提供getName公共方法&lt;/p&gt;
&lt;p&gt;3.创建PrivateTest类，利用Class类得到私有属性name属性，修改name属性值&lt;/p&gt;
&lt;p&gt;4.使用getName方法打印name属性值&lt;/p&gt;
&lt;h3&gt;题解&lt;/h3&gt;
&lt;p&gt;写出PrivateTest类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.reflection;

public class PrivateTest {
    private String name = &quot;hellokitty&quot;;

    public String getName() {
        return name;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;主方法调用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test01 {
    public static void main(String[] args) throws Exception{
        Class&amp;lt;?&amp;gt; cls = Class.forName(&quot;com.reflection.PrivateTest&quot;);
        Object obj = cls.newInstance();

        Field name = cls.getDeclaredField(&quot;name&quot;);
        name.setAccessible(true);
        name.set(obj, &quot;New name&quot;);

        Method getName = cls.getMethod(&quot;getName&quot;);
        Object invoke = getName.invoke(obj);
        String target = (String) invoke;

        System.out.println(target);//New name
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;例题二&lt;/h2&gt;
&lt;p&gt;1.利用Class类的forName方法得到File类的class对象&lt;/p&gt;
&lt;p&gt;2.在控制台打印出File类的所有构造器&lt;/p&gt;
&lt;p&gt;3.通过newInstance的方法创建File对象，并创建 E:\mynew.txt 文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class FileTest{
    public static void main(String[] args) throws Exception{
        Class&amp;lt;?&amp;gt; cls = Class.forName(&quot;java.io.File&quot;);
        Constructor&amp;lt;?&amp;gt;[] constructors = cls.getDeclaredConstructors();
        for(Constructor&amp;lt;?&amp;gt; constructor : constructors) {
            System.out.println(constructor);
        }
        Constructor&amp;lt;?&amp;gt; constructor = cls.getDeclaredConstructor(String.class);
        Object obj = constructor.newInstance(&quot;e:\\JavaFile\\mynew.txt&quot;);
        Method method = cls.getMethod(&quot;createNewFile&quot;);
        method.invoke(obj);
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Java笔记</title><link>https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0io%E6%B5%81/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0io%E6%B5%81/</guid><description>IO流</description><pubDate>Sun, 06 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Java笔记&lt;/h1&gt;
&lt;p&gt;IO流的部分我打算用两天的时间完成学习，再用一天来结束class以及反射的内容，Java的基础知识点就告一段落。&lt;/p&gt;
&lt;h2&gt;文件基础知识&lt;/h2&gt;
&lt;p&gt;文件在程序中是以流的形式来操作的&lt;/p&gt;
&lt;p&gt;Java程序（内存）——输出流——&amp;gt;文件&lt;/p&gt;
&lt;p&gt;文件——输入流——&amp;gt;Java程序（内存）&lt;/p&gt;
&lt;p&gt;流：数据在数据源（文件）和程序（内存）之间经历的路径&lt;/p&gt;
&lt;p&gt;输入流：数据从文件到程序的路径&lt;/p&gt;
&lt;p&gt;输出流：数据从程序到文件的路径&lt;/p&gt;
&lt;h2&gt;常用的文件操作&lt;/h2&gt;
&lt;h3&gt;创建文件&lt;/h3&gt;
&lt;p&gt;创建文件对象相关方法，注意只有调用createNewFile才会创建文件&lt;/p&gt;
&lt;p&gt;方式一：通过路径创建文件对象，并创建文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
    public void create01() {
        String filePath = &quot;e:\\JavaFile\\1.txt&quot;;
        File file = new File(filePath);
        try {
            file.createNewFile();
            System.out.println(&quot;创建成功&quot;);
        } catch (IOException e) {
            System.out.println(&quot;创建文件失败&quot;);
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方式二：通过父目录文件对象+文件名创建文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void create02() {
    String filePath = &quot;e:\\JavaFile&quot;;
    File file1 = new File(filePath);
    String fileName = &quot;2.txt&quot;;
    File file2 = new File(file1, fileName);
    try {
        file2.createNewFile();
        System.out.println(&quot;创建成功&quot;);
    } catch (IOException e) {
        System.out.println(&quot;创建文件失败&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方式三：通过父目录字符串+文件名创建文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void create03() {
    String filePath = &quot;e:\\JavaFile&quot;;
    String fileName = &quot;3.txt&quot;;
    File file2 = new File(filePath, fileName);
    try {
        file2.createNewFile();
        System.out.println(&quot;创建成功&quot;);
    } catch (IOException e) {
        System.out.println(&quot;创建文件失败&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;文件都创建成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/97.png&quot; alt=&quot;97&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;获取文件名称&lt;/h3&gt;
&lt;p&gt;getName&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void info() {
    File file = new File(&quot;e:\\1.txt&quot;);
    System.out.println(file.getName());//1.txt
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;获取文件绝对路径&lt;/h3&gt;
&lt;p&gt;getAbsolutePath&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void info() {
    File file = new File(&quot;e:\\1.txt&quot;);
    System.out.println(file.getAbsolutePath());//e:\1.txt
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;获取父级目录&lt;/h3&gt;
&lt;p&gt;getParent&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void info() {
    File file = new File(&quot;e:\\1.txt&quot;);
    System.out.println(file.getParent());//e:\
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;获取文件大小&lt;/h3&gt;
&lt;p&gt;length 字节&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    @Test
    public void info() {
        File file = new File(&quot;e:\\JavaFile\\1.txt&quot;);//6 
        //文件里是 你好 中文字符在UTF-8占三个字节
        System.out.println(file.length());//6 
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;检测文件是否存在&lt;/h3&gt;
&lt;p&gt;exists&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void info() {
    File file = new File(&quot;e:\\JavaFile\\1.txt&quot;);
    System.out.println(file.exists());//true
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;检测是不是文件&lt;/h3&gt;
&lt;p&gt;isFile&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void info() {
    File file = new File(&quot;e:\\JavaFile\\1.txt&quot;);
    System.out.println(file.isFile());//true
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;检测是不是目录&lt;/h3&gt;
&lt;p&gt;isDirectory&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void info() {
    File file = new File(&quot;e:\\JavaFile\\1.txt&quot;);
    System.out.println(file.isFile());//false
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;创建目录&lt;/h3&gt;
&lt;h4&gt;创建一级目录&lt;/h4&gt;
&lt;p&gt;mkdir&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void mkdir() {
    String filePath = &quot;e:\\JavaFile\\New&quot;;
    File file = new File(filePath);
    if (!file.exists()) {
        file.mkdir();
        System.out.println(filePath + &quot; 目录创建&quot;);
    } else {
        System.out.println(&quot;目录已存在&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;创建多级目录&lt;/h4&gt;
&lt;p&gt;mkdirs&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void mkdirs() {
    String filePath = &quot;e:\\JavaFile\\New\\another\\other&quot;;
    File file = new File(filePath);
    if (!file.exists()) {
        file.mkdirs();
        System.out.println(filePath + &quot; 目录创建&quot;);
    } else {
        System.out.println(&quot;目录已存在&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;删除空目录或文件&lt;/h3&gt;
&lt;p&gt;delete&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void delete() {
    String filePath = &quot;e:\\JavaFile\\1.txt&quot;;
    File file = new File(filePath);
    if (file.exists()) {
        file.delete();
        System.out.println(filePath + &quot;被删除&quot;);//1.txt被删除
    } else {
        System.out.println(&quot;文件不存在&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Java IO流原理&lt;/h2&gt;
&lt;p&gt;1.I/O是Input/Output的缩写，I/O技术是非常实用的技术，用于处理数据传输，如读写文件，网络通讯等&lt;/p&gt;
&lt;p&gt;2.Java程序中，对于数据的输入/输出以 流 ”stream“ 的方式进行。&lt;/p&gt;
&lt;p&gt;3.java.io包下提供了各种“流”类和接口，以获取不同种类的数据，并通过方法输入或者输出数据&lt;/p&gt;
&lt;p&gt;4.输入input：读取外部数据（磁盘，光盘的设备的数据）到程序（内存）中&lt;/p&gt;
&lt;p&gt;5.输出output：将程序（内存）数据输出到磁盘，光盘等存储设备中&lt;/p&gt;
&lt;h3&gt;流的分类&lt;/h3&gt;
&lt;p&gt;按照操作数据单位不同分为：字节流（8bit），字符流（按字符）&lt;/p&gt;
&lt;p&gt;按照数据流向分为：输入，输出流&lt;/p&gt;
&lt;p&gt;按照流的角色不同分为：节点流，处理流，包装流&lt;/p&gt;
&lt;h3&gt;四个抽象基类&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;抽象基类&lt;/th&gt;
&lt;th&gt;字节流&lt;/th&gt;
&lt;th&gt;字符流&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;输入流&lt;/td&gt;
&lt;td&gt;InputStream&lt;/td&gt;
&lt;td&gt;Reader&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;输出流&lt;/td&gt;
&lt;td&gt;OutputStream&lt;/td&gt;
&lt;td&gt;Writer&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;1.Java的IO流设计40多个类，实际上非常规则，都是从如上的4个抽象基类派生的&lt;/p&gt;
&lt;p&gt;2.由这四个派生出来的子类名称都是以其父类民作为子类名后缀。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/98.png&quot; alt=&quot;98&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/99.png&quot; alt=&quot;99&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;文件输入输出流&lt;/h2&gt;
&lt;h3&gt;FileInputStream&lt;/h3&gt;
&lt;p&gt;文件输入流&lt;/p&gt;
&lt;h4&gt;构造方法&lt;/h4&gt;
&lt;p&gt;传入文件对象 File&lt;/p&gt;
&lt;p&gt;传入文件描述符&lt;/p&gt;
&lt;p&gt;传入文件路径字符串 String&lt;/p&gt;
&lt;h4&gt;流循环读取单个字节&lt;/h4&gt;
&lt;p&gt;当文件字节读取完毕时返回-1&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Stream {
    public static void main(String[] args) {
        String filePath = &quot;e:\\JavaFile\\2.txt&quot;;
        int readData = 0;
        InputStream inputstream = null;
        try {
            inputstream = new FileInputStream(filePath);//创建文件对象流

            while ((readData = inputstream.read()) != -1) {
                System.out.print((char)readData);
            }
        } catch (IOException e) {
            System.out.println(&quot;没有找到文件...&quot;);
        } finally {
            try {
                inputstream.close();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;使用字节流数组读取&lt;/h4&gt;
&lt;p&gt;在read中添加一个byte数组参数，如果读取正常返回一个读取到的字节数&lt;/p&gt;
&lt;p&gt;再通过返回的字节数根据buf字节数组用String构造一个字符串（从0到每次读取到的字节数）输出&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Stream {
    public static void main(String[] args) {
        String filePath = &quot;e:\\JavaFile\\2.txt&quot;;
        int readLen = 0;
        byte[] buf = new byte[8];
        InputStream inputstream = null;
        try {
            inputstream = new FileInputStream(filePath);//创建文件对象流
            while ((readLen = (inputstream.read(buf)) )!= -1) {
                System.out.println(new String(buf, 0, readLen));
            }
         //Hello Wo
		//rld!!
        } catch (IOException e) {
            System.out.println(&quot;没有找到文件...&quot;);
        } finally {
            try {
                inputstream.close();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;FileOutputStream&lt;/h3&gt;
&lt;p&gt;文件字节输出流&lt;/p&gt;
&lt;h4&gt;写入单个字符&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class OUTSTREAM {
    public static void main(String[] args) {
        File file = new File(&quot;e:\\JavaFile\\4.txt&quot;);
        FileOutputStream fos = null;

        try {
            fos = new FileOutputStream(file);
            //如果没有文件会创建文件
            fos.write(&apos;A&apos;);
        } catch (IOException e) {
            throw new RuntimeException(e);
        } finally {
            try {
                fos.close();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;写入一个字节数组&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class OUTSTREAM {
    public static void main(String[] args) {
        File file = new File(&quot;e:\\JavaFile\\4.txt&quot;);
        FileOutputStream fos = null;
        String target = &quot;Hello World!&quot;;
        byte[] buffer = target.getBytes();
        //通过getBytes得到字节数组
        try {
            fos = new FileOutputStream(file);
            fos.write(buffer, 0, buffer.length);
            //后两个参数可选左闭右包，无则将调用如上形式
        } catch (IOException e) {
            throw new RuntimeException(e);
        } finally {
            try {
                fos.close();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;追加内容&lt;/h4&gt;
&lt;p&gt;以上是将目标文件直接进行内容更新，如果要添加内容则需要在构造器里添加第二个boolean参数（设置为true）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fos = new FileOutputStream(file, true);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;文件拷贝&lt;/h4&gt;
&lt;p&gt;运用文件输入流和文件输出流来进行文件的拷贝&lt;/p&gt;
&lt;h5&gt;单个字节流&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;package com;

import java.io.*;

public class FileCopy {
    public static void main(String[] args) {
        String inputPath = &quot;e:\\JavaFile\\1.jpg&quot;;
        String outputPath = &quot;e:\\JavaFile\\New\\3.jpg&quot;;
        FileInputStream fis = null;
        FileOutputStream fos = null;
        int target;
        try {
            fis = new FileInputStream(inputPath);
            fos = new FileOutputStream(outputPath);
            while((target = fis.read()) != -1) {
                fos.write(target);
            }
        } catch (IOException e) {
            System.out.println(&quot;发生异常&quot;);
        } finally {
            try {
                fis.close();
                fos.close();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;字节流数组&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;package com;

import java.io.*;

public class FileCopy {
    public static void main(String[] args) {
        String inputPath = &quot;e:\\JavaFile\\1.jpg&quot;;
        String outputPath = &quot;e:\\JavaFile\\New\\3.jpg&quot;;
        FileInputStream fis = null;
        FileOutputStream fos = null;
        int bufLength = 0;
        byte[] buffer = new byte[1024];
        try {
            fis = new FileInputStream(inputPath);
            fos = new FileOutputStream(outputPath);
            while((bufLength = fis.read(buffer)) != -1) {
                for (int i = 0; i &amp;lt; bufLength; i++) {
                    fos.write(buffer[i]);
                }
            }
        } catch (IOException e) {
            System.out.println(&quot;发生异常&quot;);
        } finally {
            try {
                fis.close();
                fos.close();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;package com;

import java.io.*;

public class FileCopy {
    public static void main(String[] args) {
        String inputPath = &quot;e:\\JavaFile\\1.jpg&quot;;
        String outputPath = &quot;e:\\JavaFile\\New\\4.jpg&quot;;
        FileInputStream fis = null;
        FileOutputStream fos = null;
        int bufLength = 0;
        byte[] buffer = new byte[1024];
        try {
            fis = new FileInputStream(inputPath);
            fos = new FileOutputStream(outputPath);
            while((bufLength = fis.read(buffer)) != -1) {
                fos.write(buffer, 0, bufLength);
            }
        } catch (IOException e) {
            System.out.println(&quot;发生异常&quot;);
        } finally {
            try {
                fis.close();
                fos.close();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;字符输入输出流&lt;/h2&gt;
&lt;p&gt;相比于文件字节流而言，当读取到由多个字节组成的字符（例如中文）会将多个字节传为字符读出&lt;/p&gt;
&lt;h3&gt;FileReader&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../images/101.png&quot; alt=&quot;101&quot; /&gt;&lt;/p&gt;
&lt;p&gt;相关方法&lt;/p&gt;
&lt;p&gt;构造方法:传入文件对象或者文件路径字符串&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;new FileReader(File\String);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;read:读取单个字符，返回字符如果读取到-1代表到达文件末尾&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class FileReader01 {
    public static void main(String[] args) {
        String inputPath = &quot;e:\\JavaFile\\2.txt&quot;;
        String outputPath = &quot;e:\\JavaFile\\New\\1.txt&quot;;
        FileReader filereader = null;
        int target;
        try {
            filereader = new FileReader(inputPath);
            while((target = filereader.read()) != -1) {
                System.out.print((char)target);
            }
        } catch (IOException e) {
            System.out.println(&quot;发生异常&quot;);
        } finally {
            try {
                filereader.close();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;read（char[]）:读取多个字符到字符数组，返回读到的字符数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class FileReader01 {
    public static void main(String[] args) {
        String inputPath = &quot;e:\\JavaFile\\2.txt&quot;;
        String outputPath = &quot;e:\\JavaFile\\New\\1.txt&quot;;
        FileReader filereader = null;
        char[] buffer = new char[4];
        int length;
        try {
            filereader = new FileReader(inputPath);
            while((length = filereader.read(buffer)) != -1) {
                String target = new String(buffer, 0, length);
                System.out.print(target);
            }
        } catch (IOException e) {
            System.out.println(&quot;发生异常&quot;);
        } finally {
            try {
                filereader.close();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;FileWriter&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../images/100.png&quot; alt=&quot;100&quot; /&gt;&lt;/p&gt;
&lt;p&gt;常用方法：&lt;/p&gt;
&lt;p&gt;write(int):写入单个字符&lt;/p&gt;
&lt;p&gt;write(char[ ]):写入指定数组&lt;/p&gt;
&lt;p&gt;write(char[], off, len):写入数组指定部分&lt;/p&gt;
&lt;p&gt;write(string):写入整个字符串&lt;/p&gt;
&lt;p&gt;write(string, off, len):写入字符串指定部分&lt;/p&gt;
&lt;p&gt;注意：当FileWriter使用后，必须要使用close关闭或者flush刷新后才可以写入完成&lt;/p&gt;
&lt;p&gt;以下是一个代码示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class FileWriter01 {
    public static void main(String[] args) {
        String outputPath = &quot;e:\\JavaFile\\New\\1.txt&quot;;
        FileWriter filewriter = null;
        char[] buffer = &quot;风雨之后，遇见彩虹&quot;.toCharArray();
        try {
            filewriter = new FileWriter(outputPath);
            filewriter.write(buffer, 0, buffer.length);
            filewriter.flush();//在完成写之后记得刷入
        } catch (IOException e) {
            System.out.println(&quot;发生异常&quot;);
        } finally {
            try {
                filewriter.close();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;节点流和处理流&lt;/h2&gt;
&lt;h3&gt;节点流&lt;/h3&gt;
&lt;p&gt;节点流可以从一个特定的数据源读写数据，例如FileReader，FileWriter&lt;/p&gt;
&lt;h3&gt;处理流&lt;/h3&gt;
&lt;p&gt;处理流（包装流）是连接已存在的流（节点流或处理流）之上，为程序提供更为强大的读写功能，如BufferedReader，BufferedWriter，更加灵活&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/102.png&quot; alt=&quot;102&quot; /&gt;&lt;/p&gt;
&lt;p&gt;处理流具体功能&lt;/p&gt;
&lt;p&gt;1.性能的提高：主要以增加缓冲的方式来提高输入输出的效率&lt;/p&gt;
&lt;p&gt;2.操作的便捷：处理流可能提供了一系列便捷的方法来一次输入输出大批量的数据，使用更加的灵活&lt;/p&gt;
&lt;h3&gt;区别与联系&lt;/h3&gt;
&lt;p&gt;1.节点流是底层流/低级流，直接和数据源相接&lt;/p&gt;
&lt;p&gt;2.处理流包装节点流，既可以消除不同节点流的实现差异，也可以提供方便的方法来完成输入输出&lt;/p&gt;
&lt;p&gt;3.处理流对节点流进行了包装，使用了修饰器设计模式，不会直接与数据源相连接&lt;/p&gt;
&lt;h3&gt;修饰器设计模式示例&lt;/h3&gt;
&lt;p&gt;我们来模拟一下处理流封装节点流，有点类似于之前提到的代理模式&lt;/p&gt;
&lt;p&gt;但是还是有些区别：装饰器关注于动态添加功能，代理关注于控制访问&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test {
    public static void main(String[] args) {
        BufferedReader_ bufferedReader = new BufferedReader_(new FileReader_());
        System.out.println(&quot;拓展的Read方法&quot;);
        bufferedReader.readFiles(3);
    }
}

class BufferedReader_ extends Reader_ {
    private Reader_ reader_;

    public BufferedReader_(Reader_ reader_){
        this.reader_ = reader_;
    }

  	//将原本的reader方法封装在修饰器中
    public void readFile() {
        reader_.readFile();
    }  
  
    //在BufferedReader_中可以添加FileReader_的方法（拓展修饰）
    public void readFiles(int num) {
        for (int i = 0; i &amp;lt; num; i++) {
            reader_.readFile();
        }
    }
}

abstract class Reader_ {
    public void readFile(){}
    public void readString(){}
}

class FileReader_ extends Reader_{
    public void readFile() {
        System.out.println(&quot;对文件进行读取...&quot;);
    }
}

class StringReader_ extends Reader_{
    public void readString() {
        System.out.println(&quot;对字符串进行读取...&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过这样的方式我们可以通过构造的处理流来调用更具有便捷性的方法来操作节点流。&lt;/p&gt;
&lt;h3&gt;字符处理流&lt;/h3&gt;
&lt;h4&gt;BufferedReader&lt;/h4&gt;
&lt;p&gt;在其中有属性Reader，可以封装一个节点流（可以是任意的Reader子类），还有一个char数组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class BufferedReader extends Reader {

    private Reader in;

    private char cb[];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以下是一个代码示例，我们将文件的输入字符流放在了创建的读入字符处理流里，通过这个处理流调用读取下一行方法读取内容，并且输出&lt;/p&gt;
&lt;p&gt;readLine方法，返回字符串类型，如果读完就返回null&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class BufferedReader01 {
    public static void main(String[] args) {
        String filePath = &quot;e:\\JavaFile\\2.txt&quot;;
        FileReader filereader = null;
        BufferedReader bufferedreader = null;

        try {
            filereader = new FileReader(filePath);
            bufferedreader = new BufferedReader(filereader);
            String line;
            while ((line = bufferedreader.readLine()) != null) {
                System.out.println(line);
            }
            System.out.println(line);
        } catch (IOException e) {
            throw new RuntimeException(e);
        } finally {
            try {
                bufferedreader.close();//关闭外层流即可
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;你好！！Hello World!!
我来自于西安
你好
null
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意在释放资源的时候只需要关闭外层流即可，在调用的时候会将Reader的in释放&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void close() throws IOException {
    synchronized (lock) {
        if (in == null)
            return;
        try {
            in.close();
        } finally {
            in = null;
            cb = null;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;BufferedWriter&lt;/h4&gt;
&lt;p&gt;在其中有属性Writer，可以封装一个节点流（可以是任意的Writer子类），还有一个char数组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class BufferedWriter extends Writer {

    private Writer out;

    private char cb[];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用处理流写入内容&lt;/p&gt;
&lt;p&gt;可以使用newLine插入换行符（根据操作系统对应的换行符）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class BufferedWriter01 {
    public static void main(String[] args) {
        String filePath = &quot;e:\\JavaFile\\2.txt&quot;;
        FileWriter filewriter = null;
        BufferedWriter bufferwriter = null;
        try {
            filewriter = new FileWriter(filePath, true);
            //在节点流设置追加模式
            bufferwriter = new BufferedWriter(filewriter);
            bufferwriter.write(&quot;处理流写入&quot;);
            bufferwriter.newLine();//插入一个换行符
            bufferwriter.write(&quot;处理流写入&quot;);
            bufferwriter.newLine();//插入一个换行符
            bufferwriter.write(&quot;处理流写入&quot;);
            bufferwriter.newLine();//插入一个换行符
            bufferwriter.flush();
        } catch (IOException e) {
            throw new RuntimeException(e);
        } finally {
            try {
                bufferwriter.close();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;处理流字符文件拷贝案例（不可以拷贝视频，图片，音频）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com;

import java.io.*;

public class BufferedWriter01 {
    public static void main(String[] args) {
        String targetFilePath = &quot;e:\\JavaFile\\target.txt&quot;;
        FileWriter filewriter = null;
        BufferedWriter bufferwriter = null;

        String srcFilePath = &quot;e:\\JavaFile\\src.txt&quot;;
        FileReader filereader = null;
        BufferedReader bufferreader = null;
        try {
            filewriter = new FileWriter(targetFilePath, true);
            bufferwriter = new BufferedWriter(filewriter);
            filereader = new FileReader(srcFilePath);
            bufferreader = new BufferedReader(filereader);
            String line;
            while ((line = bufferreader.readLine()) != null) {
                bufferwriter.write(line);
                bufferwriter.newLine();
            }
            bufferwriter.flush();
        } catch (IOException e) {
            throw new RuntimeException(e);
        } finally {
            try {
                bufferwriter.close();
                bufferreader.close();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;字节处理流&lt;/h3&gt;
&lt;h4&gt;BufferedInputStream&lt;/h4&gt;
&lt;h4&gt;BufferedOutputStream&lt;/h4&gt;
&lt;p&gt;通过拷贝案例说明使用方式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com;

import java.io.*;

public class BufferedWriter01 {
    public static void main(String[] args) {
        String targetFilePath = &quot;e:\\JavaFile\\2.jpg&quot;;
        FileOutputStream fos = null;
        BufferedOutputStream bos = null;

        String srcFilePath = &quot;e:\\JavaFile\\1.jpg&quot;;
        FileInputStream fis = null;
        BufferedInputStream bis = null;
        try {
            fos = new FileOutputStream(targetFilePath);
            fis = new FileInputStream(srcFilePath);
            bos = new BufferedOutputStream(fos);
            bis = new BufferedInputStream(fis);
            byte[] buffer = new byte[1024];
            int length;
            while((length = bis.read(buffer)) != -1) {
                bos.write(buffer, 0 , length);
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        } finally {
            try {
                bos.close();
                bis.close();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;对象处理流&lt;/h2&gt;
&lt;p&gt;在实际开发中我们可能会需要保存对象，和从文件中恢复对象（要求保存数据类型）这个时候我们就会需要到 对象处理流（专门用于处理对象）&lt;/p&gt;
&lt;h3&gt;序列化和反序列化&lt;/h3&gt;
&lt;p&gt;1.序列化就是在保存数据的时候，保存数据的值和数据类型&lt;/p&gt;
&lt;p&gt;2.反序列化就是在恢复数据时，恢复数据的值和数据类型&lt;/p&gt;
&lt;p&gt;3.需要让某个对象支持序列化机制，我们就必须让其类是可序列化的，类需要实现Serializable接口或者Externalizable接口（推荐使用第一个标记接口，没有方法）（后一个需要实现方法）&lt;/p&gt;
&lt;h3&gt;对象输入输出流&lt;/h3&gt;
&lt;h4&gt;ObjectOutputStream&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;实际案例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们需要保存int型的数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int n = 100;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;保存一个Dog类型的数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Dog dog = new Dog(&quot;来福&quot;, 18);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public class ObjectClass {
    public static void main(String[] args) {
        String filePath = &quot;e:\\JavaFile\\data.dat&quot;;
        ObjectOutputStream oos = null;
        FileOutputStream fos = null;
        try {
            fos = new FileOutputStream(filePath);
            oos = new ObjectOutputStream(fos);
            oos.write(100);//保存整形100
            oos.writeObject(new Dog(&quot;来福&quot;, 18));
            //保存狗类示例对象
        } catch (IOException e) {
            throw new RuntimeException(e);
        } finally {
            try {
                oos.close();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }
}

class Dog implements Serializable {
    String name;
    int age;

    public Dog(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    @Override
    public String toString() {
        return name + &quot; &quot; + age;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;ObjectInputStream&lt;/h4&gt;
&lt;p&gt;接下来我们来从文件中恢复对象（反序列化）&lt;/p&gt;
&lt;p&gt;在回复对象的Java文件下应该也有类的定义，要求类的定义完全相同，因为这里因为在同一个包下，可以不用再打一次（或者建议把Dog单独写成一个共有的类）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class ObjectClassRead {
    public static void main(String[] args) {
        String filePath = &quot;e:\\JavaFile\\data.dat&quot;;
        ObjectInputStream ois = null;
        FileInputStream fis = null;
        try {
            fis = new FileInputStream(filePath);
            ois = new ObjectInputStream(fis);
            int i = ois.read();
            Object obj = ois.readObject();//运行类型是Dog
            System.out.println(i);
            System.out.println(obj);
        } catch (Exception e) {
            throw new RuntimeException(e);
        } finally {
            try {
                ois.close();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;100
来福 18
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;对象处理流的细节&lt;/h3&gt;
&lt;p&gt;1.读写顺序要求一致（例如前一道题目先传入int再传入Dog，读的时候先int再Dog）&lt;/p&gt;
&lt;p&gt;2.要求实现序列化或者反序列化对象（实现Serializable接口）&lt;/p&gt;
&lt;p&gt;3.序列化的类中建议添加Serial Version UID 以提高版本的兼容性（修改类的时候会认为是原来的升级版本，而非全新的类）&lt;/p&gt;
&lt;p&gt;4.序列化对象的时候，默认将里面的所有属性都进行序列化，但除了static和transient关键字修饰的成员&lt;/p&gt;
&lt;p&gt;5.序列化对象时，要求对象属性的类型也都实现了序列化接口&lt;/p&gt;
&lt;p&gt;6.序列化具备可继承性，即某类实现了序列化，则它的子类也默认实现了序列化&lt;/p&gt;
&lt;h2&gt;标准输入输出流&lt;/h2&gt;
&lt;h3&gt;System.in 标准输入&lt;/h3&gt;
&lt;p&gt;默认设备为键盘&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public final static InputStream in = null;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们在使用Scanner的时候传入的就是我们的标准输入流&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Scanner scanner = new Scanner(System.in);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编译类型为InputStream，运行时类型为BufferedInputStream&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class InputAndOutput {
    public static void main(String[] args) {
        System.out.println(System.in.getClass());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;class java.io.BufferedInputStream
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;System.out 标准输出&lt;/h3&gt;
&lt;p&gt;默认设备为显示器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public final static PrintStream out = null;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们在用sout打印的时候，用的就是这个输出流到终端&lt;/p&gt;
&lt;p&gt;编译类型和运行时类型为PrintStream&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class InputAndOutput {
    public static void main(String[] args) {
        System.out.println(System.out.getClass());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;class java.io.PrintStream
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;转换流&lt;/h2&gt;
&lt;h3&gt;问题引出&lt;/h3&gt;
&lt;p&gt;我们在读取文件的时候使用的是UTF-8&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class transformation {
    public static void main(String[] args) throws Exception {
        String filePath = &quot;e:\\JavaFile\\2.txt&quot;;
        BufferedReader bufferedReader = new BufferedReader(new FileReader(filePath));
        String s = bufferedReader.readLine();
        System.out.println(s);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果在读取非UTF-8的时候，可能就会读出乱码&lt;/p&gt;
&lt;p&gt;这个时候我们就需要运用转换流将字节流指定格式转为字符流即可解决问题&lt;/p&gt;
&lt;h3&gt;InputStreamReader&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../images/103.png&quot; alt=&quot;103&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Reader的子类，可以将InputStream（字节流）包装成为Reader（字符流）&lt;/p&gt;
&lt;p&gt;其中有一个非常重要的构造方法（InputStream,Charset）后一个参数指定编码格式&lt;/p&gt;
&lt;p&gt;使用方式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class transformation {
    public static void main(String[] args) throws Exception {
        String filePath = &quot;e:\\JavaFile\\2.txt&quot;;
        FileInputStream fis = new FileInputStream(filePath);//获取文件字节流
        InputStreamReader isr = new InputStreamReader(fis, &quot;UTF-8&quot;);//将字节流指定编码转为字符流
        BufferedReader bufferedReader = new BufferedReader(isr);//将字符流放入字符处理流
        String s = bufferedReader.readLine();
        System.out.println(s);
        bufferedReader.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;OutputStreamWriter&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../images/104.png&quot; alt=&quot;104&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Writer的子类，可以将OutputStream（字节流）包装成为Writer（字符流）&lt;/p&gt;
&lt;p&gt;也有一个构造器（OutputStream,Charset）后一个参数指定编码格式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class transformation {
    public static void main(String[] args) throws Exception {
        String filePath = &quot;e:\\JavaFile\\2.txt&quot;;
        BufferedWriter bufferwrite = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(filePath), &quot;UTF-8&quot;));
        bufferwrite.write(&quot;你好！！&quot;);
        bufferwrite.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;打印流&lt;/h2&gt;
&lt;h3&gt;PrintStream&lt;/h3&gt;
&lt;p&gt;打印字节流&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/105.png&quot; alt=&quot;105&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class PrintStream_ {
    public static void main(String[] args) {
        PrintStream out = System.out;
        out.print(&quot;你好&quot;);//运用打印输出流可以输出到显示器
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;print调用了write，也可以直接调用write方法进行打印&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void print(String s) {
    if (s == null) {
        s = &quot;null&quot;;
    }
    write(s);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们也可以调用System.setOut来设置System.out打印输出流的位置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class PrintStream_ {
    public static void main(String[] args) throws IOException {
        System.setOut(new PrintStream(&quot;e:\\JavaFile\\1.txt&quot;));
        PrintStream out = System.out;
        out.write(&quot;你好&quot;.getBytes());
        out.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;PrintWriter&lt;/h3&gt;
&lt;p&gt;打印字符流&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/106.png&quot; alt=&quot;106&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class PrintStream_ {
    public static void main(String[] args) throws IOException {
        PrintWriter printWriter = new PrintWriter(System.out);
        printWriter.print(&quot;hello&quot;);
        printWriter.close();//需要用close关闭后刷入
    }

    @Test
    public void test() throws IOException {
        String filePath = &quot;e:\\JavaFile\\1.txt&quot;;
        PrintWriter printWriter = new PrintWriter(new FileWriter(filePath));
        printWriter.print(&quot;hello&quot;);
        printWriter.close();//需要用close关闭后刷入
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Properties&lt;/h2&gt;
&lt;p&gt;在讲集合的时候曾提到过&lt;/p&gt;
&lt;p&gt;1.专门用于读写配置文件的集合类，格式如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;键=值
键=值
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.注意键值对不需要有空格，值不需要用引号括起来，默认类型是String&lt;/p&gt;
&lt;h3&gt;常见方法&lt;/h3&gt;
&lt;h4&gt;load&lt;/h4&gt;
&lt;p&gt;加载配置文件的键值对到Properties对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;String filePath = &quot;e:\\JavaFile\\mysql.properties&quot;;
Properties properties = new Properties();
properties.load(new FileReader(filePath));//加载文件到对象
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;list&lt;/h4&gt;
&lt;p&gt;将数据显示到指定设备&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;properties.list(System.out);//将键值对打印在控制台
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;user=root
pwd=12345
ip=127.0.0.1
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;getProperty(key)&lt;/h4&gt;
&lt;p&gt;根据键获取值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;String user = properties.getProperty(&quot;user&quot;);
String pwd = properties.getProperty(&quot;pwd&quot;);
System.out.println(user + &quot; &quot; + pwd);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;root 12345
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;setProperty(key)&lt;/h4&gt;
&lt;p&gt;根据键值设置到Properties对象&lt;/p&gt;
&lt;h4&gt;store&lt;/h4&gt;
&lt;p&gt;将Properties的键值对存储到配置文件中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class IPIP {
    public static void main(String[] args) throws IOException {
        String filePath = &quot;e:\\JavaFile\\another.properties&quot;;
        Properties properties = new Properties();
        properties.setProperty(&quot;charset&quot;, &quot;utf8&quot;);
        properties.setProperty(&quot;user&quot;, &quot;tom&quot;);
        properties.setProperty(&quot;pwd&quot;, &quot;123456&quot;);
        properties.store(new FileOutputStream(filePath), null);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;使用场景&lt;/h3&gt;
&lt;p&gt;有一个配置文件mysql.properties如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ip = 127.0.0.1
user = root
pwd = 12345
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;传统方式实现&lt;/h4&gt;
&lt;p&gt;我们需要使用文件IO进行读取ip，user，pwd比较复杂&lt;/p&gt;
&lt;p&gt;通过处理流读取每一行字符串数据，再通过字符串拆分处理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class IPIP {
    public static void main(String[] args) throws IOException {
        String filePath = &quot;e:\\JavaFile\\mysql.properties&quot;;
        BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(filePath), &quot;UTF-8&quot;));
        String line;
        while ((line = br.readLine()) != null) {
            String[] targerArr = line.split(&quot;=&quot;);
            System.out.println(targerArr[0] + &quot; 内容是 &quot; + targerArr[1]);
        }

        br.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;Properties类实现&lt;/h4&gt;
&lt;p&gt;我们可以使用Properties类方便实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class IPIP {
    public static void main(String[] args) throws IOException {
        String filePath = &quot;e:\\JavaFile\\mysql.properties&quot;;
        Properties properties = new Properties();
        properties.load(new FileReader(filePath));//加载配置文件到对象
        properties.list(System.out);//将键值对打印在控制台
        String user = properties.getProperty(&quot;user&quot;);
        String pwd = properties.getProperty(&quot;pwd&quot;);
        System.out.println(user + &quot; &quot; + pwd);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;IO章节作业&lt;/h1&gt;
&lt;h2&gt;例题一：&lt;/h2&gt;
&lt;p&gt;1.判断e盘下是否有文件夹mytemp，没有则创建mytemp&lt;/p&gt;
&lt;p&gt;2.再mytemp目录下创建文件hello.txt&lt;/p&gt;
&lt;p&gt;3.如果hello.txt存在，就提示已存在，不再重复创建&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class HomeWork01 {
    public static void main(String[] args) {
        File directory = new File(&quot;e:\\mytemp&quot;);
        File file = new File(directory, &quot;hello.txt&quot;);

        if (directory.isDirectory()) {
            System.out.println(&quot;已存在该目录&quot;);
        } else {
            if (directory.mkdir()) {
                System.out.println(&quot;创建成功&quot;);
            } else {
                System.out.println(&quot;创建失败&quot;);
            }
        }

        if (file.exists()) {
            System.out.println(&quot;已存在该文件&quot;);
        } else {
            try {
                if (file.createNewFile()) {
                    System.out.println(&quot;创建成功&quot;);
                } else {
                    System.out.println(&quot;创建失败&quot;);
                }
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;例题二：&lt;/h2&gt;
&lt;p&gt;用BufferedReader读取一个文本文件，为每行加上行号，再将内容输出到屏幕上&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Homework02 {
    public static void main(String[] args) throws IOException {
        String filePath = &quot;e:\\JavaFile\\src.txt&quot;;
        BufferedReader br = new BufferedReader(new FileReader(filePath));
        String line;
        int count = 1;
        while((line = br.readLine()) != null) {
            System.out.print(count++ + &quot; &quot; + line + &quot;\n&quot;);
        }
        br.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1 这是一个
2 处理流拷贝的
3 测试案例
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;例题三：&lt;/h2&gt;
&lt;p&gt;1.编写一个dog.properties配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;name = tom
age = 5
color = red
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.编写Dog（name，age，color）类，创建一个对象，读取dog配置文件中的内容完成初始化，输出&lt;/p&gt;
&lt;p&gt;3.将创建的Dog对象序列化输出到dog.txt文件&lt;/p&gt;
&lt;p&gt;同理我们也可以将文件反序列化，读出&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.stander;

import java.io.*;
import java.util.Properties;


public class IPIP {
    public static void main(String[] args) throws IOException, ClassNotFoundException {
        String filePath = &quot;e:\\JavaFile\\dog.properties&quot;;
        Properties properties = new Properties();
        properties.load(new FileInputStream(filePath));
        String name = properties.getProperty(&quot;name&quot;);
        String age = properties.getProperty(&quot;age&quot;);
        String color = properties.getProperty(&quot;color&quot;);
        Dog dog = new Dog(name, age, color);
        System.out.println(dog);

        String savePath = &quot;e:\\JavaFile\\save.dat&quot;;
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(savePath));
        oos.writeObject(dog);

        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(savePath));
        Dog another = (Dog) ois.readObject();
        System.out.println(another);
    }
}

class Dog implements Serializable {
    String name;
    String age;
    String color;

    public Dog(String name, String age, String color) {
        this.name = name;
        this.age = age;
        this.color = color;
    }

    @Override
    public String toString() {
        return name + &quot; &quot; + age + &quot; &quot; + color;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Java笔记</title><link>https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B/</guid><description>多线程基础，较为简陋，后续添加内容</description><pubDate>Fri, 04 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Java笔记&lt;/h1&gt;
&lt;p&gt;在韩顺平老师的Java课程中会结合一个坦克大战的实战项目，我急功近利，就不写坦克大战的编写了，只学Java中最核心的几个知识点&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;java绘图坐标体系&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基本概念&lt;/p&gt;
&lt;p&gt;在Java中坐标原点位于左上角，以像素为单位，x坐标代表距离竖坐标向右x个像素，而y代表位于横坐标的下y个像素&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Java事件处理机制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;java事件处理采取的是&quot;委派事件模型&quot;，当事件发生的时候，产生事件的对象，会把此信息传递给事件的监听者进行处理，事件在代码中体现为一个事件对象。&lt;/p&gt;
&lt;p&gt;事件源：是一个产生事件的对象，比如按钮，窗口等&lt;/p&gt;
&lt;p&gt;事件：事件就是承载事件源状态改变时的对象，比如说键盘事件，鼠标事件，窗口事件等等，会生成一个事件对象，保存当前事件的很多信息。&lt;/p&gt;
&lt;h2&gt;多线程基础&lt;/h2&gt;
&lt;p&gt;单线程：同一个时刻只允许执行一个线程&lt;/p&gt;
&lt;p&gt;多线程：同一个时刻可以执行多个线程，例如QQ打开多个聊天窗口&lt;/p&gt;
&lt;p&gt;并发：同一个时刻，多个任务交替执行，给人以同时进行的错觉（单线程多任务）&lt;/p&gt;
&lt;p&gt;并行：同一个时刻，多个任务同时进行（多核CPU可以支持并行）&lt;/p&gt;
&lt;p&gt;可通过Java写一个返回可用CPU数量的代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class CupNum {
    public static void main(String[] args) {
        Runtime runtime = Runtime.getRuntime();
        int cupNums = runtime.availableProcessors();
        System.out.println(cupNums);//16
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;线程的基本使用&lt;/h2&gt;
&lt;p&gt;在Java中线程有两种使用方式&lt;/p&gt;
&lt;p&gt;继承关系，其中Thread类实现了Runnable接口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/94.png&quot; alt=&quot;94&quot; /&gt;&lt;/p&gt;
&lt;p&gt;1.继承Thread类，重写run方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//1.当一个类继承了Thread类，该类就可以被当作线程使用
//2.一般我们会重写run方法，写上自己的业务代码
//3.run Thread 类实现了 Runnable 接口的run方法
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.实现Runnable接口，重写run方法&lt;/p&gt;
&lt;p&gt;我们先用thread实现run&lt;/p&gt;
&lt;h3&gt;继承Thread&lt;/h3&gt;
&lt;p&gt;以下是一个代码示例，启动一个猫叫的线程，输出5次&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class CupNum {
    public static void main(String[] args) {
        Cat cat = new Cat();//对于一个继承了Thread类的类
        cat.start();//我们可以把它当作一个线程来启动
    }
}

class Cat extends Thread {
    private int times = 0;

    @Override
    public void run() {
        while (times &amp;lt; 5) {
            System.out.println(&quot;我是猫猫&quot;);
            times++;
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;我是猫猫 第0次 线程名 Thread-0
我是猫猫 第1次 线程名 Thread-0
我是猫猫 第2次 线程名 Thread-0
我是猫猫 第3次 线程名 Thread-0
我是猫猫 第4次 线程名 Thread-0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到以上的代码中我们重写了Cat的run方法，但是在cat的实例中我们调用的是start方法，实际运行的也是run方法，这就涉及到了线程启用的机制&lt;/p&gt;
&lt;h3&gt;实现Runnable&lt;/h3&gt;
&lt;p&gt;1.因为Java是单继承的，我们有的时候仅仅依靠继承Thread类，是没有办法将一个子类再去继承Thread来实现多线程&lt;/p&gt;
&lt;p&gt;2.Java的设计者提供了另外的一个方式创建线程，就是通过Runnable接口来创建线程&lt;/p&gt;
&lt;p&gt;Runnable中没有start方法，而且不能够使用run来启动线程（因为直接调用run方法是阻塞的），我们需要创建线程对象将实现了Runnable接口的对象放入，再通过线程的start方法启用线程&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Hi {
    public static void main(String[] args) {
        Dog dog = new Dog();
        Thread thread = new Thread(dog);
        thread.start();
    }
}

class Dog implements Runnable {
    @Override
    public void run () {
        while(true) {
            System.out.println(&quot;大狗大狗叫叫叫~&quot;);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                System.out.println(&quot;捕获异常&quot;);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里的底层使用了一个名为代理模式(静态代理)的设计模式&lt;/p&gt;
&lt;p&gt;模拟实现Runnable接口开发线程的机制（没有实现start0的多线程）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class ThreadProxy implements Runnable {
    //Thread将Proxy当作一个线程类
    private Runnable target = null;

    @Override
    public void run() {
        if (target != null) {
            target.run();
        }
    }

    public ThreadProxy(Runnable target) {
        this.target = target;
    }

    public void start() {
        start0();
    }

    public void start0(){//真正实现多线程的方法
        run();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个时候我们有一个继承了父类的子类，我们就可以把这个子类实现Runnable接口，再去重写一个run方法（而通过动态绑定机制我们就可以调用run方法），将子类传给代理者，通过start方法就会开始启用多线程调用多线程子类的run方法。&lt;/p&gt;
&lt;h3&gt;多个子线程启用&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;public class Hi {
    public static void main(String[] args) {
        Dog dog1 = new Dog(&quot;来福&quot;);
        Dog dog2 = new Dog(&quot;旺财&quot;);
        Thread thread1 = new Thread(dog1);
        Thread thread2 = new Thread(dog2);
        thread1.start();
        thread2.start();
    }
}

class Dog implements Runnable {
    private int count = 0;
    private String name;

    public Dog(String name) {
        this.name = name;
    }

    @Override
    public void run() {
        while (count &amp;lt; 10) {
            System.out.println(&quot;大狗 &quot; + name + &quot; 叫叫叫~&quot;);
            count++;
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                System.out.println(&quot;捕获异常&quot;);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;大狗 旺财 叫叫叫~
大狗 来福 叫叫叫~
大狗 来福 叫叫叫~
大狗 旺财 叫叫叫~
大狗 旺财 叫叫叫~
大狗 来福 叫叫叫~
大狗 旺财 叫叫叫~
大狗 来福 叫叫叫~
大狗 来福 叫叫叫~
大狗 旺财 叫叫叫~
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中并不是完全交替执行的，其原因和底层CPU调用机制有关&lt;/p&gt;
&lt;p&gt;用jconsole监视线程，发现main线程很快退出，而两个子线程继续执行，并在各个线程结束后消散，最后进程结束&lt;/p&gt;
&lt;p&gt;Thread和Runnable&lt;/p&gt;
&lt;p&gt;1.之间本质上都没有什么区别，都是通过了start0方法去创建一个线程运行，而通过源码上来看发现Thread类本身也实现了Runnable的接口&lt;/p&gt;
&lt;p&gt;2.实现Runnable接口方式更加适合多个线程共享一个资源的情况，并且避免了单继承的限制&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Dog dog = new Dog();
Thread thread1 = new Thread(dog);
Thread thread2 = new Thread(dog);
thread1.start();
thread2.start();
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;线程启用的机制&lt;/h2&gt;
&lt;h3&gt;线程的运行与生命周期&lt;/h3&gt;
&lt;p&gt;在我们运行代码的时候，我们会开启一个进程，在这个进程中我们会开启一个主线程，在主线程又会开启Thread-0子线程，用这种方式启动子线程后，主线程不会阻塞，会继续执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class CupNum {
    public static void main(String[] args) {
        Cat cat = new Cat();
        cat.start();
        for(int i = 0; i &amp;lt; 3; i++) {
            System.out.println(&quot;主线程 &quot; + i);
            try{
                Thread.sleep(1000);
            } catch (Exception e) {
                System.out.println(&quot;捕获主线程异常&quot;);
            }
        }
    }
}

class Cat extends Thread {
    private int times = 0;

    @Override
    public void run() {
        while (times &amp;lt; 5) {
            System.out.println(&quot;我是猫猫 第&quot; + times + &quot;次 线程名 &quot; + Thread.currentThread().getName());
            times++;
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                System.out.println(&quot;捕获子线程异常&quot;);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;直观上来看，子线程，主线程交替执行，直到线程执行完毕&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;主线程 0
我是猫猫 第0次 线程名 Thread-0
主线程 1
我是猫猫 第1次 线程名 Thread-0
主线程 2
我是猫猫 第2次 线程名 Thread-0
我是猫猫 第3次 线程名 Thread-0
我是猫猫 第4次 线程名 Thread-0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了直观的看到线程的创建，我们使用jconsole来监视线程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/95.png&quot; alt=&quot;95&quot; /&gt;&lt;/p&gt;
&lt;p&gt;当子线程执行完后Thread就会被挂了，而主线程继续执行，或者如果主线程先挂，子线程也会继续执行，这就意味着主方法执行完毕的时候，可能进程任然在工作。（当所有的线程执行完毕的时候，进程才会被挂）&lt;/p&gt;
&lt;h3&gt;为什么时用start而不是run&lt;/h3&gt;
&lt;p&gt;当直接调用run方法启动代码的时候其实没有启用一个线程，实际上会发生阻塞，并不能实现我们预期中多线程&lt;/p&gt;
&lt;p&gt;1.先调用start方法，其中包含了start0方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public synchronized void start() {
    if (threadStatus != 0)
        throw new IllegalThreadStateException();
    group.add(this);

    boolean started = false;
    try {
        start0();
        started = true;
    } finally {
        try {
            if (!started) {
                group.threadStartFailed(this);
            }
        } catch (Throwable ignore) {
        
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.在使用start方法的时候会调用start0（JVM）方法，这个方法由底层实现，实现了多线程，使用多线程的方法调用run，而run加载到可运行的线程中，由CPU进行执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private native void start0();
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;实际案例（缺省版）&lt;/h2&gt;
&lt;p&gt;在后续同步机制中补完&lt;/p&gt;
&lt;p&gt;我们模拟一个三个窗口售票的情景&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com;

public class SellTicket {
    public static void main(String[] args) {
        SellTicket01 sell = new SellTicket01();
        Thread t1 = new Thread(sell);
        Thread t2 = new Thread(sell);
        Thread t3 = new Thread(sell);
        t1.start();
        t2.start();
        t3.start();
    }
}

class SellTicket01 implements Runnable {
    private static int ticketNum = 10;

    @Override
    public void run() {
        while(true) {
            if(ticketNum &amp;lt;= 0) {
                System.out.println(&quot;票售完&quot;);
                break;
            }

            try {
                System.out.println(&quot;售出一张票&quot;);
                ticketNum--;
                System.out.println(&quot;剩余&quot; + ticketNum + &quot;张票&quot;);
                Thread.sleep(5000);
            } catch (Exception e) {
                System.out.println(&quot;捕获异常&quot;);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果如下：我们会发现虽然设置了当票数&amp;lt;=0的时候需要break，但是在没有来得及对于票数进行减少的前提下，线程中的判断条件就已经执行（判断还剩余票，可以继续售卖），就会导致了票数超卖的情况&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;售出一张票
售出一张票
剩余8张票
售出一张票
剩余7张票
剩余9张票
售出一张票
剩余6张票
售出一张票
剩余5张票
售出一张票
剩余4张票
售出一张票
剩余3张票
售出一张票
剩余2张票
售出一张票
剩余1张票
售出一张票
剩余0张票
售出一张票
剩余-1张票
售出一张票
剩余-2张票
票售完
票售完
票售完
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们需要使用线程的同步互斥来解决这个问题&lt;/p&gt;
&lt;h2&gt;线程的退出&lt;/h2&gt;
&lt;p&gt;1.当线程完成任务的时候，线程会自动退出&lt;/p&gt;
&lt;p&gt;2.还可以使用变量来控制run方法的退出的方式停止线程，及通知方式&lt;/p&gt;
&lt;p&gt;以下代码通过修改flag判断条件退出线程&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com;

public class Exit01 {
    public static void main(String[] args) {
        T t = new T();
        Thread thread = new Thread(t);
        thread.start();
        try {
            Thread.sleep(6000);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        t.flag = false;//设置为不再运行
    }
}

class T implements Runnable {
    public boolean flag = true;
    @Override
    public void run() {
        while(flag) {
            System.out.println(&quot;持续运行&quot;);
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                System.out.println(&quot;捕获异常&quot;);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;持续运行
持续运行
持续运行
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;线程常用的方法&lt;/h2&gt;
&lt;h3&gt;setName&lt;/h3&gt;
&lt;p&gt;设置线程名称，使与参数name同名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Thread01 {
    public static void main(String[] args) {
        M m = new M();
        Thread t = new Thread(m);
        t.setName(&quot;线程1&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;getName&lt;/h3&gt;
&lt;p&gt;获取当前线程名称&lt;/p&gt;
&lt;h3&gt;setPriority&lt;/h3&gt;
&lt;p&gt;更改线程优先级&lt;/p&gt;
&lt;p&gt;分为1， 5， 10 从低到高&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Thread01 {
    public static void main(String[] args) {
        M m = new M();
        Thread t = new Thread(m);
        t.setName(&quot;线程1&quot;);
        t.setPriority(Thread.MIN_PRIORITY);//设置优先级为最低
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;getPriority&lt;/h3&gt;
&lt;p&gt;获取线程优先级&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public final static int MIN_PRIORITY = 1;
public final static int NORM_PRIORITY = 5;
public final static int MAX_PRIORITY = 10;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;sleep&lt;/h3&gt;
&lt;p&gt;暂停当前线程进入休眠&lt;/p&gt;
&lt;h3&gt;interrupt&lt;/h3&gt;
&lt;p&gt;中断线程，没有结束线程，一般用于中断正在休眠的线程（用于唤醒休眠线程）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Thread01 {
    public static void main(String[] args) {
        M m = new M();
        Thread t = new Thread(m);
        t.setName(&quot;线程1&quot;);//设置线程名字
        t.setPriority(Thread.MIN_PRIORITY);//设置优先级为最低
        System.out.println(t.getName());//获取线程名字
        t.start();
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        t.interrupt();
    }
}

class M implements Runnable {
    public boolean flag = true;

    @Override
    public void run() {
        System.out.println(&quot;线程运行&quot;);
        try {
            System.out.println(&quot;线程休眠20s&quot;);
            Thread.sleep(20000);
        } catch (InterruptedException e) {
            System.out.println(&quot;休眠被中断&quot;);
        }
        System.out.println(&quot;线程结束&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;线程1
线程运行
线程休眠20s
休眠被中断
线程结束
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;线程插队&lt;/h3&gt;
&lt;h3&gt;yield&lt;/h3&gt;
&lt;p&gt;线程礼让，让出CPU，让其他的线程执行，但是礼让的时间不确定，所以也不一定礼让成功&lt;/p&gt;
&lt;h3&gt;join&lt;/h3&gt;
&lt;p&gt;线程的插队，插队的线程一旦插队成功，则肯定先在执行完插入的线程的所有任务&lt;/p&gt;
&lt;h3&gt;使用join&lt;/h3&gt;
&lt;p&gt;代码示例（不加入插队的情况），两个线程交替进行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Thread02 {
    public static void main(String[] args) {
        System.out.println(&quot;主线程开始运行&quot;);
        N n = new N();
        Thread thread1 = new Thread(n);
        thread1.start();
        for(int i = 0; i &amp;lt; 20; i++) {
            System.out.println(&quot;主线程占用&quot; + i);
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }
}

class N implements Runnable {
    @Override
    public void run() {
        System.out.println(&quot;子线程开始运行&quot;);
        for(int i = 0; i &amp;lt; 20; i++) {
            System.out.println(&quot;子线程占用&quot; + i);
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;主线程开始运行
主线程占用0
子线程开始运行
子线程占用0
子线程占用1
主线程占用1
主线程占用2
子线程占用2
主线程占用3
子线程占用3
主线程占用4
子线程占用4
子线程占用5
主线程占用5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;主线程加入join，让子线程插队&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for(int i = 0; i &amp;lt; 20; i++) {
    System.out.println(&quot;主线程占用&quot; + i);
    try {
        if(i == 2) {
            thread1.join();//在判断主线程执行3次的时候，让子线程插队
        }
        Thread.sleep(500);
    } catch (InterruptedException e) {
        throw new RuntimeException(e);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;主线程开始运行
主线程占用0
子线程开始运行
子线程占用0
主线程占用1
子线程占用1
主线程占用2
子线程占用2
子线程占用3
子线程占用4
子线程占用5
子线程占用6
子线程占用7
子线程占用8
子线程占用9
子线程占用10
......
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当子线程结束后，主线程再继续执行&lt;/p&gt;
&lt;h3&gt;使用yield&lt;/h3&gt;
&lt;p&gt;（调用静态方法）&lt;/p&gt;
&lt;p&gt;而使用yield在资源不紧张的情况下可以使得继续同步执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for(int i = 0; i &amp;lt; 20; i++) {
    System.out.println(&quot;主线程占用&quot; + i);
    try {
        if(i == 2) {
            Thread.yield();
        }
        Thread.sleep(500);
    } catch (InterruptedException e) {
        throw new RuntimeException(e);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：仍然继续同步执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;主线程开始运行
主线程占用0
子线程开始运行
子线程占用0
主线程占用1
子线程占用1
子线程占用2
主线程占用2
子线程占用3
主线程占用3
子线程占用4
主线程占用4
主线程占用5
子线程占用5
主线程占用6
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;线程插队例题&lt;/h3&gt;
&lt;p&gt;1.主线程每间隔1s输出hi，一共10次&lt;/p&gt;
&lt;p&gt;2.当输出5次hi后，启动一个子线程，每隔1s输出hello （要求使用join插队）&lt;/p&gt;
&lt;p&gt;3.在子线程执行完毕后继续输出主线程的hi&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com;
public class Homework {
    public static void main(String[] args) throws InterruptedException {
        AA aa = new AA();
        Thread thread = new Thread(aa);
        for (int i = 1; i &amp;lt; 11; i++) {
            System.out.println(&quot;hi &quot; + i);
            if (i == 5) {
                thread.start();
                thread.join();
            }
            Thread.sleep(1000);
        }
        System.out.println(&quot;主线程结束&quot;);
    }
}

class AA implements Runnable {
    @Override
    public void run() {
        for (int i = 1; i &amp;lt; 11; i++) {
            System.out.println(&quot;hello &quot; + i);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
        System.out.println(&quot;子线程结束&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;用户线程和守护线程&lt;/h2&gt;
&lt;p&gt;1.用户线程：也被称为工作线程，当线程的任务执行完成或通知方式结束&lt;/p&gt;
&lt;p&gt;2.守护线程：一般是为了工作线程服务的，当所有的用户线程结束的时候，守护线程自动结束&lt;/p&gt;
&lt;p&gt;3.常见的守护线程：垃圾回收机制&lt;/p&gt;
&lt;p&gt;我们接下来模拟一个守护线程，这个线程在主线程运行完毕之后退出，只需要将子线程设置为守护线程即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com;

public class Thread03 {
    public static void main(String[] args) {
        B b = new B();
        Thread thread = new Thread(b);
        thread.setDaemon(true);
        //设置守护线程 注意先设置再启动
        thread.start();
        for (int i = 0; i &amp;lt; 10; i++) {
            System.out.println(&quot;主线程工作中...&quot;);
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }
}

class B implements Runnable {
    @Override
    public void run() {
        while(true) {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            System.out.println(&quot;守护线程工作中...&quot;);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：可见使用setDaemon关键字进行设置守护线程&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;主线程工作中...
主线程工作中...
主线程工作中...
守护线程工作中...
主线程工作中...
主线程工作中...
守护线程工作中...
主线程工作中...
主线程工作中...
守护线程工作中...
主线程工作中...
守护线程工作中...
主线程工作中...
主线程工作中...
守护线程工作中...
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;线程的生命周期&lt;/h2&gt;
&lt;p&gt;在JDK文档中有一个State的枚举类型，用于表示线程的六种状态&lt;/p&gt;
&lt;p&gt;NEW 尚未启动的线程位于此状态&lt;/p&gt;
&lt;p&gt;RUNNABLE 在Java虚拟机中执行的线程位于此状态&lt;/p&gt;
&lt;p&gt;BLOCKED 被阻塞等待监视器锁定的线程位于此状态&lt;/p&gt;
&lt;p&gt;WAITING 正在等待另一个线程执行特定动作的线程位于此状态&lt;/p&gt;
&lt;p&gt;TIMED_WAITING 正在等待另一个线程执行特定动作到指定的等待时间的线程位于此状态&lt;/p&gt;
&lt;p&gt;TERMINATED 已退出的线程位于此状态&lt;/p&gt;
&lt;p&gt;在有一些说法中有七种状态之说：其实是RUNNABLE细化为了READY和RUNNING，取决于是否真正在运行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/96.png&quot; alt=&quot;96&quot; /&gt;&lt;/p&gt;
&lt;p&gt;其中RUNNABLE会通过三种不同的操作进入WAITING TIMED_WAITING BLOCKED 而在特定的条件下返回RUNNABLE&lt;/p&gt;
&lt;p&gt;在以前提到的wait和join实际上就是将线程的状态切换为WAITING 或者 TIMED_WAITING（取决于加不加参数），而yeild是将RUNING状态尝试着切换到Ready状态，从而让出CPU时间&lt;/p&gt;
&lt;p&gt;代码示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Thread03 {
    public static void main(String[] args) {
        B b = new B();
        Thread thread = new Thread(b);
        System.out.println(&quot;thread 的状态为 &quot; + thread.getState());//再启动前输出状态（1）
        thread.start();
        //在状态不为结束的时候重复输出状态
        while(Thread.State.TERMINATED != thread.getState()) {
            System.out.println(&quot;thread 的状态为 &quot; + thread.getState());//在RUNNABLE的状态输出（2）
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
        System.out.println(&quot;thread 的状态为 &quot; + thread.getState());//在线程结束时输出状态（3）
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;thread 的状态为 NEW（1）
thread 的状态为 RUNNABLE
线程工作中...
线程工作中...
thread 的状态为 RUNNABLE
线程工作中...
线程工作中...
thread 的状态为 RUNNABLE
线程工作中...
线程工作中...
thread 的状态为 RUNNABLE
线程工作中...
线程工作中...
thread 的状态为 TIMED_WAITING//在子线程启用sleep时进入了TIMED_WAITING
线程工作中...
线程工作中...
thread 的状态为 RUNNABLE
thread 的状态为 TERMINATED（3）
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;线程同步机制&lt;/h2&gt;
&lt;p&gt;还记得我们之前的售票问题吗？因为没有办法预期什么时候票售完，而导致了过量销售票的问题，现在我们要来解决这个问题&lt;/p&gt;
&lt;h3&gt;同步&lt;/h3&gt;
&lt;p&gt;1.在多线程编程中，一些敏感的数据不允许被多个线程同时访问，此时就要使用同步访问技术，保证数据在任何一个时刻最多只能有一个线程访问它，保证数据的完整性&lt;/p&gt;
&lt;p&gt;2.从内存上而言，线程同步是当有一个线程对特定的内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作&lt;/p&gt;
&lt;h3&gt;Synchronized关键字&lt;/h3&gt;
&lt;p&gt;1.同步代码块&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;synchronized(对象){	//得到对象的锁之后才可以操作代码
	//需要被同步的代码;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.运用synchronized放在方法声明&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public synchronized void m () {
	//需要被同步的代码;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;互斥锁&lt;/h3&gt;
&lt;p&gt;1.Java中，引入了对象互斥锁的概念，来保证共享数据操作的完整性&lt;/p&gt;
&lt;p&gt;2.每个对象都对应于一个可称为“互斥锁”的标记，这个标记用于保证在任一时刻，只能有一个线程访问该对象&lt;/p&gt;
&lt;p&gt;3.关键字synchronized来与对象的互斥锁联系，当某个对象用synchronized装饰的时候，表明该对象在任一时刻只能由一个线程访问&lt;/p&gt;
&lt;p&gt;4.同步的局限性：导致程序的执行效率降低&lt;/p&gt;
&lt;p&gt;5.同步方法（非静态的）的锁可以是this，也可以是其他对象（要求是同一个对象）&lt;/p&gt;
&lt;p&gt;6.同步方法（静态的）的锁为当前类本身&lt;/p&gt;
&lt;h3&gt;解决方法&lt;/h3&gt;
&lt;h4&gt;解决方法1&lt;/h4&gt;
&lt;p&gt;在方法上直接加锁，加上synchronized关键字&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class SellTicket01 implements Runnable {
    private static int ticketNum = 10;
    private boolean loop = true;
    @Override
    public void run() {
        while(loop) {
            sell();
        }
    }

    public synchronized void sell() {
        if(ticketNum &amp;lt;= 0) {
            System.out.println(&quot;票售完&quot;);
            loop = false;
            return;
        }

        try {
            System.out.println(Thread.currentThread().getName() + &quot;售出一张票&quot;);
            ticketNum--;
            System.out.println(&quot;剩余&quot; + ticketNum + &quot;张票&quot;);
            Thread.sleep(5000);
        } catch (Exception e) {
            System.out.println(&quot;捕获异常&quot;);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Thread-0售出一张票
剩余9张票
Thread-1售出一张票
剩余8张票
Thread-2售出一张票
剩余7张票
Thread-2售出一张票
剩余6张票
Thread-1售出一张票
剩余5张票
Thread-1售出一张票
剩余4张票
Thread-1售出一张票
剩余3张票
Thread-1售出一张票
剩余2张票
Thread-1售出一张票
剩余1张票
Thread-0售出一张票
剩余0张票
票售完
票售完
票售完
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;解决方法2&lt;/h4&gt;
&lt;p&gt;在代码块上加锁&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class SellTicket01 implements Runnable {
    private static int ticketNum = 10;
    private boolean loop = true;
    @Override
    public void run() {
        while(loop) {
            sell();
        }
    }

    public void sell() {
        synchronized(this) {
            if(ticketNum &amp;lt;= 0) {
                System.out.println(&quot;票售完&quot;);
                loop = false;
                return;
            }

            try {
                System.out.println(Thread.currentThread().getName() + &quot;售出一张票&quot;);
                ticketNum--;
                System.out.println(&quot;剩余&quot; + ticketNum + &quot;张票&quot;);
                Thread.sleep(5000);
            } catch (Exception e) {
                System.out.println(&quot;捕获异常&quot;);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;改进&lt;/h4&gt;
&lt;p&gt;其实还可以改进一下，将模拟的sleep放在所代码块的外面，这样可以模拟每一个售票窗口每5s售一张票，而不是没5s只有一个售票口出一张票（其实这里在实际编程中不会加入sleep休眠，只是增强一下对锁的理解，sleep休眠的时间是不受this锁的影响）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class SellTicket01 implements Runnable {
    private static int ticketNum = 10;
    private boolean loop = true;
    @Override
    public void run() {
        while(loop) {
            sell();
        }
    }

    public void sell() {
        synchronized(this) {
            if(ticketNum &amp;lt;= 0) {
                System.out.println(&quot;票售完&quot;);
                loop = false;
                return;
            }
                System.out.println(Thread.currentThread().getName() + &quot;售出一张票&quot;);
                ticketNum--;
                System.out.println(&quot;剩余&quot; + ticketNum + &quot;张票&quot;);
        }

        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;注意细节&lt;/h3&gt;
&lt;p&gt;1.同步方法如果没有使用static修饰：默认锁对象为this&lt;/p&gt;
&lt;p&gt;2.如果方法使用static修饰，默认锁对象：当前类.class&lt;/p&gt;
&lt;p&gt;3.要求多个线程的锁对象为同一个&lt;/p&gt;
&lt;h3&gt;线程死锁&lt;/h3&gt;
&lt;p&gt;多个线程都占用了对方的锁资源，但是不肯相让，导致了死锁&lt;/p&gt;
&lt;p&gt;例如：A要B的b资源，但是b资源被B占用，而B要等到A的a资源释放后才可以继续运行完毕释放b资源，导致了A也无法获取到b资源，从而释放a。&lt;/p&gt;
&lt;p&gt;以下是一个发生死锁的代码示例，两个Object资源由static修饰，两个新创建的对象共享资源&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com;

public class DeadLock {
    public static void main(String[] args) {
        Thread thread1 = new Thread(new DeadLockDemo(true));
        Thread thread2 = new Thread(new DeadLockDemo(false));
        thread1.start();
        thread2.start();
    }
}

class DeadLockDemo implements Runnable {
    static Object resource1 = new Object();
    static Object resource2 = new Object();

    boolean flag;

    public DeadLockDemo(boolean flag) {
        this.flag = flag;
    }

    @Override
    public void run() {
        if (flag) {
            synchronized (resource1) {
                try {
                    System.out.println(Thread.currentThread().getName() + &quot;获取资源1,下一步获取资源2&quot;);
                    Thread.sleep(5000);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                synchronized (resource2) {
                    try {
                        System.out.println(Thread.currentThread().getName() + &quot;获取资源2&quot;);
                        Thread.sleep(5000);
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                }
            }
        } else {
            synchronized (resource2) {
                try {
                    System.out.println(Thread.currentThread().getName() + &quot;获取资源2,下一步获取资源1&quot;);
                    Thread.sleep(5000);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                synchronized (resource1) {
                    try {
                        System.out.println(Thread.currentThread().getName() + &quot;获取资源1&quot;);
                        Thread.sleep(5000);
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;发生死锁&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Thread-0获取资源1,下一步获取资源2
Thread-1获取资源2,下一步获取资源1
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;释放锁&lt;/h3&gt;
&lt;h4&gt;会释放锁的情况&lt;/h4&gt;
&lt;p&gt;1.当前线程的同步方法、同步代码块执行完毕&lt;/p&gt;
&lt;p&gt;2.当前线程在同步方法、同步代码块中遇到了break、return&lt;/p&gt;
&lt;p&gt;3.当前线程在同步方法、同步代码块中遇到了异常&lt;/p&gt;
&lt;p&gt;4.当前线程在同步方法、同步代码块中调用了线程对象的wait方法，使线程暂停&lt;/p&gt;
&lt;h4&gt;不会释放锁的情况&lt;/h4&gt;
&lt;p&gt;1.当前线程在同步方法、同步代码块中使用了Thread.sleep/yield方法&lt;/p&gt;
&lt;p&gt;2.线程执行同步代码块中，其他线程调用了该线程的suspend( )方法，将该线程挂起，该线程不会释放锁。（不推荐使用suspend和resume进行编程）&lt;/p&gt;
&lt;h1&gt;多线程编程作业&lt;/h1&gt;
&lt;h2&gt;例题一&lt;/h2&gt;
&lt;p&gt;1.在main方法中启动两个线程&lt;/p&gt;
&lt;p&gt;2.在第一个线程中随机循环打印100以内的整数&lt;/p&gt;
&lt;p&gt;3.直到第二个线程中从键盘读取了Q命令&lt;/p&gt;
&lt;p&gt;解题思路：&lt;/p&gt;
&lt;p&gt;我将线程2设置为守护线程，当线程1结束时，守护线程2自动结束&lt;/p&gt;
&lt;p&gt;而线程2中可以去设置线程1类的loop从而终止线程1&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Homework01 {
    public static void main(String[] args) {
        Thread thread1 = new Thread(new Task1());
        Thread thread2 = new Thread(new Task2());
        thread2.setDaemon(true);
        thread1.start();
        thread2.start();
    }
}

class Task1 implements Runnable {
    public static boolean loop = true;

    @Override
    public void run() {
        while (loop) {
            System.out.println((int) (Math.random() * 100));
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }
}

class Task2 implements Runnable {
    @Override
    public void run() {
        while (true) {
            Scanner scanner = new Scanner(System.in);
            char c = scanner.next().charAt(0);
            if (c == &apos;Q&apos; || c == &apos;q&apos;) {
                Task1.loop = false;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者你也可以在判断条件下直接break Task2，就不用守护线程了&lt;/p&gt;
&lt;h2&gt;例题二&lt;/h2&gt;
&lt;p&gt;1.有两个用户分别从一个卡上取钱（总额1000元）&lt;/p&gt;
&lt;p&gt;2.每次取1000块，当余额不足时就不能取了&lt;/p&gt;
&lt;p&gt;我对题目稍做了一些更改：每次随机取（0-1000元），使其更符合生活实际&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com;

public class HomeWork02 {
    public static void main(String[] args) {
        Bank bank = new Bank();
        Thread thread1 = new Thread(bank);
        Thread thread2 = new Thread(bank);
        thread1.start();
        thread2.start();
    }
}

class Bank implements Runnable {
    public static int money = 10000;
    static final Object obj = new Object();

    @Override
    public void run() {
        while (true) {
            synchronized (obj) {
                int getMoney = (int) (Math.random() * 1000);
                if (money - getMoney &amp;lt; 0) {
                    System.out.println(&quot;钱不够取 剩余 &quot; + money);
                    break;
                } else {
                    System.out.println(Thread.currentThread().getName() + &quot; 取出 &quot; + getMoney + &quot; 剩余 &quot; + money);
                    money -= getMoney;
                }
            }
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Thread-0 取出 153 剩余 10000
Thread-1 取出 82 剩余 9847
Thread-0 取出 852 剩余 9765
Thread-1 取出 727 剩余 8913
Thread-1 取出 857 剩余 8186
Thread-0 取出 765 剩余 7329
Thread-1 取出 904 剩余 6564
Thread-0 取出 766 剩余 5660
Thread-1 取出 901 剩余 4894
Thread-0 取出 440 剩余 3993
Thread-1 取出 430 剩余 3553
Thread-0 取出 5 剩余 3123
Thread-1 取出 726 剩余 3118
Thread-0 取出 293 剩余 2392
Thread-0 取出 655 剩余 2099
Thread-1 取出 372 剩余 1444
Thread-0 取出 874 剩余 1072
钱不够取 剩余 198
钱不够取 剩余 198
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Java笔记</title><link>https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E6%B3%9B%E5%9E%8Bjunit/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E6%B3%9B%E5%9E%8Bjunit/</guid><description>泛型，JUnit实际使用</description><pubDate>Thu, 03 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Java笔记&lt;/h1&gt;
&lt;h2&gt;泛型&lt;/h2&gt;
&lt;h3&gt;使用案例&lt;/h3&gt;
&lt;p&gt;我们先来看一个例子&lt;/p&gt;
&lt;p&gt;运用集合来存储狗&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Generic_ {
    public static void main(String[] args) {
        ArrayList list = new ArrayList();
        list.add(new Dog(&quot;旺财&quot;, 19));
        list.add(new Dog(&quot;来福&quot;, 33));
        list.add(new Dog(&quot;小黑&quot;, 12));
        Iterator iterator = list.iterator();
        while (iterator.hasNext()) {
            Dog d = (Dog) iterator.next();
            System.out.println(d);
        }
    }
}

class Dog {
    String name;
    int age;

    public Dog(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以通过迭代器遍历所有的狗，但是加入程序员不小心放入了一只猫，程序就会因为类型转化错误而抛出异常&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Exception in thread &quot;main&quot; java.lang.ClassCastException: com.Cat cannot be cast to com.Dog
	at com.Generic_.main(Generic_.java:19)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样的情况下我们可以使用instanceof加上类型转换来进行处理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Generic_ {
    public static void main(String[] args) {
        ArrayList list = new ArrayList();
        list.add(new Dog(&quot;旺财&quot;, 19));
        list.add(new Dog(&quot;来福&quot;, 33));
        list.add(new Dog(&quot;小黑&quot;, 12));
        list.add(new Cat(&quot;小花&quot;, 11));
        Iterator iterator = list.iterator();
        while (iterator.hasNext()) {
            Object obj = iterator.next();
            Object animal;
            if(obj instanceof Dog){
                animal = (Dog) obj;
            } else {
                animal = (Cat) obj;
            }
            System.out.println(animal);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是如果我们后续有不小心放入了一只羊，我们就还要去改进代码逻辑&lt;/p&gt;
&lt;p&gt;为了解决这个问题，我们引入了泛型，以约束传入的类型，使得在放入了不同于Dog类型的元素的时候就会发生编译器的编译警告，而不是在运行的时候报错&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Generic_ {
    public static void main(String[] args) {
        ArrayList&amp;lt;Dog&amp;gt; list = new ArrayList&amp;lt;Dog&amp;gt;();
        list.add(new Dog(&quot;旺财&quot;, 19));
        list.add(new Dog(&quot;来福&quot;, 33));
        list.add(new Dog(&quot;小黑&quot;, 12));
        //list.add(new Cat(&quot;黑猫&quot;, 12));编译出错
        for(Dog d : list) {
            System.out.println(d);
        }
    }
}

class Dog {
    String name;
    int age;

    public Dog(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而且可以通过增强的for循环来直接取出Dog对象，使得遍历更加的方便&lt;/p&gt;
&lt;p&gt;&lt;em&gt;泛型的好处&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;1.在编译的时候会检查元素的类型，提升了安全性&lt;/p&gt;
&lt;p&gt;2.减少了类型的转换次数，提升了效率&lt;/p&gt;
&lt;p&gt;详细说明：在不使用泛型的时候，放入的时候需要转为Object放入，而取出时通过Object取出引用，需要进行类型的转换。在使用泛型的时候，放入和取出的时候，不需要类型转化&lt;/p&gt;
&lt;p&gt;3.不再提示编译警告（无需加入SuppressWarnings的注解）&lt;/p&gt;
&lt;h3&gt;泛型的定义&lt;/h3&gt;
&lt;p&gt;泛型是一种可以表示数据类型的数据类型，由程序员来指定&lt;/p&gt;
&lt;p&gt;1.泛型又称为参数化类型，是Jdk5.0出现的新特性，解决数据类型的安全问题&lt;/p&gt;
&lt;p&gt;2.在类声明或者实例化时只需要指定好需要的具体类型即可&lt;/p&gt;
&lt;p&gt;3.Java泛型可以保证如果程序在编译时发出警告，而不是运行时出现异常，同时代码更加的简介健壮&lt;/p&gt;
&lt;p&gt;4.泛型的作用是，可以在类声明时通过一个标识表示类中的某个属性的类型，或者是某个方法的返回值类型，或者是参数类型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Generic03 {
    public static void main(String[] args) {
        Person&amp;lt;String&amp;gt; person = new Person&amp;lt;String&amp;gt;(&quot;礼物&quot;);
        Person&amp;lt;Integer&amp;gt; person1 = new Person&amp;lt;Integer&amp;gt;(1);
    }
}

class Person&amp;lt;E&amp;gt; {
    E s;
    //E表示的是 s的数据类型，该数据类型在定义Person对象时指定
    //即在编译期间就确定E的类型

    public Person(E s) {
        this.s = s;
    }

    public E f() {
        return s;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;E表示的是 s的数据类型，该数据类型在定义Person对象时指定，即在编译期间就确定E的类型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Generic03 {
    public static void main(String[] args) {
        Person&amp;lt;String&amp;gt; person = new Person&amp;lt;String&amp;gt;(&quot;礼物&quot;);
        person.classReturn();//class java.lang.String
        Person&amp;lt;Integer&amp;gt; person1 = new Person&amp;lt;Integer&amp;gt;(1);
        person1.classReturn();//class java.lang.Integer
    }
}

class Person&amp;lt;E&amp;gt; {
    E s;

    public Person(E s) {
        this.s = s;
    }

    public void classReturn() {
        System.out.println(s.getClass());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;泛型的语法&lt;/h3&gt;
&lt;h4&gt;声明&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;interface 接口&amp;lt;E&amp;gt; {}
class 类&amp;lt;E,F&amp;gt; {}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;实例化&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;List&amp;lt;String&amp;gt; strList = new ArrayList&amp;lt;String&amp;gt;();
Iterator&amp;lt;Customer&amp;gt; iterator = customers.iterator();
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;例题&lt;/h4&gt;
&lt;p&gt;总而言之在创建泛型集合的时候，传入的泛型类型就会在源码中赋给所有的泛型变量，在实际使用的时候运用var补全即可方便的获取迭代器、EntrySet&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Generic03 {
    public static void main(String[] args) {
        HashSet&amp;lt;Student&amp;gt; set= new HashSet&amp;lt;Student&amp;gt;();
        Student person1 = new Student(&quot;李明&quot;, 19);
        Student person2 = new Student(&quot;王名&quot;, 29);
        Student person3 = new Student(&quot;王王&quot;, 9);
        set.add(person1);
        set.add(person2);
        set.add(person3);
        Iterator&amp;lt;Student&amp;gt; it = set.iterator();
        while(it.hasNext()) {
            Student student = it.next();
            System.out.println(student);
        }

        for(Student student : set){
            System.out.println(student);
        }
    }
}

class Student {
    String name;
    int age;

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return &quot;学生 &quot; + name + &quot; &quot; + age;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;HashMap来使用泛型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Generic03 {
    public static void main(String[] args) {
        HashMap&amp;lt;String, Student&amp;gt; map= new HashMap&amp;lt;String, Student&amp;gt;();
        Student person1 = new Student(&quot;李明&quot;, 19);
        Student person2 = new Student(&quot;王名&quot;, 29);
        Student person3 = new Student(&quot;王王&quot;, 9);
        map.put(&quot;学生1&quot;, person1);
        map.put(&quot;学生2&quot;, person2);
        map.put(&quot;学生3&quot;, person3);
        Set&amp;lt;Map.Entry&amp;lt;String, Student&amp;gt;&amp;gt; entrySet = map.entrySet();
        Iterator&amp;lt;Map.Entry&amp;lt;String, Student&amp;gt;&amp;gt; iterator = entrySet.iterator();
        while(iterator.hasNext()) {
            Map.Entry&amp;lt;String, Student&amp;gt; entry = iterator.next();
            String lable = entry.getKey();
            Student student = entry.getValue();
            System.out.println(lable + student);
        }
    }
}

class Student {
    String name;
    int age;

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return &quot; &quot; + name + &quot; &quot; + age;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;泛型的使用细节&lt;/h3&gt;
&lt;p&gt;1.泛型里面的类型只能够是引用数据类型，不可以传入基本数据类型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Generic04 {
    public static void main(String[] args) {
        List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;Integer&amp;gt;();
        //List&amp;lt;int&amp;gt; listInt = new ArrayList&amp;lt;int&amp;gt;();编译错误
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.在指定泛型具体类型后，可以传入该类型或者该类型的子类型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Generic04 {
    public static void main(String[] args) {
        List&amp;lt;A&amp;gt; list = new ArrayList&amp;lt;A&amp;gt;();
        list.add(new A());
        list.add(new AA());
    }
}

class A {}
class AA extends A {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者自定义一个类型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Generic04 {
    public static void main(String[] args) {
        A a = new A();
        AA aa = new AA();
        Test&amp;lt;A&amp;gt; test1 = new Test&amp;lt;A&amp;gt;(a);
        Test&amp;lt;A&amp;gt; test2 = new Test&amp;lt;A&amp;gt;(aa);//传入泛型A的子类型实例引用aa
    }
}

class Test&amp;lt;E&amp;gt; {
    E e;

    public Test(E e) {
        this.e = e;
    }
}

class A {}
class AA extends A {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.泛型的使用形式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;List&amp;lt;Integer&amp;gt; list1 = new ArrayList&amp;lt;Integer&amp;gt;();
List&amp;lt;Integer&amp;gt; list2 = new ArrayList&amp;lt;&amp;gt;();//编译器会自动推断泛型类型

List list3 = new ArrayList();//等价于如下形式
List&amp;lt;Object&amp;gt; list4 = new ArrayList&amp;lt;&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们可以去证明一下，其中e可已接收任何类型的实例，判断出e被指定为一个Object类型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Generic04 {
    public static void main(String[] args) {
        Test test = new Test();
        test.e = 100;
        System.out.println(test.e.getClass());
        test.e = &quot;Hello&quot;;
        System.out.println(test.e.getClass());
    }
}

class Test&amp;lt;E&amp;gt; {
    public E e;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class java.lang.Integer
class java.lang.String
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;练习题&lt;/h3&gt;
&lt;p&gt;一个练习题，实现员工的排序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.*;

public class Generic04 {
    public static void main(String[] args) {
        Employee person1 = new Employee(&quot;丽华&quot;, 19100.0, new MyDate(2004, 5, 2));
        Employee person2 = new Employee(&quot;李丽&quot;, 13900.0, new MyDate(1964, 1, 12));
        Employee person3 = new Employee(&quot;王芳&quot;, 3900.0, new MyDate(1994, 3, 23));
        Employee person4 = new Employee(&quot;王芳&quot;, 300.0, new MyDate(1993, 11, 23));
        Employee person5 = new Employee(&quot;王芳&quot;, 900.0, new MyDate(1994, 3, 23));
        List&amp;lt;Employee&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        list.add(person1);
        list.add(person2);
        list.add(person3);
        list.add(person4);
        list.add(person5);

        list.sort(new Comparator&amp;lt;Employee&amp;gt;() {
            @Override
            public int compare(Employee o1, Employee o2) {
                int i = o1.getName().compareTo(o2.getName());
                if (i != 0) {
                    return i;
                }
                return o1.getBirthday().compareTo(o2.getBirthday());
            }
        });

        for (Employee e : list) {
            System.out.println(e);
        }
    }
}

class Employee {
    private String name;
    private double sal;
    private MyDate birthday;


    public Employee(String name, double sal, MyDate birthday) {
        this.name = name;
        this.sal = sal;
        this.birthday = birthday;
    }

    @Override
    public String toString() {
        return name + &quot; 薪水是 &quot; + sal + &quot; 生日是 &quot; + birthday.toString();
    }

    public double getSal() {
        return sal;
    }

    public void setSal(double sal) {
        this.sal = sal;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public MyDate getBirthday() {
        return birthday;
    }

    public void setBirthday(MyDate birthday) {
        this.birthday = birthday;
    }
}

class MyDate implements Comparable&amp;lt;MyDate&amp;gt;{
    private int year;
    private int month;
    private int day;

    public MyDate(int year, int month, int day) {
        this.year = year;
        this.month = month;
        this.day = day;
    }

    public int compareTo(MyDate o2) {
        int year = getYear() - o2.getYear();
        if (year != 0) {
            return year;
        }
        int  month= getMonth() - o2.getMonth();
        if (month != 0) {
            return month;
        }
        int day = getDay() - o2.getDay();
            return day;
    }

    @Override
    public String toString() {
        return &quot;&quot; + year + &quot;-&quot; + month + &quot;-&quot; + day;
    }

    public int getYear() {
        return year;
    }

    public void setYear(int year) {
        this.year = year;
    }

    public int getMonth() {
        return month;
    }

    public void setMonth(int month) {
        this.month = month;
    }

    public int getDay() {
        return day;
    }

    public void setDay(int day) {
        this.day = day;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;自定义泛型&lt;/h2&gt;
&lt;h3&gt;自定义泛型类&lt;/h3&gt;
&lt;h4&gt;基本语法&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;class 类名&amp;lt;T,E ...&amp;gt; {
	成员
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;使用细节&lt;/h4&gt;
&lt;p&gt;1.普通成员可以使用泛型（属性，方法）&lt;/p&gt;
&lt;p&gt;2.使用泛型的数组，不可以初始化（因为不知道空间大小）&lt;/p&gt;
&lt;p&gt;3.静态方法中不可以使用类的泛型&lt;/p&gt;
&lt;p&gt;4.泛型类的类型，是在创建对象时确定的（因为创建对象时，需要确定类型）&lt;/p&gt;
&lt;p&gt;5.如果在创建对象时没有指定类型，默认为Object&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Tiger&amp;lt;T, R, M&amp;gt; {
    String name;
    T t;
    R r;
    M m;

    public Tiger (String name, T t, R r, M m) {
        this.name = name;
        this.t = t;
        this.r = r;
        this.m = m;
    }

    public T gerT() {
        return this.t;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public class generic {
    public static void main(String[] args) {
        Tiger&amp;lt;String, Integer, Double&amp;gt; tiger = new Tiger&amp;lt;&amp;gt;(&quot;Tiger&quot;, &quot;Tiger&quot;, 1, 1.1);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以使用泛型实现复数相加&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Complex&amp;lt;T extends Number&amp;gt; {
    private final T real;  // 实部
    private final T imaginary;  // 虚部

    public Complex(T real, T imaginary) {
        this.real = real;
        this.imaginary = imaginary;
    }

    // 复数相加（返回新的 Complex&amp;lt;T&amp;gt;）
    public Complex&amp;lt;T&amp;gt; add(Complex&amp;lt;T&amp;gt; other, BinaryOperator&amp;lt;T&amp;gt; adder) {
        T newReal = adder.apply(this.real, other.real);
        T newImaginary = adder.apply(this.imaginary, other.imaginary);
        return new Complex&amp;lt;&amp;gt;(newReal, newImaginary);
    }

    @Override
    public String toString() {
        return real + &quot; + &quot; + imaginary + &quot;i&quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;自定义泛型接口&lt;/h3&gt;
&lt;h4&gt;基本语法&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;interface 接口名&amp;lt;T, R...&amp;gt; {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;使用细节&lt;/h4&gt;
&lt;p&gt;1.接口中，静态成员也不可以使用泛型&lt;/p&gt;
&lt;p&gt;2.泛型的接口类型，在继承接口，或者实现接口时确定&lt;/p&gt;
&lt;p&gt;3.没有指定类型，泛型默认为Object&lt;/p&gt;
&lt;p&gt;使用样例，这里没什么实际运用价值，只是作为展示如何使用（在源码中有很多这种泛型接口），这里是直接指定接口的泛型，事实上，你也可以去添加类的泛型和接口一样，从而保留泛型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Interface_ {
    public static void main(String[] args) {
        SomeNumber num = new SomeNumber(&quot;数学&quot;, 10);
        System.out.println(num.start(&quot; 难&quot;));
        System.out.println(num.end(10));

    }
}

interface Number&amp;lt;K, V&amp;gt; {
    K start(K k);
    V end(V v);
}

//实现接口的时候，直接指定
class SomeNumber implements Number&amp;lt;String, Integer&amp;gt;{
    String name;
    Integer i;

    public SomeNumber(String name, Integer i) {
        this.name = name;
        this.i = i;
    }

    @Override
    public String start(String s) {
        return name + s;
    }

    @Override
    public Integer end(Integer integer) {
        return i + integer;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;自定义泛型方法&lt;/h3&gt;
&lt;h4&gt;基本语法&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;修饰符 &amp;lt;T, R ...&amp;gt;返回类型 方法名 (参数列表) {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;使用细节&lt;/h4&gt;
&lt;p&gt;1.泛型方法，可以定义在普通类中，也可以定义在泛型类中&lt;/p&gt;
&lt;p&gt;2.当泛型方法被调用的时候，类型会确定&lt;/p&gt;
&lt;p&gt;3.public void eat(E e) {}，修饰符后没有&amp;lt;T, R&amp;gt; eat不是泛型方法，只是使用了泛型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Function {
    public static void main(String[] args) {
        MyTool.printT(&quot;你好&quot;);
        MyTool.printT(23);
    }
}

class MyTool {
    public static&amp;lt;T&amp;gt; void printT(T t) {
        System.out.println(t);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;泛型的继承&lt;/h2&gt;
&lt;p&gt;1.泛型不具备继承性，不可以把创建的以子类泛型赋值给父类泛型修饰的类型&lt;/p&gt;
&lt;p&gt;2.&amp;lt;?&amp;gt;支持任意泛型类型&lt;/p&gt;
&lt;p&gt;3.&amp;lt;? extands A&amp;gt;支持A类以及A类的子类，规定了泛型的上限&lt;/p&gt;
&lt;p&gt;4.&amp;lt;? super A&amp;gt;支持A类以及A类的父类，不限于直接父类，规定了泛型的下限&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Function {
    public static void main(String[] args) {
        List&amp;lt;Object&amp;gt; list1 = new ArrayList&amp;lt;&amp;gt;();
        List&amp;lt;String&amp;gt; list2 = new ArrayList&amp;lt;&amp;gt;();
        List&amp;lt;AA&amp;gt; list3 = new ArrayList&amp;lt;&amp;gt;();
        List&amp;lt;BB&amp;gt; list4 = new ArrayList&amp;lt;&amp;gt;();
        List&amp;lt;CC&amp;gt; list5 = new ArrayList&amp;lt;&amp;gt;();
        printCollection1(list1);
        printCollection1(list2);
        printCollection1(list3);
        printCollection1(list4);
        printCollection1(list5);

        printCollection2(list1);//错误，上限是AA，Object是AA的父类
        printCollection2(list2);//错误，String和AA不存在继承关系
        printCollection2(list3);
        printCollection2(list4);
        printCollection2(list5);

        printCollection3(list1);
        printCollection3(list2);//错误，String和AA不存在继承关系
        printCollection3(list3);
        printCollection3(list4);
        printCollection3(list5);

    }

    public static void printCollection1(List&amp;lt;?&amp;gt; c) {
        for (Object obj : c) {
            System.out.println(obj);
        }
    }

    public static void printCollection2(List&amp;lt;? extends AA&amp;gt; c) {
        for (Object obj : c) {
            System.out.println(obj);
        }
    }

    public static void printCollection3(List&amp;lt;? super CC&amp;gt; c) {
        for (Object obj : c) {
            System.out.println(obj);
        }
    }
}

class AA {

}

class BB extends AA {

}

class CC extends BB {

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;泛型例题&lt;/h2&gt;
&lt;p&gt;创建一个泛型类，放入map&amp;lt;String, T&amp;gt;，实现相关方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com;
import org.junit.jupiter.api.Test;
import java.util.*;

public class Homework {
    public static void main(String[] args) {

    }

    @Test
    public void test1 () {
        User usr1 = new User(1, 18, &quot;lory&quot;);
        User usr2 = new User(2, 38, &quot;marry&quot;);
        User usr3 = new User(3, 28, &quot;jack&quot;);

        Dao&amp;lt;User&amp;gt; map = new Dao&amp;lt;&amp;gt;();
        map.save(&quot;100&quot;, usr1);
        map.save(&quot;200&quot;, usr3);
        map.save(&quot;300&quot;, usr2);
        System.out.println(map.get(&quot;200&quot;));
        List&amp;lt;User&amp;gt; list = map.list();
        for(User usr : list) {
            System.out.println(usr);
        }
    }
}

class Dao&amp;lt;T&amp;gt; {
    private Map&amp;lt;String, T&amp;gt; map = new HashMap&amp;lt;&amp;gt;();

    public void save(String id, T entity) {
        map.put(id, entity);
    }

    public T get(String id) {
        return map.get(id);
    }

    public List&amp;lt;T&amp;gt; list() {
        Set&amp;lt;Map.Entry&amp;lt;String, T&amp;gt;&amp;gt; entrySet = map.entrySet();
        Iterator&amp;lt;Map.Entry&amp;lt;String, T&amp;gt;&amp;gt; iterator = entrySet.iterator();
        ArrayList&amp;lt;T&amp;gt; target = new ArrayList&amp;lt;&amp;gt;();
        while (iterator.hasNext()) {
            Map.Entry&amp;lt;String, T&amp;gt; entry = iterator.next();
            target.add(entry.getValue());
        }
        return target;
    }

    public void delete(String id) {
        map.remove(id);
    }
}

class User {
    private int id;
    private int age;
    private String name;

    public User(int id, int age, String name) {
        this.id = id;
        this.age = age;
        this.name = name;
    }

    @Override
    public String toString() {
        return id + &quot; &quot; + age + &quot; &quot; + name;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;JUnit单元测试框架&lt;/h2&gt;
&lt;p&gt;在以往的测试中，我们需要手动的将编写的方法类实例化，在主方法中进行调用，这样做似乎有些复杂了，我们可以通过在需要测试的方法上添加@Test注解，并引入相关的包就可以单独运行方法，甚至支持Debug&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/93.png&quot; alt=&quot;93&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com;
import org.junit.jupiter.api.Test;

public class Junit {
    public static void main(String[] args) {

    }

    @Test
    public void m1() {
        System.out.println(&quot;m1&quot;);//m1
    }

    @Test
    public void m2() {
        System.out.println(&quot;m2&quot;);//m2
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实际使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.batis.junit;

public class Calculate {
    public int add(int a, int b) {
        return a + b;
    }
    public int sub(int a, int b) {
        return a - b;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过断言式进行判别&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class CalculateTest {
    @Test
    public void testAdd() {
        int actual = Calculate.add(1, 2);
        int expected = 3;
        Assert.assertEquals(expected, actual);
    }

    @Test
    public void testSub() {
        int actual = Calculate.sub(1, 2);
        int expected = -1;
        Assert.assertEquals(expected, actual);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果结果不一致抛出异常&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;java.lang.AssertionError: 
预期:-2
实际:-1
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Java笔记</title><link>https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E9%9B%86%E5%90%8802/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E9%9B%86%E5%90%8802/</guid><description>集合第二部分</description><pubDate>Wed, 02 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Java笔记&lt;/h1&gt;
&lt;h2&gt;Map接口&lt;/h2&gt;
&lt;h3&gt;定义及性质&lt;/h3&gt;
&lt;p&gt;双列集合&lt;/p&gt;
&lt;p&gt;存放的是K-V&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/91.png&quot; alt=&quot;91&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Map接口下有三个重要的类Hashtable ，HashMap ， TreeMap，其中HashMap时使用频率最高的&lt;/p&gt;
&lt;p&gt;1.Map与Collection并列存在，保存具有映射关系的数据，Key-Value&lt;/p&gt;
&lt;p&gt;2.Map中的key和value可以是任何引用类型的数据，会封装在HashMap$Node对象中&lt;/p&gt;
&lt;p&gt;3.Map中的key不允许重复，原因和HashSet一样&lt;/p&gt;
&lt;p&gt;4.Map中的key可以重复&lt;/p&gt;
&lt;p&gt;5.Map中的key和value可以为null，但是key中的null只能有一个，而value不做限制&lt;/p&gt;
&lt;p&gt;6.常用类String类可以作为Map的key&lt;/p&gt;
&lt;p&gt;7.key和value之间存在单向的一对一关系，即通过指定的key总可以找到对应的value&lt;/p&gt;
&lt;p&gt;8.map存放数据k-v，一对key-value是存放在HashMapNode中的&lt;/p&gt;
&lt;p&gt;为了程序员遍历方便，还会创建EntrySet集合，该集合放入的是Entry（事实上是将EntrySet中的table 存储的Entry节点指向Map的Node）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;transient Node&amp;lt;K,V&amp;gt;[] table;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;transient Set&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt; entrySet;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Map常用方法&lt;/h3&gt;
&lt;h4&gt;put&lt;/h4&gt;
&lt;p&gt;放入Map集合&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Map_ {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        Map map = new HashMap();
        map.put(12, &quot;lory&quot;);
        map.put(16, &quot;marry&quot;);
        map.put(10, &quot;jack&quot;);
        map.put(10, &quot;hello&quot;);
        System.out.println(map);
        //{16=marry, 10=hello, 12=lory}
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可见put当key重复的时候其实起的是替换的作用&lt;/p&gt;
&lt;p&gt;而value是可以重复的，只要key不一样即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Map_ {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        Map map = new HashMap();
        map.put(12, &quot;lory&quot;);
        map.put(16, &quot;marry&quot;);
        map.put(10, &quot;hello&quot;);
        map.put(13, &quot;hello&quot;);
        System.out.println(map.size());//4
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;get&lt;/h4&gt;
&lt;p&gt;通过key返回value&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Map_ {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        Map map = new HashMap();
        map.put(12, &quot;lory&quot;);
        map.put(16, &quot;marry&quot;);
        map.put(10, &quot;hello&quot;);
        map.put(13, &quot;hello&quot;);
        System.out.println(map.get(12));//lory
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;remove&lt;/h4&gt;
&lt;p&gt;根据key删除映射关系&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Map_ {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        Map map = new HashMap();
        map.put(12, &quot;lory&quot;);
        map.put(16, &quot;marry&quot;);
        map.put(10, &quot;hello&quot;);
        map.remove(16);
        System.out.println(map);
        //{10=hello, 12=lory}
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;size&lt;/h4&gt;
&lt;p&gt;获取元素个数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Map_ {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        Map map = new HashMap();
        map.put(12, &quot;lory&quot;);
        map.put(16, &quot;marry&quot;);
        map.put(10, &quot;hello&quot;);
        System.out.println(map.size());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;isEmpty&lt;/h4&gt;
&lt;p&gt;判断元素个数是否为0&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Map_ {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        Map map = new HashMap();
        map.put(12, &quot;lory&quot;);
        map.put(16, &quot;marry&quot;);
        map.put(10, &quot;hello&quot;);
        System.out.println(map.isEmpty());//false
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;clear&lt;/h4&gt;
&lt;p&gt;清除所有元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Map_ {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        Map map = new HashMap();
        map.put(12, &quot;lory&quot;);
        map.put(16, &quot;marry&quot;);
        map.put(10, &quot;hello&quot;);
        map.clear();
        System.out.println(map.isEmpty());//true
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;containsKey&lt;/h4&gt;
&lt;p&gt;查找键是否存在&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Map_ {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        Map map = new HashMap();
        map.put(12, &quot;lory&quot;);
        map.put(16, &quot;marry&quot;);
        map.put(10, &quot;hello&quot;);
        System.out.println(map.containsKey(10));//true
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Map接口的遍历方式&lt;/h3&gt;
&lt;p&gt;总共有六种方式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Set&amp;lt;K&amp;gt; keySet();
Collection&amp;lt;V&amp;gt; values();
Set&amp;lt;Map.Entry&amp;lt;K, V&amp;gt;&amp;gt; entrySet();
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;keySet&lt;/h4&gt;
&lt;p&gt;1、2、通过取出Key的Set集合，遍历Set集合中的Key，还可以通过Key取出Map中的Value&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Map_ {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        Map map = new HashMap();
        map.put(12, &quot;lory&quot;);
        map.put(16, &quot;marry&quot;);
        map.put(10, &quot;hello&quot;);
        Set keySet = map.keySet();
        for (Object key : keySet) {
            System.out.println(key + &quot;: &quot; + map.get(key));
        }
        Iterator iterator = keySet.iterator();
        while (iterator.hasNext()) {
            Object key = iterator.next();
            System.out.println(key + &quot;: &quot; + map.get(key));
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;values&lt;/h4&gt;
&lt;p&gt;3、4、取出Values，进行遍历（用接口Collection接收）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Map_ {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        Map map = new HashMap();
        map.put(12, &quot;lory&quot;);
        map.put(16, &quot;marry&quot;);
        map.put(10, &quot;hello&quot;);
        Collection values = map.values();
        for(Object obj : values) {
            System.out.print(obj + &quot; &quot;);
        }

        Iterator iterator = values.iterator();
        while(iterator.hasNext()) {
            Object obj = iterator.next();
            System.out.print(obj + &quot; &quot;);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;entrySet&lt;/h4&gt;
&lt;p&gt;5、6、通过取出Entry的Set集合，将entry（Object）转为Map.Entry，再通过Map.Entry实现的getKey和getValue方法取出Map中的KV&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Map_ {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        Map map = new HashMap();
        map.put(12, &quot;lory&quot;);
        map.put(16, &quot;marry&quot;);
        map.put(10, &quot;hello&quot;);
        Set entrySet = map.entrySet();
        for(Object o : entrySet) {
            Map.Entry entry = (Map.Entry) o;
            System.out.println(entry.getKey() + &quot; &quot; + entry.getValue());
        }

        Iterator iterator = entrySet.iterator();
        while(iterator.hasNext()) {
            Object o = iterator.next();
            Map.Entry entry = (Map.Entry) o;
            System.out.println(entry.getKey() + &quot; &quot; + entry.getValue());
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;综合案例&lt;/h4&gt;
&lt;p&gt;输出集合中工资大于18000的键值以及对应老师toString方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Map_ {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        Map map = new HashMap();
        map.put(12, new Teacher(&quot;lory&quot;, 22, 12000 ));
        map.put(16, new Teacher(&quot;marry&quot;, 44, 13000));
        map.put(13, new Teacher(&quot;jack&quot;, 55, 19000));
        Set entrySet = map.entrySet();
        for (Object obj : entrySet) {
            Map.Entry entry = (Map.Entry) obj;
            Teacher teacher = (Teacher) entry.getValue();
            if(teacher.salary &amp;gt; 18000) {
                System.out.println(entry.getKey() + &quot; &quot; + entry.getValue());
            }
        }
    }
}

class Teacher {
    String name;
    int age;
    double salary;

    public Teacher(String name, int age, double salary) {
        this.name = name;
        this.age = age;
        this.salary = salary;
    }

    @Override
    public String toString() {
        return &quot;教师 &quot; + name + &quot; &quot; +
                &quot;今年 &quot; + age + &quot; 岁&quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Map的实现子类&lt;/h2&gt;
&lt;h3&gt;HashMap&lt;/h3&gt;
&lt;p&gt;1.Map接口的常用实现类是HashMap，Hashtable，Properties&lt;/p&gt;
&lt;p&gt;2.其中HashMap是Map接口中使用频率最高的实现类&lt;/p&gt;
&lt;p&gt;3.通过key-value的方式存储数据&lt;/p&gt;
&lt;p&gt;4.和HashSet一样，不保证映射的顺序，因为底层是由hash表的方式来存储的&lt;/p&gt;
&lt;p&gt;5.HashMap没有实现线程同步，因此线程不安全&lt;/p&gt;
&lt;p&gt;HashMap扩容上而言和HashSet一模一样，扩容因子是0.75扩容为原来的两倍，默认初始化为16&lt;/p&gt;
&lt;h3&gt;Hashtable&lt;/h3&gt;
&lt;p&gt;1.放入的元素为键值对Key-Value&lt;/p&gt;
&lt;p&gt;2.Hashtable的键和值都不能为null（否则会派出NullPointException）&lt;/p&gt;
&lt;p&gt;3.Hashtable的使用和HashMap基本相同&lt;/p&gt;
&lt;p&gt;4.Hashtable是线程安全的，而HashMap不是线程安全的&lt;/p&gt;
&lt;h3&gt;HashMap与Hashtable对比&lt;/h3&gt;
&lt;p&gt;HashMap线程不安全而Hashtable安全&lt;/p&gt;
&lt;p&gt;HashMap效率优于Hashtable&lt;/p&gt;
&lt;p&gt;Hashtable不允许null键值和null数据&lt;/p&gt;
&lt;h3&gt;Properties&lt;/h3&gt;
&lt;p&gt;1.Properties类继承于Hashtable并且实现了Map接口，是一种键值对的形式保存数据&lt;/p&gt;
&lt;p&gt;2.使用方式和Hashtable类似&lt;/p&gt;
&lt;p&gt;3.Properties还可以用于从xxx.properites文件中，加载数据带Properties类对象，并进行读取和修改（广泛用于从配置文件中读取账号和密码，避免硬编码）&lt;/p&gt;
&lt;p&gt;4.xxx.properites文件通常作为配置文件，在后续的IO流会介绍&lt;/p&gt;
&lt;p&gt;代码示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Properties_ {
    public static void main(String[] args) {
        Properties properties = new Properties();
        properties.put(18, &quot;lory&quot;);
        properties.put(19, &quot;marry&quot;);
        properties.put(20, &quot;jack&quot;);
        System.out.println(properties.get(18));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;LinkedHashMap&lt;/h3&gt;
&lt;p&gt;和LinkedHashSet与HashSet的关系类似&lt;/p&gt;
&lt;p&gt;是HashMap的有序排列（通过双向链表维护）&lt;/p&gt;
&lt;h3&gt;TreeMap&lt;/h3&gt;
&lt;p&gt;直接实现Map接口&lt;/p&gt;
&lt;p&gt;保证插入时的键有序（通过传入一个Comparator接口比较器）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class TreeMap01 {
    public static void main(String[] args) {
        TreeMap treeMap = new TreeMap(new Comparator() {
            public int compare(Object o1, Object o2) {
                int i1 = (Integer)o1;
                int i2 = (Integer)o2;
                return i1 - i2;
            }
        });
        treeMap.put(1, &quot;Tom&quot;);
        treeMap.put(3, &quot;Marry&quot;);
        treeMap.put(4, &quot;Lory&quot;);
        treeMap.put(2, &quot;Thrinisty&quot;);
        System.out.println(treeMap);
        //{1=Tom, 2=Thrinisty, 3=Marry, 4=Lory}
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Collections工具类&lt;/h2&gt;
&lt;h3&gt;定义&lt;/h3&gt;
&lt;p&gt;1.Collections是一个操作Set，List，Map集合的工具类&lt;/p&gt;
&lt;p&gt;2.提供了一系列的静态方法对集合元素进行排序，查询，修改等操作&lt;/p&gt;
&lt;h3&gt;常用的工具类&lt;/h3&gt;
&lt;h4&gt;reverse（List）&lt;/h4&gt;
&lt;p&gt;将List中的元素顺序反转&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class List01 {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;A&quot;);
        list.add(10);
        list.add(true);
        list.add(&quot;B&quot;);
        list.add(&quot;C&quot;);
        Collections.reverse(list);
        System.out.println(list);
        //[C, B, true, 10, A]
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;shuffle（List）&lt;/h4&gt;
&lt;p&gt;将List中的元素随机排序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class List01 {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;A&quot;);
        list.add(10);
        list.add(true);
        list.add(&quot;B&quot;);
        list.add(&quot;C&quot;);
        Collections.shuffle(list);
        System.out.println(list);
        //[B, true, C, 10, A]
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;sort（List，Comparator）&lt;/h4&gt;
&lt;p&gt;将List中的元素按照指定功能排序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class List01 {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;A&quot;);
        list.add(&quot;BFXC&quot;);
        list.add(&quot;DVB&quot;);
        list.add(&quot;B&quot;);
        list.add(&quot;C&quot;);
        Collections.sort(list, new Comparator() {
            public int compare(Object o1, Object o2) {
                String s1 = (String)o1;
                String s2 = (String)o2;
                return s1.compareTo(s2);
            }
        });
        System.out.println(list);
        //[A, B, BFXC, C, DVB]
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;swap（List，int， int）&lt;/h4&gt;
&lt;p&gt;交换List中的两个对应下标中的元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class List01 {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;A&quot;);
        list.add(&quot;BFXC&quot;);
        list.add(&quot;DVB&quot;);
        list.add(&quot;B&quot;);
        list.add(&quot;C&quot;);
        Collections.swap(list, 3, 2);
        System.out.println(list);
        //[A, BFXC, B, DVB, C]
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;max（Collection，Comparator）&lt;/h4&gt;
&lt;p&gt;按照指定顺序返回最大元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class List01 {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;A&quot;);
        list.add(&quot;BFXC&quot;);
        list.add(&quot;DVB&quot;);
        list.add(&quot;B&quot;);
        list.add(&quot;C&quot;);
        System.out.println(Collections.max(list, new Comparator() {
            public int compare(Object o1, Object o2) {
                String s1 = (String) o1;
                String s2 = (String) o2;
                return s1.length() - s2.length();
            }
        }));
        //BFXC
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;frequency（Collection， Object）&lt;/h4&gt;
&lt;p&gt;返回指定集合中指定元素出现的次数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class List01 {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;A&quot;);
        list.add(&quot;BFXC&quot;);
        list.add(&quot;DVB&quot;);
        list.add(&quot;A&quot;);
        list.add(&quot;A&quot;);
        System.out.println(Collections.frequency(list, &quot;A&quot;));
        //3
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;copy（List dest，List src）&lt;/h4&gt;
&lt;p&gt;将src的内容复制到dest中&lt;/p&gt;
&lt;p&gt;要求新的集合大小大于旧的，否则或抛出异常&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class List01 {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;A&quot;);
        list.add(&quot;BFXC&quot;);
        list.add(&quot;DVB&quot;);
        List list1 = new ArrayList();
        list1.add(&quot; &quot;);
        list1.add(&quot; &quot;);
        list1.add(&quot; &quot;);
        Collections.copy(list1, list);
        System.out.println(list1);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如下这种方式也不行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class List01 {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;A&quot;);
        list.add(&quot;BFXC&quot;);
        list.add(&quot;DVB&quot;);
        List list1 = new ArrayList(4);
        list1.add(&quot; &quot;);
        Collections.copy(list1, list);
        System.out.println(list1);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;new ArrayList(4)&lt;/code&gt; 只是设置初始容量（&lt;code&gt;capacity&lt;/code&gt;），但 &lt;code&gt;size()&lt;/code&gt; 仍然是 0。&lt;/p&gt;
&lt;p&gt;调用 &lt;code&gt;list1.add(&quot; &quot;)&lt;/code&gt; 后，&lt;code&gt;list1.size()&lt;/code&gt; 变为 1，但 &lt;code&gt;list.size()&lt;/code&gt; 是 3。&lt;/p&gt;
&lt;p&gt;目标列表 &lt;code&gt;list1&lt;/code&gt; 的长度（1） &amp;lt; 源列表 &lt;code&gt;list&lt;/code&gt; 的长度（3），不满足 &lt;code&gt;copy()&lt;/code&gt; 的条件。&lt;/p&gt;
&lt;h4&gt;replaceAll（List list， Object oldVal， Object newVal）&lt;/h4&gt;
&lt;p&gt;使用新值替换所有旧值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class List01 {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;A&quot;);
        list.add(&quot;BFXC&quot;);
        list.add(&quot;A&quot;);
        list.add(&quot;A&quot;);
        Collections.replaceAll(list, &quot;A&quot;, &quot;B&quot;);
        System.out.println(list);//[B, BFXC, B, B]
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;简答题&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;../images/92.png&quot; alt=&quot;92&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>自学第一月份总结</title><link>https://thrinisty.github.io/posts/%E8%87%AA%E5%AD%A6%E7%AC%AC%E4%B8%80%E6%9C%88%E4%BB%BD%E6%80%BB%E7%BB%93/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/%E8%87%AA%E5%AD%A6%E7%AC%AC%E4%B8%80%E6%9C%88%E4%BB%BD%E6%80%BB%E7%BB%93/</guid><description>收获多多</description><pubDate>Tue, 01 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;自学第一月份总结&lt;/h1&gt;
&lt;p&gt;​	还是过的挺快的，从三月初决定不再考研开始，我投入了大量的时间去巩固Java的基础，也刷了很少的一部分面试算法题目，回顾了一些来自于之前课堂上的知识，例如操作系统，计算机网络等。&lt;/p&gt;
&lt;p&gt;​	也是在这一个月中很幸运的收到了来自第一份正式的面试邀约，无论结果如何，都对我是一次很好的锻炼机会吧。我也明白，虽然自身能力目前还达不到找到工作的水准，但是我知道自己也是在不断地向前走的，回过来看一看我自己，相比刚来到大学的时候的青涩，不敢勇于表达而言，我在面试中可以较为完整的表达出来自自己的一些观点，有着自己的一些思考，算是不错的进步了。&lt;/p&gt;
&lt;p&gt;​	从计划而言，原先的Java30天速成的计划可能得向后延期了，因为我发现，除了我原先想的知识以外，还有很多实用的Java外知识等着我去学习，如MySQL数据库，SQL注入，JDBC，正规式等要学完这一些，得再加上15天的时间，哎，总之继续努力吧。&lt;/p&gt;
&lt;p&gt;​	在课余上，买了把吉他，天天都会把自己折磨的有点手疼，进步也是蛮快的，15天左右了，练了些基础上的内容，拿着变调夹也可以弹一些简单的安河桥之类的，晴天前奏（学会扫弦还不大可能）&lt;/p&gt;
&lt;p&gt;​	感觉还是非常充实的一个月，收获很大，也有按时吃早餐，但是早睡是不可能的，最起码得留点时间给辛苦一天自己玩。&lt;/p&gt;
</content:encoded></item><item><title>Java笔记</title><link>https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E9%9B%86%E5%90%8801/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E9%9B%86%E5%90%8801/</guid><description>集合第一部分</description><pubDate>Tue, 01 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Java笔记&lt;/h1&gt;
&lt;h2&gt;集合&lt;/h2&gt;
&lt;h3&gt;集合框架体系&lt;/h3&gt;
&lt;p&gt;（要求记忆）&lt;/p&gt;
&lt;p&gt;单列集合&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/90.png&quot; alt=&quot;90&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Collection下有两大重要的接口一个List另一个为Set&lt;/p&gt;
&lt;p&gt;双列集合&lt;/p&gt;
&lt;p&gt;存放的是K-V&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/91.png&quot; alt=&quot;91&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Map接口下有三个重要的类Hashtable ，HashMap ， TreeMap&lt;/p&gt;
&lt;p&gt;两个集合不同区别，存放数据的个数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Collection_ {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        //单列集合
        ArrayList arrayList = new ArrayList();
        arrayList.add(&quot;A&quot;);
        arrayList.add(&quot;B&quot;);
        arrayList.add(&quot;C&quot;);
	    //双列集合
        HashMap hashMap = new HashMap();
        hashMap.put(&quot;1&quot;, &quot;北京&quot;);
        hashMap.put(&quot;2&quot;, &quot;北京&quot;);
        hashMap.put(&quot;3&quot;, &quot;北京&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;产生原因&lt;/h3&gt;
&lt;p&gt;为什么要学习集合，是因为数组的灵活性不够&lt;/p&gt;
&lt;p&gt;数组的不足：&lt;/p&gt;
&lt;p&gt;1.数组长度没有办法扩容&lt;/p&gt;
&lt;p&gt;2.保存的数据使用一类型（虽然可以使用多态）&lt;/p&gt;
&lt;p&gt;3.使用数组进行增加和删除的时候比较麻烦（要创建新的数组依次拷贝）&lt;/p&gt;
&lt;p&gt;而集合上而言&lt;/p&gt;
&lt;p&gt;1.它可以动态保存任意多个对象，使用方便&lt;/p&gt;
&lt;p&gt;2.提供了一系列方便的操作对象的方法实现增删改查&lt;/p&gt;
&lt;p&gt;3.使用了集合添加元素简单明了&lt;/p&gt;
&lt;h2&gt;Collection接口&lt;/h2&gt;
&lt;p&gt;单列集合&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/90.png&quot; alt=&quot;90&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Collection下有两大重要的接口一个List另一个为Set&lt;/p&gt;
&lt;h3&gt;接口特点&lt;/h3&gt;
&lt;p&gt;1.Collection实现子类可以存放多个元素，每个元素可以是Object（多态）&lt;/p&gt;
&lt;p&gt;2.有的Collection接口的实现类可以放重复元素（List，Queue），而有的不可以放重复元素（Set）&lt;/p&gt;
&lt;p&gt;3.Collection的实现类中，有的保持插入顺序（List），有的不保证顺序（如 HashSet），还有的会自动排序（如 TreeSet PriorityQueue）&lt;/p&gt;
&lt;p&gt;4.Collection接口没有直接实现的子类，而是通过子接口Set和List来实现&lt;/p&gt;
&lt;h3&gt;Collection中常用的方法&lt;/h3&gt;
&lt;p&gt;以ArrayList演示&lt;/p&gt;
&lt;h4&gt;add添加元素&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class Collection_ {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;A&quot;);
        list.add(10);//在放整数的过程中会装入包装类
        list.add(true);//在放boolean的过程中会装入包装类
        System.out.println(list);//[A, 10, true]
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;remove删除元素&lt;/h4&gt;
&lt;p&gt;传入元素&lt;/p&gt;
&lt;p&gt;List中删除数字类型的元素得创建包装类去删除，否则会删除对应下标的元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Collection_ {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;A&quot;);
        list.add(10);//在放整数的过程中会装入包装类
        list.add(true);//在放boolean的过程中会装入包装类

        list.remove(2);//删除true通过下标删除
        list.remove(new Integer(10));
        System.out.println(list);//[A]
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;contains存在性&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class Collection_ {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;A&quot;);
        list.add(10);//在放整数的过程中会装入包装类
        list.add(true);//在放boolean的过程中会装入包装类

        System.out.println(list.contains(15));//false
        //System.out.println(list);//[A]
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;size获取元素个数&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class Collection_ {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;A&quot;);
        list.add(10);//在放整数的过程中会装入包装类
        list.add(true);//在放boolean的过程中会装入包装类
        System.out.println(list.size());//3
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;isEmpty判断是否为空&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class Collection_ {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;A&quot;);
        list.add(10);//在放整数的过程中会装入包装类
        list.add(true);//在放boolean的过程中会装入包装类
        System.out.println(list.isEmpty());//false
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;clear清空集合&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class Collection_ {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;A&quot;);
        list.add(10);//在放整数的过程中会装入包装类
        list.add(true);//在放boolean的过程中会装入包装类
        list.clear();
        list.add(&quot;B&quot;);
        System.out.println(list);//[B]
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;addAll添加多个元素&lt;/h4&gt;
&lt;p&gt;可以传入集合&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Collection_ {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;A&quot;);
        list.add(10);//在放整数的过程中会装入包装类
        list.add(true);//在放boolean的过程中会装入包装类

        List list2 = new ArrayList();
        list2.add(&quot;B&quot;);
        list2.add(&quot;C&quot;);

        list.addAll(list2);
        System.out.println(list);//[A, 10, true, B, C]
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;removeAll删除多个元素&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class Collection_ {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;A&quot;);
        list.add(10);//在放整数的过程中会装入包装类
        list.add(true);//在放boolean的过程中会装入包装类

        List list2 = new ArrayList();
        list2.add(&quot;A&quot;);
        list2.add(10);

        list.removeAll(list2);
        System.out.println(list);//[true]
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Collection遍历方式&lt;/h2&gt;
&lt;h3&gt;迭代器&lt;/h3&gt;
&lt;p&gt;Iterator对象，可以用它进行元素遍历，而Collection接口实现了Iterator，所以只要是实现了Collection接口的子类都可以获取一个迭代器Iterator() 遍历元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface Iterator&amp;lt;E&amp;gt; {
    boolean hasNext();
    E next();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;next用于返回元素然后下移，而hasNext方法要求实现有下一个元素返回true，在子类的实现中应该在next前加上hasNext的判断条件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Collection_ {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;A&quot;);
        list.add(10);
        list.add(true);

        Iterator it = list.iterator();//获取迭代器
        while (it.hasNext()) {
            Object next = it.next();
            System.out.print(next + &quot; &quot;);//A 10 true
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在IDEA中可以使用 itit 模板补全迭代器while循环&lt;/p&gt;
&lt;p&gt;当我们需要再次遍历的时候我们需要重置迭代器(将指针指向开头)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Iterator it = list.iterator();//获取迭代器
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;增强for循环&lt;/h3&gt;
&lt;p&gt;底层是迭代器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Collection_ {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;A&quot;);
        list.add(10);
        list.add(true);
        for (Object o : list) {
            System.out.print(o + &quot; &quot;);//A 10 true 
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;调试步骤&lt;/p&gt;
&lt;p&gt;用IDEA就可以使用快捷补全 大写的 I&lt;/p&gt;
&lt;p&gt;1.先获取迭代器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public Iterator&amp;lt;E&amp;gt; iterator() {
    return new Itr();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.判断有下一个元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public boolean hasNext() {
    return cursor != size;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.获取并指向下一个&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public E next() {
    checkForComodification();
    int i = cursor;
    if (i &amp;gt;= size)
        throw new NoSuchElementException();
    Object[] elementData = ArrayList.this.elementData;
    if (i &amp;gt;= elementData.length)
        throw new ConcurrentModificationException();
    cursor = i + 1;
    return (E) elementData[lastRet = i];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以在数组上使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Collection_ {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        int[] array = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        for(int o : array) {
            System.out.print(o + &quot; &quot;);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;List接口&lt;/h2&gt;
&lt;h3&gt;List接口特点&lt;/h3&gt;
&lt;p&gt;Set接口的子类（HashSet，TreeSet）无法使用这些方法&lt;/p&gt;
&lt;p&gt;而List接口子类Vector， ArrayList ， LinkedList可以使用List接口方法&lt;/p&gt;
&lt;p&gt;List集合中的元素有序（添加和取出顺序一致），元素可以重复，支持索引获取&lt;/p&gt;
&lt;h3&gt;常用方法&lt;/h3&gt;
&lt;h4&gt;get获取元素&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class List01 {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;jack&quot;);
        list.add(&quot;tom&quot;);
        list.add(&quot;marry&quot;);
        list.add(&quot;lory&quot;);
        list.add(&quot;jack&quot;);
        System.out.println(list);
        //[jack, tom, marry, lory, jack]
        System.out.println(list.get(3));//lory
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;add插入元素&lt;/h4&gt;
&lt;p&gt;默认插入到元素末尾，可以添加索引指定插入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class List01 {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;jack&quot;);
        list.add(&quot;tom&quot;);
        list.add(&quot;marry&quot;);
        list.add(&quot;lory&quot;);
        list.add(&quot;jack&quot;);
        System.out.println(list);
        //[jack, tom, marry, lory, jack]
        list.add(2, &quot;funny&quot;);
        System.out.println(list);
        //[jack, tom, funny, marry, lory, jack]
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;addAll插入集合&lt;/h4&gt;
&lt;p&gt;默认插入集合尾部&lt;/p&gt;
&lt;p&gt;传入索引 加 集合，可以在指定位置插入多个元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class List01 {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;jack&quot;);
        list.add(&quot;tom&quot;);
        list.add(&quot;marry&quot;);
        list.add(&quot;lory&quot;);

        List list1 = new ArrayList();
        list1.add(&quot;杰克&quot;);
        list1.add(&quot;杰瑞&quot;);

        list.addAll(1, list1);
        System.out.println(list);
        [jack, 杰克, 杰瑞, tom, marry, lory]
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;index Of与 lastIndexOf 和数组类似&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class List01 {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;jack&quot;);
        list.add(&quot;tom&quot;);
        list.add(&quot;marry&quot;);
        list.add(&quot;lory&quot;);

        System.out.println(list.indexOf(&quot;jack&quot;));//0
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;set 替换元素&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class List01 {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;jack&quot;);
        list.add(&quot;tom&quot;);
        list.add(&quot;marry&quot;);
        list.add(&quot;lory&quot;);
        list.set(0, &quot;tom&quot;);
        System.out.println(list);
        //[tom, tom, marry, lory]
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;subList 返回子集合&lt;/h4&gt;
&lt;p&gt;左闭右包&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class List01 {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;jack&quot;);
        list.add(&quot;tom&quot;);
        list.add(&quot;marry&quot;);
        list.add(&quot;lory&quot;);
        list.set(0, &quot;tom&quot;);
        System.out.println(list.subList(1, 3));
        //[tom, marry]
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;除了迭代器遍历，增强for循环，ArrayList由于底层是数组实现，我们还可以通过普通的for循环遍历&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class List01 {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;jack&quot;);
        list.add(&quot;tom&quot;);
        list.add(&quot;marry&quot;);
        list.add(&quot;lory&quot;);
        list.set(0, &quot;tom&quot;);
        for(int i = 0; i &amp;lt; list.size(); i++) {
            Object o = list.get(i);
            System.out.println(o);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例题（按年龄集合排序）&lt;/p&gt;
&lt;p&gt;我自己做的时候是将集合转为数组，用数组自定义排序，再放回集合，但是有些复杂了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.*;

public class Collection_ {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        ArrayList list = new ArrayList();
        list.add(new Dog(&quot;旺财&quot;, 19));
        list.add(new Dog(&quot;来福&quot;, 12));
        list.add(new Dog(&quot;小黑&quot;, 13));
        list = sortList(list);
        System.out.println(list);
    }

    public static List sortList(List list) {
        Dog[] array = new Dog[list.size()];
        for (int i = 0; i &amp;lt; list.size(); i++) {
            Dog d = (Dog)list.get(i);
            array[i] = d;
        }

        Arrays.sort(array, new Comparator() {
            public int compare(Object o1, Object o2) {
                Dog d1 = (Dog)o1;
                Dog d2 = (Dog)o2;
                return d1.age - d2.age;
            }
        });

        list.clear();
        for (int i = 0; i &amp;lt; array.length; i++) {
            list.add(array[i]);
        }
        return list;
    }
}

class Dog {
    String name;
    int age;

    Dog(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return &quot; Dog &quot; + name + &quot; are &quot; + age;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以使用标准的冒泡排序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void sortList(List list) {
    int size = list.size();
    for (int i = 0; i &amp;lt; size - 1; i++) {
        for (int j = 0; j &amp;lt; size - i - 1; j++) {
            Dog dog1 = (Dog) list.get(j);
            Dog dog2 = (Dog) list.get(j + 1);
            if(dog1.age &amp;gt; dog2.age) {
                list.set(j, dog2);
                list.set(j + 1, dog1);                }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为都是List的子类，所以方法可以传入Vector ArrayList LinkedList&lt;/p&gt;
&lt;h2&gt;List子类&lt;/h2&gt;
&lt;h3&gt;ArrayList使用注意事项&lt;/h3&gt;
&lt;p&gt;1.ArrayList中可以放入null，而且是多个&lt;/p&gt;
&lt;p&gt;2.ArrayList是由数组来实现数据存储的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;transient Object[] elementData;
private int size
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.ArrayList基本上等同于Vector，除了ArrayList是线程不安全的（但是执行效率高）&lt;/p&gt;
&lt;p&gt;它的方法没有synchronized关键字&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public boolean add(E e) {
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    elementData[size++] = e;
    return true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而Vector是有的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public synchronized boolean add(E e) {
    modCount++;
    ensureCapacityHelper(elementCount + 1);
    elementData[elementCount++] = e;
    return true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;ArrayList的底层机制&lt;/h3&gt;
&lt;h4&gt;扩容流程&lt;/h4&gt;
&lt;p&gt;1.ArrayList中维护了一个Object类型的数组elementData&lt;/p&gt;
&lt;p&gt;其中transient（短暂的），表示该属性不会被序列化&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;transient Object[] elementData;
private int size
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.当创建ArrayList对象的时候，如果使用的是无参构造器，则出事的elementData容量为0，当第一次添加的时候，扩容10，再次扩容扩容原来的1.5倍&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public ArrayList() {
    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    //这是个空数组
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.如果是使用指定大小的构造器，则初始elementData容量为指定大小，扩容扩容原来的1.5倍&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public ArrayList(int initialCapacity) {
    if (initialCapacity &amp;gt; 0) {
        this.elementData = new Object[initialCapacity];
    } else if (initialCapacity == 0) {
        this.elementData = EMPTY_ELEMENTDATA;
    } else {
        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+
                                           initialCapacity);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;底层扩容机制&lt;/h4&gt;
&lt;p&gt;建议自己去Debug追一下&lt;/p&gt;
&lt;p&gt;当添加的时候会调用ensureCapacityInternal&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public boolean add(E e) {
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    elementData[size++] = e;
    return true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;private void ensureExplicitCapacity(int minCapacity) {
    modCount++;

    // 当容量不够的时候才调用grow
    if (minCapacity - elementData.length &amp;gt; 0)
        grow(minCapacity);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;底层判断容量不够时扩容的方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private void grow(int minCapacity) {
    int oldCapacity = elementData.length;
    int newCapacity = oldCapacity + (oldCapacity &amp;gt;&amp;gt; 1);
    //这里就是1.5被扩容
    if (newCapacity - minCapacity &amp;lt; 0)
        newCapacity = minCapacity;
    //如果是为0，就会赋初值10
    if (newCapacity - MAX_ARRAY_SIZE &amp;gt; 0)
        newCapacity = hugeCapacity(minCapacity);
    elementData = Arrays.copyOf(elementData, newCapacity);
    //将调用Arrays进行赋值
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Vector使用注意事项&lt;/h3&gt;
&lt;p&gt;1.定义继承于AbstractList抽象类，实现了 List&amp;lt;E&amp;gt;, RandomAccess, Cloneable接口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Vector&amp;lt;E&amp;gt;
    extends AbstractList&amp;lt;E&amp;gt;
    implements List&amp;lt;E&amp;gt;, RandomAccess, Cloneable, java.io.Serializable
{
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.底层也是维护了一个对象数组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;protected Object[] elementData;
protected int elementCount;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.Vector是线程同步的，操作的方法带有synchronized，所以在多线程并发的时候需要使用Vector而不是ArrayList，除非只有一个线程来操作该数据，可以使用ArrayList提高效率（不需要进行线程安全的检查）&lt;/p&gt;
&lt;h3&gt;Vector的扩容机制&lt;/h3&gt;
&lt;p&gt;这里不再过多的重复，大体跟ArrayList类似，只是后续扩容更改为两倍扩容&lt;/p&gt;
&lt;h3&gt;LinkedList使用注意事项&lt;/h3&gt;
&lt;p&gt;1.LinkedList底层实现了双向链表和双端队列特点&lt;/p&gt;
&lt;p&gt;2.可以添加任意元素（元素可以重复）包括null&lt;/p&gt;
&lt;p&gt;3.线程不安全，没有实现同步&lt;/p&gt;
&lt;h3&gt;双端队列补充知识&lt;/h3&gt;
&lt;p&gt;双端队列(Deque, Double Ended Queue)允许在队列的两端进行插入和删除操作，这为&lt;code&gt;LinkedList&lt;/code&gt;带来了以下优势&lt;/p&gt;
&lt;h3&gt;两端操作能力&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;头部操作&lt;/strong&gt;：可以在列表开头高效地添加/删除元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;list.addFirst(e);  // 或 offerFirst(e)
list.removeFirst(); // 或 pollFirst()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;尾部操作&lt;/strong&gt;：可以在列表末尾高效地添加/删除元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;list.addLast(e);  // 或 offerLast(e)
list.removeLast(); // 或 pollLast()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;实现多种数据结构&lt;/h3&gt;
&lt;p&gt;利用双端队列特性，&lt;code&gt;LinkedList&lt;/code&gt;可以轻松模拟：&lt;/p&gt;
&lt;p&gt;栈(Stack)：后进先出(LIFO)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Deque&amp;lt;String&amp;gt; stack = new LinkedList&amp;lt;&amp;gt;();
stack.push(&quot;A&quot;); // 压栈
stack.pop();     // 弹栈
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;队列(Queue)：先进先出(FIFO)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Queue&amp;lt;String&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;();
queue.offer(&quot;A&quot;); // 入队
queue.poll();     // 出队
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;学过数据结构的可以直接跳过这一个部分&lt;/p&gt;
&lt;p&gt;可以直接去构造这么一个链表节点，实现一些方法去输出链表，添加节点，删除节点等&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Node {
    public Node next;
    public Node prev;
    public Object item;

    public Node(Object item) {
        this.item = item;
    }

    public void addNode(Node newNode) {
        this.next = newNode;
        newNode.prev = this;
    }

    public void printNode() {
        Node Point = this;
        while(Point != null) {
            System.out.println(Point.item);
            Point = Point.next;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;底层源码中我们在添加的时候会创建新的链表结点，然后运用前后引用连接&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public boolean add(E e) {
    linkLast(e);
    return true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;void linkLast(E e) {
    final Node&amp;lt;E&amp;gt; l = last;
    final Node&amp;lt;E&amp;gt; newNode = new Node&amp;lt;&amp;gt;(l, e, null);
    last = newNode;
    if (l == null)
        first = newNode;
    else
        l.next = newNode;
    size++;
    modCount++;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;LinkedList和ArrayList的比较&lt;/h3&gt;
&lt;p&gt;1.在维护的数据结构上而言，前者是双向链表，而后者是数组&lt;/p&gt;
&lt;p&gt;2.在增删的效率上而言LinkedList高于ArrayList&lt;/p&gt;
&lt;p&gt;3.在改查的效率上而言LinkedList低于于ArrayList&lt;/p&gt;
&lt;p&gt;结论：在一般的情况下程序中80%-90%的操作都是查询，大多数选的是ArrayList，也可以根据需要使用LinkedList&lt;/p&gt;
&lt;h2&gt;Set接口&lt;/h2&gt;
&lt;h3&gt;set接口特点&lt;/h3&gt;
&lt;p&gt;1.无序（添加和取出的顺序不一致），没有索引，无法通过索引来操作&lt;/p&gt;
&lt;p&gt;2.不允许重复元素，最多包含有一个null&lt;/p&gt;
&lt;p&gt;3.Set接口类常用的有两个TreeSet，HashSet&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class SetMethod {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        Set set = new HashSet();
        set.add(&quot;hello&quot;);
        set.add(&quot;world&quot;);
        set.add(&quot;hello&quot;);
        set.add(&quot;world&quot;);
        set.add(null);
        System.out.println(set);//[null, world, hello]
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里看到虽然加入了两个hello world，但是只存放了一个，而且输出的顺序和放入的不一致（但是输出的顺序是同一个不会因为再次输出而改变）&lt;/p&gt;
&lt;p&gt;可以通过两种方式遍历（迭代器和增强for循环）&lt;/p&gt;
&lt;p&gt;但是不可以使用for循环，因为没有办法使用get用索引找到对应元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class SetMethod {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        Set set = new HashSet();
        set.add(&quot;hello&quot;);
        set.add(&quot;world&quot;);
        set.add(&quot;hello&quot;);
        set.add(&quot;world&quot;);
        set.add(null);
        Iterator iterator = set.iterator();
        while(iterator.hasNext()) {
            Object obj = iterator.next();
            System.out.println(obj);
        }

        for(Object obj : set) {
            System.out.println(obj);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Set子类&lt;/h2&gt;
&lt;h3&gt;HashSet说明&lt;/h3&gt;
&lt;p&gt;1.HashSet实现了Set接口&lt;/p&gt;
&lt;p&gt;2.HashSet实际上是HashMap&lt;/p&gt;
&lt;p&gt;3.可以存放null，但只能有一个null&lt;/p&gt;
&lt;p&gt;4.HashSet不保证元素有序，取决于hash后确定的索引结果&lt;/p&gt;
&lt;p&gt;5.不能有重复的对象&lt;/p&gt;
&lt;p&gt;在add添加元素的时候会返回一个boolean值，当添加成功的时候会返回一个true&lt;/p&gt;
&lt;p&gt;，当添加失败的时候返回一个false&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class SetMethod {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        Set set = new HashSet();
        set.add(&quot;hello&quot;);
        set.add(&quot;world&quot;);
        System.out.println(set.add(&quot;hello&quot;));
        //添加失败，添加的是同一个字符串常量
        
        set.add(new Student());
        System.out.println(set.add(new Student()));
        //在这里添加的是不同的对象，所以可以添加成功
        set.add(null);
        System.out.println(set);
    }
}

class Student {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;false
true
[null, world, com.Student@74a14482, com.Student@4554617c, hello]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;HashSet的底层机制&lt;/h3&gt;
&lt;p&gt;HashSet的底层是HashMap而，HashMap的底层是（数组+链表+红黑树）&lt;/p&gt;
&lt;h4&gt;模拟简单的HashSet&lt;/h4&gt;
&lt;p&gt;在讲解底层机制之前我们先去模拟一下简单的数组+链表结构（忽略到达一定程度分为红黑树）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class HashSetStructure {
    public static void main(String[] args) {
        //模拟一个HashSet的底层（HashMap）
        Node[] table = new Node[16];

        Node john = new Node(&quot;John&quot;, null);
        table[2] = john;//将John添加到table数组中
        Node jane = new Node(&quot;Jane&quot;, null);
        john.next = jane;//将jane添加到john后
        Node rose = new Node(&quot;Rose&quot;, null);
        jane.next = rose;//将rose添加到jane后

        Node Lucy = new Node(&quot;Lucy&quot;, null);
        table[5] = Lucy;//将Lucy添加到table数组中
    }
}

class Node { //节点，存储数据，可以指向下一个节点，形成链表
    Object item;
    Node next;

    public Node(Object item, Node next) {
        this.item = item;
        this.next = next;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;HashSet底层添加元素&lt;/h4&gt;
&lt;p&gt;1.当添加一个元素的时候会先得到hash值，而又会将hash值转为索引值&lt;/p&gt;
&lt;p&gt;2.找到存储的table表，通过这个索引位置看是否有元素以及被放入&lt;/p&gt;
&lt;p&gt;3.如果没有就将该元素放入table表中&lt;/p&gt;
&lt;p&gt;4.有的话先调用equals进行比较，如果相同就放弃添加，并返回false，不相同就将该元素放入链表最后&lt;/p&gt;
&lt;p&gt;5.在Java8中，一条链表中的元素个数大于等于上限（8），并且table的大小大于等于阈值（64）就会将链表树化（红黑树）&lt;/p&gt;
&lt;p&gt;HashSet创建添加元素（Debug调试）&lt;/p&gt;
&lt;p&gt;首先先创建一个HashMap结构&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public HashSet() {
    map = new HashMap&amp;lt;&amp;gt;();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在添加元素的时候调用add添加&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public boolean add(E e) {
    return map.put(e, PRESENT)==null;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;传入的是key值以及value，而hash方法会根据key调用HashCode创建一个值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; 16);
    //不完全是哈希值，而是一个算法（h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; 16）
    //尽量哈希值不会碰撞
    //h ^ (h &amp;gt;&amp;gt;&amp;gt; 16) 的目的是让哈希值的高位信息影响低位，减少哈希冲突。

//这样即使 HashMap 的数组长度 n 较小，也能让 key 分布更均匀，提高查询效率。
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;返回HashCode的一个编码后，会进入正真扩容存放节点的方法，我用AI添加了一些注释用于辅助理解&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) {
    // 定义局部变量
    Node&amp;lt;K,V&amp;gt;[] tab;  // 哈希表数组
    Node&amp;lt;K,V&amp;gt; p;      // 当前节点
    int n, i;         // n: 数组长度，i: 计算出的索引位置
    
    // 步骤1：初始化哈希表（如果是第一次添加元素）
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;  // 调用resize()初始化表，默认大小16
    
    // 步骤2：计算索引位置并处理空桶情况
    // (n-1) &amp;amp; hash 相当于 hash % n，但效率更高
    if ((p = tab[i = (n - 1) &amp;amp; hash]) == null)
        tab[i] = newNode(hash, key, value, null);  // 空桶直接创建新节点
    else {
        // 步骤3：处理哈希冲突情况
        Node&amp;lt;K,V&amp;gt; e;  // 用于临时存储已存在的节点
        K k;          // 临时存储键
        
        // 情况3.1：检查第一个节点是否就是要找的键
        if (p.hash == hash &amp;amp;&amp;amp;
            ((k = p.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
            e = p;  // 找到相同key的节点
            
        // 情况3.2：如果是树节点，调用树的插入方法
        else if (p instanceof TreeNode)
            e = ((TreeNode&amp;lt;K,V&amp;gt;)p).putTreeVal(this, tab, hash, key, value);
            
        // 情况3.3：链表遍历查找
        else {
            for (int binCount = 0; ; ++binCount) {
                if ((e = p.next) == null) {
                    // 到达链表末尾，添加新节点
                    p.next = newNode(hash, key, value, null);
                    
                    // 检查是否需要树化（链表长度&amp;gt;=8）
                    if (binCount &amp;gt;= TREEIFY_THRESHOLD - 1) // TREEIFY_THRESHOLD=8
                        treeifyBin(tab, hash);  // 转换为红黑树
                    break;
                }
                
                // 检查当前节点是否是要找的键
                if (e.hash == hash &amp;amp;&amp;amp;
                    ((k = e.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
                    break;
                    
                p = e;  // 移动到下一个节点
            }
        }
        
        // 步骤4：处理键已存在的情况
        if (e != null) { // 已存在相同key的映射
            V oldValue = e.value;
            // onlyIfAbsent为false或原值为null时才更新
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e);  // 用于LinkedHashMap的回调
            return oldValue;     // 返回旧值
        }
    }
    
    // 步骤5：更新修改计数和检查扩容
    ++modCount;  // 并发修改检查计数器
    
    // 检查是否超过阈值需要扩容
    if (++size &amp;gt; threshold)  // threshold=容量*负载因子(默认0.75)
        resize();
        
    afterNodeInsertion(evict);  // 用于LinkedHashMap的回调
    
    return null;  // 新增节点返回null
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中判断是否扩容的条件是用resize方法实现的，其中涉及到了一个扩容因子为0.75，当达到这个容量的时候就会去进行一个容的扩（*2）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;else {       
    newCap = DEFAULT_INITIAL_CAPACITY;
    newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;HashSet实践&lt;/h3&gt;
&lt;p&gt;放入自定义类，并判断当属性和Set中的某一个元素相同的时候，添加失败，返回false&lt;/p&gt;
&lt;p&gt;以下是我第一次碰见这道题目的解决方式（有些复杂）&lt;/p&gt;
&lt;p&gt;由于这里不同创建的对象有着相同的属性，而set.add中所判断的是HashCode从而判断这是两个不同的元素，我们需要重新创建添加方法&lt;/p&gt;
&lt;p&gt;我在这里建立了三个方法，其中的类方法是重写了equals方法使其判断两个员工类的属性是一致的，而在两个静态方法中，addSet调用了contains方法去判断在set中是否有和待添加的元素属性相同的元素，有则不添加&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class HomeWork {
    public static void main(String[] args) {
        Set set = new HashSet();
        Employee person1 = new Employee(&quot;黎明&quot;, 18);
        Employee person2 = new Employee(&quot;丽丽&quot;, 11);
        Employee person3 = new Employee(&quot;黎明&quot;, 18);
        addSet(person1, set);
        addSet(person2, set);
        addSet(person3, set);
        System.out.println(set.size());
    }

    public static boolean addSet(Object o, Set set) {
        if (contains(o, set)) {
            return false;
        }
        set.add(o);
        return true;
    }

    public static boolean contains(Object o, Set set) {
        Employee person = (Employee) o;
        Iterator it = set.iterator();
        while (it.hasNext()) {
            Employee temp = (Employee) it.next();
            if(person.equals(temp)) {
                return true;
            }
        }
        return false;
    }
}


class Employee {
    String name;
    int age;

    public Employee(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public boolean equals(Object o) {
        if (o instanceof Employee) {
            Employee temp = (Employee) o;
            if(temp.name == this.name &amp;amp;&amp;amp; temp.age == this.age) {
                return true;
            }
        }
        return false;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而标准的方式则是去重写hashCode的一个方法，在hashCode中去调用一个Objects的方法hash(name, age)，传入name和age，当数据相等的时候，返回的哈希值就是一样的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

public class HomeWork {
    public static void main(String[] args) {
        Set set = new HashSet();
        Employee person1 = new Employee(&quot;黎明&quot;, 18);
        Employee person2 = new Employee(&quot;丽丽&quot;, 11);
        Employee person3 = new Employee(&quot;黎明&quot;, 18);
        set.add(person1);
        set.add(person2);
        set.add(person3);
        System.out.println(set.size());
    }

}

class Employee {
    String name;
    int age;

    public Employee(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public boolean equals(Object o) {
        if (o instanceof Employee) {
            Employee temp = (Employee) o;
            if(temp.name == this.name &amp;amp;&amp;amp; temp.age == this.age) {
                return true;
            }
        }
        return false;
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;基于 &lt;code&gt;Arrays.hashCode(Object[])&lt;/code&gt;，遍历字段并合并哈希，必须保证 &lt;code&gt;equals()&lt;/code&gt; 相同的对象，&lt;code&gt;Objects.hash()&lt;/code&gt; 结果相同&lt;/p&gt;
&lt;h3&gt;LinkedHashSet&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;public class LinkedHashSet&amp;lt;E&amp;gt;
    extends HashSet&amp;lt;E&amp;gt;
    implements Set&amp;lt;E&amp;gt;, Cloneable, java.io.Serializable {
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1.是HashSet的子类，同时也实现了Set接口&lt;/p&gt;
&lt;p&gt;2.LinkedHashSet底层是一个LinkedHashMap，底层维护了一个数组+双向链表&lt;/p&gt;
&lt;p&gt;3.LinkedHashSet根据元素的hashCode值来决定元素的存储位置，同时用链表维护元素的次序，使得元素在看起来是以插入顺序保存的&lt;/p&gt;
&lt;p&gt;4.LinkedHashSet不允许添加重复元素&lt;/p&gt;
&lt;p&gt;其中存储的节点继承于HashMapNode，名为Entry是一个内部类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static class Entry&amp;lt;K,V&amp;gt; extends HashMap.Node&amp;lt;K,V&amp;gt; {
    Entry&amp;lt;K,V&amp;gt; before, after;
    Entry(int hash, K key, V value, Node&amp;lt;K,V&amp;gt; next) {
        super(hash, key, value, next);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中维护了先后引用用于，达到顺序输出的效果&lt;/p&gt;
&lt;h3&gt;TreeSet&lt;/h3&gt;
&lt;p&gt;通过传入一个Comparator接口可以实现有序的排序（可自定义）&lt;/p&gt;
&lt;p&gt;注意这里如果不传入Comparator就会将添加入的对象转为Comparable类型，如果这个类型没有实现Comparable接口的话就会发生异常，抛出错误ClassCastExceprion&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class TreeSet01 {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        TreeSet treeSet = new TreeSet(new Comparator() {
            public int compare(Object o1, Object o2) {
                String s1 = (String)o1;
                String s2 = (String)o2;
                return s1.compareTo(s2);
            }
        });
        treeSet.add(&quot;jack&quot;);
        treeSet.add(&quot;ae&quot;);
        treeSet.add(&quot;jille&quot;);
        treeSet.add(&quot;band&quot;);
        System.out.println(treeSet);
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Java笔记</title><link>https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0matharrayssystem%E5%A4%A7%E6%95%B0%E5%A4%84%E7%90%86/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0matharrayssystem%E5%A4%A7%E6%95%B0%E5%A4%84%E7%90%86/</guid><description>Math，Arrays，System，大数处理</description><pubDate>Mon, 31 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Java笔记&lt;/h1&gt;
&lt;h2&gt;Math&lt;/h2&gt;
&lt;p&gt;Math类包含了执行基本数学运算的方法，如初等函数，对数，平方根，三角函数&lt;/p&gt;
&lt;h3&gt;常用的方法&lt;/h3&gt;
&lt;h4&gt;abs求绝对值&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class Math01 {
    public static void main(String[] args) {
        System.out.println(Math.abs(-123));//123
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;pow求幂&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class Math01 {
    public static void main(String[] args) {
        System.out.println(Math.pow(2, 4));//16.0
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;ceil向上取整&lt;/h4&gt;
&lt;p&gt;返回大于等于这个数的最小整数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Math01 {
    public static void main(String[] args) {
        System.out.println(Math.ceil(20.2));//21.0
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;floor向上取整&lt;/h4&gt;
&lt;p&gt;返回小于等于这个数的最大整数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Math01 {
    public static void main(String[] args) {
        System.out.println(Math.floor(20.2));//20.0
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;round四舍五入&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class Math01 {
    public static void main(String[] args) {
        System.out.println(Math.round(20.35));//20.0
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;sqrt开方&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class Math01 {
    public static void main(String[] args) {
        System.out.println(Math.sqrt(9));//3.0
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;random随机数&lt;/h4&gt;
&lt;p&gt;返回一个[0,1)之间的随机小数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Math01 {
    public static void main(String[] args) {
        System.out.println(Math.random());//0.8490844298476015
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2-7之间的随机整数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Math01 {
    public static void main(String[] args) {
        //Math.random() * x 返回了一个数[0, x)
        //Math.random() * 5 返回了[0, 5),
        System.out.println(Math.random() * 5 + 2);//[2,7)
        System.out.println((int)(Math.random() * 6 + 2));//2-7的整数
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;max和min&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class Math01 {
    public static void main(String[] args) {
        System.out.println(Math.max(1, 2));//2
        System.out.println(Math.min(1, 2));//1
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Arrays&lt;/h2&gt;
&lt;p&gt;包含了一系列的静态方法，用于管理和操作数组（例如排序和搜索）&lt;/p&gt;
&lt;h3&gt;常用方法&lt;/h3&gt;
&lt;h4&gt;toString方法&lt;/h4&gt;
&lt;p&gt;返回一个字符串&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Arrays01 {
    public static void main(String[] args) {
        Integer[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        System.out.println(Arrays.toString(arr));
        //[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;sort排序&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class Arrays01 {
    public static void main(String[] args) {
        Integer[] arr = {2, 1, 3, 8, 5, 6, 7, 4, 10, 9};
        Arrays.sort(arr);
        System.out.println(Arrays.toString(arr));
        //[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;binarySearch二分查找&lt;/h4&gt;
&lt;p&gt;要求排序，找不到返回-(low + 1)，表示如果存在应该在的地方&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Arrays01 {
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9};
        System.out.println(Arrays.binarySearch(arr, 5));//4
        System.out.println(Arrays.binarySearch(arr, 15));//-10
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;copyOf拷贝数组&lt;/h4&gt;
&lt;p&gt;拷贝arr的3个数，如果长度大于arr的length，多的int用0填充，Integer用null填充&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Arrays01 {
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9};
        int[] arrNew = Arrays.copyOf(arr, 3);
        System.out.println(Arrays.toString(arrNew));//[1, 2, 3]
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public class Arrays01 {
    public static void main(String[] args) {
        Integer[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9};
        Integer[] arrNew = Arrays.copyOf(arr, 11);
        System.out.println(Arrays.toString(arrNew));
        //[1, 2, 3, 4, 5, 6, 7, 8, 9, null, null]
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;fill数组填充&lt;/h4&gt;
&lt;p&gt;用后面的数填充整个数组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Arrays01 {
    public static void main(String[] args) {
        Integer[] arr = {1, 2, 3};
        Arrays.fill(arr, 4);
        System.out.println(Arrays.toString(arr));//[4, 4, 4]
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;equals比较数组元素&lt;/h4&gt;
&lt;p&gt;注意与直接使用arr.equals(arr2)区分&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Arrays01 {
    public static void main(String[] args) {
        Integer[] arr = {1, 2, 3};
        Integer[] arr2 = {1, 2, 3};
        System.out.println(Arrays.equals(arr, arr2));//true
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;asList将一组值转为list&lt;/p&gt;
&lt;p&gt;将数组转为一个asList集合&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Arrays01 {
    public static void main(String[] args) {
        Integer[] arr = {1, 2, 3};
        List asList = Arrays.asList(arr);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;定制排序及其底层实现&lt;/h3&gt;
&lt;p&gt;额外的，我们可以传入一个匿名内部类，定制排序&lt;/p&gt;
&lt;p&gt;匿名内部类，动态绑定，接口编程的组合可以在编程的时候变得非常灵活&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Arrays01 {
    public static void main(String[] args) {
        Integer[] arr = {2, 1, 3, 8, 5, 6, 7, 4, 10, 9};
        Arrays.sort(arr, new Comparator() {
            @Override
            public int compare(Object o1, Object o2) {
                Integer i1 = (Integer) o1;
                Integer i2 = (Integer) o2;
                return i2 - i1;
            }
        });
        System.out.println(Arrays.toString(arr));
        [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在底层的代码中会执行我们实现的匿名内部类，从而影响内部逻辑，改变排序顺序（有兴趣的可以通过断点调试去试一试）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static &amp;lt;T&amp;gt; void sort(T[] a, Comparator&amp;lt;? super T&amp;gt; c)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;...... 这里省略了一些调用过程，下面是类c的使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;while (left &amp;lt; right) {
    int mid = (left + right) &amp;gt;&amp;gt;&amp;gt; 1;
    if (c.compare(pivot, a[mid]) &amp;lt; 0)//这里的c就是我们实现接口的类
        right = mid;
    else
        left = mid + 1;
}
assert left == right;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;模拟底层排序&lt;/h3&gt;
&lt;p&gt;我们也可以自己来模拟以下底层的排序，以下是以往的自定义方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Arrays01 {
    public static void main(String[] args) {
        int[] arr = {2, 1, 3, 8, 5, 6, 7, 4, 10, 9};
        bubbleSort(arr);
        System.out.println(Arrays.toString(arr));
    }

    public static void bubbleSort(int[] a) {
        for(int i = 0; i &amp;lt; a.length - 1; i++) {
            for(int j = 0; j &amp;lt; a.length - i - 1; j++) {
                if(a[j] &amp;gt; a[j + 1]) {
                    int temp = a[j];
                    a[j] = a[j + 1];
                    a[j + 1] = temp;
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实现定制排序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Arrays01 {
    public static void main(String[] args) {
        int[] arr = {2, 1, 3, 8, 5, 6, 7, 4, 10, 9};
        bubbleSort(arr, new Comparator() {
            public int compare(Object o1, Object o2) {
                int i1 = (Integer)o1;
                int i2 = (Integer)o2;
                return i2 - i1;
            }
        });
        System.out.println(Arrays.toString(arr));
    }

    public static void bubbleSort(int[] a, Comparator c) {
        for (int i = 0; i &amp;lt; a.length - 1; i++) {
            for (int j = 0; j &amp;lt; a.length - i - 1; j++) {
                if (c.compare(a[j], a[j + 1]) &amp;gt; 0) {
                    int temp = a[j];
                    a[j] = a[j + 1];
                    a[j + 1] = temp;
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其实一般限定的也比较死，都是i2 - i1是从大到小，反之亦然&lt;/p&gt;
&lt;p&gt;一个书本排序的案例（按照价格从大到小）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Arrays01 {
    public static void main(String[] args) {
        Book[] books = new Book[4];
        books[0] = new Book(&quot;爱丽丝&quot;, 1);
        books[1] = new Book(&quot;齐欢乐&quot;, 12);
        books[2] = new Book(&quot;英雄联盟&quot;, 123);
        books[3] = new Book(&quot;王者荣耀&quot;, 14);
        System.out.println(&quot;排序前&quot;);
        printBooks(books);
        Arrays.sort(books, new Comparator() {
            public int compare(Object o1, Object o2) {
                Book b1 = (Book) o1;
                Book b2 = (Book) o2;
                return b2.price - b1.price;
            }
        });
        System.out.println(&quot;排序后&quot;);
        printBooks(books);
    }

    public static void printBooks(Book[] books) {
        for (Book book : books) {
            System.out.println(book.price + &quot; &quot; + book.name);
        }
    }
}
class Book {
    String name;
    int price;

    public Book(String name, int price) {
        this.name = name;
        this.price = price;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;按照名字长度从大到小，自定义排序用匿名类重写compare即可&lt;/p&gt;
&lt;p&gt;因为sort传入的是泛型，我们只需要重写接口的compare方法改为我们需要使用到的排序属性做一个相减比较即可实现类数组的排序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Arrays.sort(books, new Comparator() {
    public int compare(Object o1, Object o2) {
        Book b1 = (Book) o1;
        Book b2 = (Book) o2;
        return b2.name.length() - b1.name.length();
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;System&lt;/h2&gt;
&lt;h3&gt;System常见的方法&lt;/h3&gt;
&lt;h4&gt;exit&lt;/h4&gt;
&lt;p&gt;退出当前程序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class System01 {
    public static void main(String[] args) {
        System.exit(0);//程序退出，0代表正常退出
        System.out.println(&quot;continue...&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;arraycopy&lt;/h4&gt;
&lt;p&gt;复制数组元素copyOf调用的底层就是这个方法&lt;/p&gt;
&lt;p&gt;Arrays中的&lt;/p&gt;
&lt;p&gt;第一个参数表示拷贝源，第二个为源开始拷贝的下表
第三个参数表示拷贝目标，第四个为源开始复制的下表
第五个表示拷贝的长度&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class System01 {
    public static void main(String[] args) {
        int[] src = {1, 3, 4};
        int[] newSrc = new int[src.length];
        System.arraycopy(src, 0, newSrc, 1, 2);
        System.out.println(Arrays.toString(newSrc));
        //[0, 1, 3]
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;currentTimeMillens&lt;/h4&gt;
&lt;p&gt;返回当前时间距离1970-1-1的毫秒数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class System01 {
    public static void main(String[] args) {
        System.out.println(System.currentTimeMillis());
        //1743413461175
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;gc&lt;/h4&gt;
&lt;p&gt;运行垃圾回收机制（非阻塞）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Hashcode {
    public static void main(String[] args) {
        AA aa = new AA();
        aa = null;
        System.gc();//主动调用回收器
        System.out.println(&quot;代码结束&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;大数处理&lt;/h2&gt;
&lt;h3&gt;BigInteger&lt;/h3&gt;
&lt;p&gt;比较适合保存较大的整形&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class BigInteger_ {
    public static void main(String[] args) {
        BigInteger biginteger = new BigInteger(&quot;1234567893242342235233253532532&quot;);
        System.out.println(biginteger);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在进行BigInteger的加减乘除的时候需要使用对应方法(加减乘除)&lt;/p&gt;
&lt;p&gt;add&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class BigInteger_ {
    public static void main(String[] args) {
        BigInteger biginteger = new BigInteger(&quot;1234567893242342235233253532532&quot;);
        biginteger = biginteger.add(biginteger);
        System.out.println(biginteger);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;subtract&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class BigInteger_ {
    public static void main(String[] args) {
        BigInteger biginteger = new BigInteger(&quot;1234567893242342235233253532532&quot;);
        biginteger = biginteger.subtract(biginteger);
        System.out.println(biginteger);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;divide&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class BigInteger_ {
    public static void main(String[] args) {
        BigInteger biginteger = new BigInteger(&quot;1234567893242342235233253532532&quot;);
        biginteger = biginteger.divide(biginteger);
        System.out.println(biginteger);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;multiply&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class BigInteger_ {
    public static void main(String[] args) {
        BigInteger biginteger = new BigInteger(&quot;1234567893242342235233253532532&quot;);
        biginteger = biginteger.multiply(BigInteger.valueOf(2));
        System.out.println(biginteger);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;BigDecimal&lt;/h3&gt;
&lt;p&gt;适合保存精度更高的浮点型（小数）&lt;/p&gt;
&lt;p&gt;方法同理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class BigInteger_ {
    public static void main(String[] args) {
        BigDecimal big = new BigDecimal(&quot;1.0000003982039023029309239203992032093&quot;);
        BigDecimal big2 = new BigDecimal(&quot;121.333&quot;);
        big = big.add(big2);
        System.out.println(big);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在作除法的时候可能会抛出除不尽的异常&lt;/p&gt;
&lt;p&gt;可以通过以下调用divide方法时指定精度&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class BigInteger_ {
    public static void main(String[] args) {
        BigDecimal big = new BigDecimal(&quot;1.0000003982039023029309239203992032093&quot;);
        BigDecimal big2 = new BigDecimal(&quot;121.333&quot;);
        big = big.divide(big2, BigDecimal.ROUND_CEILING);
        //保留分子精度
        System.out.println(big);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;日期类&lt;/h2&gt;
&lt;h3&gt;Date&lt;/h3&gt;
&lt;p&gt;第一代日期类：精确到毫秒，代表特定时间，实现了比较接口，克隆接口，可序列化接口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Date
    implements java.io.Serializable, Cloneable, Comparable&amp;lt;Date&amp;gt;
{ ......
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;构造方法&lt;/h4&gt;
&lt;p&gt;Date无参构造器，获取当前系统时间&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Date01 {
    public static void main(String[] args) {
        Date d1 = new Date();//获取当前系统时间
        System.out.println(d1);//默认为外国时间格式，需要转换
        //Mon Mar 31 19:56:05 CST 2025
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Date构造器传入一个long型的数（毫秒数），转为Date型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Date01 {
    public static void main(String[] args) {
        Date d1 = new Date(1341324134);
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 || hh:mm:ss&quot;);
        System.out.println(sdf.format(d1));
        //1970年01月16日 || 08:35:24
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;SimpleDateFormat&lt;/h4&gt;
&lt;p&gt;格式和解析日期的类&lt;/p&gt;
&lt;p&gt;先定义一个日期的格式，创建sdf对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;按照对应格式输出时间&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Date01 {
    public static void main(String[] args) {
        Date d1 = new Date();
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 || hh:mm:ss&quot;);
        System.out.println(sdf.format(d1));
        //2025年03月31日 || 07:58:20
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将Date格式化日期转为Date&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Date01 {
    public static void main(String[] args) throws ParseException {
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 || hh:mm:ss&quot;);
        Date d1 = sdf.parse(&quot;1970年01月16日 || 08:35:24&quot;);
        //需要日期格式对应，否则抛出异常
        System.out.println(d1);
        //Fri Jan 16 08:35:24 CST 1970
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Calendar&lt;/h3&gt;
&lt;p&gt;日历：第二代日期类，是一个抽象类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public abstract class Calendar implements Serializable, Cloneable, Comparable&amp;lt;Calendar&amp;gt; {...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该类的构造器添加了private无法手动创建实例&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/89.png&quot; alt=&quot;89&quot; /&gt;&lt;/p&gt;
&lt;p&gt;通过getInstance获取实例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Calendar01 {
    public static void main(String[] args) {
        Calendar cal = Calendar.getInstance();
        System.out.println(cal.get(Calendar.YEAR));
        //2025
        System.out.println(cal.get(Calendar.MONTH) + 1);
        //3 月份需要+1，因为是由0开始编码
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;没有格式化输出方法，可以由自己自由定义，以下是一个代码示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Calendar01 {
    public static void main(String[] args) {
        Calendar cal = Calendar.getInstance();
        System.out.println(formatPrint(cal));
        //2025-2-31 20:21:58
    }

    public static String formatPrint(Calendar cal) {
        int year = cal.get(Calendar.YEAR);
        int month = cal.get(Calendar.MONTH);
        int day = cal.get(Calendar.DAY_OF_MONTH);
        int hour = cal.get(Calendar.HOUR_OF_DAY);//24进制
        //12进制位HOUR
        int minute = cal.get(Calendar.MINUTE);
        int second = cal.get(Calendar.SECOND);
        return year + &quot;-&quot; + month + &quot;-&quot; + day + &quot; &quot; + hour + &quot;:&quot; + minute + &quot;:&quot; + second;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;第三代日期类&lt;/h3&gt;
&lt;h4&gt;引入原因&lt;/h4&gt;
&lt;p&gt;是由于前两代的不足引入的&lt;/p&gt;
&lt;p&gt;Date大多数方法在JDK1.1之后就被弃用了&lt;/p&gt;
&lt;p&gt;而Calendar类也存在一下问题&lt;/p&gt;
&lt;p&gt;可变性：日期和时间的类应该是不可变的&lt;/p&gt;
&lt;p&gt;偏移性：Date中的年份是从1900开始的，而月份是从0开始的&lt;/p&gt;
&lt;p&gt;格式化：格式化只对Date有用，Calendar不行&lt;/p&gt;
&lt;p&gt;线程安全：两者都不是线程安全的；同时不能处理闰秒（每隔2天，多1s）&lt;/p&gt;
&lt;h4&gt;第三代日期的常见的使用&lt;/h4&gt;
&lt;h5&gt;LocalDate&lt;/h5&gt;
&lt;p&gt;只包含日期，可以获取日期字段&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Local01 {
    public static void main(String[] args) {
        LocalDate ldt = LocalDate.now();
        System.out.println(ldt);//2025-03-31
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;LocalTime&lt;/h5&gt;
&lt;p&gt;只包含时间，可以获取时间字段&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Local01 {
    public static void main(String[] args) {
        LocalTime ldt = LocalTime.now();
        System.out.println(ldt);//20:34:32.321
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;LocalDateTime&lt;/h5&gt;
&lt;p&gt;包含日期、时间&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Local01 {
    public static void main(String[] args) {
        LocalDateTime ldt = LocalDateTime.now();
        System.out.println(ldt);//2025-03-31T20:33:20.585
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;常见的方法&lt;/h4&gt;
&lt;p&gt;即查即用即可，以下是一个自定义格式代码示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Local01 {
    public static void main(String[] args) {
        LocalDateTime ldt = LocalDateTime.now();
        System.out.println(formatPrint(ldt));//2025-3-31
    }

    public static String formatPrint(LocalDateTime ldt) {
        int year = ldt.getYear();
        int month = ldt.getMonthValue();
        int day = ldt.getDayOfMonth();
        return year + &quot;-&quot; + month + &quot;-&quot; + day ;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者我们可以使用DateTimeFormatter来定义&lt;/p&gt;
&lt;p&gt;类似于Date中的SimpleDateFormat&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Local01 {
    public static void main(String[] args) {
        LocalDateTime d1 = LocalDateTime.now();
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;MM-dd-yyyy&quot;);
        System.out.println(d1.format(formatter));
        //03-31-2025
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;比较，前一个传入的参数是格式器，后一个传入的是日期类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Date01 {
    public static void main(String[] args) {
        Date d1 = new Date();
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 || hh:mm:ss&quot;);
        System.out.println(sdf.format(d1));
        //2025年03月31日 || 07:58:20
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;时间戳与Date的转换&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class Local01 {
    public static void main(String[] args) {
        Instant instant = Instant.now();//通过now获取时间戳
        System.out.println(instant);//2025-03-31T12:47:34.897Z
        Date date = Date.from(instant);//将时间戳转为Date
        instant = date.toInstant();//将Date转为时间戳
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;时间计算&lt;/h4&gt;
&lt;p&gt;在做订单的时候比较常用&lt;/p&gt;
&lt;p&gt;可以使用plus和minus方法可以对当前时间进行加或者减&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Local01 {
    public static void main(String[] args) {
        LocalDateTime localDateTime = LocalDateTime.now();
        System.out.println(localDateTime.minusMonths(1));
        //2025-03-30T20:53:15.177
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Java笔记</title><link>https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%8C%85%E8%A3%85%E7%B1%BBstringstringbufferstringbuilder/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%8C%85%E8%A3%85%E7%B1%BBstringstringbufferstringbuilder/</guid><description>包装类，String，StringBuffer，StringBuilder</description><pubDate>Fri, 28 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Java笔记&lt;/h1&gt;
&lt;h2&gt;包装类&lt;/h2&gt;
&lt;p&gt;Wrapper（包装器）&lt;/p&gt;
&lt;h3&gt;定义&lt;/h3&gt;
&lt;p&gt;针对八种基本的数据类型类型响应的引用类型&lt;/p&gt;
&lt;p&gt;有类的特点，可以调用类的方法&lt;/p&gt;
&lt;p&gt;除了 int -&amp;gt; Integer char- &amp;gt; Character 其余的六个都是将首字母大写就是对应的包装类&lt;/p&gt;
&lt;p&gt;Boolean  Byte Short Long Float Double&lt;/p&gt;
&lt;p&gt;Boolean 与 Character 二者是实现了比较和可序列化的接口的Object子类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public final class Boolean implements java.io.Serializable,
                                      Comparable&amp;lt;Boolean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;class Character implements java.io.Serializable, Comparable&amp;lt;Character&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而这些数字的类型一般都是继承了Number类，而Number类是实现了可序列化的接口的Object子类，数字类型直接实现比较接口&lt;/p&gt;
&lt;p&gt;图标如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/83.png&quot; alt=&quot;83&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;装箱与拆箱&lt;/h3&gt;
&lt;p&gt;自动拆装箱，本质上和手动没有区别，由编译器自动调用方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class WrapperType {
    public static void main(String[] args) {
        //jdk5以前是用手动装箱,拆箱
        int i = 10;
        Integer pack = new Integer(i);
        Integer pack2 = Integer.valueOf(i);

        int j = pack.intValue();//手动拆箱

        //jdk5以后支持自动拆装箱
        int k = 200;
        Integer pack3 = k;//自动装箱
        int k1 = pack3;//自动拆箱
        //本质上和手动没有区别，由编译器自动调用方法
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一道比较经典的面试题目&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/84.png&quot; alt=&quot;84&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;包装类型和String转换&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;public class WrapperType {
    public static void main(String[] args) {
        Integer i = 127;
        String s1 = i + &quot;&quot;;//包装类转字符串
        String s2 = i.toString();
        /* 包装类的toString方法
        public String toString() {
                return toString(value);
            }
         */
        System.out.println(s1);

        Integer i1 = Integer.parseInt(s1);//字符串转包装类
        Integer i2 = Integer.valueOf(s1);//会调用parseInt

        System.out.println(i2);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;一些常用的方法&lt;/h3&gt;
&lt;p&gt;即查即用，不用特殊记忆&lt;/p&gt;
&lt;p&gt;返回最小值 最大值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class WrapperType {
    public static void main(String[] args) {
        Integer i = 127;
        System.out.println(i.MIN_VALUE);
        System.out.println(Integer.MIN_VALUE);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;判断是不是数字，是不是字母，是不是大写，是不是小写，是不是空格，转成大写，转成小写（查询使用即可，或者可以自己实现）&lt;/p&gt;
&lt;h3&gt;Integer的面试题&lt;/h3&gt;
&lt;p&gt;之前也涉及到过，在前面的数据类型中我曾写过&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class WrapperType {
    public static void main(String[] args) {
        Integer i1 = new Integer(12);
        Integer i2 = new Integer(12);
        System.out.println(i1 == i2);//false
	//创建新的对象，指向的地址肯定不同
        Integer i3 = 12;//Integer.valueOf(12);
        Integer i4 = 12;//Integer.valueOf(12);
        System.out.println(i3 == i4);//true
	//Integer自动包装调用valueOf()，其中涉及到常量池的概念
        Integer i5 = 128;
        Integer i6 = 128;
        System.out.println(i5 == i6);//false
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public static Integer valueOf(int i) {
    if (i &amp;gt;= IntegerCache.low &amp;amp;&amp;amp; i &amp;lt;= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;存在一个cache，-128—127，在范围外才会创建对象&lt;/p&gt;
&lt;p&gt;已经静态的创建好了一个Integer包装数组，将-128—127，在范围内直接用引用指向即可&lt;/p&gt;
&lt;p&gt;还有一个，这里涉及到的是基本数据类型，比较的是值是否相等&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/85.png&quot; alt=&quot;85&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;String&lt;/h2&gt;
&lt;h3&gt;定义&lt;/h3&gt;
&lt;p&gt;支持可序列化接口，比较接口，可读的字符序列接口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public final class String
    implements java.io.Serializable, Comparable&amp;lt;String&amp;gt;, CharSequence { ... }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1.String 对象是用来保存字符串的，是一组字符序列&lt;/p&gt;
&lt;p&gt;2.字符串常量对象使用双引号括起的字符序列&lt;/p&gt;
&lt;p&gt;3.字符串的字符使用的是Unicode字符编码，一个字符占用两个字节&lt;/p&gt;
&lt;p&gt;4.String类较为常用的构造方法有以下:多种构造器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;()

(String original)

(char[] a)

(char[] a, int startIndex, int count)

(byte[] b)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;String 有属性private final char value[ ] :用于存储字符串内容，final代表value指向的地址不可以被修改（而地址存储的单个字符内容可以变化），以下是一个代码示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class String1 {
    public static void main(String[] args) {
        final char[] target = {&apos;1&apos;,&apos;2&apos;,&apos;5&apos;};
        target[0] = &apos;4&apos;;
        char[] target1 = {&apos;1&apos;,&apos;2&apos;,&apos;3&apos;};
        //target = target1;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;创建String对象方式&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;public class String1 {
    public static void main(String[] args) {
        String str1 = &quot;abc&quot;;//方式一
        String str2 = new String(&quot;abc&quot;);//方式二
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方式一：查看常量池中是否有&quot;abc&quot;的数据空间，如果有直接指向，如果没有则在常量池中创建，最后指向的是常量池中的空间地址&lt;/p&gt;
&lt;p&gt;方式二：在堆中创建空间，如果里面维护了value属性，指向常量池中的&quot;abc&quot;空间，如果常量池中没有&quot;abc&quot;重新创建，如果有直接通过value指向，最终指向的是堆中的空间地址，堆中的引用指向常量池中的地址&lt;/p&gt;
&lt;p&gt;以下是示例图片&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/86.png&quot; alt=&quot;86&quot; /&gt;&lt;/p&gt;
&lt;p&gt;虽然指向的最终都是到常量池中的字符，但是二者指向的第一个地址不一样（一个在堆中，另一个在常量池中）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class String1 {
    public static void main(String[] args) {
        String str1 = &quot;abc&quot;
        String str2 = new String(&quot;abc&quot;);
        System.out.println(str1 == str2);//false
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;调用intern方法时，如果常量池中已经包含了对应的字符串，就返回池中的字符串地址，否则先添加String对象添加到池中，并返回池中的地址&lt;/p&gt;
&lt;p&gt;一个测试题目&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/87.png&quot; alt=&quot;87&quot; /&gt;&lt;/p&gt;
&lt;p&gt;最后一个e指向常量池，true，优化为e = &quot;helloabc&quot;;&lt;/p&gt;
&lt;h3&gt;String的常用方法&lt;/h3&gt;
&lt;h4&gt;equals&lt;/h4&gt;
&lt;p&gt;//判断是否相等&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;String str1 = new String(&quot;abc&quot;);
String str2 = new String(&quot;abccdff&quot;);
System.out.println(str1.equals(str2));//false
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;equalsIgnoreCase&lt;/h4&gt;
&lt;p&gt;//忽略大小写判断是否相等&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;String str1 = new String(&quot;abc&quot;);
String str2 = new String(&quot;ABC&quot;);
System.out.println(str1.equalsIgnoreCase(str2));//true
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;length&lt;/h4&gt;
&lt;p&gt;//字符个数，字符串长度&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;System.out.println(str1.length());//3
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;indexOf&lt;/h4&gt;
&lt;p&gt;//获取第一个对应对应字符的索引，无则返回-1&lt;/p&gt;
&lt;p&gt;注意可以传入字符串&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;System.out.println(str1.indexOf(&quot;bc&quot;));//2
System.out.println(str2.lastIndexOf(&apos;B&apos;));//2
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;lastIndexOf&lt;/h4&gt;
&lt;p&gt;//获取最后一个对应字符的索引，无则返回-1&lt;/p&gt;
&lt;p&gt;同上类似&lt;/p&gt;
&lt;h4&gt;substring&lt;/h4&gt;
&lt;p&gt;//截取指定范围的字串&lt;/p&gt;
&lt;p&gt;一个参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public String substring(int beginIndex) {
    if (beginIndex &amp;lt; 0) {
        throw new StringIndexOutOfBoundsException(beginIndex);
    }
    int subLen = value.length - beginIndex;
    if (subLen &amp;lt; 0) {
        throw new StringIndexOutOfBoundsException(subLen);
    }
    return (beginIndex == 0) ? this : new String(value, beginIndex, subLen);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;两个参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public String substring(int beginIndex, int endIndex) {
    if (beginIndex &amp;lt; 0) {
        throw new StringIndexOutOfBoundsException(beginIndex);
    }
    if (endIndex &amp;gt; value.length) {
        throw new StringIndexOutOfBoundsException(endIndex);
    }
    int subLen = endIndex - beginIndex;
    if (subLen &amp;lt; 0) {
        throw new StringIndexOutOfBoundsException(subLen);
    }
    return ((beginIndex == 0) &amp;amp;&amp;amp; (endIndex == value.length)) ? this
            : new String(value, beginIndex, subLen);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;concat&lt;/h4&gt;
&lt;p&gt;//拼接字符串&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;System.out.println(str1.concat(str2));//abcABC
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;replace&lt;/h4&gt;
&lt;p&gt;//替换字符串&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;System.out.println(str1.replace(&quot;a&quot;, &quot;b&quot;));//bbc
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;toUpperCase&lt;/h4&gt;
&lt;p&gt;//向上取大写&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;System.out.println(str1.toUpperCase());//ABC
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;toLowerCase&lt;/h4&gt;
&lt;p&gt;//取向下小写&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;System.out.println(str2.toLowerCase());//abc
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;split&lt;/h4&gt;
&lt;p&gt;//以（）为标准分割字符串内容&lt;/p&gt;
&lt;p&gt;转移字符需要在前加 \&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;String str3 = new String(&quot;abc,ABe,CDE&quot;);
String[] stringArr = str3.split(&quot;,&quot;);
String str4 = stringArr[0];
System.out.println(str4);//abc
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;toCharArray&lt;/h4&gt;
&lt;p&gt;//转换为字符数组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;char[] a = str1.toCharArray();
System.out.println(a[1]);//b
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;compareTo&lt;/h4&gt;
&lt;p&gt;//比较大小&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;String str1 = new String(&quot;abc&quot;);
String str2 = new String(&quot;ABC&quot;);
System.out.println(str1.compareTo(str2));//32
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当区分不出大小且，长度不一样时有不同返回值，详见源码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public int compareTo(String anotherString) {
    int len1 = value.length;
    int len2 = anotherString.value.length;
    int lim = Math.min(len1, len2);
    char v1[] = value;
    char v2[] = anotherString.value;

    int k = 0;
    while (k &amp;lt; lim) {
        char c1 = v1[k];
        char c2 = v2[k];
        if (c1 != c2) {
            return c1 - c2;
        }
        k++;
    }
    return len1 - len2;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;trim&lt;/h4&gt;
&lt;p&gt;//去前后空格&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;String str1 = new String(&quot;  ab c  &quot;);
System.out.println(str1.trim());//ab c
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;format&lt;/h4&gt;
&lt;p&gt;//字符串格式化拼接&lt;/p&gt;
&lt;p&gt;类似于C语言中printf&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;String str1 = new String(&quot;abc&quot;);
String str2 = new String(&quot;ABC&quot;);
String str3 = String.format(&quot;你好 %s 和 %s&quot;, str1, str2);
System.out.println(str3);//你好 abc 和 ABC
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有点太多了，没必要全记，记不得在查，早晚会熟练使用的&lt;/p&gt;
&lt;h2&gt;StringBuffer&lt;/h2&gt;
&lt;h3&gt;定义&lt;/h3&gt;
&lt;p&gt;是一种增强的String支持增删改，直接父类是AbstractStringBuilder，实现了可序列化的接口，是一个final类型，不可被继承&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/88.png&quot; alt=&quot;88&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;abstract class AbstractStringBuilder implements Appendable, CharSequence {
    char[] value;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中有value char数组，存放在堆中&lt;/p&gt;
&lt;p&gt;StringBuffer相较于String保存的字符串常量（值无法修改），StringBuffer不用在修改内容的时候更改地址（除非内存不足时重新扩容复制），所以效率上高于String&lt;/p&gt;
&lt;h3&gt;常用的构造器&lt;/h3&gt;
&lt;p&gt;默认的无参构造器（创建一个16字符的空间）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class StringBuffer01 {
    public static void main(String[] args) {
        StringBuffer sb = new StringBuffer();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;传入int参数构造器，其中容量为32个字符&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class StringBuffer01 {
    public static void main(String[] args) {
        StringBuffer sb = new StringBuffer(32);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;传入String常量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class StringBuffer01 {
    public static void main(String[] args) {
        StringBuffer sb = new StringBuffer(&quot;StringBuffer01&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;jdk源码，其中先new一个同样大小的数组，再通过append拼接+16的容量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public StringBuffer(String str) {
    super(str.length() + 16);
    append(str);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;AbstractStringBuilder(int capacity) {
    value = new char[capacity];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;与String的转化&lt;/h3&gt;
&lt;p&gt;转为String&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class StringBuffer01 {
    public static void main(String[] args) {
        String str = &quot;hello&quot;;
        StringBuffer sb1 = new StringBuffer(str);//对原先的str没有影响
        StringBuffer sb2 = new StringBuffer();
        sb2.append(str);//通过添加完成
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;转为StringBuffer&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class StringBuffer01 {
    public static void main(String[] args) {
        StringBuffer sb = new StringBuffer(&quot;Hello&quot;);
        String str1 = sb.toString();
        String str2 = new String(sb);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;StringBuffer常用方法&lt;/h3&gt;
&lt;h4&gt;append&lt;/h4&gt;
&lt;p&gt;在末尾添加字符&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class StringBuffer01 {
    public static void main(String[] args) {
        StringBuffer sb = new StringBuffer(&quot;Hello&quot;);
        sb.append(&quot; World!!&quot;);
        System.out.println(sb);//Hello World!
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;delete&lt;/h4&gt;
&lt;p&gt;删除 [1，3）的内容&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class StringBuffer01 {
    public static void main(String[] args) {
        StringBuffer sb = new StringBuffer(&quot;Hello&quot;);
        sb.delete(1, 3);
        System.out.println(sb.toString());//Hlo
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;replace&lt;/h4&gt;
&lt;p&gt;替换，有三个参数，从 [1，3）的内容用参数 3 替换&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class StringBuffer01 {
    public static void main(String[] args) {
        StringBuffer sb = new StringBuffer(&quot;Hello&quot;);
        sb.replace(1, 3, &quot;世界&quot;);
        System.out.println(sb.toString());//H世界lo
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;indexOf&lt;/h4&gt;
&lt;p&gt;返回查找内容的索引（第一个）传入字符串&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class StringBuffer01 {
    public static void main(String[] args) {
        StringBuffer sb = new StringBuffer(&quot;Hello&quot;);
        System.out.println(sb.indexOf(&quot;l&quot;));//2
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;insert&lt;/h4&gt;
&lt;p&gt;在（第一个参数的位置）插入内容&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class StringBuffer01 {
    public static void main(String[] args) {
        StringBuffer sb = new StringBuffer(&quot;Hello&quot;);
        sb.insert(1, &quot;插入&quot;);
        System.out.println(sb);//H插入ello
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;length&lt;/h4&gt;
&lt;p&gt;返回长度&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class StringBuffer01 {
    public static void main(String[] args) {
        StringBuffer sb = new StringBuffer(&quot;Hello&quot;);
        System.out.println(sb.length());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;常见的例题&lt;/h3&gt;
&lt;p&gt;使用append传入null字符串&lt;/p&gt;
&lt;p&gt;当为null的时候返回appendNull，而返回的值是一个null字符串&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class StringBuffer01 {
    public static void main(String[] args) {
        StringBuffer sb = new StringBuffer();
        String str = null;
        sb.append(str);
        System.out.println(sb.length());//4
        System.out.println(sb.toString());//null
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public AbstractStringBuilder append(String str) {
    if (str == null)
        return appendNull();
    int len = str.length();
    ensureCapacityInternal(count + len);
    str.getChars(0, len, value, count);
    count += len;
    return this;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;private AbstractStringBuilder appendNull() {
    int c = count;
    ensureCapacityInternal(c + 4);
    final char[] value = this.value;
    value[c++] = &apos;n&apos;;
    value[c++] = &apos;u&apos;;
    value[c++] = &apos;l&apos;;
    value[c++] = &apos;l&apos;;
    count = c;
    return this;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二种情况：使用构造器传入null&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class StringBuffer01 {
    public static void main(String[] args) {
        String str = null;
        StringBuffer sb = new StringBuffer(str);//抛出异常
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public StringBuffer(String str) {
    super(str.length() + 16);//在源码这里因为null抛出异常
    append(str);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一个在价格中增添，的代码示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class StringBuffer01 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String price = sc.nextLine();//输入一个价格，在小数点前每隔3位用,隔离开
        StringBuffer sb = new StringBuffer(price);//123456.78
        int index = sb.indexOf(&quot;.&quot;);
        for(int i = index - 3; i &amp;gt; 0; i -= 3) {
            sb.insert(i, &quot;,&quot;);
        }
        System.out.println(sb);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;StringBuilder&lt;/h2&gt;
&lt;h3&gt;定义&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;public final class StringBuilder
    extends AbstractStringBuilder
    implements Serializable, CharSequence
{
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;是一个可变的字符序列，提供与StringBuffer兼容的API，但是不保证线程安全，被设计为StringBuffer的简易替换，用在字符串缓冲区被单个线程使用的时候&lt;/p&gt;
&lt;p&gt;如果可能优先使用StringBuilder，因为它的效率大多都要比StringBuffer快&lt;/p&gt;
&lt;p&gt;在StringBuilder上的主要操作时append和insert方法，可以重载这些方法用以接收任意类型的数据&lt;/p&gt;
&lt;p&gt;StringBuffer继承了AbstractStringBuilder类，可串行化，可以保存在文件，是一个final类型，不可被继承&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;abstract class AbstractStringBuilder implements Appendable, CharSequence {

    char[] value;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;字符存放在堆中&lt;/p&gt;
&lt;p&gt;StringBuilder的方法没有作互斥的处理，没有synchronization关键字，只能在单线程中使用&lt;/p&gt;
&lt;h2&gt;String三者比较&lt;/h2&gt;
&lt;p&gt;1.StringBuilder和StringBuffer类似，均代表可变字符序列，方法一致&lt;/p&gt;
&lt;p&gt;2.String是不可变字符序列，效率低，但是复用率高&lt;/p&gt;
&lt;p&gt;3.StringBuffer是可变字符序列，效率较高（增删），线程安全&lt;/p&gt;
&lt;p&gt;4.StringBuilder是可变字符序列，效率最高，线程不安全&lt;/p&gt;
&lt;h1&gt;课后练习&lt;/h1&gt;
&lt;p&gt;String str = new String(&quot;hello&quot;) + new String(&quot;word&quot;)过程中产生了几个对象&lt;/p&gt;
&lt;p&gt;在Java中，当你使用&lt;code&gt;+&lt;/code&gt;运算符进行字符串拼接时，编译器会自动进行优化，底层实际上是使用&lt;code&gt;StringBuilder&lt;/code&gt;来实现的。这是出于性能和内存效率的考虑。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;String str = new String(&quot;hello&quot;) + new String(&quot;word&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编译器会将其转换为类似以下的字节码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;StringBuilder sb = new StringBuilder();
sb.append(new String(&quot;hello&quot;));
sb.append(new String(&quot;word&quot;));
String str = sb.toString();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1.反转字符串（将指定的部分反转）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Homework {
    public static void main(String[] args) {
        String str = new String(&quot;HelloWorld&quot;);
        str = reverse(str, 0, str.length() - 1);
        System.out.println(str.toString());
    }

    public static String reverse(String str, int start, int end) {
        char[] arr = str.toCharArray();
        for (int i = start, j = end; i &amp;lt; j; i++, j--) {
            char temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
        return new String(arr);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.判断账号密码是否正确&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Homework {
    public static void main(String[] args) {
        String input = new Scanner(System.in).nextLine();
        String[] strArray = input.split(&quot;,&quot;);
        if(strArray[0].length() == 2 || strArray[0]
                .length() == 3 || strArray[0].length() == 4) {
            System.out.println(&quot;用户名正确&quot;);
        }
        if(strArray[1].length() == 6 &amp;amp;&amp;amp; isDigital(strArray[1])) {
            System.out.println(&quot;密码正确&quot;);
        }
    }
    public static boolean isDigital(String str) {
        char[] chars = str.toCharArray();
        for (int i = 0; i &amp;lt; chars.length; i++) {
            if (!Character.isDigit(chars[i])) {
                return false;
            }
        }
        return true;
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;100,123456
用户名正确
密码正确
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>面试小结</title><link>https://thrinisty.github.io/posts/%E9%9D%A2%E8%AF%95%E5%B0%8F%E7%BB%93/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/%E9%9D%A2%E8%AF%95%E5%B0%8F%E7%BB%93/</guid><description>字节跳动面试总结</description><pubDate>Thu, 27 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;面试小结&lt;/h1&gt;
&lt;p&gt;这一次面试没有想象中的那么压力山大，面试官也没有去死咬着某个知识点去提问，而是通过投递的简历来提问，其中计算机操作系统相关的题目较多，而我有对计算机系统方面的线程进程问题又比较了解，在这个部分表现得还算过得去，但是在于存储的方面我确实没有一个很好的实践积累，回答的大多都是在理论上的知识点，还有设备IO方面，我知道的也不是很多，面试官看我不是很清楚也就没有深挖。计算机网络相关的基础没有问到，不知道是不是看我的简历上有一两个网络编程的经验就跳过了。&lt;/p&gt;
&lt;p&gt;缺少知识点：多线程相关的细节，Mysql，Redis，哈希表，红黑树&lt;/p&gt;
&lt;p&gt;面试除了基础知识的提问，还考察了在设计项目上的思路，例如操作系统上如何去降低一个响应的时间：我除了进程之外也懂得不多，我就回答的是可以优化进程调度的一个策略，例如调整时间片大小，在线程之下创建亚线程。内存我直接不管了，另外加多CPU支持并行，多的我面试的时候也没有想到。&lt;/p&gt;
&lt;p&gt;以下是AI生成的其他回答&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; I/O优化
异步I/O：用非阻塞I/O（如epoll、io_uring）替代同步阻塞调用。

缓冲和批处理：合并小I/O请求为大操作（如磁盘写合并）。

SSD/高速存储：替换机械硬盘，降低I/O延迟。

内核参数调优
调整调度器：如Linux的CFS（完全公平调度器）参数或改用实时调度策略（SCHED_FIFO）。

中断优化：启用中断负载均衡（irqbalance），或绑定中断到特定CPU。

亚线程/协程：将任务拆分为更轻量级的单元（如协程、用户态线程），减少阻塞。

CPU绑定（Affinity）：将关键进程绑定到特定CPU核心，避免缓存失效和迁移开销。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;网络相关场景题&lt;/h3&gt;
&lt;p&gt;还有在网络繁忙的时候该如何解决大量访问的问题，这里我回答的是一个限流，以下是常见的限流算法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;令牌桶（Token Bucket）：

固定速率生成令牌，请求需消耗令牌（突发流量允许一定峰值）。

实现工具：Nginx limit_req、Redis + Lua脚本。

漏桶（Leaky Bucket）：

请求以恒定速率处理（平滑流量，严格限制突发）。

固定窗口/滑动窗口计数：

统计单位时间内的请求数（如每分钟100次），滑动窗口更精确但开销略高。

自适应限流：

根据系统负载动态调整阈值（如CPU、队列长度），如Netflix的Hystrix。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以下是AI回答&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;流量整形与负载均衡
队列缓冲：用消息队列（Kafka、RabbitMQ）异步处理请求，削峰填谷。

负载均衡：

横向扩展：增加服务实例，通过LB（如Nginx、HAProxy）分发流量。

智能路由：根据服务器负载动态分配请求（如Least Connections算法）。

服务降级与熔断
降级：关闭非核心功能（如推荐服务），返回缓存或默认值。

熔断：当错误率超过阈值时，短暂拒绝请求（如Hystrix、Resilience4j）。

服务隔离：将关键服务与非关键服务分离（如线程池隔离）。

缓存优化
多级缓存：

客户端缓存 → CDN → 服务端缓存（Redis）→ 数据库缓存。

热点数据预加载：提前缓存高频访问数据（如秒杀商品库存）。

弹性伸缩与云原生方案
自动扩缩容：Kubernetes HPA、AWS Auto Scaling。

Serverless：突发流量由无服务函数（如AWS Lambda）处理。

协议与连接优化
长连接复用：减少TCP握手开销（如HTTP/2、gRPC）。

压缩数据：减小传输体积（如Gzip、Protobuf）。

快速失败：设置超时时间（如TCP SYN队列调优）。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;哈希表和红黑树&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;：&lt;em&gt;“哈希表和红黑树有什么区别？如何选择？”&lt;/em&gt;
&lt;strong&gt;回答模板&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;先对比核心特性&lt;/strong&gt;：
“哈希表基于哈希函数，理想情况下查询是&lt;code&gt;O(1)&lt;/code&gt;，但可能因冲突退化；红黑树是自平衡二叉搜索树，稳定在&lt;code&gt;O(log n)&lt;/code&gt;，且支持有序遍历。”&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提优缺点&lt;/strong&gt;：
“哈希表内存占用大但查询快，适合字典类场景；红黑树更省内存且有序，适合范围查询。”&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;举例应用&lt;/strong&gt;：
“比如Java的&lt;code&gt;HashMap&lt;/code&gt;用哈希表实现快速查找，而&lt;code&gt;TreeMap&lt;/code&gt;用红黑树保证键的有序性。”&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;哈希表如何解决冲突？&lt;/strong&gt;
→ 拉链法（链表+红黑树，如Java 8的&lt;code&gt;HashMap&lt;/code&gt;）、开放寻址法。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;红黑树 vs AVL树？&lt;/strong&gt;
→ 红黑树牺牲严格平衡性换取更少的旋转操作，适合频繁插入删除的场景。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;算法题目&lt;/h3&gt;
&lt;p&gt;有思路的，可惜没有写出来，以下是题目样例，具体的输入我想不起来了&lt;/p&gt;
&lt;p&gt;我理解的这是一种压缩的方式：&lt;/p&gt;
&lt;p&gt;例如字符串 ab[avv]{2}dd 代表的是 abavvavvdd，要求写一个算法输入字符串，输出对应的字符串，这一道题我的理解是将 [ 放入栈结构里面，记录右侧下表，遇到]时候弹栈，读取后面的循环次数（限制为2-9，不然更麻烦了），循环输出，但是这里有个重点是这样一个[ ] 是要求可以嵌套使用的，最后写出来的只能处理不嵌套的一种样式，以下是 AI生成的算法，学学看吧&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.algorithm;
import java.util.Stack;

public class Interview {
    public static void main(String[] args) {
        String s1 = &quot;ab[avv]{2}dd&quot;;
        System.out.println(decodeString(s1));  // 输出: abavvavvdd

        String s2 = &quot;a[b[c]{2}]{3}d&quot;;
        System.out.println(decodeString(s2));  // 输出: abccbccbccd
    }

    // 手动实现的字符串重复方法（兼容 Java 8）
    public static String repeat(String str, int times) {
        if (times &amp;lt;= 0) {
            return &quot;&quot;;
        }
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i &amp;lt; times; i++) {
            sb.append(str);
        }
        return sb.toString();
    }

    public static String decodeString(String s) {
        Stack&amp;lt;StringBuilder&amp;gt; strStack = new Stack&amp;lt;&amp;gt;();
        Stack&amp;lt;Integer&amp;gt; numStack = new Stack&amp;lt;&amp;gt;();
        StringBuilder currentStr = new StringBuilder();
        int i = 0;
        int n = s.length();

        while (i &amp;lt; n) {
            char c = s.charAt(i);
            if (c == &apos;[&apos;) {
                // 遇到 &apos;[&apos;, 压栈当前状态
                strStack.push(currentStr);
                currentStr = new StringBuilder();
                i++;
            } else if (c == &apos;]&apos;) {
                // 遇到 &apos;]&apos;, 准备读取 &apos;{n}&apos;
                i++;  // 跳过 &apos;]&apos;
                if (i &amp;lt; n &amp;amp;&amp;amp; s.charAt(i) == &apos;{&apos;) {
                    i++;  // 跳过 &apos;{&apos;
                    if (i &amp;lt; n &amp;amp;&amp;amp; Character.isDigit(s.charAt(i))) {
                        int repeatTimes = s.charAt(i) - &apos;0&apos;;
                        i++;  // 跳过数字
                        if (i &amp;lt; n &amp;amp;&amp;amp; s.charAt(i) == &apos;}&apos;) {
                            i++;  // 跳过 &apos;}&apos;
                        }
                        // 弹出栈顶状态并使用自定义的repeat方法
                        StringBuilder prevStr = strStack.pop();
                        String repeatedStr = repeat(currentStr.toString(), repeatTimes);  // 使用自定义repeat
                        prevStr.append(repeatedStr);
                        currentStr = prevStr;
                    }
                }
            } else {
                // 普通字符，直接追加
                currentStr.append(c);
                i++;
            }
        }

        return currentStr.toString();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其实看起来还是有点困难的，主要还是我Java还没有学习到字符串相关的常用类String那里，哎，慢慢学吧&lt;/p&gt;
</content:encoded></item><item><title>Java笔记</title><link>https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E6%9E%9A%E4%B8%BE%E7%B1%BB%E6%B3%A8%E8%A7%A3%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E6%9E%9A%E4%B8%BE%E7%B1%BB%E6%B3%A8%E8%A7%A3%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</guid><description>枚举类，注解，异常处理</description><pubDate>Mon, 24 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Java笔记&lt;/h1&gt;
&lt;h2&gt;枚举类&lt;/h2&gt;
&lt;p&gt;在设计一个季节对象的时候，我们可以用传统的方式实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Enumeration {
    Season season = new Season(&quot;春天&quot;, &quot;温暖&quot;);
}

class Season {
    private String season;
    private String description;
    Season(String season, String description) {
        this.season = season;
        this.description = description;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是众所周知，季节只有四季，不能体现只有四个这个特征，为了解决这个问题，我们可以使用枚举类来定义季节，设计几个有限的值&lt;/p&gt;
&lt;h3&gt;枚举定义&lt;/h3&gt;
&lt;p&gt;是一组常量的集合：枚举是一种特殊的类，里面只包含一组有限的特定对象&lt;/p&gt;
&lt;p&gt;自定义枚举&lt;/p&gt;
&lt;p&gt;1.不需要提供set方法，因为枚举对象通常是只读的&lt;/p&gt;
&lt;p&gt;2.写枚举对象/属性的使用一般用final + static 修饰&lt;/p&gt;
&lt;p&gt;3.枚举对象名通常用大写来命名，常量的命名规范&lt;/p&gt;
&lt;p&gt;4.枚举对象根据需要也可以拥有多个属性&lt;/p&gt;
&lt;h3&gt;使用方式1&lt;/h3&gt;
&lt;p&gt;1.私有化构造器，防止直接new&lt;/p&gt;
&lt;p&gt;2.删去set方法，防止属性修改&lt;/p&gt;
&lt;p&gt;3.在Season内部直接创建固定对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Enumeration {
    Season season = Season.SPRING;
}

class Season {
    private String season;
    private String description;

    public static final Season SPRING = new Season(&quot;春天&quot;, &quot;温暖&quot;);
    public static final Season SUMMER = new Season(&quot;夏天&quot;, &quot;炎热&quot;);
    public static final Season AUTUMN = new Season(&quot;秋天&quot;, &quot;凉爽&quot;);
    public static final Season WINTER = new Season(&quot;冬天&quot;, &quot;寒冷&quot;);
    
    private Season(String season, String description) {
        this.season = season;
        this.description = description;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;使用方式2&lt;/h3&gt;
&lt;p&gt;使用关键字enum&lt;/p&gt;
&lt;p&gt;使用细节&lt;/p&gt;
&lt;p&gt;1.要将枚举对象放在枚举类的行首&lt;/p&gt;
&lt;p&gt;2.常量之间用“，”间隔&lt;/p&gt;
&lt;p&gt;3.常量通过构造器构造，必须知道用哪一个构造器&lt;/p&gt;
&lt;p&gt;4.使用无参构造器的时候可以省略形参列表和小括号&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Enumeration {
    Season season = Season.SPRING;
}

enum Season {
    SPRING(&quot;春天&quot;, &quot;温暖&quot;),
    SUMMER(&quot;夏天&quot;, &quot;炎热&quot;),
    AUTUMN(&quot;秋天&quot;, &quot;凉爽&quot;),
    WINTER(&quot;冬天&quot;, &quot;寒冷&quot;);

    private String season;
    private String description;

    private Season(String season, String description) {
        this.season = season;
        this.description = description;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.当使用enum关键字开发一个枚举类的时候，默认继承了Enum类&lt;/p&gt;
&lt;p&gt;这里可以运用反编译来进行证明&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;PS C:\Users\71460\Desktop\Java\IDEA\chapter11\out\production\chapter11\com\enum_&amp;gt; javap Season.class
Compiled from &quot;Enumeration.java&quot;
final class com.enum_.Season extends java.lang.Enum&amp;lt;com.enum_.Season&amp;gt; {
  public static final com.enum_.Season SPRING;
  public static final com.enum_.Season SUMMER;
  public static final com.enum_.Season AUTUMN;
  public static final com.enum_.Season WINTER;
  public static com.enum_.Season[] values();
  public static com.enum_.Season valueOf(java.lang.String);
  static {};
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Enum类&lt;/h3&gt;
&lt;p&gt;关键enum字修饰的类隐式的继承了Enum类，这个类中有一些常用的方法&lt;/p&gt;
&lt;p&gt;挨个解释有点麻烦，这里直接上代码示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Enumeration {
    public static void main(String[] args) {
        Season season = Season.WINTER;
        System.out.println(season.toString());// WINTER 输出枚举的名字
        System.out.println(season.name());// WINTER 输出枚举的名字
        System.out.println(season.ordinal());// 3 输出枚举对象的次序，从0开始编号
        for (Season s : Season.values()) {
            System.out.println(s.toString()); // 输出一个枚举常量的数组
        }
        Season season2 = Season.valueOf(&quot;SPRING&quot;);// 用valueOf可以将字符串转为枚举常量
        System.out.println(season2.compareTo(season));
        //-3 比较两个枚举类型，return self.ordinal - other.ordinal;
    }

}

enum Season {
    SPRING(&quot;春天&quot;, &quot;温暖&quot;),
    SUMMER(&quot;夏天&quot;, &quot;炎热&quot;),
    AUTUMN(&quot;秋天&quot;, &quot;凉爽&quot;),
    WINTER(&quot;冬天&quot;, &quot;寒冷&quot;);

    private String season;
    private String description;

    private Season(String season, String description) {
        this.season = season;
        this.description = description;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Enum使用细节&lt;/p&gt;
&lt;p&gt;1.enum不可以继承其他类，因为已经继承了Enum父类&lt;/p&gt;
&lt;p&gt;2.枚举类和普通类一样可以实现接口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Homework {
    public static void main(String[] args) {
        Week week = Week.TUESDAY;
        week.doSomething();
    }
}

interface Doing {
    void doSomething();
}

enum Week implements Doing {
    MONDAY(&quot;星期一&quot;),
    TUESDAY(&quot;星期二&quot;),
    WEDNESDAY(&quot;星期三&quot;);

    private String name;
    private Week(String name) {
        this.name = name;
    }

    @Override
    public void doSomething() {
        System.out.println(name);
    }

    @Override
    public String toString() {
        return name;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;注解&lt;/h2&gt;
&lt;h3&gt;定义&lt;/h3&gt;
&lt;p&gt;注解（Annotation）也被称为元数据（Metadata）&lt;/p&gt;
&lt;p&gt;1.用于修饰包，类，方法，属性，构造器，局部变量的数据信息&lt;/p&gt;
&lt;p&gt;2.和注释一样，注解不影响程序逻辑，但是注解可以被编译运行，相当于嵌入在代码中的补充信息&lt;/p&gt;
&lt;p&gt;3.在JavaSE中，注解使用的目的比较简单，例如标记过过时的功能，忽略警告等&lt;/p&gt;
&lt;p&gt;4.在JavaEE中注解占据了更加重要的角色，例如配置应用程序的任何切面，代替JavaEE旧版中所遗留的，繁冗代码和XML配置等&lt;/p&gt;
&lt;h3&gt;三个基本的Annotation&lt;/h3&gt;
&lt;h4&gt;@Override&lt;/h4&gt;
&lt;p&gt;限定某个方法，是重写父类方法，该注解只可以用于方法&lt;/p&gt;
&lt;p&gt;源码中的override注解说明，其中@target是注解注解的注解&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE)
public @interface Override {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;加上了这个注解，编译器会检查子类是否重写父类方法，如果没有重写会报错&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Father {
    public Father() {}
    public void Print() {
        System.out.println(&quot;Father&quot;);
    }
}

class Child extends Father {
    public Child() {}
    @Override//加上了override注解
    public void Print() {
        System.out.println(&quot;Child&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;@Deprecated&lt;/h4&gt;
&lt;p&gt;可以做版本过渡使用（保证了兼容性）&lt;/p&gt;
&lt;p&gt;用于表示某个程序元素（类，方法等）已过时，可以修饰方法，字段，包，参数，类，局部变量，类型等&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE})
public @interface Deprecated {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在以下代码中表示Child类以及过时，但是还是可以使用，只是不建议使用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/77.png&quot; alt=&quot;77&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Deprecated
class Child extends Father {
    public Child() {}
    @Override
    public void Print() {
        System.out.println(&quot;Child&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;@SuppressWarnings&lt;/h4&gt;
&lt;p&gt;抑制编译器警告&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})
@Retention(RetentionPolicy.SOURCE)
public @interface SuppressWarnings {
    String[] value();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在编写代码的时候，往往会出现一些黄色的线条勾选部分代码，如果在合理的范围中你不想见到这一些警告，你可以使用@SuppressWarnings不显示一些警告信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Main {
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;her&quot;);
        list.add(&quot;he&quot;);
        list.add(&quot;it&quot;);
        System.out.println(list.get(0));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以下是使用方式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Main {
    @SuppressWarnings({&quot;all&quot;})//忽略编译警告
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;her&quot;);
        list.add(&quot;he&quot;);
        list.add(&quot;it&quot;);
        System.out.println(list.get(0));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在{ }中填入对应需要忽略的警告信息，有点类似字符串数组的静态创建（其实本质就是一个字符串数组，可以查看jdk源码验证）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; String[] value();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外该注解的作用范围和注解的位置有关，像如上代码中抑制的范围是main方法中，或者更大的范围可以放在类上&lt;/p&gt;
&lt;h3&gt;JDK中的元注解&lt;/h3&gt;
&lt;p&gt;修饰注解的注解，再查看注解源码的时候可以用元注解了解注解相应作用即可&lt;/p&gt;
&lt;p&gt;@Retention注解的作用范围&lt;/p&gt;
&lt;p&gt;@Target使用位置&lt;/p&gt;
&lt;p&gt;@Documented 是否在javadoc中体现&lt;/p&gt;
&lt;p&gt;@inherited 子类会继承父类注解（使用较少）&lt;/p&gt;
&lt;p&gt;以下是一个例子&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Documented//会显示在javadoc文档
@Retention(RetentionPolicy.RUNTIME)//注解的注解范围（源码，类，运行时）
@Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE})//注解的使用场景
public @interface Deprecated {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;异常&lt;/h2&gt;
&lt;h3&gt;概念&lt;/h3&gt;
&lt;h4&gt;异常的概念&lt;/h4&gt;
&lt;p&gt;在Java中，将程序执行过程中发生的不正常情况称为异常&lt;/p&gt;
&lt;p&gt;分为两大类：Error错误以及Exception&lt;/p&gt;
&lt;p&gt;Error： Java 虚拟机无法解决的严重问题例如JVM系统内部错误，资源溢出&lt;/p&gt;
&lt;p&gt;Exception：由于编程错误或者偶然的外在因素导致的一般性问题，可以使用针对性地代码进行处理，异常又分为两大类，一种是编译时异常，另一种是运行时异常。&lt;/p&gt;
&lt;h4&gt;异常体系图&lt;/h4&gt;
&lt;p&gt;异常中又分为编译时异常（javac），运行时异常（java）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/78.png&quot; alt=&quot;78&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;异常处理概念&lt;/h4&gt;
&lt;p&gt;如果程序员认为代码会出现异常，可以使用try-catch异常处理机制来解决&lt;/p&gt;
&lt;p&gt;在程序运行的过程中有可能会发送各种异常，而发生程序异常的时候，程序往往发成崩溃&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Exception01 {
    public static void main(String[] args) {
        int num1 = 10;
        int num2 = 0;
        System.out.println(num1 / num2);
        System.out.println(&quot;程序运行完毕&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这一段代码不会输出最后运行完毕的提示消息，在写程序的时候不应该因为一个微小地异常而导致整个程序崩溃，我们可以通过运用异常处理机制来解决这个问题&lt;/p&gt;
&lt;p&gt;用ctrl alt + t -&amp;gt; 选中try-catch，如果异常处理，即使出现异常程序也可以正常执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Exception01 {
    public static void main(String[] args) {
        int num1 = 10;
        int num2 = 0;
        try {
            System.out.println(num1 / num2);
        } catch (Exception e) {
            System.out.println(&quot;异常被捕获&quot;);
        }
        System.out.println(&quot;程序运行完毕&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;异常被捕获
程序运行完毕
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;常见的异常&lt;/h3&gt;
&lt;h4&gt;运行时异常&lt;/h4&gt;
&lt;p&gt;空指针异常 NullPointerExceprion&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Exception01 {
    public static void main(String[] args) {
        String name = null;
        try {
            name.toString();
        } catch (NullPointerException e) {
            System.out.println(&quot;异常被捕获&quot;);
        }
        System.out.println(&quot;程序运行完毕&quot;);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;算数异常 ArithmeticException&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Exception01 {
    public static void main(String[] args) {
        int num1 = 10;
        int num2 = 0;
        try {
            System.out.println(num1 / num2);
        } catch (ArithmeticException e) {
            System.out.println(&quot;异常被捕获&quot;);
        }
        System.out.println(&quot;程序运行完毕&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;数组越界访问异常 ArrayIndexOutOfBoundsException&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Exception01 {
    public static void main(String[] args) {
        int[] arr = {1, 3, 4, 6, 7};
        try {
            System.out.println(arr[5]);
        } catch (ArrayIndexOutOfBoundsException e) {
            System.out.println(&quot;异常被捕获&quot;);
        }
        System.out.println(&quot;程序运行完毕&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;类型转换异常 ClassCastException&lt;/p&gt;
&lt;p&gt;解释说明：当将对象试图转换为不是实例的子类的时候会发生该异常&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Exception01 {
    public static void main(String[] args) {
        A a = new B();
        B b = (B) a;
        try {
            C c = (C) a;
        } catch (ClassCastException e) {
            System.out.println(&quot;异常被捕获&quot; + e.getMessage());
        }
        System.out.println(&quot;程序运行完毕&quot;);
    }
}

class A {
}

class B extends A {
}

class C {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是这里没有捕获到异常，程序崩溃（暂时未知原因，丢给AI解释说是和开发环境以及缓存有关，后续会查证）&lt;/p&gt;
&lt;p&gt;数字格式不正确 NumberFormatException&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Exception01 {
    public static void main(String[] args) {
        String name = &quot;thrinisty&quot;;
        try {
            int num = Integer.parseInt(name);
        } catch (NumberFormatException e) {
            System.out.println(&quot;异常被捕获&quot; + e.getMessage());
        }
        System.out.println(&quot;程序运行完毕&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;编译时异常&lt;/h4&gt;
&lt;p&gt;在编译期间就必须要处理的异常，否则代码不通过编译&lt;/p&gt;
&lt;p&gt;例如无对应文件异常，数据库异常等，在后续学习文件IO时候会进行补充&lt;/p&gt;
&lt;h3&gt;处理异常的方式&lt;/h3&gt;
&lt;p&gt;二选一即可&lt;/p&gt;
&lt;h4&gt;try-catch-finally&lt;/h4&gt;
&lt;p&gt;程序员在代码中捕获发送的异常，自行处理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;try {
   	//代码可能会出现异常，将异常封装为Exception对象e，传递catch
} catch (Exception e) {
   	//异常传递给catch
   	//用e来进行自定义处理
} finally {
    //（可以不写finally）
   	//不管try代码块是否有异常，始终要执行finally
    //一般是用来在这里进行资源关闭
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用细节：&lt;/p&gt;
&lt;p&gt;1.如果异常发生，则catch中异常后的代码不再执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu;

/**
 * @author 李昊轩
 * @version 1.0
 */
public class Exception01 {
    public static void main(String[] args) {
        String name = &quot;thrinisty&quot;;
        try {
            int num = Integer.parseInt(name);
            System.out.println(&quot;try 异常之后的代码&quot;);//不执行
        } catch (NumberFormatException e) {
            System.out.println(&quot;异常被捕获&quot; + e.getMessage());
        } finally {

        }
        System.out.println(&quot;程序运行完毕&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.如果没有发生异常，catch代码块不会被执行&lt;/p&gt;
&lt;p&gt;3.finally中的内容无论异常是否被接收都会被执行，一般用于释放资源&lt;/p&gt;
&lt;p&gt;4.可以有多个catch语句，捕获不同的异常，要求父异常写在后，子异常在前例如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu;

/**
 * @author 李昊轩
 * @version 1.0
 */
public class Exception01 {
    public static void main(String[] args) {
        String name = &quot;thrinisty&quot;;
        try {
            int num = Integer.parseInt(name);
            System.out.println(&quot;try 异常之后的代码&quot;);
        } catch (NumberFormatException e) {
            System.out.println(&quot;转换异常被捕获&quot; + e.getMessage());
        } catch (Exception e) {
            System.out.println(&quot;异常发生&quot;);
        } finally {
            System.out.println(&quot;finally&quot;);
        }
        System.out.println(&quot;程序运行完毕&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.try-finally配合使用：用于执行一段代码，之后无论异常是否发生，都会执行finally代码块&lt;/p&gt;
&lt;p&gt;一个容易出错的题目：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/80.png&quot; alt=&quot;80&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;throws&lt;/h4&gt;
&lt;p&gt;将发生的异常抛出，交给调用者（方法）来进行处理，最顶端的处理者是JVM&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/79.png&quot; alt=&quot;79&quot; /&gt;&lt;/p&gt;
&lt;p&gt;假如在代码中没有进行throw显示的处理，而发生了异常，就会默认的抛出异常依次传递直到JVM处理异常，退出程序&lt;/p&gt;
&lt;p&gt;代码示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.util.Scanner;

/**
 * @author 李昊轩
 * @version 1.0
 */
public class Exception01 {
    public static void main(String[] args) {
        try {
            m1();
        } catch (FileNotFoundException e) {
            System.out.println(&quot;File not found&quot;);
        }
    }

    public static void m1() throws FileNotFoundException {
        FileInputStream fis = new FileInputStream(&quot;cd&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;异常交予main函数进行处理，抛出的异常可以是一个列表，对应的异常，异常的父异常&lt;/p&gt;
&lt;h4&gt;异常使用细节&lt;/h4&gt;
&lt;p&gt;1.编译异常必须处理&lt;/p&gt;
&lt;p&gt;2.对于运行时异常，程序中没有进行处理默认为throws方式处理&lt;/p&gt;
&lt;p&gt;3.子类重写父类方法的时候，要么抛出异常的规定，子类重写方法，所抛出的异常类型要和父类抛出的异常一致，要么为父类抛出异常类型的子类型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Father {
    public void sayHello() throws Exception {}
}

class Son extends Father {
    public void sayHello() throws IOException {}
}//子类不可以扩大异常范围
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.运行异常可以默认处理，但是编译异常必须显示的处理&lt;/p&gt;
&lt;h3&gt;课堂练习&lt;/h3&gt;
&lt;p&gt;输入整数，不是整数就继续输入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Exception01 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int num = 0;
        System.out.print(&quot;输入一个整数 &quot;);
        while (true) {
            try {
                num = Integer.parseInt(sc.nextLine());
                break;
            } catch (Exception e) {
                System.out.println(&quot;请重新输入...&quot;);
            }
        }
        System.out.println(num);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;自定义异常&lt;/h3&gt;
&lt;p&gt;使用步骤：&lt;/p&gt;
&lt;p&gt;1.定义类：自定义异常类名，继承Exception或者RuntimeException&lt;/p&gt;
&lt;p&gt;2.继承Exception属于编译异常&lt;/p&gt;
&lt;p&gt;3.继承RuntimeException是运行异常&lt;/p&gt;
&lt;p&gt;通过throw关键字抛出对应的自定义异常，并运用构造器传入异常信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Exception01 {
    public static void main(String[] args) {
        int age = 15;
        try {
            test(age);
        } catch (TypeException e){
            System.out.println(e.getMessage());
        }
    }

    public static void test(int age) {
        if(age &amp;lt; 18) {
            throw new TypeException(&quot;年龄要在18岁以上&quot;);
        }
    }
}

class TypeException extends RuntimeException {
    public TypeException(String message) {
        super(message);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;throw与throws&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../images/81.png&quot; alt=&quot;81&quot; /&gt;&lt;/p&gt;
&lt;p&gt;到此枚举类，注解，异常处理的部分结束&lt;/p&gt;
</content:encoded></item><item><title>Java笔记</title><link>https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%8E%A5%E5%8F%A3%E5%86%85%E9%83%A8%E7%B1%BB/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%8E%A5%E5%8F%A3%E5%86%85%E9%83%A8%E7%B1%BB/</guid><description>抽象类，接口，内部类</description><pubDate>Sun, 23 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Java笔记&lt;/h1&gt;
&lt;h2&gt;抽象类&lt;/h2&gt;
&lt;h3&gt;使用场景&lt;/h3&gt;
&lt;p&gt;当父类方法不确定的时候，需要声明但是不知道该如何实现的时候，可以将其声明为抽象方法，这个类就是抽象类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Animal {
    private String name;
    
    public Animal(String name) {
        this.name = name;
    }
    
    public void eat() {
        System.out.println(&quot;吃一个...&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个时候可以将该方法设计为抽象方法，所谓抽象方法就是没有实现的方法（没有方法体）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;abstract class Animal {
    private String name;

    public Animal(String name) {
        this.name = name;
    }

    public abstract void eat();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当将一个类中的方法设置为抽象方法的时候，要将类也声明为抽象类&lt;/p&gt;
&lt;p&gt;使用方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;访问修饰符 abstract 返回类型 方法名（）;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再用子类继承实现这些抽象方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Dog extends Animal {
    public Dog(String name) {
        super(name);
    }

    public void eat() {
        System.out.println(&quot;Dog eat&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;抽象类的价值更多的是在于设计，在设计者设计好后，让子类继承并实现&lt;/p&gt;
&lt;h3&gt;抽象类细节&lt;/h3&gt;
&lt;p&gt;1.抽象类不能够被实例化&lt;/p&gt;
&lt;p&gt;2.抽象类不一定要包含抽象方法&lt;/p&gt;
&lt;p&gt;3.抽象方法所在的类必须用abstract修饰&lt;/p&gt;
&lt;p&gt;4.abstract只能修饰类和方法&lt;/p&gt;
&lt;p&gt;5.抽象类可以有任意成员，非抽象方法，构造器，静态属性&lt;/p&gt;
&lt;p&gt;6.抽象方法不能有主体&lt;/p&gt;
&lt;p&gt;7.如果一个类继承了抽象类，则这个类必须要实现所有的抽象方法，除非他自己也声明为abstract类&lt;/p&gt;
&lt;p&gt;8.抽象方法不能够用private final static修饰，因为和重写实现型成悖论&lt;/p&gt;
&lt;h3&gt;模板设计模式&lt;/h3&gt;
&lt;p&gt;抽象类的实践&lt;/p&gt;
&lt;p&gt;需求&lt;/p&gt;
&lt;p&gt;1.有多个类，完成不同的任务&lt;/p&gt;
&lt;p&gt;2.要求能够统计得到各自完成的时间&lt;/p&gt;
&lt;p&gt;3.编程实现&lt;/p&gt;
&lt;p&gt;先使用不同的类实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.abstract_;

public class Abstract {
    public static void main(String[] args) {
        new AA().job();
        new BB().job();
    }
}

class AA {
    public void job() {
        long start = System.currentTimeMillis();
        long num = 0;
        for (long i = 0; i &amp;lt; 800000; i++) {
            num += i;
        }
        long end = System.currentTimeMillis();
        System.out.println(num);
        System.out.println(end - start);
    }
}

class BB {
    public void job() {
        long start = System.currentTimeMillis();
        long num = 0;
        for (long i = 0; i &amp;lt; 800000; i++) {
            num += i / 2;
        }
        long end = System.currentTimeMillis();
        System.out.println(num);
        System.out.println(end - start);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以将公共的部分提取出来&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.abstract_;

public class Abstract {
    public static void main(String[] args) {
        new AA().calulateTime();
        new BB().calulateTime();
    }
}

class AA {
    public void calulateTime() {
        long start = System.currentTimeMillis();
        job();
        long end = System.currentTimeMillis();
        System.out.println((end - start));
    }

    public void job() {
        long num = 0;
        for (long i = 0; i &amp;lt; 800000; i++) {
            num += i;
        }
        long end = System.currentTimeMillis();
        System.out.println(num);
    }
}

class BB {
    public void calulateTime() {
        long start = System.currentTimeMillis();
        job();
        long end = System.currentTimeMillis();
        System.out.println((end - start));
    }

    public void job() {
        long num = 0;
        for (long i = 0; i &amp;lt; 800000; i++) {
            num += i / 2;
        }
        long end = System.currentTimeMillis();
        System.out.println(num);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果说加上了C在C类中还是必须要实现calulateTime方法，所以可以将job写为一个抽象方法，calulateTime在抽象类里实现，用各个子类继承实现job即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.abstract_;

public class Abstract {
    public static void main(String[] args) {
        new AA().calulateTime();
        new BB().calulateTime();
    }
}

abstract class DD {
    public void calulateTime() {
        long start = System.currentTimeMillis();
        job();
        long end = System.currentTimeMillis();
        System.out.println((end - start));
    }

    public abstract void job();
}

class AA extends DD {
    public void job() {
        long num = 0;
        for (long i = 0; i &amp;lt; 800000; i++) {
            num += i;
        }
        long end = System.currentTimeMillis();
        System.out.println(num);
    }
}

class BB extends DD {
    public void job() {
        long num = 0;
        for (long i = 0; i &amp;lt; 800000; i++) {
            num += i / 2;
        }
        long end = System.currentTimeMillis();
        System.out.println(num);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这里运用到了动态绑定机制，job调用的是子类的具体实现&lt;/p&gt;
&lt;p&gt;运用到模板设计模式，也已大幅度提高代码的复用性，简易性&lt;/p&gt;
&lt;h2&gt;接口&lt;/h2&gt;
&lt;h3&gt;快速入门&lt;/h3&gt;
&lt;p&gt;现实中使用充电器，usb接口，都有着统一的尺寸规定，方便用户使用，这种思路在语言编程中也有对应使用&lt;/p&gt;
&lt;p&gt;可以用以下代码模拟&lt;/p&gt;
&lt;p&gt;有如下接口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface UsbInterface {
    //规定接口的相关方法
    public void start();
    public void stop();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;手机实现了接口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.interface_;
//实现接口
public class Phone implements UsbInterface{
    public void start() {
        System.out.println(&quot;Phone start&quot;);
    }
    public void stop() {
        System.out.println(&quot;Phone stop&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;相机实现了接口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.interface_;

public class Camera implements UsbInterface{
    public void start(){
        System.out.println(&quot;Camera start&quot;);
    }
    public void stop(){
        System.out.println(&quot;Camera stop&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;电脑使用接口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.interface_;

public class Computer {
    public void work(UsbInterface usbInterface) {
        //通过接口调用接口方法
        usbInterface.start();
        usbInterface.stop();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;就可以传入接口，使用接口实现的类的接口实现方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.interface_;

public class Interface {
    public static void main(String[] args) {
        Camera camera = new Camera();
        Phone phone = new Phone();
        Computer computer = new Computer();
        computer.work(phone);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码中可以通过computer的work传入phone，调用phone的方法&lt;/p&gt;
&lt;h3&gt;基本介绍&lt;/h3&gt;
&lt;p&gt;接口就是给出一些没有实现的方法，封装在一起，在某个类要使用的时候，再根据具体的情况把这些方法写出来，语法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;interface 接口名 {
	//属性
	//方法
}

class 类名 implements 接口名 {
	//属性
	//方法
	//必须实现的接口抽象方法
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：在jdk7之前的接口中没有方法体，都是抽象方法，而在jdk8之后接口可以有静态方法，默认方法，也就是接口中可以有方法的具体实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.interface_;

public interface AInterface {
    public int num = 0;
    public void hi();//在接口中不需要加abstract，默认为抽象方法
    public default void lo() {//默认的方法实现，使用default
        System.out.println(1);
    }
    public static void test() {
        System.out.println(&quot;test&quot;);
    }
}

class A implements AInterface {
    @Override
    public void hi() {
        System.out.println(&quot;hi&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;接口的使用场景&lt;/h3&gt;
&lt;p&gt;1.在设计飞机时，专家规定飞机需要实现的功能/规格即可，让别人具体实现&lt;/p&gt;
&lt;p&gt;2.项目经理，管理三个程序员，功能开发一个软件，为了控制和管理软件，项目经理可以定义一些接口，然后由程序员具体实现&lt;/p&gt;
&lt;p&gt;例如：3个程序员编写三各类，分别完成对于MySQL，Oracle，DB2数据库的 connect &amp;amp; close的定义，可以分别对三个数据库规定三个接口，三个程序员就必须要统一连接和关闭的方法名，接口也可以识别connect &amp;amp; close对应的是哪一个接口&lt;/p&gt;
&lt;p&gt;接口的使用细节&lt;/p&gt;
&lt;p&gt;1.接口不能够被实例化&lt;/p&gt;
&lt;p&gt;2.接口中所有的方法是public方法，接口中的抽象方法可以不用abstract修饰方法也可以不用public修饰&lt;/p&gt;
&lt;p&gt;3.一个普通类实现接口，就必须将接口中的方法都实现&lt;/p&gt;
&lt;p&gt;4.抽象类实现接口，可以不用实现接口的方法&lt;/p&gt;
&lt;p&gt;5.一个类可以同时实现多个接口（类的继承不允许继承多个类）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class A implements IB, IC {
    //实现IB接口
    //实现IC接口
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;6.接口中的属性只能是final的，而且是public static final 修饰符，比如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int a = 1;
//实际上是 public static final int a = 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;7.接口中属性的访问形式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;接口名.属性名
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;8.一个接口不能继承其他的类，但是可以继承多个别的接口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;interface A extends B, C {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;9.接口的修饰符只能够是public和默认，和类的修饰符同理&lt;/p&gt;
&lt;p&gt;一个课堂练习，以下三种方式均可以成功访问&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.interface_;

import com.sun.xml.internal.ws.api.model.wsdl.WSDLOutput;

public class AInterface {
    public static void main(String[] args) {
        A a = new A();
        System.out.println(a.num);//通过实例对象引用接口中的成员
        System.out.println(A.num);//通过类使用接口静态成员
        System.out.println(InterfaceTest.num);//通过接口使用静态成员
    }
}
interface InterfaceTest {
    int num = 1;
}

class A implements InterfaceTest {

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;接口VS继承&lt;/h3&gt;
&lt;p&gt;接口在Java中算单继承的补充，例如一只小猴，对于猴类来说，猴子天生就会爬树，这算是继承，但是如果要学会游泳，这只猴子就需要去学习游泳（实现游泳接口的功能）&lt;/p&gt;
&lt;p&gt;接口比继承更加灵活，继承是is — a 的关系，而接口只需要满足 like — a 的关系&lt;/p&gt;
&lt;p&gt;接口在一定程度上实现代码的解耦（接口的规范性 + 动态绑定机制）在后续讲解源码的时候会有所涉及&lt;/p&gt;
&lt;h3&gt;接口的多态特性&lt;/h3&gt;
&lt;p&gt;1.多态参数&lt;/p&gt;
&lt;p&gt;例如在前面涉及到的入门，电脑在调用接口参数的时候，这个参数可以接受实现了这个接口的对象实例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.interface_;

public class Interface {
    public static void main(String[] args) {
        Camera camera = new Camera();
        Phone phone = new Phone();
        Computer computer = new Computer();
        computer.work(phone);//手机和相机都实现了work中参数接口
        computer.work(camera);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外一个例子&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.interface_;

import com.sun.xml.internal.ws.api.model.wsdl.WSDLOutput;

public class AInterface {
    public static void main(String[] args) {
        InterfaceTest iface = new A();
        InterfaceTest iface2 = new B();
    }
}
interface InterfaceTest {}
class A implements InterfaceTest {}
class B implements InterfaceTest {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接口类型应用变量可以指向实现了接口的对象实例，这个和继承多态类似（向下转型）&lt;/p&gt;
&lt;p&gt;2.多态数组&lt;/p&gt;
&lt;p&gt;同继承的多态，我们可以使用向下转型，使用运行类型的方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.interface_;

public class AInterface {
    public static void main(String[] args) {
        USBInterface[] usbInterfaces = new USBInterface[3];
        usbInterfaces[0] = new PhoneA();
        usbInterfaces[1] = new PhoneB();
        usbInterfaces[2] = new PhoneA();
        for (int i = 0; i &amp;lt; usbInterfaces.length; i++) {
            usbInterfaces[i].start();
            if (usbInterfaces[i] instanceof PhoneA) {
                ((PhoneA) usbInterfaces[i]).call();
            }
        }
    }
}
interface USBInterface {
    void start();
}

class PhoneA implements USBInterface {
    public void start() {
        System.out.println(&quot;Phone A start&quot;);
    }

    public void call() {
        System.out.println(&quot;Phone A call&quot;);
    }
}

class PhoneB implements USBInterface {
    public void start() {
        System.out.println(&quot;Phone B start&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.接口的多态传递&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.interfacearr;

public class InterfacePoly {
    IG ig = new Teacher();//接口类型可以指向实现接口的实例对象
    IH ih = new Teacher();//因为IG继承于IH，所以teacher也实现了IG的接口
}

interface IH {
    void teach();
}
interface IG extends IH { }

class Teacher implements IG {
    //teacher也需要实现IG继承的IH接口
    public void teach() {
        System.out.println(&quot;Teacher&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;内部类&lt;/h2&gt;
&lt;p&gt;一个类的内部内嵌套了另外的一个类，内部的类称作内部类，是类的五大成员之一：属性，方法， 构造器，代码块，内部类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class A {
	class Inner {
		//内部类	
	}
}

class B {
	//其他类
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内部类的最大特点是可以直接访问私有属性，并且可以体现出类与类之间的包含关系，底层源码有大量的内部类&lt;/p&gt;
&lt;p&gt;有四种内部类&lt;/p&gt;
&lt;p&gt;第一类：定义在外部类局部上（比如方法内）&lt;/p&gt;
&lt;p&gt;1.局部内部类&lt;/p&gt;
&lt;p&gt;2.匿名内部类&lt;/p&gt;
&lt;p&gt;第二类：定义在外部类的成员位置上&lt;/p&gt;
&lt;p&gt;3.成员内部类（没用static修饰）&lt;/p&gt;
&lt;p&gt;4.静态内部类（使用static修饰）&lt;/p&gt;
&lt;h3&gt;局部内部类&lt;/h3&gt;
&lt;p&gt;1.可以直接访问外部类的所有成员&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Outer {
    private int n1 = 100;
    public Outer(int n1) {
        this.n1 = n1;
    }

    {
        System.out.println(&quot;代码块&quot;);
    }

    public void teach() {
        System.out.println(n1 + 1);
    }

    public void Print() {
        class Inner {//内部类
            public void function() {
                System.out.println(n1);//访问外部类属性
                teach();//访问外部类的方法
            }
        }
        System.out.println(n1);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.不能添加访问修饰符，因为它的地位是一个局部变量，但是可以使用final修饰，内部类可以被类继承&lt;/p&gt;
&lt;p&gt;3.作用域仅限于定义它的方法或代码块中&lt;/p&gt;
&lt;p&gt;4.局部内部类访问外部类成员方式：直接访问&lt;/p&gt;
&lt;p&gt;5外部类成员访问内部类方式：创建对象，再进行访问&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.inner;

public class Main {//其他类
    public static void main(String[] args) {
        Outer outer = new Outer(1);
        outer.Print();
    }
}

class Outer {
    private int n1 = 100;
    public Outer(int n1) {
        this.n1 = n1;
    }

    {
        System.out.println(&quot;代码块&quot;);
    }

    public void teach() {
        System.out.println(n1 + 1);
    }


    public void Print() {
        class Inner {//内部类
            public void function() {
                System.out.println(n1);
                teach();
            }
        }
        System.out.println(n1);
        Inner inner = new Inner();//先创建对象
        inner.function();//在进行调用
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;6.外部其他类不可以访问内部类&lt;/p&gt;
&lt;p&gt;7.如果外部类和内部类的成员重名的时候，默认遵循就近原则，如果想访问外部类的成员可以使用 外部类名.this.成员 访问&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.inner;

public class Main {//其他类
    public static void main(String[] args) {
        Outer outer = new Outer();
        outer.Print();
    }
}

class Outer {
    private int n1 = 100;
    {
        System.out.println(&quot;代码块&quot;);
    }

    public void Print() {
        class Inner {//内部类
            private int n1 = 200;
            public void function() {
                System.out.println(n1);//200，就近原则
                System.out.println(Outer.this.n1);//100，Outer.this本质是指的是Outer类的对象实例
            }
        }
        Inner inner = new Inner();
        inner.function();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;匿名内部类（重要！！）&lt;/h3&gt;
&lt;p&gt;本质是一个类，是一个内部类，是匿名的，同时还是一个对象&lt;/p&gt;
&lt;h4&gt;个人理解：&lt;/h4&gt;
&lt;p&gt;匿名内部类就是一个渣男，使用的时候创建了这样的一个内部类，这个内部类就会跑路，再也没有办法使用，还留下了一个孩子（匿名内部类的实例）。当然，孩子是有用的，可以调用匿名内部类实现的一切方法，通过这样就可以不用额外的创建一个新的类，极大的简化了代码&lt;/p&gt;
&lt;p&gt;基本语法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;new 类或接口 (参数列表) {
	类体
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码示例：传统上而言 写一个类实现接口，创建对象，在主方法中创建类的对象完成接口创建Tiger实例与调用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.inner;

public class Anonymous {
    public static void main(String[] args) {
        Outer04 outer04 = new Outer04();
        outer04.method();
    }
}

class Outer04 {//外部类
    private int n1 = 10;
    public void method() {
        //基于接口的匿名内部类
        //需求分析：想使用IA接口，并创建对象
        //传统上：写一个类实现接口，创建对象
        IA tiger = new Tiger();
        tiger.cry();
    }
}

interface IA {//接口
    void cry();
}

class Tiger implements IA{//一个类
    public void cry() {
        System.out.println(&quot;Tiger 叫&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;使用匿名内部类实现接口&lt;/h4&gt;
&lt;p&gt;不想创建类，只想单独一次实现接口，并使用方法，可以使用匿名内部类简化（这个匿名内部类不能被使用第二次）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.inner;

public class Anonymous {
    public static void main(String[] args) {
        Outer04 outer04 = new Outer04();
        outer04.method();
    }
}

class Outer04 {//外部类
    private int n1 = 10;
    public void method() {
        //基于接口的匿名内部类
        //需求分析：想使用IA接口，并创建对象
        IA tiger = new IA() {
            public void cry() {
                System.out.println(&quot;tiger 叫&quot;);
            }
        };
        tiger.cry();
    }
}

interface IA {//接口
    void cry();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这个例子中，tiger的编译类型是IA接口类型，而tiger的运行类型则是由底层系统分配名称的匿名内部类，这个类实现了接口，并立即创建实例，可以通过实例访问接口方法&lt;/p&gt;
&lt;p&gt;可以用tiger.getClass() 验证&lt;/p&gt;
&lt;p&gt;运行结构&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tiger 叫
运行类型为：class com.npu.inner.Outer04$1
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;使用匿名内部类重写一个类方法&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.inner;

public class Anonymous {
    public static void main(String[] args) {
        Outer04 outer04 = new Outer04();
        outer04.method();
    }
}

class Outer04 {
    private int n1 = 10;
    public void method() {
        Father father = new Father(&quot;jack&quot;){
            //jack的参数会被传递给Father的构造器！！
            int age = 19;
            @Override
            public void Print() {
                System.out.println(this.name+ &quot; 年龄是 &quot; + age);
            }
        };
        father.Print();
        System.out.println(&quot;运行类型为：&quot; + father.getClass());
    }
}

class Father {
    String name;
    Father(String name) {
        this.name = name;
    }

    public void Print() {
        System.out.println(this.name);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;基于抽象类的匿名内部类&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.inner;

public class Anonymous {
    public static void main(String[] args) {
        Outer04 outer04 = new Outer04();
        outer04.method();
    }
}

class Outer04 {
    private int n1 = 10;
    public void method() {
        Animal animal = new Animal(){
            public void eat(){
                System.out.println(&quot;吃&quot;);
            }
        };
        animal.eat();
        System.out.println(&quot;运行类型为：&quot; + animal.getClass());
    }
}

abstract class Animal {
    abstract void eat();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;匿名内部类的使用细节&lt;/h4&gt;
&lt;p&gt;1.内部类创建完的结果是一个实例对象&lt;/p&gt;
&lt;p&gt;我们要访问匿名内部类的方法可以通过这个实例对象直接用.调用方法，或者可以先用一个接口，抽象类，类的引用接收，再通过这个引用调用运行类型为匿名内部类的类方法&lt;/p&gt;
&lt;p&gt;2.可以直接访问外部类的所有成员，包含私有的&lt;/p&gt;
&lt;p&gt;3.不能添加访问修饰符，因为是一个局部变量&lt;/p&gt;
&lt;p&gt;4.作用域位于处于的方法或者代码块&lt;/p&gt;
&lt;p&gt;5.如果外部类和匿名内部类成员重名的时候，就近访问内部类的成员，要使用外部类的同名成员的时候需要使用 外部类名.this.成员名&lt;/p&gt;
&lt;p&gt;外部类名.this指的是调用method()的对象&lt;/p&gt;
&lt;h3&gt;匿名内部类使用场景&lt;/h3&gt;
&lt;p&gt;1.当作实参直接传递，简洁高效&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.inner;

public class Test {
    public static void main(String[] args) {
        f1(new IL(){
           @Override
           public void show() {
               System.out.println(&quot;鸡哥&quot;);
           }
        });
    }
    //静态方法
    public static void f1(IL il){
        il.show();
    }
}

interface IL{
    void show();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;传统上需要先实现一个实现了接口的类，再将类实例化，将实例传入f1，根据运行类型调用方法&lt;/p&gt;
&lt;p&gt;一个代码示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.inner;

public class Test {
    public static void main(String[] args) {
        Cellphone cellphone = new Cellphone();

        cellphone.alarmclock(new Bell() {
            @Override
            public void ring() {
                System.out.println(&quot;ring1&quot;);
            }
        });

        cellphone.alarmclock(new Bell() {
            @Override
            public void ring() {
                System.out.println(&quot;ring2&quot;);
            }
        });
    }
}

interface Bell {
    void ring();
}

class Cellphone {
    public void alarmclock (Bell bell) {
        bell.ring();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;成员内部类&lt;/h3&gt;
&lt;p&gt;成员内部类定义在外部类的成员位置&lt;/p&gt;
&lt;p&gt;1.内部类可以访问外部类的所有成员，包含私有的&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.inner;

public class Member {
    public static void main(String[] args) {
        Outer08 outer = new Outer08();
        outer.inner.Print();
    }
}

class Outer08 {
    private int n1 = 200;
    Inner inner = new Inner();
    {
        System.out.println(&quot;代码块&quot;);
    }
    class Inner {
        public void Print() {
            System.out.println(n1);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.成员内部类可以用访问修饰符修饰，因为它的地位是类的成员&lt;/p&gt;
&lt;p&gt;3.作用域为整个类体中&lt;/p&gt;
&lt;p&gt;4.访问同名成员的时候会遵循就近原则，要访问外部类的成员要使用 外部类名.this.重名成员 来进行访问&lt;/p&gt;
&lt;p&gt;5.外部其他类可以有如下的两种方式访问成员内部类&lt;/p&gt;
&lt;p&gt;1 使用外部类对象 通过new来创建一个成员内部类对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.inner;

public class Member {//其他类
    public static void main(String[] args) {
        Outer08 outer = new Outer08();
        Outer08.Inner inner = outer.new Inner();
    }
}

class Outer08 {
    private int n1 = 200;

    class Inner {
        public void Print() {
            System.out.println(n1);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2 再外部类中编写一个方法返回一个Inner的实例（将第一种写为方法）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.inner;

public class Member {//其他类
    public static void main(String[] args) {
        Outer08 outer = new Outer08();
        Outer08.Inner inner = outer.getInner();

    }
}

class Outer08 {
    private int n1 = 200;

    class Inner {
        public void Print() {
            System.out.println(n1);
        }
    }

    public Inner getInner() {
        return new Inner();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;静态内部类&lt;/h3&gt;
&lt;p&gt;定义在外部类的成员位置，由static修饰&lt;/p&gt;
&lt;p&gt;1.可以直接访问外部类的所有静态成员，包含私有的，但是不可以访问非静态成员&lt;/p&gt;
&lt;p&gt;2.成员内部类可以用访问修饰符修饰，因为它的地位是类的成员&lt;/p&gt;
&lt;p&gt;3.作用域为整个类体中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.inner;

public class Member {//其他类
    public static void main(String[] args) {
        Outer08 outer = new Outer08();
        outer.getInner();

    }
}

class Outer08 {
    private int n1 = 200;
    private static int n2 = 100;

    public static class Inner {
        public void Print() {
            System.out.println(n2);
        }
    }

    public void getInner() {
        Inner inner = new Inner();
        inner.Print();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.外部其他类使用静态内部类有以下几种方式&lt;/p&gt;
&lt;p&gt;1 用外部类静态创建内部类（不会创建外部类）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.inner;

public class Member {//其他类
    public static void main(String[] args) {
        Outer08.Inner inner = new Outer08.Inner();
        inner.Print();
    }
}

class Outer08 {
    private int n1 = 200;
    private static int n2 = 100;

    public static class Inner {
        public void Print() {
            System.out.println(n2);
        }
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2 静态方法返回&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.inner;

public class Member {//其他类
    public static void main(String[] args) {
        Outer08.Inner inner = Outer08.getInner();
        inner.Print();
    }
}

class Outer08 {
    private int n1 = 200;
    private static int n2 = 100;

    public static class Inner {
        public void Print() {
            System.out.println(n2);
        }
    }

    public static Inner getInner() {
        return new Inner();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.在遇到同名成员的时候默认就近访问，要访问外部类成员需要使用 外部类名.成员访问&lt;/p&gt;
</content:encoded></item><item><title>Java笔记</title><link>https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E7%B1%BB%E6%96%B9%E6%B3%95%E7%B1%BB%E5%8F%98%E9%87%8F%E4%BB%A3%E7%A0%81%E5%9D%97%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8Ffinal%E5%85%B3%E9%94%AE%E5%AD%97/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E7%B1%BB%E6%96%B9%E6%B3%95%E7%B1%BB%E5%8F%98%E9%87%8F%E4%BB%A3%E7%A0%81%E5%9D%97%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8Ffinal%E5%85%B3%E9%94%AE%E5%AD%97/</guid><description>类方法，类变量，代码块，设计模式，final关键字</description><pubDate>Thu, 20 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;听课笔记&lt;/h1&gt;
&lt;h2&gt;初级部分学习完成&lt;/h2&gt;
&lt;p&gt;终于完成了Java网络通讯的大作业，将整个项目的大致流程掌握，可以熟练的使用socket套接字进行TCP，UDP的网络编程，但是由于在进行项目的时候没有进行前置知识的学习，导致在多线程，异常处理，IO流的部分仍然无法自己独立完成，从这一课我将开始进入Java编程高级部分。&lt;/p&gt;
&lt;h2&gt;类变量和类方法&lt;/h2&gt;
&lt;h3&gt;类变量&lt;/h3&gt;
&lt;p&gt;以下是一个代码示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.static_;

public class ChildGame {
    public static void main(String[] args) {
        int count = 0;//记录有几个小孩加入游戏

        Child child1 = new Child(&quot;1&quot;);
        child1.join();
        count++;
        Child child2 = new Child(&quot;2&quot;);
        child2.join();
        count++;
        Child child3 = new Child(&quot;3&quot;);
        child3.join();
        count++;

        System.out.println(&quot;一共有 &quot; + count + &quot; 小孩&quot;);
    }

}

class Child {
    private String name;

    public Child(String name) {
        this.name = name;
    }

    public void join() {
        System.out.println(this.name + &quot; join&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们会很容易发现这样做count（独立于对象）没有办法在类方法中使用，我们必须要将这个计数的功能单独提取出来，这会弱化代码的可读性（没有面向对象）较为麻烦，这个时候我们就要将count设置为类变量（静态变量）&lt;/p&gt;
&lt;p&gt;使用static关键字可以修饰一个可以供所有类同时享用的变量&lt;/p&gt;
&lt;p&gt;语法定义：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;访问修饰符 static 数据类型 变量名 ; [推荐使用]
static 访问修饰符 数据类型 变量名 ;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用方式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;对象名.静态变量
类名.静态变量 [推荐使用]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.static_;

public class ChildGame {
    public static void main(String[] args) {


        Child child1 = new Child(&quot;1&quot;);
        Child child2 = new Child(&quot;2&quot;);
        Child child3 = new Child(&quot;3&quot;);

        child1.join();
        child2.join();
        child3.join();

        System.out.println(&quot;一共有 &quot; + Child.count + &quot; 小孩&quot;);
    }

}

class Child {
    private String name;
    public static int count = 0;

    public Child(String name) {
        this.name = name;
    }

    public void join() {
        System.out.println(this.name + &quot; join&quot;);
        count++;
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;各个孩子对象实例访问到的count都是同一个，加强count和Child类的联系&lt;/p&gt;
&lt;h3&gt;类变量在内存中的布局&lt;/h3&gt;
&lt;p&gt;类变量在不同版本有不同的存放方式，有存放在Class实例尾部中（堆），也有存放在方法区的静态域之中，但是在运用的时候，只需要了解静态变量可以供所有的（同一个类）对象共享，在类加载的时候生成&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.static_;

public class VisitStatic {
    public static void main(String[] args) {
        System.out.println(A.count);
        //无需创建类即可访问，因为是类加载的时候count就被创建
    }
}

class A {
    public static int count = 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;类方法&lt;/h3&gt;
&lt;p&gt;类方法也叫静态方法&lt;/p&gt;
&lt;p&gt;定义形式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;访问修饰符 static 数据返回类型 方法名 () {} [推荐使用]
static 访问修饰符 数据返回类型 方法名 () {} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;类方法的调用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;类名.类方法名()[推荐使用]
对象名.类方法名()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;类方法的使用场景&lt;/h3&gt;
&lt;p&gt;1.同类变量一样，在没有创建对象实例前可以通过类名来调用类方法&lt;/p&gt;
&lt;p&gt;代码示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.static_;

public class VisitStatic {
    public static void main(String[] args) {
        System.out.print(&quot;收钱前：&quot;);
        Stu.showFee();
        Stu tom = new Stu(&quot;Tom&quot;);
        Stu.payFee(100);
        Stu sony = new Stu(&quot;Sony&quot;);
        Stu.payFee(100);
        System.out.print(&quot;收钱后：&quot;);
        Stu.showFee();
    }
}

class Stu {
    private String name;
    private static double fee = 0.0;

    public Stu(String name) {
        this.name = name;
    }

    public static void payFee(double fee) {
        Stu.fee += fee;
    }

    public static void showFee() {
        System.out.println(fee);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.当方法中不涉及任何和对象相关的成员，可以将方法设计成为静态方法，提高开发效率（例如 Math 类），自己制作工具类的时候也推荐这样做&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.static_;

public class VisitStatic {
    public static void main(String[] args) {
        System.out.println(Math.abs(-3));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Math源码中的abs静态方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static int abs(int a) {
    return (a &amp;lt; 0) ? -a : a;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;类方法细节&lt;/h3&gt;
&lt;p&gt;1.类方法会随着类的加载而加载，将结构信息存放在方法区&lt;/p&gt;
&lt;p&gt;2.类方法中没有this super参数，不允许使用和对象有关的关键字&lt;/p&gt;
&lt;p&gt;3.类方法只能访问类方法类变量，不可以使用普通成员和普通方法&lt;/p&gt;
&lt;p&gt;4.普通成员方法可以使用类变量，也可以使用静态方法&lt;/p&gt;
&lt;h2&gt;main方法&lt;/h2&gt;
&lt;p&gt;一个常见的main方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Main {
    public static void main(String[] args) {
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1.main方法由java虚拟机调用，访问权限必须为public&lt;/p&gt;
&lt;p&gt;2.java虚拟机在执行main（）方法的时候不会创建对象，所以方法由static修饰&lt;/p&gt;
&lt;p&gt;3.该方法接收String类型的数组参数，该数组中保存执行java命令时所传递给所有运行类的参数，接收参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu;

public class Main {
    public static void main(String[] args) {
        for(int i = 0; i &amp;lt; args.length; i++) {
            System.out.println(&quot;第&quot;+ (i+1) + &quot;个参数&quot; + args[i]);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在运用终端java运行class的时候，通过终端传入参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;java 运行类名 第一个参数 第二个参数 第三个参数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;静态变量和静态方法可以被对应的类直接使用，我们可以在main中使用在类中定义的静态方法和静态变量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu;
public class Main {
    private static String name = &quot;Hello&quot;;
    private static void Print() {
        System.out.println(name);
    }
    public static void main(String[] args) {
        Print();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意这里不可以在main方法中使用非静态的方法变量，要使用的前提是新创建一个main的实例，通过实例对象来进行调用&lt;/p&gt;
&lt;p&gt;在IDEA继承的开发环境中可以通过如下设置传递命令行参数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/73.png&quot; alt=&quot;73&quot; /&gt;&lt;/p&gt;
&lt;p&gt;输入对应的参数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/74.png&quot; alt=&quot;74&quot; /&gt;&lt;/p&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/75.png&quot; alt=&quot;75&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;代码块&lt;/h2&gt;
&lt;p&gt;代码块又称为初始化块，属于类中的成员是类的一部分，类似于方法，将逻辑语句封装在方法体中，通过{ } 包围起来&lt;/p&gt;
&lt;p&gt;和方法不同没有方法名，没有返回没有参数，只有方法体，不能够通过对象或者类显式调用，而是在加载类的时候，或者创建对象的时候隐式的调用&lt;/p&gt;
&lt;p&gt;使用基本语法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[修饰符]{
	代码部分
};//;可选写或者不写
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修饰符可选static修饰，分别称作（static）静态代码块，普通代码块&lt;/p&gt;
&lt;h3&gt;代码块的使用场景&lt;/h3&gt;
&lt;p&gt;1.普通代码块相当于另外一种形式的构造器，可以进行初始化的操作&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu;
public class Main {
    public static void main(String[] args) {

    }
}

class Movie {
    private String title;
    private String director;
    private int year;

    public Movie(String title, String director, int year) {
        System.out.println(&quot;Movie&quot;);
        this.title = title;
        this.director = director;
        this.year = year;
    }

    public Movie(String title) {
        System.out.println(&quot;Movie&quot;);
        this.title = title;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如上的两个构造器都有输出，我们可以把相同的语句放入代码块中，在构造的时候会统一调用代码块（先调用普通代码块，后调用构造器），去除冗余&lt;/p&gt;
&lt;p&gt;代码示例如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu;
public class Main {
    public static void main(String[] args) {
        Movie movie = new Movie(&quot;2&quot;);
    }
}

class Movie {
    private String title;
    private String director;
    private int year;

    {
        System.out.println(&quot;Movie&quot;);
    }
    
    public Movie(String title, String director, int year) {
        this.title = title;
        this.director = director;
        this.year = year;
    }

    public Movie(String title) {
        this.title = title;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;代码块的使用细节&lt;/h3&gt;
&lt;h4&gt;1.静态代码块在类加载的时候执行，只会执行一次，如果是普通代码块每创建一个对象就执行一次&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;package com.npu;

public class CodeBlock {
    public static void main(String[] args) {
        new AA();
       
    }
}

class AA {
    static {
        System.out.println(&quot;AA静态代码块&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;2.类什么时候被加载（只会加载一次）&lt;/h4&gt;
&lt;p&gt;创建对象实例的时候&lt;/p&gt;
&lt;p&gt;创建子类对象实例父类会被加载&lt;/p&gt;
&lt;p&gt;使用类的静态成员变量的时候，代码块被加载&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu;

public class CodeBlock {
    public static void main(String[] args) {
        new BB();
    }
}

class AA {
    static {
        System.out.println(&quot;AA静态代码块&quot;);
    }
}

class BB extends AA {
    static {
        System.out.println(&quot;BB静态代码块&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;先加载父类代码块，在加载子类代码块&lt;/p&gt;
&lt;h4&gt;3.普通代码块在创建对象实例的时候被隐式调用，创建多少次调用多少次，但是在使用静态成员的时候，普通代码块不会被执行&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;package com.npu;

public class CodeBlock {
    public static void main(String[] args) {
        System.out.println(AA.i);
    }
}

class AA {
    static {
        System.out.println(&quot;AA静态代码块&quot;);
    }

    {
        System.out.println(&quot;AA的普通代码块&quot;);
    }

    public static int i;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如上输出为（因为没有创建对象不调用普通代码块）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;AA静态代码块
0
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;4.创建一个对象的时候，在一个类的调用顺序是：&lt;/h4&gt;
&lt;p&gt;1调用静态代码块，和静态属性初始化 优先级一致（和前后顺序有关）&lt;/p&gt;
&lt;p&gt;2调用普通代码块和普通属性的初始化&lt;/p&gt;
&lt;p&gt;3调用构造方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu;

public class CodeBlock {
    public static void main(String[] args) {
        AA a = new AA();
    }
}

class AA {
    public static int i = getN1();
    private int j = getJ();

    public AA(){
        System.out.println(&quot;构造器&quot;);
    }

    public static int getN1() {
        System.out.println(&quot;静态方法调用&quot;);
        return 100;
    }

    public int getJ() {
        System.out.println(&quot;普通方法调用&quot;);
        return 200;
    }

    static {
        System.out.println(&quot;AA静态代码块&quot;);
    }

    {
        System.out.println(&quot;AA的普通代码块&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;静态方法调用
AA静态代码块
普通方法调用
AA的普通代码块
构造器
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;5.构造器的最前端隐含了super和普通代码块&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;package com.npu;

public class CodeBlock {
    public static void main(String[] args) {
        BB b = new BB();
    }
}

class AA {
    {
        System.out.println(&quot;AA普通代码块&quot;);
    }

    public AA () {
        //super
        //本类的普通代码块
        System.out.println(&quot;AA构造器被调用&quot;);
    }
}

class BB extends AA {
    {
        System.out.println(&quot;BB普通代码块&quot;);
    }

    public BB() {
        //super
        //本类的普通代码块
        System.out.println(&quot;BB构造器被调用&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;AA普通代码块
AA构造器被调用
BB普通代码块
BB构造器被调用
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;6.静态代码块只能调用静态成员，普通代码块可以调用任意成员&lt;/h4&gt;
&lt;h2&gt;设计模式（单例）&lt;/h2&gt;
&lt;p&gt;设计模式是在大量的实践和总结下优选的代码结构，编程风格，以及解决问题的思考方式，设计模式类似于经典的棋谱，使用的时候套公式是最好的方式&lt;/p&gt;
&lt;p&gt;单例模式：要求采用一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法&lt;/p&gt;
&lt;p&gt;单例模式有两种：饿汉式，懒汉式&lt;/p&gt;
&lt;h3&gt;饿汉式&lt;/h3&gt;
&lt;p&gt;1.将构造器私有化（防止new）&lt;/p&gt;
&lt;p&gt;2.类的内部构造对象&lt;/p&gt;
&lt;p&gt;3.向外暴露一个静态的公共方法getInstance&lt;/p&gt;
&lt;p&gt;以下是代码具体实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu;

public class CodeBlock {
    public static void main(String[] args) {
        Game instance = Game.getInstance();
        String string = instance.toString();
        System.out.println(string);
    }
}

class Game {
    private String name;
    //将构造器私有化
    private Game (String name) {
        this.name = name;
    }
    //初始化创建静态实例
    private static Game game = new Game(&quot;饿汉&quot;);
    //提供对外静态调用方法
    public static Game getInstance() {
        return game;
    }

    public String toString() {
        return name;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;就算调用接口再建立一个Game引用指向的也是由静态创建的实例&lt;/p&gt;
&lt;p&gt;之所以是饿汉式，是因为如果要调用Game中的静态成员，就会提前自动创建对象实例，可能会造成资源的浪费(对象实例没有被使用)&lt;/p&gt;
&lt;p&gt;例如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu;

public class CodeBlock {
    public static void main(String[] args) {
        int j = Game.i;
    }
}

class Game {
    public static int i = 0;
    private String name;
    //将构造器私有化
    private Game (String name) {
        System.out.println(&quot;构造器被调用&quot;);
        this.name = name;
    }
    //初始化创建静态实例
    private static Game game = new Game(&quot;饿汉&quot;);
    //提供对外静态调用方法
    public static Game getInstance() {
        return game;
    }

    public String toString() {
        return name;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;构造器被调用，结果输出&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;构造器被调用
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;懒汉式&lt;/h3&gt;
&lt;p&gt;事实上是懒汉式的改进&lt;/p&gt;
&lt;p&gt;1.将构造器私有化&lt;/p&gt;
&lt;p&gt;2.定义一个static静态属性对象（没用new创建实例）&lt;/p&gt;
&lt;p&gt;3.提供一个public的static方法，在方法中创建实例&lt;/p&gt;
&lt;p&gt;以下是代码示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu;

public class CodeBlock {
    public static void main(String[] args) {
        Game instance = Game.getInstance();
        String string = instance.toString();
        System.out.println(string);
    }
}

class Game {
    private String name;
    //将构造器私有化
    private Game (String name) {
        System.out.println(&quot;构造器调用&quot;);
        this.name = name;
    }
    //初始化创建静态实例
    private static Game game;
    //提供对外静态调用方法
    public static Game getInstance() {
        if (game == null) {
            game = new Game(&quot;懒汉&quot;);
        }
        return game;
    }

    public String toString() {
        return name;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在类加载的时候不会立即创建实例对象，而是通过静态的方法中创建&lt;/p&gt;
&lt;p&gt;而通过判断语句可以使得只创建一个实例对象&lt;/p&gt;
&lt;p&gt;这样就可以省去单例对象资源的浪费&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu;

public class CodeBlock {
    public static void main(String[] args) {
        System.out.println(Game.i);
    }
}

class Game {
    private String name;
    public static int i = 0;
    //将构造器私有化
    private Game (String name) {
        System.out.println(&quot;构造器调用&quot;);
        this.name = name;
    }
    //初始化创建静态实例
    private static Game game;
    //提供对外静态调用方法
    public static Game getInstance() {
        if (game == null) {
            game = new Game(&quot;懒汉&quot;);
        }
        return game;
    }

    public String toString() {
        return name;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;补充内容&lt;/h3&gt;
&lt;p&gt;饿汉式不存在线程安全问题，而懒汉式存在线程安全问题（多个线程同时判断game == null 从而创建多个对象）&lt;/p&gt;
&lt;h2&gt;final关键字&lt;/h2&gt;
&lt;p&gt;final可以修饰类，属性，方法，局部变量&lt;/p&gt;
&lt;h3&gt;使用场景&lt;/h3&gt;
&lt;h4&gt;1.当不希望类被继承的时候使用&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;package com.npu;

public class final_ {
    public static void main(String[] args) {

    }
}

final class A {
//用final修饰
}

class B extends A {
//错误
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;2.当不希望父类的某个方法被子类覆盖（重写），可以用final修饰&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;package com.npu;

public class final_ {
    public static void main(String[] args) {

    }
}

class A {
    final public void Print(){//final修饰，不允许重写
        System.out.println(1);
    }
}

class B extends A {
    @Override//报错
    public void Print(){
        System.out.println(2);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;3.当不希望类的某个值被修改，可以用final修饰&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;package com.npu;

public class final_ {
    public static final double Pi = 3.14;
    public static void main(String[] args) {
        Pi = 9;//报错，final修饰的属性不允许修改
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;4.当不希望某个局部变量被修改&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;package com.npu;

public class final_ {
    public static void main(String[] args) {

    }
}

class Tool {
    public void test() {
        final double i = 2.0;
        i = 1.0;//报错，不允许修改final修饰的局部变量
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;final细节&lt;/h3&gt;
&lt;p&gt;1.final修饰的属性被称作常量，一般用XX_XX_XX_XX来命名&lt;/p&gt;
&lt;p&gt;2.final修饰的属性需要在定义的时候初始化（定义时，构造器，代码块选择其一）&lt;/p&gt;
&lt;p&gt;3.如果final修饰的属性使静态的，则初始化的位置只能是在定义时，静态代码块（注意不可以是在构造器中初始化，因为静态变量的赋值在构造器之前）&lt;/p&gt;
&lt;p&gt;4.如果不是final类，但是含有final方法，不可以重修final方法，但是类可以被继承&lt;/p&gt;
&lt;p&gt;5.一般来说类用final修饰，就没有必要将类中的方法用final修饰了&lt;/p&gt;
&lt;p&gt;6.final不能修饰构造器&lt;/p&gt;
&lt;p&gt;7.final和static往往搭配使用，效率更高，不会导致类的加载，例如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu;

public class final_ {
    public static void main(String[] args) {
        int num = Tool.num;
    }
}

class Tool {
    public final static int num = 10000;
    static {
        System.out.println(&quot;static block&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编译器优化，不会加载静态代码块&lt;/p&gt;
&lt;p&gt;8.包装类例如Integer，Double，Float，Boolean都是final类&lt;/p&gt;
&lt;p&gt;今天的内容就此结束，明天将会学习抽象类，接口，内部类&lt;/p&gt;
</content:encoded></item><item><title>项目标准开发流程</title><link>https://thrinisty.github.io/posts/%E9%A1%B9%E7%9B%AE%E6%A0%87%E5%87%86%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/%E9%A1%B9%E7%9B%AE%E6%A0%87%E5%87%86%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/</guid><description>企业标准开发流程</description><pubDate>Mon, 17 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;项目开发流程&lt;/h1&gt;
&lt;p&gt;需求分析---设计阶段---编码实现---测试阶段---实施阶段&lt;/p&gt;
&lt;h2&gt;1.需求分析（需求分析师）&lt;/h2&gt;
&lt;p&gt;目的是产出一个需求分析报告，包含客户具体要求，项目功能&lt;/p&gt;
&lt;h2&gt;2.设计阶段（架构师/项目经理）&lt;/h2&gt;
&lt;p&gt;设计工作UML类图，流程图，模块设计，数据库，架构，原型开发 组建团队&lt;/p&gt;
&lt;h2&gt;3.实现阶段（程序员/码农）&lt;/h2&gt;
&lt;p&gt;完成架构师的模块功能，测试自己的模块&lt;/p&gt;
&lt;h2&gt;4.测试阶段（测试工程师）&lt;/h2&gt;
&lt;p&gt;单元测试，测试用例，白盒测试，黑盒测试，集成测试&lt;/p&gt;
&lt;h2&gt;5.实施阶段（实施工程师）&lt;/h2&gt;
&lt;p&gt;将项目部署到客户的平台，保证运行正常，要求对环境的部署能力要高&lt;/p&gt;
&lt;h2&gt;6.维护阶段（不固定人员）&lt;/h2&gt;
&lt;p&gt;Debug，项目升级，发现bug&lt;/p&gt;
</content:encoded></item><item><title>Java笔记</title><link>https://thrinisty.github.io/posts/java%E5%A4%9A%E7%94%A8%E6%88%B7%E9%80%9A%E8%AE%AF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java%E5%A4%9A%E7%94%A8%E6%88%B7%E9%80%9A%E8%AE%AF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</guid><description>Java多用户通讯系统设计</description><pubDate>Mon, 17 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;多用户通信系统设计&lt;/h1&gt;
&lt;p&gt;https://github.com/thrinisty/Multi-user-communication-system.git&lt;/p&gt;
&lt;h2&gt;功能实现&lt;/h2&gt;
&lt;p&gt;1.用户登录&lt;/p&gt;
&lt;p&gt;2.拉取用户列表&lt;/p&gt;
&lt;p&gt;3.私聊&lt;/p&gt;
&lt;p&gt;4.群聊&lt;/p&gt;
&lt;p&gt;5.发文件&lt;/p&gt;
&lt;h2&gt;思路分析&lt;/h2&gt;
&lt;p&gt;当客户端与服务端产生链接的时候，服务端会产生一个socket，必须要创建一个线程来持有并管理产生的socket&lt;/p&gt;
&lt;p&gt;服务器端的多个线程需要一个管理线程的集合，用以后续的服务器推送新闻&lt;/p&gt;
&lt;p&gt;每一个客户端也可能会创建多个线程，和服务器端通信，需要客户端线程的管理集合（hashmap）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/66.png&quot; alt=&quot;66&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;服务端&lt;/h3&gt;
&lt;p&gt;1.当客户端连接到服务器时得到了socket&lt;/p&gt;
&lt;p&gt;2.启动了一个线程，该线程持有socket，socket是线程的属性&lt;/p&gt;
&lt;p&gt;3.为了管理线程，用集合hashmap管理线程，将线程放入集合&lt;/p&gt;
&lt;h3&gt;客户端&lt;/h3&gt;
&lt;p&gt;1.和服务端通信的时候使用对象的方式，可以使用对象流来进行读写&lt;/p&gt;
&lt;p&gt;2.当客户端连接到服务器端时，会得到socket&lt;/p&gt;
&lt;p&gt;3.启动一个线程，该线程持有socket&lt;/p&gt;
&lt;p&gt;4.为了管理线程，用集合hashmap管理线程，将线程放入集合&lt;/p&gt;
&lt;h2&gt;代码实现&lt;/h2&gt;
&lt;h3&gt;1.用户登录&lt;/h3&gt;
&lt;p&gt;创建User对象，表示一个用户信息（如果对象要在IO中传输，对象需要进行序列化）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.qqcommon;

import java.io.Serializable;

//表示一个用户信息
public class User implements Serializable {
    private static final long serialVersionUID = 1L;//增强兼容性
    private String userId;//用户名
    private String password;

    User(String userId, String password) {
        this.userId = userId;
        this.password = password;
    }

    public String getUserId() {
        return userId;
    }

    public void setUserId(String userId) {
        this.userId = userId;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建Message对象，表示客户端和服务端通信时的消息对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.qqcommon;

import java.io.Serializable;

//表示客户端和服务端通信时的消息对象
public class Message implements Serializable {
    private static final long serialVersionUID = 1L;
    private String sender;//发送者
    private String getter;//接收者
    private String content;//消息内容
    private String sendTime;//发送时间
    private String mesType;//消息类型【可以在接口定义消息类型】

    public String getMesType() {
        return mesType;
    }

    public void setMesType(String mesType) {
        this.mesType = mesType;
    }

    public String getSender() {
        return sender;
    }

    public void setSender(String sender) {
        this.sender = sender;
    }

    public String getGetter() {
        return getter;
    }

    public void setGetter(String getter) {
        this.getter = getter;
    }

    public String getContent() {
        return content;
    }

    public void setContent(String content) {
        this.content = content;
    }

    public String getSendTime() {
        return sendTime;
    }

    public void setSendTime(String sendTime) {
        this.sendTime = sendTime;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;MessageType接口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.qqcommon;

public interface MessageType {
    String MESSAGE_LOGIN_SUCCEED = &quot;1&quot;;//登录成功
    String MESSAGE_LOGIN_FAIL = &quot;2&quot;;//登录失败
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;客户端&lt;/h4&gt;
&lt;p&gt;客户端聊天的菜单界面（内部逻辑）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.qqcommon;

import java.util.Scanner;

public class QQview {
    //显示主菜单
    private boolean loop = true;
    private String key = &quot;&quot;;
    Scanner scanner = new Scanner(System.in);

    public static void main(String[] args) {
        QQview qqview = new QQview();
        qqview.mainMenu();
        System.out.println(&quot;退出聊天系统&quot;);
    }

    public void mainMenu() {
        while (loop) {
            System.out.println(&quot;==========欢迎来到网络登录系统==========&quot;);
            System.out.println(&quot;\t\t 1 登陆系统&quot;);
            System.out.println(&quot;\t\t 9 退出系统&quot;);
            System.out.print(&quot;请输入1-9： &quot;);
            key = scanner.next();
            switch (key) {
                case &quot;1&quot;:
                    System.out.println(&quot;登陆系统&quot;);
                    System.out.println(&quot;请输入用户号码： &quot;);
                    String userId = scanner.next();
                    System.out.println(&quot;请输入用户密码： &quot;);
                    String password = scanner.next();
                    //将用户密码和用户名称发送到服务端，暂定
                    if (true) {
                        System.out.println(&quot;==========登录成功==========&quot;);
                        while (loop) {
                            System.out.println(&quot;==========网络通讯系统==========&quot;);
                            System.out.println(&quot;欢迎用户&quot; + userId);
                            System.out.println(&quot;\t\t 1 显示在线用户列表&quot;);
                            System.out.println(&quot;\t\t 2 群发消息&quot;);
                            System.out.println(&quot;\t\t 3 私聊消息&quot;);
                            System.out.println(&quot;\t\t 4 发送文件&quot;);
                            System.out.println(&quot;\t\t 9 退出系统&quot;);
                            System.out.print(&quot;请输入1-9 &quot;);
                            key = scanner.next();
                            switch (key) {
                                case &quot;1&quot;:
                                    System.out.println(&quot;显示在线用户列表&quot;);
                                    break;
                                case &quot;2&quot;:
                                    System.out.println(&quot;群发消息&quot;);
                                    break;
                                case &quot;3&quot;:
                                    System.out.println(&quot;私聊消息&quot;);
                                    break;
                                case &quot;4&quot;:
                                    System.out.println(&quot;发送文件&quot;);
                                    break;
                                case &quot;9&quot;:
                                    System.out.println(&quot;退出系统&quot;);
                                    loop = false;
                                    break;
                            }

                        }
                    } else {
                        System.out.println(&quot;==========登陆失败==========&quot;);
                    }
                    break;
                case &quot;9&quot;:
                    System.out.println(&quot;==========登陆退出==========&quot;);
                    loop = false;
                    break;
            }

        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;线程服务类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.qqclient.service;

import com.npu.qqcommon.Message;
import com.npu.qqcommon.MessageType;
import com.npu.qqcommon.User;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.InetAddress;
import java.net.Socket;


public class UserClientService {
    private User u = new User();//因为要在其他地方使用属性
    private Socket socket;

    public Socket getSocket() {
        return socket;
    }

    public void setSocket(Socket socket) {
        this.socket = socket;
    }

    //用以判断是否登录正确，消息来自于服务端按
    public boolean checkUser(String userId, String password) {
        boolean b = false;
        u.setUserId(userId);
        u.setPassword(password);
        //连接到服务器，发送u对象
        try {
            socket = new Socket(InetAddress.getByName(&quot;127.0.0.1&quot;), 9999);
            ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());
            oos.writeObject(u);//发送User对象
            
            //读取收到的Message对象
            ObjectInputStream ois = new ObjectInputStream(socket.getInputStream());
            Message ms = (Message) ois.readObject();
            if(ms.getMesType().equals(MessageType.MESSAGE_LOGIN_SUCCEED)){
                //创建一个和服务器端保持通信的线程-&amp;gt;创建线程类 ClientConnectServerThread
                ClientConnectServerThread clientConnectServerThread = new ClientConnectServerThread(socket);
                clientConnectServerThread.start();
                //为了方便管理，将线程放入一个集合中ManageClientConnectServerThread
                ManageClientConnectServerThread.addClientConnectServerThread(userId, clientConnectServerThread);
                b = true;
            } else {
                //登陆失败不启动线程，关闭没有用到的socket
                socket.close();
            }

        } catch (Exception e) {
            e.printStackTrace();
        }
        return b;
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中创建的线程是一个类，含有socket对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.qqserver.server;

import com.npu.qqcommon.Message;
import com.npu.qqcommon.MessageType;
import com.npu.qqcommon.User;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.ServerSocket;
import java.net.Socket;

//服务端监听9999端口，等待客户端连接，保持通信
public class QQServer {
    private ServerSocket ss = null;

    public QQServer() {
        try {
            System.out.println(&quot;服务端在9999监听...&quot;);
            ss = new ServerSocket(9999);
            while(true) {
                Socket socket = ss.accept();
                ObjectInputStream ois = new ObjectInputStream(socket.getInputStream());
                ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());
                User u = (User) ois.readObject();
                //将数据进行验证，但是这没有数据库，模拟一个验证流程
                Message message = new Message();
                if(u.getUserId().equals(&quot;100&quot;) &amp;amp;&amp;amp; u.getPassword().equals(&quot;123456&quot;)) {
                    //登陆成功，向客户端发送连接信息
                    message.setMesType(MessageType.MESSAGE_LOGIN_SUCCEED);
                    oos.writeObject(message);

                    //创建线程持有socket对象
                    ServerConnectClientThread serverConnectClientThread = new ServerConnectClientThread(socket, u.getUserId());
                    serverConnectClientThread.start();

                    //将线程放入集合
                    ManageClientThreads.addClientThread(u.getUserId(),serverConnectClientThread);
                } else {
                    //登陆失败
                    System.out.println(&quot;用户 &quot; + u.getUserId() + &quot;登录无效&quot;);
                    message.setMesType(MessageType.MESSAGE_LOGIN_FAIL);
                    oos.writeObject(message);
                    socket.close();
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            //如果服务端退出循环，服务器端不再监听
            try{
                ss.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
true){
            try{
                System.out.println(&quot;客户端线程，等待读取服务器数据&quot;);
                ObjectInputStream ois = new ObjectInputStream(socket.getInputStream());
                Message message = (Message) ois.readObject();//没有发送对象 线程发送阻塞
                //其余处理
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

    }

    public Socket getSocket() {
        return socket;
    }

    public void setSocket(Socket socket) {
        this.socket = socket;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;又在服务类里面创建了一个现成的集合对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.qqclient.service;

import java.util.HashMap;

//管理客户端带服务端线程的一个类
public class ManageClientConnectServerThread {
    //把多个线程放入一个hashmap集合中，key是用户id， value是线程
    public static HashMap&amp;lt;String, ClientConnectServerThread&amp;gt; hm = new HashMap&amp;lt;&amp;gt;();

    //将线程加入
    public static void addClientConnectServerThread(String userId, ClientConnectServerThread clientConnectServerThread) {
        hm.put(userId, clientConnectServerThread);
    }
    //用id取出线程
    public static ClientConnectServerThread getClientConnectServerThread(String userId) {
        return hm.get(userId);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;服务器&lt;/h4&gt;
&lt;p&gt;基本的服务流程&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.qqserver.server;

import com.npu.qqcommon.Message;
import com.npu.qqcommon.MessageType;
import com.npu.qqcommon.User;

import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.ServerSocket;
import java.net.Socket;

//服务端监听9999端口，等待客户端连接，保持通信
public class QQServer {
    private ServerSocket ss = null;

    public QQServer() {
        try {
            System.out.println(&quot;服务端在9999监听...&quot;);
            ss = new ServerSocket(9999);
            while(true) {
                Socket socket = ss.accept();
                ObjectInputStream ois = new ObjectInputStream(socket.getInputStream());

                ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());
                User u = (User) ois.readObject();
                //将数据进行验证，但是这没有数据库，模拟一个验证流程 在后续更改为checkUser()
                Message message = new Message();
                if(u.getUserId().equals(&quot;100&quot;) &amp;amp;&amp;amp; u.getPassword().equals(&quot;123456&quot;)) {
                    //登陆成功，向客户端发送连接信息
                    message.setMesType(MessageType.MESSAGE_LOGIN_SUCCEED);
                    oos.writeObject(message);

                    //创建线程持有socket对象

                    //将线程放入集合

                } else {

                    //登陆失败
                }

            }
            
        } catch (Exception e) {
            e.printStackTrace();
        } finally {

        }

    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中的创建线程对象如下，重写了线程运行的方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.qqserver.server;

import com.npu.qqcommon.Message;

import java.io.ObjectInputStream;
import java.net.Socket;

//该类对该类的对象和客户端保持连接，拥有一个socket
public class ServerConnectClientThread extends Thread {
    Socket socket = null;
    private String userId = &quot;&quot;;//连接到服务器的用户id

    public ServerConnectClientThread(Socket socket, String userId) {
        this.socket = socket;
        this.userId = userId;
    }

   @Override
    public void run() {
        while (true) {
            try{
                System.out.println(&quot;正在尝试读取客户端数据&quot;);
                ObjectInputStream ois = new ObjectInputStream(socket.getInputStream());
                Message message = (Message) ois.readObject();
                //等待使用的数据
            } catch (Exception e) {
                e.printStackTrace();
            }

        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在服务器中创建线程的时候将线程放入一个集合中统一管理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.qqserver.server;

import java.util.HashMap;

//该类用于管理与客户端通讯的线程
public class ManageClientThreads {
    private static HashMap&amp;lt;String, ServerConnectClientThread&amp;gt; hm = new HashMap&amp;lt;&amp;gt;();

    public static void addClientThread(String userId, ServerConnectClientThread ServerConnectClientThread) {
        hm.put(userId, ServerConnectClientThread);
    }

    public static ServerConnectClientThread getClientThread(String userId) {
        return hm.get(userId);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;判断账户密码&lt;/h4&gt;
&lt;p&gt;在上述中我们服务器判断账号密码是否合法采用的是账户为100 密码为123456&lt;/p&gt;
&lt;p&gt;现在进行功能上的修改：更改为指定的数个账户&lt;/p&gt;
&lt;p&gt;判断方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public boolean checkUser(String userId, String password) {
        User user = validUsers.get(userId);
        if(user == null) {

            System.out.println(&quot;用户id错误，不存在用户&quot; + userId);
            return false;
        }
        if(!password.equals(user.getPassword())) {
            System.out.println(&quot;用户密码错误&quot;);
            return false;
        }
        return true;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中对应的hashmap集合（在静态中初始化一些用户）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; private static HashMap&amp;lt;String, User&amp;gt; validUsers = new HashMap&amp;lt;&amp;gt;();
    static {
        validUsers.put(&quot;100&quot;, new User(&quot;100&quot;, &quot;123456&quot;));
        validUsers.put(&quot;200&quot;, new User(&quot;100&quot;, &quot;123456&quot;));
        validUsers.put(&quot;300&quot;, new User(&quot;100&quot;, &quot;123456&quot;));
        validUsers.put(&quot;400&quot;, new User(&quot;100&quot;, &quot;123456&quot;));
        validUsers.put(&quot;李昊轩&quot;, new User(&quot;李昊轩&quot;, &quot;123456&quot;));
        validUsers.put(&quot;王凌&quot;, new User(&quot;王凌&quot;, &quot;123456&quot;));
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;至此多用户登录功能已经完成，下面进入拉取用户列表的实现&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/67.png&quot; alt=&quot;67&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;2.拉取用户列表&lt;/h3&gt;
&lt;h4&gt;接口扩展&lt;/h4&gt;
&lt;p&gt;扩展MessageType接口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface MessageType {
    String MESSAGE_LOGIN_SUCCEED = &quot;1&quot;;//登录成功
    String MESSAGE_LOGIN_FAIL = &quot;2&quot;;//登录失败
    String MESSAGE_COMM_MES = &quot;3&quot;;//普通信息包
    String MESSAGE_GET_ONLINE_FRIEND = &quot;4&quot;;//要求返回在线用户列表
    String MESSAGE_RET_ONLINE_FRIEND = &quot;5&quot;;//返回在线用户列表
    String MESSAGE_CLIENT_EXIT = &quot;6&quot;;//客户端请求退出
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;客户端&lt;/h4&gt;
&lt;p&gt;在客户端菜单栏中调用特定方法发送给服务器用户列表请求&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;switch (key) {
case &quot;1&quot;:
     System.out.println(&quot;显示在线用户列表&quot;);
	userClientService.onlineFriendList();
	break;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;客户端服务类的发送请求方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void onlineFriendList() {
        Message ms = new Message();
        ms.setMesType(MessageType.MESSAGE_GET_ONLINE_FRIEND);
        //发送给服务器，先得到当前线程的socket对应的输出流
        try {
            ObjectOutputStream oos = new ObjectOutputStream(ManageClientConnectServerThread
                    .getClientConnectServerThread(u.getUserId()).getSocket().getOutputStream());
            oos.writeObject(ms);//发送请求
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在客户端线程中如果收到的message类型是在线用户列进行的相关处理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void run() {
        //因为持续通信持续循环
        while(true){
            try{
                System.out.println(&quot;客户端线程，等待读取服务器数据&quot;);
                ObjectInputStream ois = new ObjectInputStream(socket.getInputStream());
                Message message = (Message) ois.readObject();//没有发送对象 线程发送阻塞
                //其余处理,后续需要使用
                //判断message类型，处理后续内容

                //当读到用户列表请求
                if(message.getMesType().equals(MessageType.MESSAGE_RET_ONLINE_FRIEND)) {
                    //取出在线列表然后返回
                    String[] onlineUsers = message.getContent().split(&quot; &quot;);
                    System.out.println(&quot;======当前在线用户======&quot;);
                    for (int i = 0; i &amp;lt; onlineUsers.length; i++) {
                        System.out.println(&quot;用户：&quot; + onlineUsers[i]);
                    }
                } else {
                    System.out.println(&quot;暂时不处理&quot;);
                }

            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;服务端&lt;/h4&gt;
&lt;p&gt;在线程中处理收到的Message信息&lt;/p&gt;
&lt;p&gt;如果收到的Message信息是请求获取列表，则构造信息返回&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void run() {
    while (true) {
        try{
            System.out.println(&quot;用户id &quot; + userId);
            System.out.println(&quot;正在尝试读取客户端数据&quot;);
            ObjectInputStream ois = new ObjectInputStream(socket.getInputStream());
            Message message = (Message) ois.readObject();
            //等待使用的数据
            //更具Message类型处理后续
            if(message.getMesType().equals(MessageType.MESSAGE_GET_ONLINE_FRIEND)) {
                //客户端要求返回在线用户列表
                System.out.println(userId + &quot; 需要在线列表&quot;);
                String onlineUser = ManageClientThreads.getOnlineUser();
                //拿到了信息构造一个Message
                Message message2 = new Message();
                message2.setMesType(MessageType.MESSAGE_RET_ONLINE_FRIEND);
                message2.setContent(onlineUser);
                message2.setGetter(message.getSender());
                //写入Message
                ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());
                oos.writeObject(message2);
                System.out.println(&quot;已发送在线用户列表给 &quot; + userId);

            }else {
                System.out.println(&quot;收到服务器消息，暂不处理&quot;);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }

    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;2.5.无异常退出&lt;/h3&gt;
&lt;p&gt;问题一：当在二级菜单 输入设置为9 退出的时候也没办法正常退出，因为服务器通讯的线程没有结束&lt;/p&gt;
&lt;p&gt;问题二：当客户端断开连接的时候，服务线程还在不断地尝试获取客户端消息，造成了报错&lt;/p&gt;
&lt;p&gt;我们需要一个好的方法进行无异常退出&lt;/p&gt;
&lt;p&gt;解决方法：&lt;/p&gt;
&lt;h4&gt;客户端&lt;/h4&gt;
&lt;p&gt;客户端没有移除集合中的线程是因为最终客户端只拥有一个线程&lt;/p&gt;
&lt;p&gt;1.在主函数中调用方法给服务器端发送一个退出的Message对象&lt;/p&gt;
&lt;p&gt;2.调用客户端 System.exit(0) 进行退出&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void logout() {
        Message ms = new Message();
        ms.setMesType(MessageType.MESSAGE_CLIENT_EXIT);
        ms.setSender(u.getUserId());
        try {
            ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());
            oos.writeObject(ms);
            System.out.println(&quot;退出系统&quot;);
            System.exit(0);//结束进程
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;服务端&lt;/h4&gt;
&lt;p&gt;1.接收message消息，当消息为退出的时候执行下述步骤&lt;/p&gt;
&lt;p&gt;2.移除集合中的对应线程&lt;/p&gt;
&lt;p&gt;3.服务器端关闭线程持有的socket,再退出线程&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;else if(message.getMesType().equals(MessageType.MESSAGE_CLIENT_EXIT)) {
       System.out.println(userId + &quot; 准备退出&quot;);
       //将客户端的线程从集合中删除
       ManageClientThreads.removeClientThread(userId);
       socket.close();
       //退出while循环
       break;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;../images/68.png&quot; alt=&quot;68&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/69.png&quot; alt=&quot;69&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;3.私聊&lt;/h3&gt;
&lt;h4&gt;客户端&lt;/h4&gt;
&lt;p&gt;1.接收用户希望给某个其他的在线用户聊天内容&lt;/p&gt;
&lt;p&gt;2.将消息构建成Message对象，通过对应的socket发送给服务器&lt;/p&gt;
&lt;p&gt;3.在通讯线程中收到其他的客户端发送的消息并显示&lt;/p&gt;
&lt;p&gt;在菜单中调用方法发送私聊&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;case &quot;3&quot;:
    System.out.println(&quot;私聊消息&quot;);
    System.out.print(&quot;请输入要聊天的用户: &quot;);
    String getterId = scanner.next();
    System.out.print(&quot;请输入想说的话&quot;);
    String content = scanner.next();
    //编写一个方法完成发送
    messageClientService.sendMessageToOne(content, userId, getterId);
    break;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;私聊实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void sendMessageToOne(String content, String senderId, String getterId) {
    Message ms = new Message();
    ms.setMesType(MessageType.MESSAGE_COMM_MES);//设置为普通消息类型
    ms.setSender(senderId);
    ms.setGetter(getterId);
    ms.setContent(content);
    System.out.println(senderId + &quot;对&quot; + getterId + &quot;私聊 内容为：&quot; + content);

    try {
        ObjectOutputStream oos = new ObjectOutputStream(ManageClientConnectServerThread
                .getClientConnectServerThread(senderId).getSocket().getOutputStream());
        oos.writeObject(ms);
    } catch (IOException e) {
        e.printStackTrace();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;收到私聊消息后显示&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;else if(message.getMesType().equals(MessageType.MESSAGE_COMM_MES)) {
    //将消息显示出来
    System.out.println(&quot;\n收到来自 &quot; + message.getSender() + &quot; 的消息，内容如下：&quot;);
    System.out.println(message.getContent());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;服务器&lt;/h4&gt;
&lt;p&gt;1.可以读取到客户端发送给某个客户的消息&lt;/p&gt;
&lt;p&gt;2.从管理的线程集合中根据发送的目标用户id，获取socket&lt;/p&gt;
&lt;p&gt;3.将message对象转发给客户&lt;/p&gt;
&lt;p&gt;服务器只完成转发的工作，当收到转发消息时转发&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;else if(message.getMesType().equals(MessageType.MESSAGE_COMM_MES)) {
    //根据收到的消息中获取发送的对象进行转发
    ServerConnectClientThread serverConnectClientThread =
            ManageClientThreads.getClientThread(message.getGetter());
    ObjectOutputStream oos = new ObjectOutputStream(serverConnectClientThread
            .getSocket().getOutputStream());
    oos.writeObject(message);//发送，如果客户不在线可以保存到数据库中
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;4.群聊&lt;/h3&gt;
&lt;p&gt;大体和私聊类似&lt;/p&gt;
&lt;p&gt;在Message消息类型补充&lt;/p&gt;
&lt;p&gt;String MESSAGE_TO_ALL_MES = &quot;7&quot;;//群发消息&lt;/p&gt;
&lt;h4&gt;客户端&lt;/h4&gt;
&lt;p&gt;菜单调用功能方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;case &quot;2&quot;:
    System.out.println(&quot;请输入群发的话，内容将被发给所有的在线用户&quot;);
    String s = scanner.next();
    //调用方法将字符串发送给服务器进行广播
    messageClientService.sendMessageToAll(s, userId);
    break;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;群发消息到服务器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void sendMessageToAll(String content, String senderId) {
    Message ms = new Message();
    ms.setMesType(MessageType.MESSAGE_TO_ALL_MES);//设置为普通消息类型
    ms.setSender(senderId);
    ms.setContent(content);
    System.out.println(senderId + &quot;群发消息，内容为：&quot; + content);

    try {
        ObjectOutputStream oos = new ObjectOutputStream(ManageClientConnectServerThread
                .getClientConnectServerThread(senderId).getSocket().getOutputStream());
        oos.writeObject(ms);
    } catch (IOException e) {
        e.printStackTrace();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接收到群发消息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;else if (message.getMesType().equals(MessageType.MESSAGE_TO_ALL_MES)) {
    System.out.println(&quot;\n收到来自 &quot; + message.getSender() + &quot; 群发的消息，内容如下：&quot;);
    System.out.println(message.getContent());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;服务端&lt;/h4&gt;
&lt;p&gt;当收到消息为群发时，中介群发给除发送者外的所有用户&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;else if (message.getMesType().equals(MessageType.MESSAGE_TO_ALL_MES)) {
    //需要遍历线程的管理集合逐个发送
    HashMap&amp;lt;String, ServerConnectClientThread&amp;gt; hm = ManageClientThreads.getHm();
    Iterator&amp;lt;String&amp;gt; interator = hm.keySet().iterator();
    while (interator.hasNext()) {
        //取出在线用户ID
        String onLineUserId = interator.next().toString();
        if(!onLineUserId.equals(message.getSender())) {
            ObjectOutputStream oos = new ObjectOutputStream(hm.get
                    (onLineUserId).getSocket().getOutputStream());
                oos.writeObject(message);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;至此群发消息功能完成&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/70.png&quot; alt=&quot;70&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;5.发文件&lt;/h3&gt;
&lt;p&gt;首先我们要扩展Message类的定义，在类中添加bytes数组，以及一些必要的成员变量，拓展MessageType，定义新的消息类型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private byte[] fileBytes;//用于发送文件
private int fileSize = 0;//文件大小
private String dest;//将文件传输到的位置
private String src;//发送的文件路径
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;客户端&lt;/h4&gt;
&lt;p&gt;1.将指定路径下的文件输出流转换为字节数组&lt;/p&gt;
&lt;p&gt;2.将字节数组封装在message对象中&lt;/p&gt;
&lt;p&gt;3.将message对象发送，在服务器进行相应处理&lt;/p&gt;
&lt;p&gt;4.接收到文件message对象的时候将message对象中的字节数组运用文件输入流存储至指定的目录下&lt;/p&gt;
&lt;p&gt;在菜单栏中调用文件类的功能方法，完成向服务器传送message消息（其中包含了文件的内容）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;case &quot;4&quot;:
    System.out.print(&quot;请输入发送对象 &quot;);
    String target = scanner.next();
    System.out.print(&quot;请输入要发送的文件路径 &quot;);
    //e:\\1.jpg  e:\\2.jpg
    String filePath = scanner.next();
    System.out.print(&quot;请输入保存至对方电脑的文件路径 &quot;);
    String savePath = scanner.next();
    fileClientService.sendFileToOne(filePath, savePath, userId, target);
    break;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;sendFileToOne具体实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class FileClientService {
    public void sendFileToOne(String src, String dest, String senderId, String getterId) {
        //构造message信息
        Message message = new Message();
        message.setMesType(MessageType.MESSAGE_FILE_MES);
        message.setSender(senderId);
        message.setDest(dest);
        message.setGetter(getterId);
        message.setSrc(src);
        //读取文件内容
        FileInputStream fileInputStream = null;
        byte[] fileBytes = new byte[(int)new File(src).length()];

        try {
            fileInputStream = new FileInputStream(src);
            fileInputStream.read(fileBytes);
            //将字节数组放入message
            message.setFileBytes(fileBytes);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if(fileInputStream != null) {
                try {
                    fileInputStream.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        try {
            ObjectOutputStream oos = new ObjectOutputStream(ManageClientConnectServerThread
                    .getClientConnectServerThread(senderId).getSocket().getOutputStream());
            oos.writeObject(message);
        } catch (IOException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;发送目录 &quot; + message.getSrc() + &quot;目录文件至 &quot;
                + message.getGetter() + &quot; 的目录 &quot; + message.getDest());
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运用线程来接收来自服务器的文件相关message，将其中的数据保存在指定目录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;else if (message.getMesType().equals(MessageType.MESSAGE_FILE_MES)) {
    System.out.println(&quot;\n收到来自 &quot; + message.getSender() + &quot; 的文件&quot;);
    FileOutputStream fos = new FileOutputStream(message.getDest());
    fos.write(message.getFileBytes());
    fos.close();
    System.out.println(&quot;文件保存在目录 &quot; + message.getDest());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;服务器&lt;/h4&gt;
&lt;p&gt;1.接收到message对象&lt;/p&gt;
&lt;p&gt;2.得到message对象中的getter，用他的userId获取通信线程&lt;/p&gt;
&lt;p&gt;3.将message对象转发给指定的用户&lt;/p&gt;
&lt;p&gt;和私聊类似，完成message转发&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;else if (message.getMesType().equals(MessageType.MESSAGE_FILE_MES)) {
    //根据getterid选取集合中的对应线程得到socket用以转发文件消息
    ServerConnectClientThread serverConnectClientThread =
            ManageClientThreads.getClientThread(message.getGetter());
    ObjectOutputStream oos = new ObjectOutputStream(serverConnectClientThread
            .getSocket().getOutputStream());
    oos.writeObject(message);

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/71.png&quot; alt=&quot;71&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/72.png&quot; alt=&quot;72&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>Java笔记</title><link>https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0udp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0udp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</guid><description>UDP网络编程</description><pubDate>Sun, 16 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;听课笔记&lt;/h1&gt;
&lt;h2&gt;UDP网络通信编程&lt;/h2&gt;
&lt;p&gt;不同于TCP通信，UDP不需要建立连接，UDP数据包中含有发送的目标地址&lt;/p&gt;
&lt;p&gt;1.类 DatagramSocket 和 DatagramPacket【数据包/数据报】实现了基于UDP协议网络程序&lt;/p&gt;
&lt;p&gt;2.UDP数据报通过数据报套接字 DatagramSocket 发送和接收，系统不保证UDP数据报有一定可以能够到达目的地，也不确定在什么时候可以到达&lt;/p&gt;
&lt;p&gt;3.DatagramPacket 对象封装了UDP数据报，在数据包中包含了发送端和接收端的IP地址以及端口号&lt;/p&gt;
&lt;p&gt;4.UDP协议中的每一个数据报都给出了完整的信息地址，因此无需建立发送方和接收方的链接吧&lt;/p&gt;
&lt;h2&gt;UDP特殊说明&lt;/h2&gt;
&lt;p&gt;1.UDP中没有明确的服务端和客户端，演变为数据的发送端和接收端&lt;/p&gt;
&lt;p&gt;2.接收数据和发送数据通过DatagramSocket对象完成&lt;/p&gt;
&lt;p&gt;3.发送数据时会将数据封装在DatagramPacket对象中，称之为装包&lt;/p&gt;
&lt;p&gt;4.当接收到数据包后，需要进行拆包取出数据&lt;/p&gt;
&lt;p&gt;5.DatagramSocket可以指定在哪个端口接收数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/65.png&quot; alt=&quot;65&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;UDP通信流程&lt;/h2&gt;
&lt;p&gt;1.建立发送端和接收端&lt;/p&gt;
&lt;p&gt;2.发送数据前建立数据包和数据报&lt;/p&gt;
&lt;p&gt;3.调用数据包的发送和接受方法&lt;/p&gt;
&lt;p&gt;4.关闭数据包&lt;/p&gt;
&lt;h2&gt;代码示例&lt;/h2&gt;
&lt;p&gt;发送端&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.udp;

import java.io.IOException;
import java.net.*;

public class Sender {
    public static void main(String[] args) throws IOException {
        DatagramSocket socket = new DatagramSocket(9998);//发送端的端口是9998
        byte[] bytes = &quot;hello&quot;.getBytes();
        DatagramPacket packet = new DatagramPacket(bytes, bytes.length, InetAddress.getByName(&quot;127.0.0.1&quot;), 9999);
        socket.send(packet);
        System.out.println(&quot;数据已发送&quot;);
        socket.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接收端&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.udp;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.SocketException;

public class Receiver {
    public static void main(String[] args) throws IOException {
        DatagramSocket socket = new DatagramSocket(9999);
        byte[] buf = new byte[1024];
        DatagramPacket packet = new DatagramPacket(buf, buf.length);

        System.out.println(&quot;等待接收数据&quot;);
        socket.receive(packet);//将收到的数据填充进入packet对象

        int length = packet.getLength();//实际接收到的数据长度
        byte[] data = packet.getData();
        String s = new String(data, 0, length);
        socket.close();
        System.out.println(s);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;一个代码的综合习题&lt;/h2&gt;
&lt;p&gt;这一道题是聊天交互的最简情况，支持一次通信，可以加上循环完成消息的重复发送与接收&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.homework;

import java.io.*;
import java.net.InetAddress;
import java.net.Socket;
import java.net.UnknownHostException;
import java.util.Scanner;

public class Client {
    public static void main(String[] args) throws IOException {
        Scanner scanner = new Scanner(System.in);
        Socket socket = new Socket(InetAddress.getByName(&quot;127.0.0.1&quot;), 6666);
        System.out.println(&quot;TCP链接建立&quot;);
        System.out.print(&quot;输入发送的消息:&quot;);
        String message = scanner.next();
        OutputStream outputStream = socket.getOutputStream();
        BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(outputStream));
        bufferedWriter.write(message);
        bufferedWriter.newLine();
        bufferedWriter.flush();
        System.out.println(&quot;消息发送完成&quot;);

        InputStream inputStream = socket.getInputStream();
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));
        String response = bufferedReader.readLine();
        System.out.println(&quot;收到服务器消息：&quot; + response);

        bufferedReader.close();
        bufferedWriter.close();
        socket.close();
        System.out.println(&quot;客户端关闭&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;package com.homework;

import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;

public class Server {
    public static void main(String[] args) throws IOException {
        ServerSocket serverSocket = new ServerSocket(6666);
        System.out.println(&quot;服务器正在监听...&quot;);
        Socket socket = serverSocket.accept();

        OutputStream outputStream = socket.getOutputStream();
        InputStream inputStream = socket.getInputStream();
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));
        BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(outputStream));

        String receive = bufferedReader.readLine();
        System.out.println(&quot;收到客户短消息&quot; + receive);
        switch (receive) {
            case &quot;name&quot;:
                bufferedWriter.write(&quot;我是nova&quot;);
                break;
            case &quot;hobby&quot;:
                bufferedWriter.write(&quot;编写java程序&quot;);
                break;
            default:
                bufferedWriter.write(&quot;未知消息&quot;);
                break;
        }
        bufferedWriter.newLine();
        bufferedWriter.flush();
        bufferedWriter.close();
        System.out.println(&quot;回复消息已发送&quot;);

        bufferedReader.close();
        bufferedWriter.close();
        socket.close();
        serverSocket.close();
        System.out.println(&quot;服务器关闭&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Java笔记</title><link>https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%AD%97%E7%AC%A6%E6%B5%81%E4%BC%A0%E8%BE%93netstat%E6%8C%87%E4%BB%A4/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%AD%97%E7%AC%A6%E6%B5%81%E4%BC%A0%E8%BE%93netstat%E6%8C%87%E4%BB%A4/</guid><description>字符流传输，netstat指令</description><pubDate>Sat, 15 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;听课笔记&lt;/h1&gt;
&lt;h2&gt;文件传输&lt;/h2&gt;
&lt;p&gt;Java中利用套接字在服务器与客户端间进行文件传输&lt;/p&gt;
&lt;p&gt;在这里需要使用到文件的输入输出流&lt;/p&gt;
&lt;p&gt;客户端上：&lt;/p&gt;
&lt;p&gt;客户端接收文件的输入流，用工具类转化为字节流进行传输&lt;/p&gt;
&lt;p&gt;服务器上&lt;/p&gt;
&lt;p&gt;在服务器端上我们要将收到的输入流使用功能类转化为字节流&lt;/p&gt;
&lt;p&gt;再将转化后的字节数组用文件输出流送到一个特定的位置&lt;/p&gt;
&lt;p&gt;客户端代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.file;

import java.io.*;
import java.net.InetAddress;
import java.net.ServerSocket;
import java.net.Socket;

public class Client {
    public static void main(String[] args) throws Exception {
        Socket socket = new Socket(InetAddress.getLocalHost(),8899);
        String filePath = &quot;C:\\Users\\71460\\Desktop\\2.jpg&quot;;
        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(filePath));
        byte[] bytes = StreamUtils.streamToByteArray(bis);

        BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream());
        bos.write(bytes);
        bos.flush();
        bis.close();
        socket.shutdownOutput();

        InputStream inputStream = socket.getInputStream();
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));

        String reBack = bufferedReader.readLine();
        System.out.println(&quot;收到服务器回复: &quot; + reBack);
        bufferedReader.close();
        socket.close();
        bos.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;服务端代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.file;

import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;

public class Server {
    public static void main(String[] args) throws Exception {
        ServerSocket serverSocket = new ServerSocket(8899);
        Socket socket = serverSocket.accept();

        BufferedInputStream bis = new BufferedInputStream(socket.getInputStream());
        byte[] bytes = StreamUtils.streamToByteArray(bis);

        String target = &quot;.\\target.jpg&quot;;
        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(target));
        bos.write(bytes);
        bos.close();

        OutputStream outputStream = socket.getOutputStream();
        BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(outputStream));

        bufferedWriter.write(&quot;收到图片&quot;);
        bufferedWriter.newLine();
        bufferedWriter.flush();
        bufferedWriter.close();
        bis.close();
        socket.close();
        serverSocket.close();

    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用到的工具包&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.file;

import java.io.ByteArrayOutputStream;
import java.io.InputStream;

public class StreamUtils {
    //将输入流转化为字节流，可以将文件的内容读入到byte数组中
    public static byte[] streamToByteArray(InputStream is) throws  Exception{
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        byte[] buffer = new byte[1024];
        int len = 0;
        while((len=is.read(buffer))!=-1){
            bos.write(buffer,0,len);
        }
        byte[] array = bos.toByteArray();
        bos.close();
        return array;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;netstat指令&lt;/h2&gt;
&lt;p&gt;netstat -an 可以查看当前主机网络情况，包括端口监听情况和网络连接情况&lt;/p&gt;
&lt;p&gt;netstat -an | more 可以分页显示&lt;/p&gt;
&lt;p&gt;Listening代表有某个端口在监听&lt;/p&gt;
&lt;p&gt;如果有一个外部程序链接到端口就会显示一条连接信息&lt;/p&gt;
&lt;p&gt;再管理员权限下可以使用netstat -anb 来观察是哪一个程序监听端口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/64.png&quot; alt=&quot;64&quot; /&gt;&lt;/p&gt;
&lt;p&gt;其中的8899端口所对应的就是我们的运行的文件传输服务器程序&lt;/p&gt;
&lt;h2&gt;TCP链接中的细节&lt;/h2&gt;
&lt;p&gt;TCP连接中，服务端监听了一个端口，再客户端和服务端建立链接的时候，客户端中也会有一个由TCP协议分配的一个端口&lt;/p&gt;
</content:encoded></item><item><title>Java笔记</title><link>https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86tcpudp%E5%AD%97%E8%8A%82%E6%B5%81%E4%BC%A0%E8%BE%93/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86tcpudp%E5%AD%97%E8%8A%82%E6%B5%81%E4%BC%A0%E8%BE%93/</guid><description>网络基础知识，TCP，UDP，字节流传输</description><pubDate>Fri, 14 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Java网络多线程&lt;/h1&gt;
&lt;h2&gt;IP地址&lt;/h2&gt;
&lt;p&gt;定义：用于唯一标识网络中的每一台计算机&lt;/p&gt;
&lt;p&gt;查看IP地址的指令：ipconfig&lt;/p&gt;
&lt;p&gt;IP地址组成：网络地址 + 主机地址&lt;/p&gt;
&lt;p&gt;A类地址 0 + 7位网络号 + 24位主机号&lt;/p&gt;
&lt;p&gt;B类地址 b10 + 14位网络号 + 16位主机号&lt;/p&gt;
&lt;p&gt;C类地址 b110 + 21位网络号 +8位主机号&lt;/p&gt;
&lt;p&gt;D类 b1110 + 28位多播组号&lt;/p&gt;
&lt;p&gt;E类 b11110 + 27位保留位&lt;/p&gt;
&lt;h2&gt;域名&lt;/h2&gt;
&lt;p&gt;www.baidu.com&lt;/p&gt;
&lt;p&gt;将ip地址映射为域名，方便记忆&lt;/p&gt;
&lt;h2&gt;端口号&lt;/h2&gt;
&lt;p&gt;概念：用于标识计算机上某个特定的网络程序&lt;/p&gt;
&lt;p&gt;通过IP + 端口即可访问一个特定网络上的特定程序&lt;/p&gt;
&lt;p&gt;表示形式：以整数形式表示：0—65535 （两个字节）&lt;/p&gt;
&lt;p&gt;0-1024被占用（在实际开发中不使用这一些端口）&lt;/p&gt;
&lt;h2&gt;网络通讯协议&lt;/h2&gt;
&lt;p&gt;在网络编程中数据的组织形式就是协议&lt;/p&gt;
&lt;p&gt;TCP/IP传输控制协议/因特网互联协议，又称网络通讯协议&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/61.png&quot; alt=&quot;61&quot; /&gt;&lt;/p&gt;
&lt;p&gt;网络层级以及对应协议&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/62.png&quot; alt=&quot;62&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;TCP与UDP&lt;/h2&gt;
&lt;h3&gt;TCP&lt;/h3&gt;
&lt;p&gt;通过三次握手建立连接，四次握手释放连接&lt;/p&gt;
&lt;p&gt;TCP协议进行通信的两个应用进程：客户端、服务端&lt;/p&gt;
&lt;h3&gt;UDP&lt;/h3&gt;
&lt;p&gt;将数据，源，目的封装为数据包，不需要建立连接&lt;/p&gt;
&lt;p&gt;每一个数据包的大小限制为64K以内&lt;/p&gt;
&lt;h2&gt;InetAddress类&lt;/h2&gt;
&lt;p&gt;相关方法&lt;/p&gt;
&lt;p&gt;1.获取本机的InetAddress对象  getLocalHost&lt;/p&gt;
&lt;p&gt;2.根据指定的主机名/域名获取ip地址对象  getByName&lt;/p&gt;
&lt;p&gt;3.获取InetAddress对象的主机名  getHostName&lt;/p&gt;
&lt;p&gt;4.获取InetAddress对象的地址  getHostAddress&lt;/p&gt;
&lt;p&gt;以下是一个代码示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.api;
import java.net.InetAddress;
import java.net.UnknownHostException;

public class Api {
    public static void main(String[] args) throws UnknownHostException {
        //1.获取本机的InetAddress对象
        InetAddress localHost = InetAddress.getLocalHost();
        System.out.println(localHost);

        //2.更具指定的主机名 获取InetAddress对象
        InetAddress host = InetAddress.getByName(&quot;thrinisty&quot;);
        System.out.println(host);

        //3.根据域名返回InetAddress对象
        InetAddress baidu = InetAddress.getByName(&quot;www.baidu.com&quot;);
        System.out.println(baidu);

        //4.通过 InetAddress对象，获取对应地址
        String baiduIp = baidu.getHostAddress();
        System.out.println(baiduIp);

        //5.通过InetAddress对象，获取域名或者主机名
        String baiduName = baidu.getHostName();
        System.out.println(baiduName);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;socket套接字&lt;/h2&gt;
&lt;p&gt;1.套接字在网络开发中广泛的被采用，成为了事实上的标准&lt;/p&gt;
&lt;p&gt;2.通信的两端都需要有socket，是两台机器通信的端点&lt;/p&gt;
&lt;p&gt;3.网络通信实际上就是socket之间的通信&lt;/p&gt;
&lt;p&gt;4.socket允许程序把网络连接当成一个流，数据在两个socket之间通过IO进行传输&lt;/p&gt;
&lt;p&gt;5.一般是主动发起通信的应用程序是客户端，等待通信请求的是服务端&lt;/p&gt;
&lt;p&gt;getOutputStream()获取输出流&lt;/p&gt;
&lt;p&gt;getInputStrean()获取输入流&lt;/p&gt;
&lt;p&gt;通信流程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/63.png&quot; alt=&quot;63&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;TCP数据传输案例&lt;/h2&gt;
&lt;h3&gt;1.使用字节流进行传输&lt;/h3&gt;
&lt;p&gt;服务端：&lt;/p&gt;
&lt;p&gt;1.在本机的9999端口监听，等待连接&lt;/p&gt;
&lt;p&gt;2.当没有客户端连接时阻塞等待连接&lt;/p&gt;
&lt;p&gt;3.通过socket.getInputStream() 获取管道中的数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.api;

import java.io.IOException;
import java.io.InputStream;
import java.net.ServerSocket;
import java.net.Socket;

public class SocketTCP01Server {
    public static void main(String[] args) throws IOException {
        ServerSocket serverSocket = new ServerSocket(9999);
        System.out.println(&quot;Server start listening on port 9999&quot;);
        Socket socket = serverSocket.accept();//如果有客户端连接返回Socket对象，退出阻塞
        System.out.println(&quot;socket = &quot; + socket.getClass());
        InputStream inputStream = socket.getInputStream();
        byte[] buffer = new byte[1024];
        int readLen = 0;
        while ((readLen = inputStream.read(buffer)) != -1) {
            System.out.println(new String(buffer, 0, readLen));
        }
        inputStream.close();
        socket.close();
        serverSocket.close();
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;客户端：&lt;/p&gt;
&lt;p&gt;1.连接服务器&lt;/p&gt;
&lt;p&gt;2.连接上后生成socket套接字，通过socket.getOutputStream()获取到输入流&lt;/p&gt;
&lt;p&gt;3.通过输出流，写数据到数据通道&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.api;

import java.io.IOException;
import java.io.OutputStream;
import java.net.InetAddress;
import java.net.Socket;
import java.net.UnknownHostException;

public class SocketTCP01Client {
    public static void main(String[] args) throws IOException {
        Socket socket = new Socket(InetAddress.getLocalHost(), 9999);
        System.out.println(&quot;socket返回 &quot; + socket.getClass());

        OutputStream outputStream = socket.getOutputStream();
        outputStream.write(&quot;Hello!!&quot;.getBytes());
        outputStream.close();
        socket.close();
        System.out.println(&quot;客户端退出&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;尝试在双端进行双向传递数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.api;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.InetAddress;
import java.net.Socket;
import java.net.UnknownHostException;

public class SocketTCP01Client {
    public static void main(String[] args) throws IOException {
        Socket socket = new Socket(InetAddress.getLocalHost(), 9999);
        System.out.println(&quot;socket返回 &quot; + socket.getClass());

        OutputStream outputStream = socket.getOutputStream();
        outputStream.write(&quot;Hello!!&quot;.getBytes());

        InputStream inputStream = socket.getInputStream();
        byte[] buffer = new byte[1024];
        int length = 0;
        while((length = inputStream.read(buffer)) != -1) {
            System.out.println(new String(buffer, 0, length));
        }
        //socket.shutdownOutput();结束标记
        System.out.println(&quot;接收服务器数据完毕&quot;);

        inputStream.close();
        outputStream.close();
        socket.close();
        System.out.println(&quot;客户端退出&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;package com.api;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.ServerSocket;
import java.net.Socket;

public class SocketTCP01Server {
    public static void main(String[] args) throws IOException {
        ServerSocket serverSocket = new ServerSocket(9999);
        System.out.println(&quot;Server start listening on port 9999&quot;);
        Socket socket = serverSocket.accept();//如果有客户端连接返回Socket对象，退出阻塞
        System.out.println(&quot;socket = &quot; + socket.getClass());
        InputStream inputStream = socket.getInputStream();
        byte[] buffer = new byte[1024];
        int readLen = 0;
        while ((readLen = inputStream.read(buffer)) != -1) {
            System.out.println(new String(buffer, 0, readLen));
        }
        OutputStream outputstream = socket.getOutputStream();
        outputstream.write(&quot;Hello client!&quot;.getBytes());
        //socket.shutdownOutput();结束标记
        System.out.println(&quot;发送完毕&quot;);

        outputstream.close();
        inputStream.close();
        socket.close();
        serverSocket.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是一开始写的一段程序，但是运行会发现，程序没有按照预期的方式运行：服务器端会送消息到客户端（实际上并没有）&lt;/p&gt;
&lt;p&gt;这是因为缺少了结束的标记，导致了客户端认为服务端的消息还没有发送完毕，任然在等待服务端消息发送完毕&lt;/p&gt;
&lt;p&gt;需要使用结束标记，在原先代码上取消相关注释即可&lt;/p&gt;
&lt;h3&gt;2.使用字符流进行传输&lt;/h3&gt;
&lt;p&gt;需要使用转换流OutputStreamWriter，将OutputStream字节流转换为字符流&lt;/p&gt;
&lt;p&gt;使用转换流InputStreamWriter，将InputStream字节流转换为字符流&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;OutputStream outputStream = socket.getOutputStream();
BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(outputStream));
bufferedWriter.write(&quot;字符流&quot;);
bufferedWriter.newLine();//插入一个换行符，表示写入内容结束，要使对方也读一个readline
bufferedWriter.flush();//使用字符流，需要手动刷新
System.out.println(&quot;发送字符流完毕&quot;);

bufferedWriter.close();//这个时候关闭外层流即可
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;InputStream inputStream = socket.getInputStream();
BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));
String s = bufferedReader.readLine();
System.out.println(s);
System.out.println(&quot;接收数据完毕&quot;);

bufferedReader.close();//关闭外层流
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以下是一个完整程序&lt;/p&gt;
&lt;p&gt;服务器端&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.test;

import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;

public class Server {
    public static void main(String[] args) throws IOException {
        ServerSocket serverSocket = new ServerSocket(8888);
        System.out.println(&quot;服务器开始监听端口8888&quot;);
        Socket socket = serverSocket.accept();
        System.out.println(&quot;链接建立&quot;);

        InputStream inputStream = socket.getInputStream();
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));

        String target = bufferedReader.readLine();
        System.out.println(&quot;收到消息 &quot; + target);

        bufferedReader.close();
        socket.close();
        System.out.println(&quot;服务器程序结束&quot;);

    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;客户端&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.test;

import java.io.BufferedWriter;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.net.InetAddress;
import java.net.Socket;
import java.net.UnknownHostException;

public class Client {
    public static void main(String[] args) throws IOException {
        Socket socket = new Socket(InetAddress.getLocalHost(), 8888);
        System.out.println(&quot;链接建立完毕&quot;);

        OutputStream outputStream = socket.getOutputStream();
        BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(outputStream));

        bufferedWriter.write(&quot;字符流数据&quot;);
        bufferedWriter.newLine();
        bufferedWriter.flush();
        System.out.println(&quot;字符发送完毕&quot;);

        bufferedWriter.close();
        socket.close();
        System.out.println(&quot;客户端程序结束&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Java笔记</title><link>https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%94%B9%E9%80%A0%E9%9B%B6%E9%92%B1%E9%80%9A%E7%BB%BC%E5%90%88%E5%AE%9E%E9%AA%8C%E7%AB%A0%E8%8A%82%E7%BB%83%E4%B9%A0/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%94%B9%E9%80%A0%E9%9B%B6%E9%92%B1%E9%80%9A%E7%BB%BC%E5%90%88%E5%AE%9E%E9%AA%8C%E7%AB%A0%E8%8A%82%E7%BB%83%E4%B9%A0/</guid><description>面向对象改造，零钱通综合实验，章节练习</description><pubDate>Thu, 13 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;听课笔记&lt;/h1&gt;
&lt;h2&gt;零钱通综合案例&lt;/h2&gt;
&lt;p&gt;目的是使用Java开发零钱通项目，可以完成收益入账，消费，查看明细，退出等功能&lt;/p&gt;
&lt;h3&gt;1.显示菜单，可以显示菜单，给出对应提示&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;package com.smallchange;

import java.util.Scanner;

public class SmallChangeSys {
    public static void main(String[] args) {
        boolean loop = true;
        do {
            System.out.println(&quot;==========零钱通==========&quot;);
            System.out.println(&quot;\t\t1 零钱通明细&quot;);
            System.out.println(&quot;\t\t2 收益入账&quot;);
            System.out.println(&quot;\t\t3 消费&quot;);
            System.out.println(&quot;\t\t4 退出&quot;);

            System.out.println(&quot;请选择1-4&quot;);
            Scanner scanner = new Scanner(System.in);
            switch (scanner.nextInt()) {
                case 1:
                    System.out.println(&quot;1 零钱通明细&quot;);
                    break;
                case 2:
                    System.out.println(&quot;2收益入账&quot;);
                    break;
                case 3:
                    System.out.println(&quot;3 收益入账&quot;);
                    break;
                case 4:
                    System.out.println(&quot;4 程序退出&quot;);
                    loop = false;
                    break;
            }
        } while (loop);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;2.完成零钱通明细&lt;/h3&gt;
&lt;p&gt;将收益放入数组，适用对象存储，用字符串进行拼接&lt;/p&gt;
&lt;p&gt;用字符串接收即可实现，打印字符串即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;case 1:
   	System.out.println(details);
break;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;3.完成收益入账&lt;/h3&gt;
&lt;p&gt;根据实现的功能定义新的变量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;case 2:
	System.out.println(&quot;收益入账金额：&quot;);
	 money = scanner.nextDouble();
	//校验金额
 	balance += money;
  	date = new Date();//获取到当前的日期
 	 SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd 		HH:mm:ss&quot;);
	details +=&quot;\n收益入账\t&quot; + money + &quot;\t&quot; + sdf.format(date) + 	&quot;\t当前余额为 &quot; + balance;
break;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;4.完成消费功能&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;case 3:
    System.out.println(&quot;输入消费金额&quot;);
   	money = scanner.nextDouble();
   	//金额校验
    System.out.print(&quot;消费说明:&quot;);
    note = scanner.next();
    balance -= money;
    date = new Date();//获取到当前的日期
   	details +=&quot;\n&quot; + note + &quot; 消费\t&quot; + money + &quot;\t&quot; + 		sdf.format(date) + &quot;\t当前余额为 &quot; + balance;
   	break;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;5.退出逻辑&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;case 4:
	 String choice = &quot;&quot;;
	while (true) {
	System.out.println(&quot;请确认是否退出&quot;);
    choice = scanner.next();
	if (&quot;y&quot;.equals(choice) || &quot;n&quot;.equals(choice)) {
 		break;
  	}
 	if (&quot;y&quot;.equals(choice)) {
		loop = false;
	}
	break;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;代码整体&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;package com.smallchange;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Scanner;

public class SmallChangeSys {
    public static void main(String[] args) {
        boolean loop = true;
        String details = &quot;------------零钱通明细---------------&quot;;
        double money = 0;
        double balance = 0;
        Date date = null;
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
        String note = null;

        do {
            System.out.println(&quot;==========零钱通==========&quot;);
            System.out.println(&quot;\t\t1 零钱通明细&quot;);
            System.out.println(&quot;\t\t2 收益入账&quot;);
            System.out.println(&quot;\t\t3 消费&quot;);
            System.out.println(&quot;\t\t4 退出&quot;);

            System.out.println(&quot;请选择1-4&quot;);
            Scanner scanner = new Scanner(System.in);
            switch (scanner.nextInt()) {
                case 1:
                    System.out.println(details);
                    break;
                case 2:
                    System.out.println(&quot;收益入账金额：&quot;);
                    money = scanner.nextDouble();
                    //校验金额
                    balance += money;
                    date = new Date();//获取到当前的日期
                    if (money &amp;lt;= 0) {
                        System.out.println(&quot;金额错误&quot;);
                        break;
                    }
                    details += &quot;\n收益入账\t&quot; + money + &quot;\t&quot; + sdf.format(date) + &quot;\t当前余额为 &quot; + balance;
                    break;
                case 3:
                    System.out.println(&quot;输入消费金额&quot;);
                    money = scanner.nextDouble();
                    if(money &amp;gt;= balance) {
                        System.out.println(&quot;余额不足&quot;);
                        break;
                    }
                    System.out.print(&quot;消费说明:&quot;);
                    note = scanner.next();
                    balance -= money;
                    date = new Date();//获取到当前的日期
                    details += &quot;\n&quot; + note + &quot; 消费\t&quot; + money + &quot;\t&quot; + sdf.format(date) + &quot;\t当前余额为 &quot; + balance;
                    break;
                case 4:
                    String choice = &quot;&quot;;
                    while (true) {
                        System.out.println(&quot;请确认是否退出&quot;);
                        choice = scanner.next();
                        if (&quot;y&quot;.equals(choice) || &quot;n&quot;.equals(choice)) {
                            break;
                        }
                    }
                    if (&quot;y&quot;.equals(choice)) {
                        loop = false;
                    }
                    break;
                default:
            }
        } while (loop);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;面向对象&lt;/h2&gt;
&lt;p&gt;以上是面向过程的代码编程，以下是对于代码的改进，体会面向对象的方便之处&lt;/p&gt;
&lt;p&gt;将各个操作更改为以类的方法实现，再将方法综合在菜单方法里调用，即可完成封装&lt;/p&gt;
&lt;p&gt;main方法构造以及调用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.smallchange;

public class SmallChangeSysApp {
    public static void main(String[] args) {
        SmallChangeSysOOP app = new SmallChangeSysOOP();
        app.mainMenu();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;零钱通类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.smallchange;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Scanner;

//面向对象编程
//将各个功能对应一个方法
public class SmallChangeSysOOP {
    boolean loop = true;
    String details = &quot;------------零钱通明细---------------&quot;;
    double money = 0;
    double balance = 0;
    Date date = null;
    SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
    String note = null;
    Scanner scanner = new Scanner(System.in);

    public void mainMenu() {
        do {
            System.out.println(&quot;==========零钱通==========&quot;);
            System.out.println(&quot;\t\t1 零钱通明细&quot;);
            System.out.println(&quot;\t\t2 收益入账&quot;);
            System.out.println(&quot;\t\t3 消费&quot;);
            System.out.println(&quot;\t\t4 退出&quot;);

            System.out.println(&quot;请选择1-4&quot;);
            Scanner scanner = new Scanner(System.in);
            switch (scanner.nextInt()) {
                case 1:
                    this.detail();
                    break;
                case 2:
                    this.income();
                    break;
                case 3:
                    this.pay();
                    break;
                case 4:
                    this.exit();
                    break;
                default:
            }
        } while (loop);
    }

    public void detail() {
        System.out.println(details);
    }

    public void income(){
        System.out.println(&quot;收益入账金额：&quot;);
        money = scanner.nextDouble();
        //校验金额
        balance += money;
        date = new Date();//获取到当前的日期
        if (money &amp;lt;= 0) {
            System.out.println(&quot;金额错误&quot;);
            return;
        }
        details += &quot;\n收益入账\t&quot; + money + &quot;\t&quot; + sdf.format(date) + &quot;\t当前余额为 &quot; + balance;
    }

    public void pay(){
        System.out.println(&quot;输入消费金额&quot;);
        money = scanner.nextDouble();
        if(money &amp;gt;= balance) {
            System.out.println(&quot;余额不足&quot;);
            return;
        }
        System.out.print(&quot;消费说明:&quot;);
        note = scanner.next();
        balance -= money;
        date = new Date();//获取到当前的日期
        details += &quot;\n&quot; + note + &quot; 消费\t&quot; + money + &quot;\t&quot; + sdf.format(date) + &quot;\t当前余额为 &quot; + balance;
    }

    public void exit() {
        String choice = &quot;&quot;;
        while (true) {
            System.out.println(&quot;请确认是否退出&quot;);
            choice = scanner.next();
            if (&quot;y&quot;.equals(choice) || &quot;n&quot;.equals(choice)) {
                break;
            }
        }
        if (&quot;y&quot;.equals(choice)) {
            loop = false;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;章节作业&lt;/h2&gt;
&lt;p&gt;1.定义Person类，对Person数组按照年龄排序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.homework;

public class Homework01 {
    public static void main(String[] args) {
        Person[] personArray = new Person[3];
        personArray[0] = new Person(&quot;Jerry&quot;, 19, &quot;1&quot;);
        personArray[1] = new Person(&quot;John&quot;, 55, &quot;2&quot;);
        personArray[2] = new Person(&quot;Mary&quot;, 33, &quot;3&quot;);
        Tool tool = new Tool();
        tool.sort(personArray);
        tool.print(personArray);
    }
}

class Person {
    String name;
    int age;
    String job;

    Person(String name, int age, String job) {
        this.name = name;
        this.age = age;
        this.job = job;
    }
    @Override
    public String toString() {
        return this.name + &quot; &quot; + this.age + &quot; &quot; + this.job;
    }
}

class Tool {
    public void sort(Person[] personArray) {
        for (int i = 0; i &amp;lt; personArray.length - 1; i++) {
            for (int j = 0; j &amp;lt; personArray.length - i - 1; j++) {
                if(personArray[j].age &amp;lt; personArray[j + 1].age) {
                    Person temp = personArray[j];
                    personArray[j] = personArray[j + 1];
                    personArray[j + 1] = temp;
                }
            }
        }
    }

    public void print(Person[] personArray) {
        for (int i = 0; i &amp;lt; personArray.length; i++) {
            System.out.println(personArray[i].toString());
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.编写老师类，使三个教师类继承老师类，在教师类中重写方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.homework;

public class Homework03 {
    public static void main(String[] args) {
        Professor professor = new Professor(&quot;LaoLi&quot;, 19, &quot;Math&quot;, 1900);
        professor.introduce();
    }
}

class Teacher {
    String name;
    int age;
    String post;
    double salary;

    public Teacher(String name, int age, String post, double salary) {
        this.name = name;
        this.age = age;
        this.post = post;
        this.salary = salary;
    }

    public void introduce() {
        System.out.println(&quot;Name: &quot; + name + &quot;, Age: &quot; + age + &quot;, Post: &quot; + post + &quot;, Salary: &quot; + salary);
    }
}

class Professor extends Teacher {
    Professor(String name, int age, String post, double salary) {
        super(name, age, post, salary);
    }
    public void introduce() {
        System.out.println(&quot;ProfessorName: &quot; + name + &quot;, Age: &quot; + age + &quot;, Post: &quot; + post + &quot;, Salary: &quot; + salary * 1.3);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.Point&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.homework;

public class Homework09 {
    public static void main(String[] args) {
        LabeledPoint point = new LabeledPoint(&quot;Thursday&quot;, 12 , 34);
    }
}

class Point {
    int x;
    int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
}

class LabeledPoint extends Point {
    String label;

    public LabeledPoint(String lable, int x, int y) {
        super(x, y);
        this.label = label;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.判断医生类是否各个属性相同&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.homework;

public class Homework10 {
    public static void main(String[] args) {
        Doctor human1 = new Doctor(&quot;Li&quot;, 19, &quot;A&quot;, &apos;F&apos;,1900);
        Doctor human2 = new Doctor(&quot;Li&quot;, 19, &quot;A&quot;, &apos;F&apos;,1900);
        System.out.println(human1.equals(human2));
    }
}

class Doctor {
    String name;
    int age;
    String job;
    char gender;
    double salary;

    public Doctor(String name, int age, String job, char gender, double salary) {
        this.name = name;
        this.age = age;
        this.job = job;
        this.gender = gender;
        this.salary = salary;
    }

    public void setter(String name, int age, String job, char gender, double salary) {
        this.name = name;
        this.age = age;
        this.job = job;
        this.gender = gender;
        this.salary = salary;
    }

    public void getter() {
        System.out.println(this.name + &quot; &quot; + this.age + &quot; &quot; + this.job + &quot; &quot; + this.gender + &quot; &quot; + this.salary);
    }

    public boolean equals(Object obj) {
        if(obj instanceof Doctor) {
            Doctor doctor = (Doctor) obj;
            return this.name.equals(doctor.name) &amp;amp;&amp;amp; this.age
                    == doctor.age &amp;amp;&amp;amp; this.job.equals(doctor.job) &amp;amp;&amp;amp; this.gender
                    == doctor.gender &amp;amp;&amp;amp; this.salary == doctor.salary;

        }
        return false;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.学生老师综合案例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.homework13;

public class Homework13 {
    public static void main(String[] args) {
        Teacher teacher1 = new Teacher(&quot;王芳&quot;, &apos;女&apos;, 39, 10);
        Student student1 = new Student(&quot;李明&quot;, &apos;男&apos;, 19, 222333);
        Person[] personArray = new Person[4];
        personArray[0] = teacher1;
        personArray[1] = student1;
        personArray[2] = new Teacher(&quot;王&quot;, &apos;男&apos;, 59, 10);
        personArray[3] = new Student(&quot;李&quot;, &apos;女&apos;, 19, 333222);
        Tool tool = new Tool();
        tool.sort(personArray);
        for(Person person : personArray) {
            System.out.println(person.toString());
            tool.play(person);
        }

    }
}

class Tool {
    public void sort(Person[] personArray) {
        Person temp = null;
        for (int i = 0; i &amp;lt; personArray.length - 1; i++) {
            for (int j = 0; j &amp;lt; personArray.length - 1 - i; j++) {
                if(personArray[j].getAge() &amp;lt; personArray[j + 1].getAge()) {
                    temp = personArray[j];
                    personArray[j] = personArray[j + 1];
                    personArray[j + 1] = temp;
                }
            }
        }
    }

    public void play(Person person) {
        if(person instanceof Teacher) {
            Teacher teacher = (Teacher) person;
            teacher.play();
        } else if(person instanceof Student) {
            Student student = (Student) person;
            student.play();
        } else {
            System.out.println(&quot;Fail to play!!&quot;);
        }
    }
}

class Person {
    private String name;
    private char sex;
    private int age;

    public Person(String name, char sex, int age) {
        this.name = name;
        this.sex = sex;
        this.age = age;
    }

    public String toString() {
        return    &quot;姓名：&quot; + this.name + &quot;\n&quot;
                + &quot;年龄：&quot; + this.age + &quot;\n&quot;
                + &quot;性别：&quot; + this.sex + &quot;\n&quot;;
    }

    public void play() {
        System.out.println(&quot;play&quot;);
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    public char getSex() {
        return this.sex;
    }

}

class Teacher extends Person {
    private int workAge;

    Teacher(String name, char sex, int age, int workAge) {
        super(name, sex, age);
        this.workAge = workAge;
    }

    public String toString() {
        return &quot;老师的信息：\n&quot; + super.toString() + &quot;工龄： &quot; + this.workAge;
    }

    public void play() {
        System.out.println(&quot;teacher play&quot;);
    }

    public int getWorkAge() {
        return workAge;
    }
}

class Student extends Person {
    private int id;
    Student(String name, char sex, int age, int id) {
        super(name, sex, age);
        this.id = id;
    }
    public String toString() {
        return &quot;学生的信息：\n&quot; + super.toString() + &quot;学号： &quot; + this.id;
    }

    public void play() {
        System.out.println(&quot;student play&quot;);
    }
    public int getId() {
        return id;
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为课程大作业的安排，我打算明天完成房屋出租系统设计之后，先进行Java网络编程部分的学习，以此复习计算机网络相关知识，再顺便水个作业，美哉美哉&lt;/p&gt;
</content:encoded></item><item><title>Java笔记</title><link>https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0object%E7%B1%BB%E9%87%8D%E5%86%99%E6%96%B9%E6%B3%95%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0object%E7%B1%BB%E9%87%8D%E5%86%99%E6%96%B9%E6%B3%95%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95/</guid><description>Object类方法，断点调试</description><pubDate>Wed, 12 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;听课笔记&lt;/h1&gt;
&lt;h2&gt;Object类&lt;/h2&gt;
&lt;p&gt;这一章会介绍object类的方法&lt;/p&gt;
&lt;p&gt;通过自动配置或者手动配置后可以运用IDEA查看Object的源代码以及其对应的方法，点击右键跳转，或者ctrl + 左键 跳转&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/55.png&quot; alt=&quot;55&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Object的子类String方法进行重写更改为，此时判断的是内容&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/56.png&quot; alt=&quot;56&quot; /&gt;&lt;/p&gt;
&lt;p&gt;整形的包装类equals判断方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/57.png&quot; alt=&quot;57&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/58.png&quot; alt=&quot;58&quot; /&gt;&lt;/p&gt;
&lt;p&gt;查看源码查看方法重写是程序员重要的技能&lt;/p&gt;
&lt;h3&gt;equals方法&lt;/h3&gt;
&lt;p&gt;在不重写equals方法的时候，Person类使用的是父类object的方法，这个时候判断的是两个引用是否指向同一个对象，如果需要用equals判断内容是否一致的时候需要重写方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.object;

public class Equals01 {
    public static void main(String[] args) {
        Person person1 = new Person(&quot;l&quot;, 1, &apos;女&apos;);
        Person person2 = new Person(&quot;k&quot;, 1, &apos;女&apos;);
        if(person2.equals(person1)) {
            System.out.println(&quot;Person 1 and Person 2 are equal&quot;);
        }
    }
}

class Person {
    private String name;
    private int age;
    private char gender;

    public Person(String name, int age, char gender) {
        this.name = name;
        this.age = age;
        this.gender = gender;
    }
    public boolean equals(Object obj) {
        if(this == obj) {
            return true;
        }
        if(obj instanceof Person) {
            Person person = (Person)obj;
            return person.name == person.name &amp;amp;&amp;amp; this.age == person.age &amp;amp;&amp;amp; this.gender == person.gender;
        }
        return false;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;hashCode方法&lt;/h3&gt;
&lt;p&gt;源码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public native int hashCode();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1.两个引用如果指向同一个对象，则哈希值一定是一样的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.object;

public class Hashcode {
    public static void main(String[] args) {
        AA aa1 = new AA();
        AA aa2 = new AA();
        AA aa3 = aa1;
        System.out.println(aa1.hashCode());
        System.out.println(aa2.hashCode());
        System.out.println(aa3.hashCode());
    }
}

class AA {}
/*运行结果
	1163157884
	1956725890
	1163157884
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.可以提高有哈希结构的容器效率&lt;/p&gt;
&lt;p&gt;3.哈希值是根据地址计算而来，但是不能够等价于地址（Java中代码是跑在虚拟机上的，不用关注于底层）&lt;/p&gt;
&lt;h3&gt;toString方法&lt;/h3&gt;
&lt;p&gt;源码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public String toString() {
        return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;全类名 + @ + 类的哈希地址十六进制&lt;/p&gt;
&lt;p&gt;全类名为 包名 + 类名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;com.npu.object.AA@4554617c
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一般而言我们会将Object类的toString方法进行重写，用于打印各个详细的属性信息&lt;/p&gt;
&lt;p&gt;当输出一个对象的时候，我们默认会调用这个对象的toString 方法进行输出&lt;/p&gt;
&lt;p&gt;以下是一个代码示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.object;

public class Hashcode {
    public static void main(String[] args) {
        AA aa = new AA();
        System.out.println(aa);
    }
}

class AA {
    int i;
    double m;

    public String toString() {
        return &quot;AA{i=&quot; + i + &quot;, m=&quot; + m + &quot;}&quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;finalize方法&lt;/h3&gt;
&lt;p&gt;当垃圾回收器检测到没有指向该对象的引用时，系统自动调用该对象的finalize方法，进行资源释放&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; AA aa = new AA();
 System.out.println(aa);
 aa = null;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当执行完毕的时候 AA的实例变为一个 垃圾 ，垃圾回收器就会被回收分配的堆空间&lt;/p&gt;
&lt;p&gt;程序员可以在销毁方法finalize 写一些自己的业务逻辑（通过重写finalize方法完成）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.object;

public class Hashcode {
    public static void main(String[] args) {
        AA aa = new AA();
        aa = null;
        System.out.println(&quot;代码结束&quot;);
    }
}

class AA {
    int i;
    double m;

    public String toString() {
        return &quot;AA{i=&quot; + i + &quot;, m=&quot; + m + &quot;}&quot;;
    }
    @Override
    protected void finalize() throws Throwable {
        System.out.println(&quot;Finalize called&quot;);
        super.finalize();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当回收的时候会输出对应的提示信息&lt;/p&gt;
&lt;p&gt;但是如上代码不会输出信息，因为回收调用回收方法的时候不是在置空引用后立即执行&lt;/p&gt;
&lt;p&gt;我们可以注定调用回收 System.gc( )&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Hashcode {
    public static void main(String[] args) {
        AA aa = new AA();
        aa = null;
        System.gc();//主动调用回收器
        System.out.println(&quot;代码结束&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;代码结束
Finalize called
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码结束输出在前&lt;/p&gt;
&lt;p&gt;因为gc方法不会阻塞代码&lt;/p&gt;
&lt;h2&gt;断点调试&lt;/h2&gt;
&lt;p&gt;1.在实际开发中要查找错误的时候，断点调试是很重要的一步，可以一步一步的看代码执行的过程，从而纠错&lt;/p&gt;
&lt;p&gt;2.在断点调试的时候是运行的，是以对象的运行类型来执行的&lt;/p&gt;
&lt;p&gt;3.断点调试也可以帮我们查看java底层源代码的执行过程，提高Java水平&lt;/p&gt;
&lt;h3&gt;断点调试中常用的快捷键&lt;/h3&gt;
&lt;p&gt;F7 跳入&lt;/p&gt;
&lt;p&gt;F8 跳过&lt;/p&gt;
&lt;p&gt;shift + F8 跳出方法&lt;/p&gt;
&lt;p&gt;F9 跳到下一个断点 支持动态添加断点，可以添加到自写代码或者jdk源码中&lt;/p&gt;
&lt;p&gt;force step into 强制进入jdk源码 alt + shift + F7&lt;/p&gt;
&lt;p&gt;面向对象编程中级内容到此结束，明天将进行零钱通项目的综合运用&lt;/p&gt;
</content:encoded></item><item><title>Java笔记</title><link>https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%9A%E6%80%81%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6%E5%A4%9A%E6%80%81%E7%9A%84%E5%BA%94%E7%94%A8/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%9A%E6%80%81%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6%E5%A4%9A%E6%80%81%E7%9A%84%E5%BA%94%E7%94%A8/</guid><description>多态，动态绑定机制，多态的应用</description><pubDate>Tue, 11 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;听课笔记&lt;/h1&gt;
&lt;h2&gt;多态&lt;/h2&gt;
&lt;p&gt;定义：方法或者对象具有多种形态&lt;/p&gt;
&lt;p&gt;1.重写或者重载体现出了方法的多态&lt;/p&gt;
&lt;p&gt;2.对象体现多态（是多态的核心）&lt;/p&gt;
&lt;p&gt;当一个类对于某一个类做一些操作的时候，我们可以对于每一个后向类编写方法，但是如果这些类都继承于同一个类，我们可以通过对于着一些类的父类编写方法来统一操作这一类的各个子类。通过这样做我们可以极大的提高代码的复用性&lt;/p&gt;
&lt;p&gt;例如我们有猫类，狗类继承于动物类，我们要通过一个人类来模拟喂食的时候需要在人类的方法中定义两个feed重载方法，这样子有大量的冗余&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.poly;

public class Poly01 {
    public static void main(String[] args) {
        Master Tom = new Master(&quot;汤姆&quot;);
        Dog dog =  new Dog(&quot;大黄&quot;);
        Bone bone = new Bone(&quot;棒骨&quot;);
        Tom.feed(dog, bone);

        Cat cat = new Cat(&quot;小花&quot;);
        Fish fish = new Fish(&quot;鱼&quot;);
        Tom.feed(cat, fish);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.poly;

public class Dog extends Animal {
    public Dog(String name) {
        super(name);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.poly;

public class Cat extends Animal {
    public Cat(String name) {
        super(name);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.poly;

public class Master {
    private String name;
    
    public void setName(String name) {
        this.name = name;
    }

    public void feed(Dog dog, Bone bone) {
        System.out.println(&quot;喂&quot; + dog.getName() + &quot;吃&quot; + bone.getName());
    }

    public void feed(Cat cat, Fish fish) {
        System.out.println(&quot;喂&quot; + cat.getName() + &quot;吃&quot; + fish.getName());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将上述的feed方法做更改，删除原先的feed方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void feed(Animal animal, Food food) {
        System.out.println(&quot;喂&quot; + animal.getName() + &quot;吃&quot; + food.getName());
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样子做，在后续加动物的子类，或者加事物的子类，都可以使用这个方法，大大提高了代码的可维护性&lt;/p&gt;
&lt;h2&gt;多态重点&lt;/h2&gt;
&lt;p&gt;1.一个对象的编译类型和运行类型可以不一致&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Animal animal = new Dog();
//animal的编译类型是Animal 运行类型是Dog类
//可以用父类的引用指向子类的一个对象
animal = new Cat();//运行类型更改为Cat
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.编译类型在定义对象时就被确定，不要能够改变&lt;/p&gt;
&lt;p&gt;3.运行类型可以变化&lt;/p&gt;
&lt;p&gt;4.编译类型看定义时 = 左边的内容， 运行时类型看 = 右边的内容&lt;/p&gt;
&lt;h2&gt;多态的细节&lt;/h2&gt;
&lt;p&gt;多态的前提是两个类存在继承关系&lt;/p&gt;
&lt;h3&gt;向上转型&lt;/h3&gt;
&lt;p&gt;父类的引用指向子类的对象&lt;/p&gt;
&lt;p&gt;语法：父类类型 父类引用名称 = new 子类类型（）；&lt;/p&gt;
&lt;p&gt;特点：编译类型是父类，运行类型是子类&lt;/p&gt;
&lt;p&gt;可以调用父类的所有成员，不可以调用子类的特有成员，但是如果有和父类的同名方法，最终调用的是子类方法&lt;/p&gt;
&lt;p&gt;这是因为在javac编译的时候只会认为对象是父类，但是交给运行器java的时候要从子类开始查找方法，按照继承那一章的步骤同理&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/53.png&quot; alt=&quot;53&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;向下转型&lt;/h3&gt;
&lt;p&gt;语法：子类类型 子类引用名称 = （子类类型） 父类引用&lt;/p&gt;
&lt;p&gt;只可以强制转化父类的引用，不能够强制转化父类的对象&lt;/p&gt;
&lt;p&gt;要求父类的引用必须要指向当前目标类型的对象  例如：不能将指向狗的动物类转化为猫类&lt;/p&gt;
&lt;p&gt;这样将父类引用转化为子类，即可使用子类类型的成员&lt;/p&gt;
&lt;h3&gt;属性细节&lt;/h3&gt;
&lt;p&gt;属性没有重写之说，属性的值看编译类型&lt;/p&gt;
&lt;h3&gt;instanceOf&lt;/h3&gt;
&lt;h3&gt;比较操作运算符&lt;/h3&gt;
&lt;p&gt;运行类型 是否是 某类型或者该类型的子类型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void main(String[] args) {
        Master Tom = new Master(&quot;汤姆&quot;);
        Dog dog = new Dog(&quot;大黄&quot;);
        Bone bone = new Bone(&quot;棒骨&quot;);
        Tom.feed(dog, bone);

        Cat cat = new Cat(&quot;小花&quot;);
        Fish fish = new Fish(&quot;鱼&quot;);
        Tom.feed(cat, fish);

        Animal animal = new Animal(&quot;123&quot;);
        System.out.println(animal instanceof Animal);
        System.out.println(cat instanceof Animal);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;喂大黄吃棒骨
喂小花吃鱼
true
true
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Java的动态绑定机制&lt;/h2&gt;
&lt;p&gt;以下是一个代码示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.dynamic;

public class Main {
    public static void main(String[] args) {
        A a = new B();
        System.out.println(a.sum());//40用运行时的类型b
        System.out.println(a.sum1());//30用运行时的类型b
    }
}

class A {
    public int i = 10;
    public int sum() {
        return getl() + 10;
    }
    public int getl() {
        return i;
    }
    public int sum1() {
        return i + 10;
    }
}

class B extends A {
    public int i = 20;
    public int sum() {
        return i + 20;
    }
    public int getl() {
        return i;
    }
    public int sum1() {
        return i + 10;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在将b子类的sum()方法注释，调用的就是父类的sum方法，但是这里问题出现了，到底是用的父类的getl方法还是子类的getl方法，引出了如下的规则&lt;/p&gt;
&lt;p&gt;动态绑定机制：&lt;/p&gt;
&lt;p&gt;1.当调用对象方法的时候，方法会和该对象的内存地址/运行类型做绑定&lt;/p&gt;
&lt;p&gt;System.out.println(a.sum());&lt;/p&gt;
&lt;p&gt;此时调用父类sum方法，sum中调用子类的getl方法，最终结果是30&lt;/p&gt;
&lt;p&gt;2.当调用对象属性的时候，没有动态绑定机制，哪里声明，就在那里使用&lt;/p&gt;
&lt;p&gt;将子类方法sum1注释，调用了父类的方法，而属性是父类的i，最终的结果是20&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.dynamic;

public class Main {
    public static void main(String[] args) {
        A a = new B();
        System.out.println(a.sum());//30
        System.out.println(a.sum1());//20
    }
}

class A {
    public int i = 10;
    public int sum() {
        return getl() + 10;
    }
    public int getl() {
        return i;
    }
    public int sum1() {
        return i + 10;
    }
}

class B extends A {
    public int i = 20;
    public int getl() {
        return i;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;多态的应用&lt;/h2&gt;
&lt;h3&gt;多态数组&lt;/h3&gt;
&lt;p&gt;数组的定义是父类类型，保存的元素类型是子类类型&lt;/p&gt;
&lt;p&gt;以下是一个存储老师和学生的Person类数组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.polyarr;

public class Main {
    public static void main(String[] args) {
        Person[] personArr = new Person[2];
        personArr[0] = new Teacher(&quot;John&quot;, 23);
        personArr[1] = new Student(&quot;Jane&quot;, 25);
        Student student = (Student) personArr[1];
        Teacher teacher = (Teacher) personArr[0];
        student.say();
        teacher.say();
    }
}

class Person {
    String name;
    int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public void say() {
        System.out.println(name + &quot; &quot; + age);
    }
}

class Student extends Person {
    public Student(String name, int age) {
        super(name, age);
    }

    public void say() {
        System.out.println(&quot;I am student&quot; + name);
    }
}

class Teacher extends Person {
    public Teacher(String name, int age) {
        super(name, age);
    }

    public void say() {
        System.out.println(&quot;I am teacher&quot; + name);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;主函数中也可以不做类型转化，因为调用的方法会根据运行类型做转化&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Main {
    public static void main(String[] args) {
        Person[] personArr = new Person[2];
        personArr[0] = new Teacher(&quot;John&quot;, 23);
        personArr[1] = new Student(&quot;Jane&quot;, 25);
        for(int i = 0; i&amp;lt;personArr.length; i++) {
            personArr[i].say();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是在调用方法的时候需要向下转换调用方法，转换为子类型的引用再调用子类方法&lt;/p&gt;
&lt;p&gt;在这里还运用了类型的判断（运行类型判断）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.polyarr;

public class Main {
    public static void main(String[] args) {
        Person[] personArr = new Person[2];
        personArr[0] = new Teacher(&quot;John&quot;, 23);
        personArr[1] = new Student(&quot;Jane&quot;, 25);
        for(int i = 0; i&amp;lt;personArr.length; i++) {
            personArr[i].say();
            if(personArr[i] instanceof Teacher) {
                Teacher teacher = (Teacher) personArr[i];
                teacher.teach();
            } else {
                Student student = (Student) personArr[i];
                student.study();
            }
        }
    }
}

class Person {
    String name;
    int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public void say() {
        System.out.println(name + &quot; &quot; + age);
    }
}

class Student extends Person {
    public Student(String name, int age) {
        super(name, age);
    }

    public void say() {
        System.out.println(&quot;I am student &quot; + name);
    }

    public void study() {
        System.out.println(&quot;studying&quot;);
    }
}

class Teacher extends Person {
    public Teacher(String name, int age) {
        super(name, age);
    }

    public void say() {
        System.out.println(&quot;I am teacher &quot; + name);
    }

    public void teach() {
        System.out.println(&quot;teaching&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;多态参数&lt;/h3&gt;
&lt;p&gt;1.前文喂动物的时候曾使用过&lt;/p&gt;
&lt;p&gt;2.模拟工厂分发工资&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.polyparameter;

public class Main {
    public static void main(String[] args) {
        Worker worker = new Worker(&quot;大壮&quot;, 2000);
        Manager manager = new Manager(&quot;小明&quot;, 2300, 3000);
        Tool tool = new Tool();
        System.out.println(tool.showEmpAnnual(worker));
        System.out.println(tool.showEmpAnnual(manager));
        tool.testWork(worker);
        tool.testWork(manager);
    }
}

class Tool {
    public double showEmpAnnual(Employee emp) {
        if(emp instanceof Worker) {
            Worker worker = (Worker) emp;
            return worker.calculateSalary();
        } else {
            Manager manager = (Manager) emp;
            return manager.calculateSalary();
        }
    }
    public void testWork(Employee emp) {
        if(emp instanceof Worker) {
            Worker worker = (Worker) emp;
            worker.work();
        } else {
            Manager manager = (Manager) emp;
            manager.manage();
        }
    }
}

class Employee {
    String name;
    double salary;

    public Employee(String name, double salary) {
        this.name = name;
        this.salary = salary;
    }

    public double calculateSalary() {
        return salary * 12;
    }
}

class Worker extends Employee {
    public Worker(String name, double salary) {
        super(name, salary);
    }
    public void work() {
        System.out.println(&quot;work&quot;);
    }

    public double calculateSalary() {
        return super.calculateSalary();
    }
}

class Manager extends Employee {
    double bonus;
    public Manager(String name, double salary, double bonus) {
        super(name, salary);
        this.bonus = bonus;
    }
    public double calculateSalary() {
        return super.calculateSalary() + bonus;
    }
    public void manage() {
        System.out.println(&quot;manage&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上就是有关于多态的内容，相关的联系还得再多做习题巩固&lt;/p&gt;
&lt;p&gt;明天会来到Object类的详解，以及断点调试相关内容&lt;/p&gt;
</content:encoded></item><item><title>Java笔记</title><link>https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E7%BB%A7%E6%89%BF%E9%87%8D%E5%86%99/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E7%BB%A7%E6%89%BF%E9%87%8D%E5%86%99/</guid><description>继承，重写</description><pubDate>Mon, 10 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;听课笔记&lt;/h1&gt;
&lt;h2&gt;面向对象的三大特征&lt;/h2&gt;
&lt;h3&gt;继承&lt;/h3&gt;
&lt;p&gt;为了解决代码复用性的情况，引出了继承的概念&lt;/p&gt;
&lt;p&gt;例如以下的代码有小学生类以及大学生类，除了各自特有的方法，他们的属性，方法大致相同&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.extend;

public class Pupil {
    public String name;
    public int age;
    private double score;

    Pupil(String name, int age, double score) {
        this.name = name;
        this.age = age;
        this.score = score;
    }

    public void infoPrint() {
        System.out.println(&quot;Name: &quot; + name + &quot;, Age: &quot; + age + &quot;, Score: &quot; + score);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.extend;

public class Graduate {
    public String name;
    public int age;
    private double score;

    Graduate(String name, int age, double score) {
        this.name = name;
        this.age = age;
        this.score = score;
    }

    public void infoPrint() {
        System.out.println(&quot;Name: &quot; + name + &quot;, Age: &quot; + age + &quot;, Score: &quot; + score);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.extend;

public class Extends01 {
    public static void main(String[] args) {
        Graduate human1 = new Graduate(&quot;thrinisy&quot;, 18, 100);
        human1.infoPrint();
        Pupil pupil1 = new Pupil(&quot;pupil&quot;, 11, 100);
        pupil1.infoPrint();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当多个类存在相同的属性和方法的时候，我们可以从类中抽象出这些相同的属性和方法制作父类，所有的子类中不需要重新定义这一些属性方法，而是通过extends 关键字声明即可&lt;/p&gt;
&lt;p&gt;父类又称为超类，基类&lt;/p&gt;
&lt;p&gt;子类又称派生类&lt;/p&gt;
&lt;p&gt;extends 使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Children extends Father {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将上述的例子稍作更改&lt;/p&gt;
&lt;p&gt;将小学生和大学生抽象出一个父类 人类People&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.extend;

public class People {
    public String name;
    public int age;
    private double score;

    public void infoPrint() {
        System.out.println(&quot;Name: &quot; + name + &quot;, Age: &quot; + age + &quot;, Score: &quot; + score);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;大学生&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.extend;

public class Graduate extends People {
    public void speak () {
        System.out.println(&quot;大学生阴暗的爬行~&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;小学生&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.extend;

public class Pupil extends People {
    public void speak () {
        System.out.println(&quot;小学生玩游戏&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;继承的细节&lt;/h3&gt;
&lt;p&gt;1.子类继承了所有的属性和方法，但是私有的属性和方法不能够直接访问，必须要通过共有的方法才可以对private 修饰的属性进行修改&lt;/p&gt;
&lt;p&gt;例如我们要修改上述的成绩属性，我们需要在People定义一个公共的方法来进行更改&lt;/p&gt;
&lt;p&gt;要调用私有的方法只可以通过一个包含该私有方法的公共方法进行调用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void setScore(double score) {
        this.score = score;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样才可以在子类中调用该方法进行修改&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.extend;

public class Extends01 {
    public static void main(String[] args) {
        Graduate graduate = new Graduate();
        graduate.name = &quot;thrinisty&quot;;
        graduate.age = 18;
        graduate.setScore(11.3);
        graduate.infoPrint();

        Pupil pupil = new Pupil();
        pupil.name = &quot;james&quot;;
        pupil.age = 11;
        pupil.setScore(110.3);
        pupil.infoPrint();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.子类必须调用父类的构造器，完成父类的初始化&lt;/p&gt;
&lt;p&gt;在创建子类的时候，先调用父类的构造器，再调用子类的构造器（默认使用了super使用父类的构造器）&lt;/p&gt;
&lt;p&gt;3.当创建子类对象的时候，不管使用子类的哪个构造器，默认情况下总会调用父类的无参构造器，如果父类没有无参构造器，则必须要在子类的构造器中用super指定用哪个父类的构造器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public Graduate(String name, int age) {
        super(name, age);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt; People(String name, int age) {
        this.name = name;
        this.age = age;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.super在使用的时候需要放在构造器的第一行&lt;/p&gt;
&lt;p&gt;5.super和 this 不同存在于同一个构造器中，因为两个都必须要写在第一行&lt;/p&gt;
&lt;p&gt;6.java中的所有类都是Object类的子类&lt;img src=&quot;../images/52.png&quot; alt=&quot;52&quot; /&gt;&lt;/p&gt;
&lt;p&gt;7.父类构造器的调用不限于直接父类，将向上追溯到Object类&lt;/p&gt;
&lt;p&gt;所以当C继承于B继承于A的时候，调用C类构造器先执行的是A的构造器---&amp;gt;B—&amp;gt;C&lt;/p&gt;
&lt;p&gt;8.Java的单继承，一个子类只能继承一个父类&lt;/p&gt;
&lt;p&gt;9.不能滥用继承关系，子类和父类必须要满足 子类是父类 的关系&lt;/p&gt;
&lt;h3&gt;继承的本质（内存布局）&lt;/h3&gt;
&lt;p&gt;在访问属性的时候按照查找关系来返回信息，先检查子类有无这个属性，有则返回，无则向上访问直到找到属性&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.extend.test;

public class Inside {
    public static void main(String[] args) {
        Son son = new Son();
        System.out.println(&quot;name &quot; + son.name);
    }
}

class Grandpa {
    String name = &quot;Grandpa&quot;;
    String hobby = &quot;GHobby&quot;;
}

class Father extends Grandpa {
    String name = &quot;Father&quot;;
    int age = 40;
}

class Son extends Father {
    String name = &quot;Son&quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;../images/53.png&quot; alt=&quot;53&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;super关键字&lt;/h3&gt;
&lt;p&gt;super是父类的引用，可以访问父类的方法 属性 构造器&lt;/p&gt;
&lt;p&gt;但是不可以访问父类的私有方法以及私有属性&lt;/p&gt;
&lt;p&gt;1.当子类父类有重名属性方法时，访问父类的重名属性方法需要使用super，没有重名的话使用super this 直接访问的效果是一样的，但是为了代码的可读性，要访问属性或者方法之前，统一加上 this 或者 super 显示的指出要访问的是本类还是父类的属性方法&lt;/p&gt;
&lt;p&gt;2.有同名的属性方法就近找，先找子类再找父类&lt;/p&gt;
&lt;h3&gt;方法的重写&lt;/h3&gt;
&lt;p&gt;当子类的一个方法和父类的某一个方法重名，返回类型一致，参数一致，我们就说子类的方法覆盖了父类的方法&lt;/p&gt;
&lt;p&gt;以下是一个代码示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.extend.overwrite;

public class Override {
    public static void main(String[] args) {
        Cat cat = new Cat();
        Dog dog = new Dog();
        cat.speak();
        dog.speak();
    }
}
class Animal {
    public int age;
    public void speak() {
        System.out.println(&quot;speak&quot;);
    }
}
class Cat extends Animal {
    public void speak() {
        System.out.println(&quot;CAT speak&quot;);
    }
}
class Dog extends Animal {
    public void speak() {
        System.out.println(&quot;Dog speak&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;方法重写细节&lt;/h3&gt;
&lt;p&gt;1.子类的方法参数，方法名称要和父类的一致&lt;/p&gt;
&lt;p&gt;2.子类的返回类型要和父类的方法类型一样或者是父类返回类型的子类&lt;/p&gt;
&lt;p&gt;3.子类方法不可以缩小父类方法的访问权限&lt;/p&gt;
&lt;p&gt;重写和重载之间的比较&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/54.png&quot; alt=&quot;54&quot; /&gt;&lt;/p&gt;
&lt;p&gt;明天会来到面向对象中的多态&lt;/p&gt;
</content:encoded></item><item><title>Java笔记</title><link>https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0idea%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83java%E5%8C%85%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%B0%81%E8%A3%85/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0idea%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83java%E5%8C%85%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%B0%81%E8%A3%85/</guid><description>IDEA集成开发环境，Java包，访问修饰符，封装</description><pubDate>Sun, 09 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;听课笔记&lt;/h1&gt;
&lt;h2&gt;IDEA的使用&lt;/h2&gt;
&lt;p&gt;IDEA支持30天试用，如果是学生或者教师可以在官网使用学校邮箱或者学信网获取授权使用&lt;/p&gt;
&lt;p&gt;IDEA之中各种快捷键，定义模板，变量名，自动补全，自动添加导入可以极大地增加开发的效率&lt;/p&gt;
&lt;h2&gt;Java中的包&lt;/h2&gt;
&lt;p&gt;包的本质是创建不同的文件夹来保存类文件&lt;/p&gt;
&lt;p&gt;包有三个重大的作用&lt;/p&gt;
&lt;p&gt;1.可以区分相同名字的类&lt;/p&gt;
&lt;p&gt;2.当类很多的时候可以高效的管理类&lt;/p&gt;
&lt;p&gt;3.控制访问范围&lt;/p&gt;
&lt;h3&gt;包的基本语法&lt;/h3&gt;
&lt;p&gt;package com.thrinisty&lt;/p&gt;
&lt;p&gt;package 关键字 表示打包&lt;/p&gt;
&lt;p&gt;com.thrinisty 表示包名&lt;/p&gt;
&lt;p&gt;以下是一个包的入门案例&lt;/p&gt;
&lt;p&gt;建立了两个包 小强的包 小明的包 在各自的包中定义了Dog方法&lt;/p&gt;
&lt;p&gt;在use包中定义了主方法，主方法中可以导入小明的Dog类，但是再导入小强的Dog类因为方法同名，可以通过com.xiaoqiang.Dog()使用小强的Dog类&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/51.png&quot; alt=&quot;51&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package use;

import com.xiaoming.Dog;

public class Test {
    public static void main(String[] args) {
        Dog dog = new Dog();
        System.out.println(dog);

        com.xiaoqiang.Dog dog1 = new com.xiaoqiang.Dog();
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;包的命名&lt;/p&gt;
&lt;p&gt;命名规则，只能包含数子，字母，小圆点，但不能够是用数字开头，不能是关键字或保留字&lt;/p&gt;
&lt;p&gt;命名规范&lt;/p&gt;
&lt;p&gt;一般是小写字母 + 小圆点&lt;/p&gt;
&lt;p&gt;com.公司名.项目名.业务模块名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.sina.crm.user;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Java中常用的包&lt;/h3&gt;
&lt;p&gt;1.lang 基本包，默认引入，不需要再次引入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.lang.*;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.util 工具包系统提供的工具类，例如Scanner&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.*
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.net 网络包，用于网络开发&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.net.*
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.awt 界面开发工具 GUI&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.awt.*
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;导入包&lt;/h3&gt;
&lt;p&gt;建议需要用哪个类就导入哪个类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Scanner;//导入Scanner类
import java.util.Scanner;//导入util下的所有类
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.pkg;

import java.util.Arrays;
public class Import {
    public static void main(String[] args) {
        int[] arr = {13, 35, 16, 67, 33};
        Arrays.sort(arr);
        System.out.println(Arrays.toString(arr));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用给定的 Arrays 方法排序输出&lt;/p&gt;
&lt;p&gt;1.package 作用是声明当前类的包，需要放在类的最上面，一个类中最多只能有一个package&lt;/p&gt;
&lt;p&gt;2.import 位置放在package下面，类定义的前面，可以导入多个包方法，且没有顺序要求&lt;/p&gt;
&lt;h2&gt;访问修饰符&lt;/h2&gt;
&lt;p&gt;1.public 公开 对外公开&lt;/p&gt;
&lt;p&gt;2.protected 受保护的 对子类和同一个包公开&lt;/p&gt;
&lt;p&gt;3.默认 向同一个包的类公开&lt;/p&gt;
&lt;p&gt;4.private 私有的 只有类的本身可以访问，不对外公开&lt;/p&gt;
&lt;p&gt;使用的注意事项&lt;/p&gt;
&lt;p&gt;1.修饰符可以用来修饰类中的属性，成员方法，以及类的本身&lt;/p&gt;
&lt;p&gt;2.只有默认和public才可以修饰类&lt;/p&gt;
&lt;p&gt;代码示例：（以属性举例）&lt;/p&gt;
&lt;p&gt;A类定义(同一个类中可以访问所有的变量)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.modifier;

public class A {
    public int n1 = 100;
    protected int n2 = 200;
    int n3 = 300;
    private int n4 = 400;
    //同一个类下可以访问所有的变量
    public void m1() {
        System.out.println(n1 + &quot; &quot; + n2 + &quot; &quot; + n3 + &quot; &quot; + n4);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;B类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.modifier;

public class B {
    public void test() {
        A a = new A();
        System.out.println(a.n1 + &quot; &quot; + a.n2 + &quot; &quot; + a.n3);
        //在同一个包下可以访问 默认 public protected 修饰的变量
        //不可以访问private修饰的n4属性
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;C类的子类权限暂时不做验证，在讲完子类后再做演示&lt;/p&gt;
&lt;p&gt;D类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.pkg;

import com.npu.modifier.A;
public class D {
    public void test() {
        A a = new A();
        System.out.println(a.n1);
        //在不同包下 只可以访问public修饰的属性方法
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;主函数调用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.modifier;

import com.npu.pkg.D;

public class Main {
    public static void main(String[] args) {
        A a = new A();
        a.test();
        B b = new B();
        b.test();
        D d = new D();
        d.test();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;面向对象的三大特征&lt;/h2&gt;
&lt;h3&gt;封装&lt;/h3&gt;
&lt;p&gt;把抽象出来的属性和方法封装在一起，数据被保护在内部，程序的其他部分只有通过授权的方法才可以对于数据进行操作&lt;/p&gt;
&lt;p&gt;好处：&lt;/p&gt;
&lt;p&gt;1.可以隐藏实现的细节，不必对外展示，外部直接传入参数即可使用&lt;/p&gt;
&lt;p&gt;2.可以对数据进行验证，保证安全合理&lt;/p&gt;
&lt;h3&gt;封装的实现步骤&lt;/h3&gt;
&lt;p&gt;1.将属性私有化&lt;/p&gt;
&lt;p&gt;2.提供一个公共的 set 方法用于对属性进行判断以及赋值(伪代码)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void setNum() {
	if(){
		set(Num);
	} else {
		sout(info)
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.提供一个公共的 get 方法，用于获取某个属性的值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public 类型 getNum(){
	return data;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以下是一个代码示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.encap;

public class Person {

    public String name;
    private int age;
    private double salary;

    public void setName(String name) {
        if(name.length() &amp;lt; 10) {
            this.name = name;
        } else {
            System.out.println(&quot;Name is too long&quot;);
        }
    }

    public void setSalary(double salary) {
        if(salary &amp;gt;= 0) {
            this.salary = salary;
        } else {
            System.out.println(&quot;illegal Salary&quot;);
        }
    }
    public void setAge(int age) {
        if(age &amp;gt;= 0 &amp;amp;&amp;amp; age &amp;lt;= 120) {
            this.age = age;
        } else {
            System.out.println(&quot;illegal Age&quot;);
        }
    }
    public void print() {
        System.out.println(&quot;Name: &quot; + name + &quot; Age: &quot; + age + &quot; Salary: &quot; + salary);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;主函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.encap;

public class Main {
    public static void main(String[] args) {
        Person p = new Person();
        p.setSalary(500);
        p.setName(&quot;Nikola&quot;);
        p.setAge(18);
        p.print();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以将构造器和封装结合起来&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public Person(String name, int age, double salary) {
        setName(name);
        setAge(age);
        setSalary(salary);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.encap;

public class Main {
    public static void main(String[] args) {
        Person p = new Person(&quot;lory&quot;, 18, 3000);
        p.print();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一个模拟银行注册的代码案例&lt;/p&gt;
&lt;p&gt;主函数调用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.encap;

public class AccountTest {
    public static void main(String[] args) {
        Account account = new Account(&quot;thrinisy&quot;, 2000, &quot;123&quot;);
        account.print();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Account类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.encap;

public class Account {
    private String name;
    private double balance;
    private String password;

    public Account(String name, double balance, String password) {
        setName(name);
        setBalance(balance);
        setPassword(password);
    }
    public void setName(String name) {
        if(name.length() == 2 || name.length() == 3|| name.length() == 4) {
            this.name = name;
            System.out.println(&quot;设置成功，用户名是&quot; + name);
        } else {
            this.name = &quot;王女士&quot;;
            System.out.println(&quot;姓名必须要满足2-4位，设置为默认用户名字：王女士&quot;);
        }
    }
    public void setBalance(double balance) {
        if(balance &amp;gt; 20) {
            this.balance = balance;
            System.out.println(&quot;设置成功，余额为&quot; + balance);
        } else {
            System.out.println(&quot;设置失败，余额必须大于20 ，赋初值位6666.6&quot;);
            this.balance = 6666.6;
        }
    }
    public void setPassword(String password) {
        if(password.length() == 6) {
            this.password = password;
            System.out.println(&quot;设置密码成功&quot;);
        } else {
            this.password = &quot;123456&quot;;
            System.out.println(&quot;设置密码失败，密码必须为六位数，默认设置为123456&quot;);
        }
    }
    public void print() {
        System.out.println(&quot;name = &quot; + name + &quot;, balance = &quot; + balance + &quot;, password = &quot; + password);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;姓名必须要满足2-4位，设置为默认用户名字：王女士
设置成功，余额为2000.0
设置密码失败，密码必须为六位数，默认设置为123456
name = 王女士, balance = 2000.0, password = 123456
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;周末有事耽搁了，本来打算今天对于继承 多态收尾的，就把这两个部分放在明天来学习&lt;/p&gt;
</content:encoded></item><item><title>Java笔记</title><link>https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E9%87%8D%E8%BD%BD%E5%A4%9A%E5%8F%82%E6%96%B9%E6%B3%95%E6%9E%84%E9%80%A0%E5%99%A8%E4%BD%9C%E7%94%A8%E5%9F%9Fthis/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E9%87%8D%E8%BD%BD%E5%A4%9A%E5%8F%82%E6%96%B9%E6%B3%95%E6%9E%84%E9%80%A0%E5%99%A8%E4%BD%9C%E7%94%A8%E5%9F%9Fthis/</guid><description>重载，多参方法，构造器，作用域，this</description><pubDate>Sat, 08 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;听课笔记&lt;/h1&gt;
&lt;h2&gt;Java中的重载&lt;/h2&gt;
&lt;p&gt;Java中允许同名方法的存在，这种情况下要求同名方法的参数不同&lt;/p&gt;
&lt;p&gt;以下是一个具体的案例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object {
    public static void main(String[] args) {
        Tool myTool = new Tool();
		myTool.Print(1);
		myTool.Print(&apos;1&apos;);
		myTool.Print(&quot;This is overload&quot;);
    }
}

class Tool {
	public void Print(int n) {
		System.out.println(n);
	}
	public void Print(char n) {
		System.out.println(n);
	}
	public void Print(String n) {
		System.out.println(n);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重载除了形式参数类型不一样还可以数量不一样&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object {
    public static void main(String[] args) {
        Tool myTool = new Tool();
		System.out.println(myTool.Test(1, 2));
		System.out.println(myTool.Test(1, 2.0));
		System.out.println(myTool.Test(1.0, 2));
		System.out.println(myTool.Test(1, 2, 3));
    }
}

class Tool {
	public int Test(int m, int n) {
		return m + n;
	}
	public double Test(int m, double n) {
		return m + n;
	}
	public double Test(double m, int n) {
		return m + n;
	}
	public int Test(int n1, int n2, int n3) {
		return n1 + n2 + n3;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;练习题目&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object {
    public static void main(String[] args) {
        Tool myTool = new Tool();
		System.out.println(myTool.Test(1, 2));
		System.out.println(myTool.Test(1.0, 2.0));
		System.out.println(myTool.Test(1.0, 3.0, 2.0));
    }
}

class Tool {
	public int Test(int m, int n) {
		return m &amp;gt; n ? m : n;
	}
	public double Test(double m, double n) {
		return m &amp;gt; n ? m : n;
	}
	public double Test(double m, double n, double i) {
		double max = m &amp;gt; n ? m : n;
		return max &amp;gt; i ? max : i;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Java中的可变参数&lt;/h2&gt;
&lt;p&gt;java中允许将同一个类中多个同名同功能但参数个数不同的方法，封装为一个方法，可以通过可变参数实现&lt;/p&gt;
&lt;p&gt;基本语法&lt;/p&gt;
&lt;p&gt;访问修饰符 返回类型 方法名称（数据类型... 形参名称）&lt;/p&gt;
&lt;p&gt;使用可变参数的时候作为数组来进行使用&lt;/p&gt;
&lt;p&gt;以下是一个可变参数的代码示例，可以计算 n 个数据的和&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object {
    public static void main(String[] args) {
        Tool myTool = new Tool();
		System.out.println(myTool.Test());
		System.out.println(myTool.Test(1.0, 2.0));
		System.out.println(myTool.Test(1.0, 3.0, 2.0));
    }
}

class Tool {
	public double Test(double... nums) {
		System.out.println(&quot;接收了&quot; + nums.length + &quot;个参数&quot;);
		double result = 0.0;
		for(int i = 0; i &amp;lt; nums.length; i++) {
			result +=nums[i];
		}
		return result;
	}	
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;可变参数的使用细节&lt;/h3&gt;
&lt;p&gt;1.可变参数的参数个数可以是 0 个或者任意多个&lt;/p&gt;
&lt;p&gt;2.可变参数的实参可以为数组（但是不允许可变的传统数组）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object {
    public static void main(String[] args) {
        Tool myTool = new Tool();
		int arr[] = {1, 2, 3};	
		myTool.Test(arr);
    }
}

class Tool {
	public void Test(int... nums) {
		System.out.println(&quot;接收了&quot; + nums.length + &quot;个参数&quot;);
	}	
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;//如下的代码编译错误
public class Object {
    public static void main(String[] args) {
        Tool myTool = new Tool();
		int arr1[] = {1, 2, 3};
		int arr2[] = {1, 2, 3};
		int arr3[] = {1, 2, 3};
		myTool.Test(arr1);
		myTool.Test(arr1, arr2, arr3);
    }
}

class Tool {
	public void Test(int... nums[]) {
		System.out.println(&quot;接收了&quot; + nums.length + &quot;个参数&quot;);	
		for(int i = 0; i &amp;lt; nums.length; i++) {
			System.out.println(&quot;第&quot;+ i + &quot;个数组&quot;);
			for(int j = 0; j &amp;lt; nums[i].length; j++) {
				System.out.print(nums[i][j] + &quot; &quot;);
			}
		}
	}
	
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.可变参数的本质就是数组&lt;/p&gt;
&lt;p&gt;4.可变参数可以和普通类型的参数一起放在形参列表，但是必须要保证可变参数在最后&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object {
    public static void main(String[] args) {
        Tool myTool = new Tool();
		int arr[] = {1, 2, 3};	
		myTool.Test(&quot;arr&quot;, arr);
//	myTool.Test(arr, &quot;arr&quot;);
    }
}
class Tool {
	public void Test(String str, int... nums) {
//  public void Test(int... nums, String str) {
		System.out.println(&quot;字符串&quot; + str);	
		System.out.println(&quot;接收了&quot; + nums.length + &quot;个参数&quot;);
	}	
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.一个形参列表只能出现一个可变参数 ，不允许多个可变参数&lt;/p&gt;
&lt;p&gt;以下是一个练习题目 其目的是接收学生的名字和不确定个数的成绩&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object {
    public static void main(String[] args) {
        Tool myTool = new Tool();
		double result = myTool.Test(&quot;Li Wen&quot;, 100.0, 33.0, 220.0);
		System.out.println(&quot;学生的总成绩是&quot; + result);
    }
}

class Tool {
	public double Test(String str, double... nums) {
		System.out.println(&quot;学生&quot; + str);	
		System.out.println(&quot;有&quot; + nums.length + &quot;个成绩&quot;);	
		double result = 0;
		for(int i = 0; i &amp;lt; nums.length; i++) {
			result += nums[i];
		}
		return result;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Java中的作用域&lt;/h2&gt;
&lt;p&gt;局部变量一般是在成员方法中定义的变量&lt;/p&gt;
&lt;h3&gt;全局变量（属性）&lt;/h3&gt;
&lt;p&gt;也就是属性，作用于是整个类体，方法可以使用他们&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object {
    public static void main(String[] args) {
        Tool myTool = new Tool();
		
    }
}

class Tool {
	String name = &quot;jack&quot;;

	public void Test() {
		int n = 10;
		System.out.println(name);
	}

	public void Test1() {
		//System.out.println(n);
	}	
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;局部变量&lt;/h3&gt;
&lt;p&gt;除了属性外的其他变量，作用域在代码块中&lt;/p&gt;
&lt;h3&gt;注意要点&lt;/h3&gt;
&lt;p&gt;全局变量可以不赋值，有默认值，局部变脸必须要赋值才可以使用，因为没有默认值&lt;/p&gt;
&lt;p&gt;作用域注意事项&lt;/p&gt;
&lt;p&gt;1.属性和局部变量可以重名，访问时遵循就近原则&lt;/p&gt;
&lt;p&gt;2.在同一个作用域内，同一个成员方法中，两个局部变量不能够重名&lt;/p&gt;
&lt;p&gt;这里 java 和 c 语言中存在不同&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;C语言&lt;/strong&gt;：允许在嵌套的代码块中重新定义与外层同名的变量，内层的变量会遮蔽外层的变量。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Java&lt;/strong&gt;：不允许在嵌套的代码块中重新定义与外层同名的变量，编译器会报错。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3.属性的生命周期长于局部变量，属性随着对象创建而创建，随对象的销毁而销毁，局部变量是在方法调用时产生，调用完成后销毁&lt;/p&gt;
&lt;p&gt;4.全局变量可以被本类使用和其他的类使用（通过对象调用完成）局部变量只可以在本类的对应方法中使用&lt;/p&gt;
&lt;p&gt;也可以支持对象之间的相互传对象本身，编译通过，但是在实际编写代码的时候应该尽量避免相互依赖&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object {
    public static void main(String[] args) {
        Tool myTool = new Tool();
		Person human = new Person();
		myTool.Test(human);
		human.Test(myTool);
    }
}

class Person {
	String name = &quot;jack&quot;;
	public void Test(Tool human) {
		System.out.println(human.name);
	}
}

class Tool {
	String name = &quot;liry&quot;;
	public void Test(Person human) {
		System.out.println(human.name);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.全局变量可以被访问修饰符使用，而局部变脸不行&lt;/p&gt;
&lt;h2&gt;Java中的构造器&lt;/h2&gt;
&lt;p&gt;构造方法，其中它的方法名字和类的名字相同&lt;/p&gt;
&lt;p&gt;构造方法没有返回值，也不能使用返回类型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[修饰符] 方法名 (形参列表) {
	方法体;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一个简单的入门代码示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object {
    public static void main(String[] args) {
        Tool myTool = new Tool(&quot;thrinisty&quot;, 14);
		myTool.test();	
    }
}
class Tool {
	String name;
	int age;
	public Tool(String n, int m) {
		name = n;
		age = m;
	}
	public void test() {
		System.out.println(&quot;名字是&quot; + name + &quot;年龄是&quot; + age);
	}
}


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;构造器的使用细节&lt;/p&gt;
&lt;p&gt;1.构造器可以被重载，可以定义多个构造器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object {
    public static void main(String[] args) {
        Tool myTool = new Tool(&quot;thrinisty&quot;);
        //在这里没有指定年龄，使用的是第二个构造方法
		myTool.test();
		
    }
}

class Tool {
	String name;
	int age;
	public Tool(String n, int m) {
		name = n;
		age = m;
	}

	public Tool(String n) {
		name = n;
		age = 0;
	}

	public void test() {
		System.out.println(&quot;名字是&quot; + name + &quot;年龄是&quot; + age);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.构造器的名称要和类的名称相同&lt;/p&gt;
&lt;p&gt;3.构造器没有返回值&lt;/p&gt;
&lt;p&gt;4.构造器不会创建兑现，他的目的只是为了完成初始化&lt;/p&gt;
&lt;p&gt;5.在创建对象的时候会自动调用构造方法，不允许主动调用构造方法&lt;/p&gt;
&lt;p&gt;6.如果没有定义构造方法，系统会自动给类生成一个无参数的构造器&lt;/p&gt;
&lt;p&gt;可以使用 javap 反编译工具进行验证&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/49.png&quot; alt=&quot;49&quot; /&gt;&lt;/p&gt;
&lt;p&gt;7.一旦定义了构造方法，默认的无参构造器就被覆盖了，如果需要使用要显示定义一次&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object {
    public static void main(String[] args) {
        Tool myTool = new Tool();
		myTool.test();
		
    }
}

class Tool {
	String name;
	int age;
	public Tool(){}

	public Tool(String n) {
		name = n;
		age = 0;
	}

	public void test() {
		System.out.println(&quot;名字是&quot; + name + &quot;年龄是&quot; + age);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Java中的this关键字&lt;/h2&gt;
&lt;p&gt;java虚拟机会给每一个对象分配一个this，这个this可以被当成为一个属性，这个属性是一个引用指向对象自己&lt;/p&gt;
&lt;p&gt;以下是一个代码示例，this 指的就是Person这个类，可以通过this 来引用类的属性&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object {
    public static void main(String[] args) {
        Person human = new Person(&quot;lory&quot;, 18);
		human.test();
		
    }
}

class Person {
	String name;
	int age;

	public Person(String name, int age) {
		this.name = name;
		this.age = age;
	}

	public void test() {
		System.out.println(&quot;名字是&quot; + name + &quot;年龄是&quot; + age);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;this在内存中的存在形式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/50.png&quot; alt=&quot;50&quot; /&gt;&lt;/p&gt;
&lt;p&gt;我们也可以通过哈希编码来验证这个this指向的内容和对象引用的内存地址是一样的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object {
    public static void main(String[] args) {
        Person human = new Person(&quot;lory&quot;, 18);
		System.out.println(&quot;对象的哈希值是&quot; + human.hashCode());
		human.test();
		
    }
}

class Person {
	String name;
	int age;

	public Person(String name, int age) {
		this.name = name;
		this.age = age;
	}

	public void test() {
		System.out.println(&quot;this引用的哈希值是&quot; + this.hashCode());
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;PS C:\Users\71460\Desktop\Java\day8\class1&amp;gt; java Object
对象的哈希值是1311053135
this引用的哈希值是1311053135
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;this关键字的使用细节&lt;/h2&gt;
&lt;p&gt;1.this 可以用来访问本类的属性，方法，构造器&lt;/p&gt;
&lt;p&gt;2.this用于区分当前类的属性和局部变量&lt;/p&gt;
&lt;p&gt;3.this不能够被类定义的外部使用，只可以在类定义的方法中使用&lt;/p&gt;
&lt;p&gt;4.访问构造器语法this (参数列表)，只可以在构造器中使用（还必须将this语句放在第一条语句）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object {
    public static void main(String[] args) {
        Person human = new Person();
		human.test();
		
    }
}

class Person {
	String name;
	int age;

	public Person() {
		this(&quot;jack&quot;, 100);//第一条语句
	}

	public Person(String name, int age) {
		this.name = name;
		this.age = age;
	}

	public void test() {
		System.out.println(&quot;对象 &quot; + this.name + this.age);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;this&lt;/code&gt;关键字用于引用当前对象的实例。在&lt;code&gt;Person&lt;/code&gt;类中，&lt;code&gt;this.name&lt;/code&gt;和&lt;code&gt;this.age&lt;/code&gt;明确地指向当前对象的&lt;code&gt;name&lt;/code&gt;和&lt;code&gt;age&lt;/code&gt;属性。然而，在&lt;code&gt;test&lt;/code&gt;方法中，直接使用&lt;code&gt;name&lt;/code&gt;和&lt;code&gt;age&lt;/code&gt;也可以访问这些属性，因为它们在当前对象的上下文中是可见的&lt;/p&gt;
&lt;p&gt;在代码规范上：开发团队或代码风格指南可能要求使用&lt;code&gt;this&lt;/code&gt;来访问实例变量，以增加代码的可读性和一致性。&lt;/p&gt;
&lt;h2&gt;this练习题目&lt;/h2&gt;
&lt;p&gt;判断类属性是否相同&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object {
    public static void main(String[] args) {
        Person human1 = new Person();
		Person human2 = new Person(&quot;lory&quot;, 11);
		if(human1.compareTo(human2)) {
			System.out.println(&quot;对象属性相同&quot;);
		} else {
			System.out.println(&quot;对象属性不同&quot;);
		}
    }
}

class Person {
	String name;
	int age;

	public Person() {
		this(&quot;jack&quot;, 100);
	}

	public Person(String name, int age) {
		this.name = name;
		this.age = age;
	}

	public boolean compareTo(Person another) {
		return another.name.equals(this.name) &amp;amp;&amp;amp; another.age == this.age;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;章节作业&lt;/h2&gt;
&lt;p&gt;1.找到double数组中最大值返回这个最大值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object {
    public static void main(String[] args) {
        double arr[] = {1.3, 2.5, 1.1, 3.2, 5.2};
		Tool myTool = new Tool();
		System.out.println(&quot;最大值是&quot; + myTool.findMax(arr));
    }
}

class Tool{
	public double findMax(double[] arr) {
		double max = 0.0;
		for(int i = 0; i &amp;lt; arr.length; i++) {
			if(max &amp;lt; arr[i]) {
				max = arr[i];
			}
		}
		return max;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.找到字符串元素的下标&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object {
    public static void main(String[] args) {
        String arr[] = {&quot;1.3&quot;, &quot;2.5&quot;, &quot;1.1&quot;, &quot;3.2&quot;, &quot;5.2&quot;};
		Tool myTool = new Tool();
		System.out.println(&quot;元素下标是&quot; + myTool.findString(arr, &quot;1.1&quot;));
    }
}

class Tool{
	public int findString(String[] arr, String target) {
		int index = -1;
		for(int i = 0; i &amp;lt; arr.length; i++) {
			if(target.equals(arr[i])){
				index = i;
				return index;
			}
		}
		return index;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.改变书本价格&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object {
    public static void main(String[] args) {
		Book myBook = new Book(&quot;爱丽丝&quot;, 133.0);
		myBook.updatePrice();
		System.out.println(myBook.price);
    }
}

class Book{
	String name;
	double price;
	public Book(String name, double price){
		this.name = name;
		this.price = price;
	}

	public void updatePrice() {
		if(this.price &amp;gt; 150) {
			this.price = 150;
		} else if(this.price &amp;lt;= 150 &amp;amp;&amp;amp; this.price &amp;gt; 100) {
			this.price = 100;
		} else {}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.实现数组的复制功能，元素和旧数组一样&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object {
    public static void main(String[] args) {
		Tool myTool = new Tool();
		int oldArr[] = {1, 3, 5, 6};
		myTool.print(oldArr);
		int newArr[] = myTool.copyArr(oldArr);
		myTool.print(newArr);
    }
}

class Tool{
	public int[] copyArr(int[] arr) {
		int newArr[] = new int[arr.length];
		for(int i = 0; i &amp;lt; arr.length; i++) {
			newArr[i] = arr[i];
		}
		return newArr;
	}

	public void print(int[] arr) {
		for(int i = 0; i &amp;lt; arr.length; i++) {
			System.out.print(arr[i] + &quot; &quot;);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.定义一个圆类，属性有半径， 提供周长方法，提供面积方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object {
    public static void main(String[] args) {
		Tool myTool = new Tool(1.9);
		System.out.println(&quot;面积是&quot; + myTool.area());
		System.out.println(&quot;周长是&quot; + myTool.lan());
    }
}

class Tool{
	double r;
	public Tool(double r) {
		this.r = r;
	}

	public double area() {
		return Math.PI * r * r;
	}

	public double lan() {
		return Math.PI * r * 2;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;6.一个简单的除法计算器&lt;/p&gt;
&lt;p&gt;其中返回的类型是Double的包装类，可以返回null&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object {
    public static void main(String[] args) {
		Tool myTool = new Tool(2.9, 0);

		if(myTool.div() != null) {
			System.out.println(&quot;结果是&quot; + myTool.div());
		}			
    }
}

class Tool{
	double num1;
	double num2;
	public Tool(double num1, double num2) {
		this.num1 = num1;
		this.num2 = num2;
	}

	public Double div() {
		if(num2 == 0){
			System.out.println(&quot;除数不能为0&quot;);
			return null;
		} else {
			return this.num1 / this.num2;
		}
	}

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;7.在类中传入其他类的实例，并调用其方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object {
    public static void main(String[] args) {
		PassObject myFunction = new PassObject();
		Tool myTool = new Tool(2.0);
		myFunction.printAreas(myTool, 3);
    }
}

class Tool{
	double r;
	public Tool(double r) {
		this.r = r;
	}

	public double area() {
		return Math.PI * r * r;
	}

	public void setC(double n) {
		this.r = n;
	}
}

class PassObject {
	public void printAreas(Tool myCircle, int times) {
		for(int i = 1; i &amp;lt;= times; i++)
		{
			myCircle.setC(i);
			System.out.println(myCircle.area());
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;8.综合实验题目：猜数字&lt;/p&gt;
&lt;p&gt;（还可以在类的封装上加以改进将People类和输入类封装在一个游戏类中通过在主函数中创建的游戏类来启动游戏，在这里不多过多介绍）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Scanner;

public class Object {
    public static void main(String[] args) {
      People myPeople = new People();
      Scanner myScanner = new Scanner(System.in);
      while(true) {
        System.out.println(&quot;请输入数字&quot;);
        myPeople.setTarget(myScanner.nextInt());
        if(myPeople.complete()) {
          System.out.println(&quot;游戏结束&quot;);
          break;
        }
      }
    }
}

class People {
    int target;
    Machine myMachine = new Machine();
    int flag = myMachine.create();

    public void setTarget(int target) {
      this.target = target;
    }
    public boolean complete() {
      if(flag == target) {
        System.out.println(&quot;结果正确&quot;);
        return true;
      } else if(flag &amp;lt; target) {
        System.out.println(&quot;结果大了，请继续&quot;);
        return false;
      } else {
        System.out.println(&quot;结果小了，请继续&quot;);
        return false;      
      }
    }

}

class Machine {
    int target;
    public int create(){
      return (int)(Math.random() * 100) + 1;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;java面向对象的基础部分到此为止，接下来会进入IDEA的使用，包，访问修饰符，封装的部分&lt;/p&gt;
</content:encoded></item><item><title>Java笔记</title><link>https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E9%80%92%E5%BD%92%E4%B8%93%E9%A2%98/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E9%80%92%E5%BD%92%E4%B8%93%E9%A2%98/</guid><description>一些递归练习题目</description><pubDate>Fri, 07 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;听课笔记&lt;/h1&gt;
&lt;h2&gt;Java中的递归&lt;/h2&gt;
&lt;p&gt;递归在算法中属于比较复杂的一类了，在这里也希望在 java 的学习中复习算法&lt;/p&gt;
&lt;p&gt;一个简单的入门案例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object{
	public static void main(String[] args) {
		Tool Mytool = new Tool();
		Mytool.test(4);
	}
}

class Tool{
	public void test(int n) {
		if(n &amp;gt; 2) {
			test(n - 1);
		}
		System.out.println(n);
	}
}


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;../images/48.png&quot; alt=&quot;48&quot; /&gt;&lt;/p&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2
3
4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要等递归的方法结束后才执行递归调用主体函数中的输出，所以结果是从2到4&lt;/p&gt;
&lt;p&gt;计算阶乘&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object{
	public static void main(String[] args) {
		Tool Mytool = new Tool();
		System.out.println(Mytool.Printni(3));
	}
}

class Tool{
	public int Printni(int n) {
		if(n == 1) {
			return 1;
		} else {
			return Printni(n - 1) * n;
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;递归的要点&lt;/h2&gt;
&lt;p&gt;1.执行方法的时候会生成一个新的独立的栈空间&lt;/p&gt;
&lt;p&gt;2.方法的局部变量是独立的不会相互影响&lt;/p&gt;
&lt;p&gt;3.如果方法中使用的是引用类型的数据变量，就会共享该引用类型的数据&lt;/p&gt;
&lt;p&gt;4.递归必须得指定退出的条件，在执行时也必须向退出的条件逼近&lt;/p&gt;
&lt;p&gt;5.当一个方法执行完毕的时候，或 return 就会返回到调用函数中&lt;/p&gt;
&lt;h2&gt;递归的经典例题&lt;/h2&gt;
&lt;h3&gt;斐波那契数列&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Scanner;
public class Object{
	public static void main(String[] args) {
		Scanner myScanner = new Scanner(System.in);
		System.out.println(&quot;请输入斐波那契数列的第几个数&quot;);
		int target = myScanner.nextInt();
		Tool myTool = new Tool();
		System.out.println(&quot;斐波那契的第&quot;+ target + &quot;个数是&quot; + myTool.test(target));
	}
}

class Tool{
	public int test(int n) {
		if(n == 1 || n == 2) {
			return 1;
		} else {
			return test(n - 1) + test(n - 2);
		}
		
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;猴子吃桃问题&lt;/h3&gt;
&lt;p&gt;猴子每天吃一般的桃子 再额外吃一个，第十天的时候有1个桃子可以吃，问第一天的时候有几个桃子&lt;/p&gt;
&lt;p&gt;递推式：第n天的桃子 = (第 n - 1 个桃子 / 2)-  1&lt;/p&gt;
&lt;p&gt;反递推式：第n天的桃子  =（第n + 1天的桃子 + 1） * 2&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Scanner;
public class Object{
	public static void main(String[] args) {
		int target = 10;
		Tool myTool = new Tool();
		System.out.println(myTool.peace(1));
	}
}

class Tool{
	public int peace(int day) {
		if(day == 10){
			return 1;
		} else {
			return (peace(day + 1) + 1) * 2;
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;经典的回溯算法走迷宫题目&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;public class Object{
	public static void main(String[] args) {
		int arr[][] = new int[8][7];
		Tool myTool = new Tool();
		for(int j = 0; j &amp;lt; arr[0].length; j++) {
			arr[0][j] = 1;
			arr[arr.length - 1][j] = 1;
		}			
		for(int i = 0; i &amp;lt; arr.length; i++) {
			arr[i][0] = 1;
			arr[i][arr[0].length - 1] = 1;
		}
		arr[3][1] = 1;
		arr[3][2] = 1;
		arr[2][2] = 1;
		myTool.Print(arr);
		System.out.println();
		myTool.findWay(arr, 1, 1);
		myTool.Print(arr);
	}
}

class Tool{
	public void Print(int arr[][]) {
		for(int i = 0; i &amp;lt; arr.length; i++) {
			for(int j = 0; j &amp;lt; arr[i].length; j++) {
				System.out.print(arr[i][j] + &quot; &quot;);
			}
			System.out.println();
		}
	}

	/*
		如果找到迷宫路径就返回true，否则就返回false
		i 和 j 代表了小球的位置，初始化为 1，1
		0 表示可以走， 1 表示障碍物， 2 表示这条路可以走 3 表示这条路走过但是不可达
		当map[6][5] = 2 表示走通，退出递归
	*/
	public boolean findWay(int map[][], int i, int j) {
		if(map[6][5] == 2) {
			return true;
		} else {
			if(map[i][j] == 0) {
				map[i][j] = 2;
				//假定为可以走通
				if(findWay(map, i + 1, j)) {
					return true;
				} else if(findWay(map, i, j + 1)) {
					return true;
				} else if(findWay(map, i - 1, j)) {
					return true;
				} else if(findWay(map, i, j - 1)) {
					return true;
				} else {
					map[i][j] = 3;
					return false;
				}
			} else {
				return false;
			}

		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;汉诺塔&lt;/h3&gt;
&lt;p&gt;简单的递归问题，一共分为三步，就和把大象塞进冰箱一样&lt;/p&gt;
&lt;p&gt;1.打开冰箱（将A盘上的 n-1 个塔放在B盘）&lt;/p&gt;
&lt;p&gt;2.放入大象（将A盘的最大盘放在C盘）&lt;/p&gt;
&lt;p&gt;3.关闭冰箱（将B盘上的 n-1 个塔放在C盘）&lt;/p&gt;
&lt;p&gt;在这里有一个值得注意的递归终止条件仅仅剩余一个盘，直接放入即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Scanner;

public class Object{
	public static void main(String[] args) {
		Hanoi myHanoi = new Hanoi();
		Scanner myScanner = new Scanner(System.in);
		System.out.println(&quot;请输入汉诺塔的层数&quot;);
		int count = myScanner.nextInt();
		myHanoi.moveTower(count, &apos;A&apos;, &apos;B&apos;, &apos;C&apos;);
	}
}

class Hanoi{
	public void moveTower(int n, char a, char b, char c) {
		if(n == 1) {
			System.out.println(&quot;将&quot; + a + &quot;盘上的第一个塔移动到&quot; + c);
		} else {
			moveTower(n - 1, a, c, b);
			System.out.println(&quot;将&quot; + a + &quot;盘上的第一个塔移动到&quot; + c);
			moveTower(n - 1, b, a, c);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;八皇后问题&lt;/h3&gt;
&lt;p&gt;将这一道例题分解为了三个部分来完成&lt;/p&gt;
&lt;p&gt;1.设计了一个一维数组结构用于存放八个皇后，数组的下标代表了放置的行号，对应的数值部分是皇后放置的列数&lt;/p&gt;
&lt;p&gt;2.八皇后递归的主体部分，要注意先将对应的皇后放入一维数组，在进行后续的递归调用&lt;/p&gt;
&lt;p&gt;3.将递归的主体部分的结果返回至一个引用传回结果自增&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object {
    public static void main(String[] args) {
        Queen myQueen = new Queen();
		int map[] = new int[8];
		int result[] = {0};
		myQueen.placeQueen(map, 0, result);
		System.out.println(result[0]);
    }
}

class Queen {
	public void placeQueen(int arr[], int row, int rst[]) {
		if(row == 8) {
			rst[0]++;
			return;
		}
		for(int col = 0; col &amp;lt; 8; col++) {
			if(canPlace(arr, row, col)){
				arr[row] = col;
				placeQueen(arr, row + 1, rst);
			}
		}
	}
   
   	public boolean canPlace(int arr[], int row, int col) {
		for(int i = 0; i &amp;lt; row; i++) {
			if(arr[i] == col || arr[i] + i == col + row || arr[i] - i == col - row) {
				return false;
			}
		}
		return true;
  	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;递归的例题完成，接下来是Java中方法的重载，可变参数，构造器的笔记&lt;/p&gt;
</content:encoded></item><item><title>Java笔记</title><link>https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E5%B1%9E%E6%80%A7%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%8B%E9%9A%86/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E5%B1%9E%E6%80%A7%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%8B%E9%9A%86/</guid><description>类与对象，方法，属性，对象的克隆</description><pubDate>Thu, 06 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;听课笔记&lt;/h1&gt;
&lt;h2&gt;杨辉三角例题&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;public class Test{
	
	public static void main(String[] args){
		int arr[][] = new int[10][];
		for(int i = 0; i &amp;lt; 10; i++) {
			arr[i] =new int[i + 1];
			arr[i][0] = 1;
			arr[i][i] = 1;

			if(i &amp;gt; 1) {
				for(int j = 1;j &amp;lt;= i - 1; j++) {
					arr[i][j] = arr[i - 1][j] + arr[i - 1][j - 1];
				}
			}			
		}
		for(int i = 0; i &amp;lt; arr.length; i++) {
			for(int j = 0; j &amp;lt; arr[i].length; j++) {
				System.out.print(arr[i][j] +&quot;\t&quot;);
			}
			System.out.println(&quot;&quot;);
		}	
	}
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;二维数组的声明有三种方式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int[][] y;
int[] y[];
int y[][];
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;插入算法经典例题&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;import java.util.*;

public class Test{	
	public static void main(String[] args){
		int arr[] = {10, 12, 45, 90};
		Scanner myScanner = new Scanner(System.in);
		int num = myScanner.nextInt();
		int table[] = new int[arr.length + 1];
	
		for(int i = 0; i &amp;lt; arr.length; i++) {
			if(num &amp;lt; arr[i]) {
				
				for(int j = 0; j &amp;lt; i; j++) {
					table[j] = arr[j];
				}
				table [i] = num;
				for(int j = i + 1; j &amp;lt; table.length; j++) {
					table[j] = arr[j - 1];
				}
				break;//我们只需要找到一次需要插入的位置即可
			}
		}
		arr = table;
		for(int i = 0; i &amp;lt; arr.length; i++) {
			System.out.print(arr[i] +&quot; &quot;);
		}
	}
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;原先的算法似乎有一些复杂，以下是一个改进的版本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.*;

public class Test{
	public static void main(String[] args){
		int arr[] = {10, 12, 45, 90};
		Scanner myScanner = new Scanner(System.in);
		int num = myScanner.nextInt();
		int table[] = new int[arr.length + 1];
		int index = -1;
		for(int i = 0; i &amp;lt; arr.length; i++) {
			if(arr[i] &amp;gt; num) {
				index = i;
				break;
			}
		}
		for(int i = 0, j = 0; i &amp;lt; table.length; i++){
			if(i != index) {
				table[i] = arr[j];
				j++;
			} else {
				table[i] = num;
			}
		}
		arr = table;
		for(int i = 0; i &amp;lt; arr.length; i++) {
			System.out.print(arr[i] +&quot; &quot;);
		}
	}
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;综合例题&lt;/h2&gt;
&lt;p&gt;用数组存储10个随机数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.*;

public class Test{
	
	public static void main(String[] args) {
		int arr[] = new int[10];
		int sum = 0;
		int max = 0;
		int index = -1;
		for(int i = 0; i &amp;lt; arr.length; i++) {
			arr[i] = (int)(Math.random() * 100) + 1;
		}
		System.out.println(&quot;正序打印&quot;);
		for(int i = 0; i &amp;lt; arr.length; i++) {
			System.out.print(arr[i] + &quot; &quot;);
			sum += arr[i];
			if(max &amp;lt; arr[i]) {
				max = arr[i];
				index = i;
			}
		}
		System.out.println(&quot;\n平均数为&quot; + sum / 10);
		System.out.println(&quot;最大值是&quot; + max + &quot; 它的下标为&quot; + index);
		//从大到小排序
		int temp = 0;
		for(int i = 0; i &amp;lt; arr.length - 1; i++) {
			for(int j = 0; j &amp;lt; arr.length - i - 1; j++) {
				if(arr[j] &amp;lt; arr[j + 1]) {
					temp = arr[j];
					arr[j] = arr[j + 1];
					arr[j + 1] = temp;
				}
			}
		}
		for(int i = 0; i &amp;lt; arr.length; i++) {
			System.out.print(arr[i] + &quot; &quot;);
		}

		int target = 30;
		for(int i = 0; i &amp;lt; arr.length; i++) {
			if(arr[i] == target) {
				System.out.println(&quot;找到了目标数&quot; + target + &quot;下表为&quot; + i);
				break;
			}
			if(arr[i] &amp;lt; target) {
				System.out.println(&quot;没有找到&quot;);
				break;
			}
		}
		
	}
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Java 类与对象&lt;/h2&gt;
&lt;p&gt;终于来到了java中最为核心的部分内容，不同于c语言中的面向方法，java 的面向对象可以使得编程更加的贴近于现实。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object{
	public static void main(String[] args) {
		String cat1Name = &quot;小白&quot;;
		int cat1Age = 3;
		String cat1Color = &quot;蓝色&quot;

		String cat2Name = &quot;小花&quot;;
		int cat2Age = 2;
		String cat2Color = &quot;红色&quot;		
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上的代码存储了猫猫的各个信息，但是这样做会使得，变量离散缺少内在的联系&lt;/p&gt;
&lt;p&gt;这个时候会想到数组的结构来存储，但是数组不能存储不同数据类型的成员，全用字符串也没法体现数据含义，在用对于下表读取成员变量时，对应关系不明确&lt;/p&gt;
&lt;p&gt;为解决以上问题我们引入的类与对象&lt;/p&gt;
&lt;p&gt;一个事物，是由它的行为和属性构成的，&lt;/p&gt;
&lt;p&gt;而对象是对于事物的一个抽象，在这样一个抽象之中，会有它的属性和行为&lt;/p&gt;
&lt;p&gt;可以将上述的案例中的猫猫定义成为一种数据类型，这种类型中有猫的颜色，年龄，颜色，还可以有方法行为，这就是类的概念。&lt;/p&gt;
&lt;p&gt;我们用这样的一个抽象的数据类型可以创建一个或者数个具体的对象，也就是猫的对应的个体，称之为实例。&lt;/p&gt;
&lt;p&gt;用类来存放猫猫&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Scanner;

public class Object{
	public static void main(String[] args) {
		//使用面向对象的方式来存放猫猫
		Cat cat1 = new Cat();
		cat1.name = &quot;小花&quot;;
		cat1.age = 2;
		cat1.color = &quot;红色&quot;;
		Cat cat2 = new Cat();
		cat2.name = &quot;小白&quot;;
		cat2.age = 3;
		cat2.color = &quot;白色&quot;;
	}
}

class Cat {
	//定义一个猫猫类
	String name;
	int age;
	String color;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用这样的方式可以方便的添加属性以及行为，也方便创建全新的猫猫实例&lt;/p&gt;
&lt;h2&gt;对象在内存中的存在形式&lt;/h2&gt;
&lt;p&gt;在创建一个对象实例的时候，对象的引用存放在 java虚拟机内存中的栈，而它所指向的属性会放在堆中（存放的形式是由对象的属性类型所决定的，基本数据类型的属性会放在堆中，而字符串类型的属性会在堆中存放其引用，而字符串内容会被放置在方法区的常量池中）&lt;/p&gt;
&lt;p&gt;额外的在用 new 创建一个对象的时候会将类的信息加载到方法区（属性，方法）&lt;img src=&quot;../images/47.png&quot; alt=&quot;47&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;属性 成员变量&lt;/h2&gt;
&lt;p&gt;从概念而言 成员变量 属性 字段都是用来表示类中的单个数据类型的，使用上是等价的&lt;/p&gt;
&lt;p&gt;1.在修饰属性中我们可以加上访问修饰符public protected 默认 private&lt;/p&gt;
&lt;p&gt;使用方式 访问修饰符 属性类型 属性名称&lt;/p&gt;
&lt;p&gt;2.属性的定义类型可以是任意类型，包含基本类型，引用类型&lt;/p&gt;
&lt;p&gt;3.属性如果不赋值，会有一些的默认值，规则同数组一样&lt;/p&gt;
&lt;p&gt;默认赋值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object{
	public static void main(String[] args) {
		Person human = new Person();
		System.out.println(&quot;姓名 &quot; + human.name + &quot;\n年龄 &quot; + human.age
		+ &quot;\n薪水 &quot; + human.salary + &quot;\n是否通过 &quot; + human.isPass);
	}
}

class Person {
	String name;
	int age;
	double salary;
	boolean isPass;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;姓名 null
年龄 0
薪水 0.0
是否通过 false
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;补充知识&lt;/h2&gt;
&lt;h3&gt;字符串常量池&lt;/h3&gt;
&lt;p&gt;字符串常量池是常量池的一部分，专门用于存储字符串字面量。它的设计目的是为了减少重复字符串的内存占用。&lt;/p&gt;
&lt;p&gt;之前笔记中提到的 int 包装类 数据类型存放在-128 -- 127也会被放在常量池中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Integer x = 10; // 自动装箱，从常量池中获取对象
Integer y = 10; // 自动装箱，从常量池中获取对象

System.out.println(x == y); // true，因为 x 和 y 指向常量池中的同一个对象
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;String s1 = &quot;Hello&quot;;  // &quot;Hello&quot; 会被放入字符串常量池
String s2 = &quot;Hello&quot;;  // 直接从字符串常量池中获取
String s3 = new String(&quot;Hello&quot;);  // 在堆中创建一个新的字符串对象

System.out.println(s1 == s2);  // true，因为 s1 和 s2 指向常量池中的同一个对象
System.out.println(s1 == s3);  // false，因为 s3 是堆中的一个新对象
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;字符串常量池的特点：&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;字面量赋值&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用双引号直接赋值的字符串（如 &lt;code&gt;&quot;Hello&quot;&lt;/code&gt;）会被放入字符串常量池。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;new String()&lt;/code&gt;&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;new String()&lt;/code&gt; 创建的字符串对象会存储在堆中，而不是字符串常量池。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;intern()&lt;/code&gt; 方法&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以将堆中的字符串对象放入字符串常量池，并返回常量池中的引用&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;String s4 = new String(&quot;World&quot;).intern();
String s5 = &quot;World&quot;;
System.out.println(s4 == s5);  // true，因为 s4 通过 intern() 方法放入了常量池
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Java中的几个存储区域&lt;/h2&gt;
&lt;p&gt;堆：存放 对象 数组 等&lt;/p&gt;
&lt;p&gt;栈：一般存放基本数据类型（局部变量）&lt;/p&gt;
&lt;p&gt;方法区：常量池（常量，比如字符串）加载信息&lt;/p&gt;
&lt;h2&gt;Java中创建对象的流程&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;	Person human = new Person();
	temp.name = &quot;thrinisty&quot;;
	temp.age = 10;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1.加载Person类信息到方法区&lt;/p&gt;
&lt;p&gt;2.在堆中进行分配空间，进行默认的初始化&lt;/p&gt;
&lt;p&gt;3.将地址赋值给类的引用&lt;/p&gt;
&lt;p&gt;4.进行指定初始化,如上述的字符串赋值，和年龄赋值&lt;/p&gt;
&lt;h2&gt;Java中的成员方法&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;public class Object{
	public static void main(String[] args) {
		Person human;
		human = new Person();
		human.speak();//调用方法
	}
}
class Person {
	String name;
	int age;

	public void speak() {
		System.out.println(&quot;我是一个好人&quot;);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这里在 Person 类中定义了一个方法，输出了一段话，并在主函数中调用了这样一个方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object{
	public static void main(String[] args) {
		Person human;
		human = new Person();
		human.speak();
		human.sum();
		System.out.println(human.add(10, 5));
	}
}
class Person {
	String name;
	int age;

	public void speak() {
		System.out.println(&quot;我是一个好人&quot;);
	}

	public void sum() {
		int result = 0;
		for(int i = 0; i &amp;lt; 1000; i++) {
			result += i;
		}
		System.out.println(result);
	}

	public int add(int count1, int count2) {
		int result = count1 + count2;
		return result;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在Java中同样可以传入参数参与方法中的运算，在这里实现了一个加法的方法并将结果返回到了主函数中，在Java中我们在调用方法的时候和C语言类似&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;保存当前指令地址&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;在Java中，JVM会维护一个调用栈（Call Stack），用于跟踪方法调用。当一个方法被调用时，JVM会将当前的执行状态（包括程序计数器，即下一条指令的地址）保存在调用栈中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;将方法参数压栈&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;Java方法的参数会被压入操作数栈（Operand Stack）中。JVM是基于栈的虚拟机，所有的操作（包括方法调用）都是通过操作数栈来完成的。参数会按照方法声明的顺序被压入栈中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;调用方法&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;JVM会执行&lt;code&gt;invokevirtual&lt;/code&gt;、&lt;code&gt;invokestatic&lt;/code&gt;、&lt;code&gt;invokeinterface&lt;/code&gt;或&lt;code&gt;invokespecial&lt;/code&gt;等字节码指令来调用方法。这些指令会根据方法的类型（实例方法、静态方法、接口方法等）来决定如何调用方法。&lt;/li&gt;
&lt;li&gt;在调用方法时，JVM会创建一个新的栈帧（Stack Frame）并将其压入调用栈。这个栈帧包含了方法的局部变量表、操作数栈等信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;执行方法体&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;方法体中的字节码指令会被逐条执行。JVM会根据指令对操作数栈进行操作，计算结果会存储在操作数栈中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;返回结果&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;当方法执行完毕后，JVM会将返回值压入调用者的操作数栈中。返回值的类型取决于方法的返回类型（&lt;code&gt;void&lt;/code&gt;、&lt;code&gt;int&lt;/code&gt;、&lt;code&gt;Object&lt;/code&gt;等）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;退栈&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;方法执行完毕后，JVM会弹出当前方法的栈帧，恢复调用者的栈帧，并继续执行调用者的下一条指令。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中与c的函数调用有一些区别&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;调用栈管理&lt;/strong&gt;：在C语言中，调用栈是由硬件和操作系统直接管理的，而在Java中，调用栈是由JVM管理的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;字节码与机器码&lt;/strong&gt;：Java方法调用是通过字节码指令（如&lt;code&gt;invokevirtual&lt;/code&gt;）来完成的，而C语言中的函数调用是通过机器码指令（如&lt;code&gt;call&lt;/code&gt;）来完成的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内存管理&lt;/strong&gt;：Java有自动内存管理（垃圾回收），而C语言需要手动管理内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;方法的妙用&lt;/h2&gt;
&lt;p&gt;可以提高代码的可读性，可以方便后续的维护，可以供用户方便调用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object{
	public static void main(String[] args) {
		int arr[][] = {{1, 3, 5}, {1, 6, 7}, {0, 3, 5}};
		Tool Mytool = new Tool();	
		Mytool.arrPrint(arr);
	}
}

class Tool {
	public void arrPrint(int table[][]) {
		for(int i = 0; i &amp;lt; table.length; i++) {
			for(int j = 0; j &amp;lt; table[i].length; j++) {
				System.out.print(table[i][j] + &quot; &quot;);
			}
			System.out.println();
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;方法的定义&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;public void arrPrint(int table[][]) {
//方法修饰类型 + 返回类型 + 方法名称 + （形参列表）
//  {
//    	方法主体	    
//  }
		for(int i = 0; i &amp;lt; table.length; i++) {
			for(int j = 0; j &amp;lt; table[i].length; j++) {
				System.out.print(table[i][j] + &quot; &quot;);
			}
			System.out.println();
		}
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当要返回多个值的时候可以使用数组的返回类型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object{
	public static void main(String[] args) {
		Tool Mytool = new Tool();	
		int rst[] = new int[2];
		rst = Mytool.AddFunction(10, 15);
		System.out.println(&quot;+:&quot; + rst[0]);
		System.out.println(&quot;-:&quot; + rst[1]);
	}
}

class Tool {
	public int[] AddFunction(int n1, int n2) {
		int result[] = new int[2];
		result[0] = n1 + n2;
		result[1] = n1 - n2;
		return result;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以使用自定义的类来进行返回&lt;/p&gt;
&lt;p&gt;在这个例子中使用了自定义的 Result 结果类 将方法返回类型更改为Result即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object{
	public static void main(String[] args) {
		Tool Mytool = new Tool();	
		Result rst = new Result();
		rst = Mytool.AddFunction(15, 10);
		System.out.println(&quot;+:&quot; + rst.add);
		System.out.println(&quot;-:&quot; + rst.sub);
	}
}

class Tool {
	public Result AddFunction(int n1, int n2) {
		Result result = new Result();
		result.add = n1 + n2;
		result.sub = n1 - n2;
		return result;
	}
}

class Result {
	int add;
	int sub;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方法不能嵌套定义&lt;/p&gt;
&lt;h2&gt;方法的调用&lt;/h2&gt;
&lt;p&gt;1.同一个类的方法可以直接调用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object{
	public static void main(String[] args) {
		A target = new A();
		target.print(19);
	}
}

class A {
	public void print(int n) {
		System.out.println(n);
	}
	public void Ok() {
		print(10);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.跨类的方法调用需要使用对象名进行调用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object{
	public static void main(String[] args) {
		A target = new A();
		target.print(19);
		target.UseB(1);
	}
}

class A {
	public void print(int n) {
		System.out.println(n);
	}
	public void Ok() {
		print(10);
	}
	public void UseB(int n) {
		B ClassB = new B();
		ClassB.print(n);
	}
}

class B {
	public void print(int n) {
		System.out.println(&quot;B类的方法：&quot; + n);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要在 A 的方法后创建一个 B 的实例，再运用 B 实例的引用来调用 B 类的方法&lt;/p&gt;
&lt;h2&gt;方法练习题目&lt;/h2&gt;
&lt;p&gt;判断一个数是是偶数还是奇数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object{
	public static void main(String[] args) {
		AA target = new AA();
		if(target.Judge(40)) {
			System.out.println(&quot;是一个偶数&quot;);
		} else {
			System.out.println(&quot;是一个奇数&quot;);
		}		
	}
}

class AA {
	public boolean Judge(int n) {
		if(n % 2 == 0) {
			return true;
		} else {
			return false;
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;打印#字符&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object{
	public static void main(String[] args) {
		AA target = new AA();
		target.Print(3, 5);	
	}
}

class AA {
	public void Print(int m, int n) {
		for(int i = 0; i &amp;lt; m; i++) {
			for(int j = 0; j &amp;lt; n; j++) {
				System.out.print(&quot;#&quot;);
			}
			System.out.println();
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;成员方法的传参机制&lt;/h2&gt;
&lt;p&gt;1.方法中基本类型参数的传递中不会改变被调用参数的值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object{
	public static void main(String[] args) {
		AA target = new AA();
		int m = 3, n = 5;
		target.Print(m, n);	
		System.out.println(&quot;主函数中的m n&quot;);
		System.out.println(&quot;m:&quot; + m);
		System.out.println(&quot;n:&quot; + n);
	}
}

class AA {
	public void Print(int m, int n) {
		int tmp = m;
		m = n;
		n = tmp;
		System.out.println(&quot;方法体中的m n&quot;);
		System.out.println(&quot;m:&quot; + m);
		System.out.println(&quot;n:&quot; + n);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;方法体中的m n
m:5
n:3
主函数中的m n
m:3
n:5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可见调用方法内部的参数发生交换，打印结果改变&lt;/p&gt;
&lt;p&gt;但是主函数中的实际参数没有发生交换，这是因为调用的方法中的参数并不是对于主函数中m n的引用，并不会对于主方法中的参数产生改变&lt;/p&gt;
&lt;p&gt;2.方法中引用类型参数的传递中会改变被调用引用所指向的值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object{
	public static void main(String[] args) {
		int array[] = {1, 3, 6, 6};
		Tool MyTool = new Tool();
		MyTool.ChangeNum(array);
		MyTool.ArrPrint(array);
	}
}

class Tool {
	public void ChangeNum(int arr[]) {
		for(int i = 0; i &amp;lt; arr.length; i++) {
			arr[i] = 0;
		}
	}

	public void ArrPrint(int arr[]) {
		for(int i = 0; i &amp;lt; arr.length; i++) {
			System.out.print(arr[i] + &quot; &quot;);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果是&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0 0 0 0 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来这个例子非常容易犯错&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object{
	public static void main(String[] args) {
		int array[] = {1, 3, 6, 6};
		Tool MyTool = new Tool();
		MyTool.ChangeNum(array);
		System.out.println(array[3]);
	}
}

class Tool {
	public void ChangeNum(int arr[]) {
		for(int i = 0; i &amp;lt; arr.length; i++) {
			arr[i] = i;
		}
		arr = null;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;问是否可以正常编译运行，我开始是这么想的，既然 arr 指向了空 ，那么代表了他没有办法正常的访问成员数据，那么在主函数中的6行就会发生报错&lt;/p&gt;
&lt;p&gt;但是结果就是可以运行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是因为运行的过程中虽然时指向了一个数组，利用方法体中的引用对于数组进行修改，但是原来主函数中的引用却没有消失，方法体中的引用设置空，不影响主方法的引用访问数组&lt;/p&gt;
&lt;h2&gt;对象的克隆&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;public class Object{
	public static void main(String[] args) {
		Tool MyTool = new Tool();
		Person human = new Person();
		human.name = &quot;Li Haoxuan&quot;;
		human.age = 22;
		Person newHuman;
		newHuman = MyTool.CloneClass(human);
		human.name = &quot;Wang Ling&quot;;
		System.out.println(newHuman.name);
		//新的对象，改变原来的名字不会改变克隆的新人类
	}
}

class Tool {
	public Person CloneClass(Person human) {
		Person newHuman =new Person();
		newHuman.name = human.name;
		newHuman.age = human.age;
		return newHuman;
	}
}

class Person {
	String name;
	int age;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将方法中创建的空间以及内容对应的引用返回赋值主函数中的引用就可以完成克隆，满足用主函数的新引用来使用克隆出来的内容&lt;/p&gt;
</content:encoded></item><item><title>Java笔记</title><link>https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E6%95%B0%E7%BB%84%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%95%B0%E7%BB%84%E8%B5%8B%E5%80%BC%E6%9C%BA%E5%88%B6/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E6%95%B0%E7%BB%84%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%95%B0%E7%BB%84%E8%B5%8B%E5%80%BC%E6%9C%BA%E5%88%B6/</guid><description>数组，二维数组，数组赋值机制</description><pubDate>Wed, 05 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;听课笔记&lt;/h1&gt;
&lt;h2&gt;Java中的数组&lt;/h2&gt;
&lt;p&gt;array 数组，在要处理大量数据的时候，引用数组的意义就非常重要了&lt;/p&gt;
&lt;p&gt;数组的定义：数组可以存放多个同一类型的数据，数组也是一种数据类型，是引用类型&lt;/p&gt;
&lt;p&gt;使用场景：例如有很多的 hens 的时候 可以使用数组大量存储hens的数据，还可以通过for 循环来进行进行数据的批量处理&lt;/p&gt;
&lt;h3&gt;数组的静态初始化&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Scanner;

public class Move{
	public static void main(String[] args) {
		double hens[] = {3, 5, 1, 3.4, 2, 50};
        /*
        等价于 double hens[] = new double[6];
        hens[0] = 3;
        ......
        hens[5] = 50;
        */
		double sum = 0;
		for(int i = 0; i &amp;lt; 6; i++) {
			sum += hens[i];
		}
		System.out.println(sum);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;数组的使用方式&lt;/h2&gt;
&lt;h3&gt;数组的动态初始化&lt;/h3&gt;
&lt;p&gt;数据类型 数组名称[ ] = new 数据类型 [ 大小 ]&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int a[] = new int[5];
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Scanner;

public class Move{
	public static void main(String[] args) {
		Scanner myscanner = new Scanner(System.in);
		double sum = 0;
		double grade[] = new double[5];
		for(int i = 0; i &amp;lt; 5; i++) {
			System.out.println(&quot;请输入第&quot; + (i+1) +&quot;个成绩&quot;);
			grade[i] = myscanner.nextInt();
			sum += grade[i];
		}
		System.out.println(&quot;总和是&quot; + sum);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以先声明，在创建数组的实例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int a[];		//这个时候数组指向空
a = new int[5];	//在这里分配了数组对应的空间，再将数组指向了这个空间
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;数组使用的注意事项&lt;/p&gt;
&lt;p&gt;1.数组元素可以是基本类型和引用类型，java不支持数组数据类型混用&lt;/p&gt;
&lt;p&gt;2.数组创建后如果没有赋值，会默认赋初始值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 *int short byte long 0
 *double float 0.0
 *char \u0000
 *boolean false
 *String null
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.使用数组的步骤，1.声明数组 2.分配空间 3.给数组的各个空间赋值 4.使用数组&lt;/p&gt;
&lt;p&gt;4.数组属于引用类型，数组型数据是对象（object）&lt;/p&gt;
&lt;p&gt;运用 java 数组存储二十六个字母&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
public class Test{
	
	public static void main(String[] args){
			
		char table[] = new char[26];
		for(int i = 0; i &amp;lt; 26; i++) {
			table[i] = (char)(&apos;a&apos; + i);
		}	
		for(int i = 0; i &amp;lt; 26; i++) {
			System.out.println(table[i]);
		}
	}
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意在这里用到了java中数据类型转换的知识，&apos;a&apos; + i 是字符型加整形，会自动类型转化为int型，不能直接赋值给 char 型的变量，需要强制类型转换&lt;/p&gt;
&lt;p&gt;习题练习&lt;/p&gt;
&lt;p&gt;找到一个数组中最大的拿一个元素，并输出&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
public class Test{	
	public static void main(String[] args){
		int table[] = {2, 3, 5, 1, 4} ;
		int max = 0;
		for(int i = 0; i &amp;lt; 5; i++) {
			max = max &amp;gt; table[i] ? max : table[i];
		}
		System.out.println(max);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;数组赋值机制&lt;/h2&gt;
&lt;p&gt;在基本数据类型赋值的时候，会赋给具体的数据，且互不影响&lt;/p&gt;
&lt;p&gt;而在数组再默认情况下赋值是引用的传递，赋给另一个数组的是数组各个元素所对应的地址&lt;/p&gt;
&lt;p&gt;代码举例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test{
	
	public static void main(String[] args){
		int i = 1;
		int j = i;
		j = 3;

		System.out.println(i);//改变j的值不会影响到i的值
		
		int table_1[] = {2, 3, 5, 1, 4} ;
		int table_2[] = new int[5];
		table_2 = table_1;
		table_2[0] = 1;

		System.out.println(table_1[0]);//改变table2 会影响到table1指向的内存空间
	}
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果需要一个全新的数据空间相互独立的数组，我们则需要一个数组拷贝&lt;/p&gt;
&lt;p&gt;可以通过for循环赋值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
public class Test{
	
	public static void main(String[] args){
		int table_1[] = {2, 3, 5, 1, 4} ;
		int table_3[] = new int[table_1.length];
		for(int i = 0; i &amp;lt; table_1.length; i++) {
			table_3[i] = table_1[i];
		}
		table_3[0] = 1;

		System.out.println(table_1[0]);//改变table3 不会影响到table1指向的内存空间
	}
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;数组操作例题&lt;/h2&gt;
&lt;p&gt;1.将数组的内容反向保存&lt;/p&gt;
&lt;p&gt;方式1：通过遍历数组的一半利用下标对于数组的各个元素收尾互换&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test{
	
	public static void main(String[] args){
		int table[] = {2, 3, 5, 1, 4, 6};
		int temp = 0;
		for(int i = 0; i &amp;lt; table.length / 2; i++) {
			temp = table[i];
			table[i] = table[table.length - i - 1];
			table[table.length - i - 1] = temp;
		}

		for(int i = 0; i &amp;lt; table.length; i++) {
			System.out.println(table[i]);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方式2：创建一个新的数组，遍历原数组将原数组中的元素反向存入新的数组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
public class Test{
	
	public static void main(String[] args){
		int table[] = {2, 3, 5, 1, 4, 6};
		int temp = 0;
		int table_2[] = new int[6];
		for(int i = 0; i &amp;lt; table_2.length; i++) {
			table_2[i] = table[table_2.length - i - 1]; 
		}

		table = table_2; //在这里将table指向了新的数组，原来的空间因为没有变量引用被销毁
		for(int i = 0; i &amp;lt; table.length; i++) {
			System.out.println(table[i]);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;数组的扩容与缩减&lt;/h2&gt;
&lt;p&gt;Java 中数组的长度是固定的，但是可以通过创建新数组的方式来将原数组的引用指向新数组的地址，以此来完成数组的扩容&lt;/p&gt;
&lt;p&gt;接下来用一段代码来完成数组的扩容&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.*;

public class Test{
	
	public static void main(String[] args){
		Scanner myScanner = new Scanner(System.in);

		int table[] = {2, 3, 5, 1, 4, 6};
		while(true) {
			char flag = &apos;n&apos;;
			System.out.println(&quot;请输入是否要添加一个元素，需要填 y &quot;);
			flag = myScanner.next().charAt(0);
			if(flag == &apos;y&apos;) {
				int num = myScanner.nextInt();
				int arr[] = new int[table.length + 1];
				for(int i = 0; i &amp;lt; table.length; i++) {
					arr[i] = table[i];
				}
				arr[table.length] = num;
				table = arr;
			} else {
				break;
			}
		}

		for(int i = 0; i &amp;lt; table.length; i++) {
			System.out.println(table[i]);
		}	
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同理我们也可以用类似的方式完成数组长度的缩减&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.*;

public class Test{
	
	public static void main(String[] args){
		Scanner myScanner = new Scanner(System.in);

		int table[] = {2, 3, 5, 1, 4, 6};
		while(true) {
			char flag = &apos;n&apos;;
			System.out.println(&quot;请输入是否要删除一个元素，需要填 y &quot;);
			flag = myScanner.next().charAt(0);
			if(flag == &apos;y&apos;) {
				if(table.length == 1) {
					System.out.println(&quot;只剩下一个元素，无法删除&quot;);
					break;
				}
				int arr[] = new int[table.length - 1];
				for(int i = 0; i &amp;lt; table.length - 1; i++) {
					arr[i] = table[i];
				}
				table = arr;
			} else {
				break;
			}
		}

		for(int i = 0; i &amp;lt; table.length; i++) {
			System.out.println(table[i]);
		}	
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是这样做太过于麻烦，可以使用后续的链表数据结构完成预期的功能&lt;/p&gt;
&lt;h2&gt;冒泡排序&lt;/h2&gt;
&lt;p&gt;经典的排序算法，在这里不过多介绍&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.*;

public class Test{	
	public static void main(String[] args){
		
		Scanner myScanner = new Scanner(System.in);
		System.out.println(&quot;请输入数组的大小&quot;);
		int number = myScanner.nextInt();
		int table[] = new int[number];		
		System.out.println(&quot;请输入数组的各个元素&quot;);
		for(int i = 0; i &amp;lt; number; i++) {
			table[i] = myScanner.nextInt();
		}
		for(int i = 0; i &amp;lt; table.length; i++) {
			System.out.print(table[i] + &quot; &quot;);
		}
		int temp = 0;
		for(int i = 0; i &amp;lt; table.length - 1; i++) {
			for(int j = 0; j &amp;lt; table.length - i - 1; j++) {
				if(table[j] &amp;gt; table[j + 1]) {
					temp = table[j];
					table[j] = table[j + 1];
					table[j + 1] = temp;
				}
			}
		}
		System.out.print(&apos;\n&apos;);
		for(int i = 0; i &amp;lt; table.length; i++) {
			System.out.print(table[i] + &quot; &quot;);
		}	
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;数组中的查找&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.*;
public class Test{	
	public static void main(String[] args){
		Scanner myScanner = new Scanner(System.in);
		String table[] = {&quot;朱雀&quot;, &quot;白虎&quot;, &quot;玄武&quot;, &quot;青龙&quot;};
		System.out.println(&quot;输入你想找到的元素&quot;);
		String target = myScanner.next();
		for(int i = 0; i &amp;lt; table.length; i++) {
			if(table[i].equals(target)) {
				System.out.println(&quot;找到了&quot; + target + &quot;位置在第&quot; + i + &quot;个元素上&quot;);
				return;
			}
		}
		System.out.println(&quot;没有找到目标的元素&quot; + target);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Java中的二维数组&lt;/h2&gt;
&lt;p&gt;二维数组数数组的扩展，相比于数组，二维数组多了一个维度，可以模拟更加复杂的现实情况，在编程中有广泛的应用&lt;/p&gt;
&lt;p&gt;以下是一个二维数组静态初始化的例子&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test{	
	public static void main(String[] args){
		int arr[][] = { {1, 1, 5, 6, 6}, 
				  	   {3, 5, 5, 6, 6}, 
				  	   {3, 5, 5, 6, 2}, 
				  	   {3, 5, 5, 6, 1}};

		for(int i = 0; i &amp;lt; arr.length; i++) {
			for(int j = 0; j &amp;lt; arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println(&quot;&quot;);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在第二个循环条件中 判断的是 对应的一维数组的长度&lt;/p&gt;
&lt;p&gt;这里有一个比较有意思的点，这里涉及到了一个存储方式的问题，以前我在c语言中没有搞明白，为什么列优先的遍历二维数组的方式会比行优先的方式要慢很多&lt;/p&gt;
&lt;p&gt;在这一段代码中可以直观地看出二维数组的存储方式是通过先行再列的方式存储在内存之中，在内存中我们存储的方式是一维的，依次访问可以通过一次内存中的遍历得到想要的所有元素&lt;/p&gt;
&lt;p&gt;而列优先的话，会导致内存的访问不连续，增加了缓存未命中的概率（这里涉及到了计算机组成原理中的 cache，缓存会从内存中加载数据用以程序的计算，而使用cache的速度是要远远快于使用内存中的数据的，假设cache目前存储的是{1, 1, 5, 6, 6 }第一个一维数组的元素，运用行优先的方式，可以一次加载cache 中的内容，而列优先的话还需要从第二个一维数组中取元素，而第二个数组不再cache中，读内存需要大量的时间浪费），从而导致了速度缓慢&lt;/p&gt;
&lt;h2&gt;二维数组的内存布局&lt;/h2&gt;
&lt;p&gt;有点类似于操作系统中的三级虚拟内存，二维数组的引用指向于一个存放一维数组引用的数组，数组的各个元素指向对应的一维数组，一维数组中才会存放需要的具体数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/46.png&quot; alt=&quot;46&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;二维数组的使用&lt;/h2&gt;
&lt;p&gt;类型 [ ] [ ] = new 类型 [ size ] [ size ];&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int arr[][] = new int[3][2]; //定义一个二维数组

int arr[][]; //也可以先定义引用，再创建二维数组的空间
arr =  new int[3][2];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;java中支持二维数组中的每个一维数组元素数量不同（列数不确定）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.*;

public class Test{
	
	public static void main(String[] args){
		int arr[][];		//声明一个二维数组的引用
		arr = new int[3][]; //先给二维数组的引用数组创建实例 没有创建存放数据包的一维数组

		for(int i = 0; i &amp;lt; arr.length; i++) {
			arr[i] = new int[i + 1];//在这里才对于一维数组中的引用，创建了每一个一维数组的空间
			for(int j = 0; j &amp;lt; arr[i].length; j++) {
				arr[i][j] = i + 1;
			}
		}
		
		for(int i = 0; i &amp;lt; arr.length; i++) {
			for(int j = 0; j &amp;lt; arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println(&quot;&quot;);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;课有点多，加上晚上要健身，今天先到这里了，明天开始会复习二维数组和相关例题，以及学习java中的类和对象&lt;/p&gt;
</content:encoded></item><item><title>Java笔记</title><link>https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%BE%AA%E7%8E%AF%E7%BB%83%E4%B9%A0%E8%B7%B3%E8%BD%AC%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%BE%AA%E7%8E%AF%E7%BB%83%E4%B9%A0%E8%B7%B3%E8%BD%AC%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</guid><description>循环练习，跳转控制语句</description><pubDate>Tue, 04 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;听课笔记&lt;/h1&gt;
&lt;h2&gt;多重循环例题&lt;/h2&gt;
&lt;h3&gt;打印九九乘法表：&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;
public class Move{
	public static void main(String[] args) {
		for(int i = 1; i &amp;lt; 10; i++) {//九九乘法表有九行 从一开始
			for(int j = 1; j &amp;lt;= i; j++) {//九九乘法表在每一行上的乘法表达式不超过行列数
				System.out.print(i + &quot; * &quot; + j + &quot;=&quot; + i*j + &quot;\t&quot;);
			}
			System.out.print(&quot;\n&quot;);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;空心金字塔：&lt;/h3&gt;
&lt;p&gt;经典的嵌套循环练习题目&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Scanner;

public class Move{
	public static void main(String[] args) {
		Scanner myScanner = new Scanner(System.in);
		int num = myScanner.nextInt();
		for(int i = 0; i &amp;lt; num; i++) {			//第一层循环 i代表每一层
			for(int j = 0; j &amp;lt; num - i; j++) {	
				System.out.print(&quot; &quot;);			//每一层都有空格开头 需要用输出填充
			}
			for(int j = 0; j &amp;lt;= 2 * i; j++) { 	//每一行需要输出 2 * 层数 + 1 个符号
				if(j == 0 || j == 2 * i || i == num -1) {
					System.out.print(&apos;*&apos;);
				} else {
					System.out.print(&apos; &apos;);
				}
				
			}
			System.out.print(&quot;\n&quot;);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在编程这一道题目的时候，可以先打印出一个实心金字塔，再对代码进行修改处理&lt;/p&gt;
&lt;p&gt;题目拓展：打印一个空心的菱形&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Scanner;

public class Move{
	public static void main(String[] args) {
		Scanner myScanner = new Scanner(System.in);
		int num = myScanner.nextInt();
		for(int i = 0; i &amp;lt; num; i++) {			//第一层循环 i代表每一层
			for(int j = 0; j &amp;lt; num - i - 1; j++) {	
				System.out.print(&quot; &quot;);			//每一层都有空格开头 需要用输出填充
			}
			for(int j = 0; j &amp;lt;= 2 * i; j++) { 	//每一行需要输出 2 * 层数 + 1 个符号
				if(j == 0 || j == 2 * i ) {
					System.out.print(&apos;*&apos;);
				} else {
					System.out.print(&apos; &apos;);
				}
				
			}
			System.out.print(&quot;\n&quot;);
		}
		for(int i = 1; i &amp;lt; num; i++) {
			for(int j = 1; j &amp;lt;= i; j++) {
				System.out.print(&apos; &apos;);
			}
			for(int j = 1; j &amp;lt;= num * 2  -2 * i - 1 ; j++) {
				if(j == 1 || j == num * 2  -2 * i - 1 ) {
					System.out.print(&apos;*&apos;);
				} else {
					System.out.print(&apos; &apos;);
				}					
			}
			System.out.print(&apos;\n&apos;);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Java中的跳转控制语句&lt;/h2&gt;
&lt;h3&gt;break&lt;/h3&gt;
&lt;p&gt;用于终止或跳出循环 以下是一个具体的代码案例 目的是记录生成的随机数50前一共生成的随机数次数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.lang.Math;	//引入Math类	

public class Move{
	public static void main(String[] args) {
		int num = 0;
		while(true) {
			num++;
			if(((int)(Math.random() * 100) + 1) == 50) // 利用random() 生成1-100 的随机数
				break;			
		}	
		
		System.out.println(num);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中Math 类中的 random 方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/45.png&quot; alt=&quot;45&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;break语句的使用细节&lt;/h4&gt;
&lt;p&gt;break 出现在多层嵌套的语句块中 ，可以通过标签 lable 指明需要终止的是那一层语句块&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
public class Move{
	public static void main(String[] args) {
		lable1:
		for(int i = 0; i &amp;lt; 3; i++) {
			System.out.println(&quot;i = &quot; + i);
			lable2:
			for(int j = 0; j &amp;lt; 2; j++) {
				System.out.println(&quot;j = &quot; + j);
				if(j == 1) break lable1;
			}
		}		
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1.break 语句可以指定退出那一层&lt;/p&gt;
&lt;p&gt;2.break 默认退出最近的一层&lt;/p&gt;
&lt;p&gt;3.在实际开发中尽量不使用break + lable的组合，会降低代码的可读性&lt;/p&gt;
&lt;p&gt;例题1：&lt;/p&gt;
&lt;p&gt;输出1+2+3+...+100中到哪一个数字的时候和大于 20&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
public class Move{
	public static void main(String[] args) {
		int sum = 0;
		for(int i = 1; i &amp;lt;= 100; i++) {
			sum += i;
			if(sum &amp;gt; 20) {
				System.out.println(&quot;最后的数字是：&quot; + i);
				break;
			}
		}		
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例题2：登陆验证，限制登录次数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Scanner;

public class Move{
	public static void main(String[] args) {
		Scanner myScanner = new Scanner(System.in);
		for(int i = 3; i &amp;gt;= 1; i--) {
			System.out.println(&quot;输入姓名&quot;);		
			String userName = myScanner.next();
			System.out.println(&quot;输入密码&quot;);		
			String password = myScanner.next();
			if(&quot;丁真&quot;.equals(userName) &amp;amp;&amp;amp; &quot;123456&quot;.equals(password)){
				System.out.println(&quot;登录成功&quot;);	
				break;
			}else {
				System.out.println(&quot;登陆失败 剩余&quot; + i + &quot;次机会&quot;);	
			}
		}
		System.out.println(&quot;登录结束&quot;);		
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意！！再java中比较字符串的时候需要使用到 String 方法的 equals()，不可以使用 == 来进行比较&lt;/p&gt;
&lt;p&gt;在比较字符串的时候，建议将常量字符串先写在前面，这样做可以避免空指针的情况引起报错&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// if(userName.equals(&quot;丁真&quot;) &amp;amp;&amp;amp; password.equals(&quot;123456&quot;))
if(&quot;丁真&quot;.equals(userName) &amp;amp;&amp;amp; &quot;123456&quot;.equals(password))
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Java 中的字符串比较&lt;/h3&gt;
&lt;p&gt;在 Java 中，字符串比较需要使用 &lt;code&gt;String&lt;/code&gt; 类的 &lt;code&gt;equals&lt;/code&gt; 方法，而不能直接使用 &lt;code&gt;==&lt;/code&gt; 运算符，原因是 &lt;strong&gt;&lt;code&gt;==&lt;/code&gt; 和 &lt;code&gt;equals&lt;/code&gt; 的作用完全不同&lt;/strong&gt;：&lt;/p&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;h4&gt;&lt;code&gt;==&lt;/code&gt; 的作用&lt;/h4&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;==&lt;/code&gt; 是 Java 中的&lt;strong&gt;比较运算符&lt;/strong&gt;，用于比较两个对象的**引用（内存地址）**是否相同。&lt;/li&gt;
&lt;li&gt;对于字符串（&lt;code&gt;String&lt;/code&gt; 类型），&lt;code&gt;==&lt;/code&gt; 比较的是两个字符串对象是否指向&lt;strong&gt;同一个内存地址&lt;/strong&gt;，而不是比较字符串的内容是否相同。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;String str1 = new String(&quot;hello&quot;);
String str2 = new String(&quot;hello&quot;);

System.out.println(str1 == str2); // false，因为 str1 和 str2 是不同的对象
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在上面的例子中，&lt;code&gt;str1&lt;/code&gt; 和 &lt;code&gt;str2&lt;/code&gt; 是两个不同的对象，尽管它们的内容都是 &lt;code&gt;&quot;hello&quot;&lt;/code&gt;，但它们的&lt;strong&gt;内存地址不同&lt;/strong&gt;，因此 &lt;code&gt;==&lt;/code&gt; 返回 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;h4&gt;&lt;code&gt;equals&lt;/code&gt; 的作用&lt;/h4&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;equals&lt;/code&gt; 是 &lt;code&gt;String&lt;/code&gt; 类中&lt;strong&gt;重写&lt;/strong&gt;的方法，用于比较两个字符串的&lt;strong&gt;内容&lt;/strong&gt;是否相同。&lt;/li&gt;
&lt;li&gt;它会逐个字符比较两个字符串的值，而不是比较它们的内存地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;String str1 = new String(&quot;hello&quot;);
String str2 = new String(&quot;hello&quot;);

System.out.println(str1.equals(str2)); // true，因为内容相同
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;尽管 &lt;code&gt;str1&lt;/code&gt; 和 &lt;code&gt;str2&lt;/code&gt; 是不同的对象，但它们的内容相同，因此 &lt;code&gt;equals&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;比较方式&lt;/th&gt;
&lt;th&gt;作用范围&lt;/th&gt;
&lt;th&gt;比较内容&lt;/th&gt;
&lt;th&gt;适用场景&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;==&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;对象引用&lt;/td&gt;
&lt;td&gt;内存地址&lt;/td&gt;
&lt;td&gt;判断两个对象是否是同一个实例&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;equals&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;对象内容&lt;/td&gt;
&lt;td&gt;字符串的实际值&lt;/td&gt;
&lt;td&gt;判断两个字符串的内容是否相同&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;引申的相关问题&lt;/h4&gt;
&lt;p&gt;1.为什么==在比较数值的时候可以使用，不是比较的是地址嘛？&lt;/p&gt;
&lt;p&gt;对于基本数据类型而言 == 比较的就是之的内容 ，而对于引用的内容而言比较的是是否是引用的同一个内容&lt;/p&gt;
&lt;p&gt;2.那如果我将基本数据类型创建实例，存储的内容不再栈上，还可以使用==进行比较吗？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基本数据类型&lt;/strong&gt;（如 &lt;code&gt;int&lt;/code&gt;、&lt;code&gt;double&lt;/code&gt;、&lt;code&gt;char&lt;/code&gt; 等）是直接存储在栈内存中的，它们没有对象实例的概念。因此，你无法直接为基本数据类型创建实例。&lt;/p&gt;
&lt;p&gt;但是，Java 提供了&lt;strong&gt;包装类&lt;/strong&gt;（Wrapper Classes）来将基本数据类型封装为对象。例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;int&lt;/code&gt; 的包装类是 &lt;code&gt;Integer&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;double&lt;/code&gt; 的包装类是 &lt;code&gt;Double&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;char&lt;/code&gt; 的包装类是 &lt;code&gt;Character&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当你使用包装类时，存储的内容是在&lt;strong&gt;堆内存&lt;/strong&gt;中，而不是栈内存中。这时，&lt;code&gt;==&lt;/code&gt; 的行为会发生变化。&lt;/p&gt;
&lt;p&gt;Java 对包装类（如 &lt;code&gt;Integer&lt;/code&gt;、&lt;code&gt;Character&lt;/code&gt; 等）做了一些优化：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于较小的值（例如 &lt;code&gt;Integer&lt;/code&gt; 在 -128 到 127 之间），Java 会使用&lt;strong&gt;常量池&lt;/strong&gt;来缓存对象。&lt;/li&gt;
&lt;li&gt;如果使用自动装箱（例如 &lt;code&gt;Integer a = 10;&lt;/code&gt;），Java 会优先从常量池中获取对象，而不是创建新的对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;Integer x = 10; // 自动装箱，从常量池中获取对象
Integer y = 10; // 自动装箱，从常量池中获取对象

System.out.println(x == y); // true，因为 x 和 y 指向常量池中的同一个对象
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这个例子中，&lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 都指向常量池中的同一个对象，因此 &lt;code&gt;==&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;但如果值超出了常量池的范围，&lt;code&gt;==&lt;/code&gt; 就会返回 &lt;code&gt;false&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Integer m = 200; // 超出常量池范围，创建新对象
Integer n = 200; // 超出常量池范围，创建新对象

System.out.println(m == n); // false，因为 m 和 n 是不同的对象
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;情况&lt;/th&gt;
&lt;th&gt;&lt;code&gt;==&lt;/code&gt; 的行为&lt;/th&gt;
&lt;th&gt;推荐方法&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;基本数据类型&lt;/td&gt;
&lt;td&gt;比较&lt;strong&gt;值&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;直接使用 &lt;code&gt;==&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;包装类对象&lt;/td&gt;
&lt;td&gt;比较&lt;strong&gt;引用（内存地址）&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;使用 &lt;code&gt;equals&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;包装类对象（常量池范围内）&lt;/td&gt;
&lt;td&gt;可能比较&lt;strong&gt;引用&lt;/strong&gt;（常量池优化）&lt;/td&gt;
&lt;td&gt;使用 &lt;code&gt;equals&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;continue&lt;/h3&gt;
&lt;p&gt;和c语言中的类似，退出当前运行的代码块，执行循环中的下一次循环&lt;/p&gt;
&lt;p&gt;也可以使用标签做 break类似的相关操作，默认执行最近的循环与语句&lt;/p&gt;
&lt;h3&gt;return&lt;/h3&gt;
&lt;p&gt;用于跳出所在的方法，在main 函数中使用退出程序&lt;/p&gt;
&lt;h2&gt;控制语句练习题目&lt;/h2&gt;
&lt;p&gt;1.求最大可以通过路口的次数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Scanner;

public class Move{
	public static void main(String[] args) {
		double money = 100000;
		int number = 0;
		while(true) {			
			if(money &amp;gt; 50000) {
				money *= 0.95;
			} else if(money &amp;lt;= 50000 &amp;amp;&amp;amp; money &amp;gt;= 1000) {
				money -= 1000;
			} else {
				break;
			}
			number++;
		}

		System.out.println(&quot;最多可以通过 &quot; + number + &quot; 次路口&quot;); 
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.判断一个年份是否为闰年&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Scanner;

public class Move{
	public static void main(String[] args) {
		Scanner myScanner = new Scanner(System.in);
		System.out.println(&quot;请输入一个年份&quot;);
		int year = myScanner.nextInt();

		if((year % 4 == 0 &amp;amp;&amp;amp; year % 100 != 0)||(year % 400 == 0)) {
			System.out.println(year + &quot;年份是一个闰年&quot;);
		} else {
			System.out.println(year + &quot;年份不是是一个闰年&quot;);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.判断一个水仙花数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Scanner;

public class Move{
	public static void main(String[] args) {
		Scanner myScanner = new Scanner(System.in);
		System.out.println(&quot;请输入一个三位数的水仙花数&quot;);
		int number = myScanner.nextInt();
		int sum = 0;
		int num1 = number / 100;
		int num2 = number % 100 / 10;
		int num3 = number % 10; 

		sum = num1 * num1 * num1 + num2 * num2 * num2 + num3 * num3 * num3;
		if(number == sum) {
			System.out.println(number + &quot;是一个水仙花数&quot;);
		} else {
			System.out.println(number + &quot;不是一个水仙花数&quot;);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这一份代码还可以进行一个代码优化，优化为支持判断所有位数的水仙花数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Scanner;

public class Move{
	public static void main(String[] args) {
		Scanner myScanner = new Scanner(System.in);
		System.out.println(&quot;请输入一个数&quot;);
		int number = myScanner.nextInt();
		int sum = 0;
		int flag = number;

		while(flag != 0) {			//当没有位数的时候停止
			int num = flag % 10;	//分离出当前数字的个位
			sum += (num * num * num);
			flag /= 10;	     	    //去除当前数字的个位
		}

		if(number == sum) {
			System.out.println(number + &quot;是一个水仙花数&quot;);
		} else {
			System.out.println(number + &quot;不是一个水仙花数&quot;);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.输出1-100间不可以被 5 整除的数字，用5个一行来显示&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Scanner;

public class Test{	
	public static void main(String[] args) {
		int count = 0;
		for(int i = 1; i &amp;lt;= 100; i++) {
			if(i % 5 != 0){
				System.out.print(i + &quot; &quot;);
				count++;
				if(count % 5 == 0){
					System.out.print(&quot;\n&quot;);
				}
			}
		} 
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.运用 for 循环打印出字母表&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Scanner;

public class Test{
	
	public static void main(String[] args) {
		for(char i = &apos;a&apos;; i &amp;lt;= &apos;z&apos;; i++) {			
			System.out.println((i));			
		} 
		for(char i = &apos;Z&apos;; i &amp;gt;= &apos;A&apos;; i--) {			
			System.out.println((i));			
		} 
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这里考察的是char 也可以做自增操作，char的本质是 Unicode编码(UTF-8)&lt;/p&gt;
&lt;p&gt;6.1 - 1/2 + 1/3 - 1/4 +1/5 - ...... - 1/100&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Scanner;

public class Test{
	public static void main(String[] args) {
		double sum = 0;
		for(int i = 1; i &amp;lt;= 100; i++) {
			double temp = 0;
			if(i % 2 == 0) {
				temp = -1.0 / i;
			} else {
				temp = 1.0 / i;
			}
			sum += temp;
		}
		System.out.println(&quot;运算结果是&quot; + sum);
	}
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;7.1 + (1+2) + (1+2+3) + ...... + （1+ ... +100）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Scanner;

public class Test{
	public static void main(String[] args) {
		int sum = 0, temp = 0;
		for(int i = 1; i &amp;lt;= 100; i++) {
			temp = 0;
			for(int j = 1; j &amp;lt;= i; j++) {
				temp += j; 
			}
			sum += temp;
		}
		System.out.println(sum);
	}
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上的代码可以正确完成功能，但是我发现了相加的每一项其实都是在前一项的基础上加上了它所对应的项数，通过一个temp变量保存前一个项的值即可让算法的复杂度降低，通过一个循环即可计算出结果，以下是代码的改进部分&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Scanner;

public class Test{
	public static void main(String[] args) {
		int sum = 0, temp = 0;
		for(int i = 1; i &amp;lt;= 100; i++) {
			temp += i;
			sum +=temp;
		}
		System.out.println(sum);
	}
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Java笔记</title><link>https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E8%BF%9B%E5%88%B6%E4%BD%8D%E8%BF%90%E7%AE%97%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E8%BF%9B%E5%88%B6%E4%BD%8D%E8%BF%90%E7%AE%97%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</guid><description>进制，位运算，流程控制</description><pubDate>Mon, 03 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;听课笔记&lt;/h1&gt;
&lt;h2&gt;Java中的进制&lt;/h2&gt;
&lt;p&gt;二进制  	0b 开头		 如 0b101， 0B1111&lt;/p&gt;
&lt;p&gt;十进制  						 如 10， 100&lt;/p&gt;
&lt;p&gt;八进制  	0 开头表示	如 077，0734&lt;/p&gt;
&lt;p&gt;十六进制  0x开头表示	如 0xFFFF， 0Xab03， 0xaaaa， 0XEEFE&lt;/p&gt;
&lt;h2&gt;Java中的位运算&lt;/h2&gt;
&lt;p&gt;~2 按位取反&lt;/p&gt;
&lt;p&gt;2&amp;amp;3 按位与&lt;/p&gt;
&lt;p&gt;2|3  按位或&lt;/p&gt;
&lt;p&gt;3^6 按位异或&lt;/p&gt;
&lt;h2&gt;Java 中的位运算符&lt;/h2&gt;
&lt;p&gt;算术左移，&amp;lt;&amp;lt;，符号位不变低位补 0&lt;/p&gt;
&lt;p&gt;算数右移，&amp;gt;&amp;gt;，符号位不变用符号位补高位&lt;/p&gt;
&lt;p&gt;逻辑右移，&amp;gt;&amp;gt;&amp;gt;，低位溢出，高位补 0&lt;/p&gt;
&lt;h2&gt;Java中的分支控制&lt;/h2&gt;
&lt;h3&gt;if &amp;amp;&amp;amp; else&lt;/h3&gt;
&lt;p&gt;随便写了一个，较为简陋&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Scanner;

public class Test{
	
	public static void main(String[] args) {
		Scanner myscanner = new Scanner(System.in);
		System.out.println(&quot;请输入成绩：&quot;);
		int grade = myscanner.nextInt();

		if(grade &amp;gt; 90) {
			System.out.println(&quot;A&quot;);
		} else if(grade &amp;gt; 60 &amp;amp;&amp;amp; grade &amp;lt;= 90) {
			System.out.println(&quot;B&quot;);
		} else {
			System.out.println(&quot;C&quot;);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;分支的嵌套注意点：在使用分支嵌套的情况下不要超过三层的分支&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;嵌套分支举例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Scanner;

public class Test{
	
	public static void main(String[] args) {
		Scanner myscanner = new Scanner(System.in);
		System.out.println(&quot;请输入成绩：&quot;);
		int grade = myscanner.nextInt();

		System.out.println(&quot;请输入性别：&quot;);
		int sex = myscanner.next().charAt(0);	
         /*
         注意在java中似乎没有nextChar()的用法 需要使用next接收一个字符串
         再将字符串中运用charAt(0)提取出第一个字符
		*/
		if(grade &amp;gt; 60) {
			System.out.println(&quot;恭喜过关&quot;);
			if(sex == &apos;男&apos;) {
				System.out.println(&quot;进入男子组决赛&quot;);
			} else {
				System.out.println(&quot;进入女子组决赛&quot;);
			}
		} else {
			System.out.println(&quot;淘汰&quot;);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;switch&lt;/h3&gt;
&lt;p&gt;与C语言同理在这里不多做说明以下是一个代码示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Scanner;

public class Test{
	
	public static void main(String[] args) {
		Scanner myscanner = new Scanner(System.in);
		System.out.println(&quot;请输入成绩：&quot;);
		int grade = myscanner.nextInt();
		switch(grade){
			case 1:
				System.out.println(&quot;A&quot;);
			break;		
             //break 退出 如果不假如break会依次执行后续的分支，在这里删除break则会输出A B
			case 2:
				System.out.println(&quot;B&quot;);
			break;		
			default:	//默认的分支
				System.out.println(&quot;C&quot;);
			break;
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;switch 中值得注意的细节&lt;/p&gt;
&lt;p&gt;1.表达式的类型应该和 case 后的常量一致，或者可以发生自动转换，例如输入的是字符，而case 后常量为 int&lt;/p&gt;
&lt;p&gt;2.case 语句后的值一定是常量，不能是变量&lt;/p&gt;
&lt;p&gt;利用 击穿 的特性我们也可以简化一些代码，如下所示&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Scanner;

public class Test{
	
	public static void main(String[] args) {
		Scanner myscanner = new Scanner(System.in);
		System.out.println(&quot;请输入月份：&quot;);
		int grade = myscanner.nextInt();
		switch(grade){
             //当满足以下三条任意的条件中的一条执行break前的指令
			case 3:
			case 4:
			case 5:
				System.out.println(&quot;春季&quot;);
			break;
			case 6:
			case 7:
			case 8:
				System.out.println(&quot;夏季&quot;);
			break;
			case 9:
			case 10:
			case 11:
				System.out.println(&quot;秋季&quot;);
			break;
			default:
				System.out.println(&quot;冬季&quot;);
			break;
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;在编程时候if 和 switch 的取舍&lt;/h3&gt;
&lt;p&gt;1.如果判断类型数值不多的情况下，并且符合byte short int char enum String 六种类型时优先使用switch&lt;/p&gt;
&lt;p&gt;2.区间判断，boolean 类型判断时 if 使用更加广泛&lt;/p&gt;
&lt;h2&gt;Java中的循环控制&lt;/h2&gt;
&lt;h3&gt;for 循环控制&lt;/h3&gt;
&lt;p&gt;与c语言基本一模一样，在这里不多介绍，以下是代码样例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Scanner;

public class Input{
	public static void main(String[] args){
		Scanner myScanner = new Scanner(System.in);
		System.out.println(&quot;请输入名字：&quot;);
		String name = myScanner.next();
		
		for(int i = 0; i &amp;lt; 10; i++){
			System.out.println(name);
		}
		
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;while 循环控制&lt;/h3&gt;
&lt;p&gt;在这里因为java中循环条件需要boolean类型的表达式，而在java中不能自动完成 int 到 boolean类型的转换&lt;/p&gt;
&lt;p&gt;c程序编写中常见的 flag-- 计数不再适用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Scanner;

public class Input{
	public static void main(String[] args){
		Scanner myScanner = new Scanner(System.in);
		System.out.println(&quot;请输入数字：&quot;);
		int flag = myScanner.nextInt();
		
		while(flag &amp;gt; 0) {
			System.out.println(flag);
			flag--;
		}
        /*
        while(flag--) {
			System.out.println(flag);
		}
        */
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然可以写成一下这种写法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Scanner;

public class Input{
	public static void main(String[] args){
		Scanner myScanner = new Scanner(System.in);
		System.out.println(&quot;请输入数字：&quot;);
		int flag = myScanner.nextInt();
		
		while((flag--) != 0) {
			System.out.println(10);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;do while 循环语句&lt;/h3&gt;
&lt;p&gt;一定会执行一次，在执行完后再次判断是否执行语句块，如下是一个暴力的催债程序:joy:&lt;/p&gt;
&lt;p&gt;先打一拳！打的时候再把问题问遍！！&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Scanner;

public class Input{
	public static void main(String[] args){
		Scanner myScanner = new Scanner(System.in);
		boolean flag = false;
		int i = 1;
		System.out.println(&quot;还不还钱？&quot;);
		do {
			System.out.println(&quot;打第&quot; + i + &quot;拳&quot;);
			i++;
			flag = myScanner.nextBoolean();
		}while(!flag); 
		System.out.println(&quot;还钱了，结束打人&quot;);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Java中的多重循环&lt;/h2&gt;
&lt;p&gt;学习到了第三天终于来到了算法难点部分，在这里也希望自己可以通过课程学习来巩固自己算法的基础。&lt;/p&gt;
</content:encoded></item><item><title>Java笔记</title><link>https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%8F%98%E9%87%8F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%BC%96%E7%A0%81%E7%B1%BB%E5%9E%8B/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%8F%98%E9%87%8F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%BC%96%E7%A0%81%E7%B1%BB%E5%9E%8B/</guid><description>变量，数据类型，类型转换，编码类型</description><pubDate>Sun, 02 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;听课笔记&lt;/h1&gt;
&lt;h2&gt;Java中的变量&lt;/h2&gt;
&lt;p&gt;在这一个部分因为本人有C语言的相关基础，只记录Java 中与C 不同的部分，以及重点部分&lt;/p&gt;
&lt;p&gt;Java中的“+”的使用方式，1.当左右两边都是数值的时候，做加法运算，当有一方是字符串时，做拼接运算&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test{
	
	public static void main(String[] args){
		System.out.println(100 + 11);			//111
		System.out.println(1 + &quot;100&quot;);			//1100
		System.out.println(100 + 11 + &quot;100&quot;);	//111100
		System.out.println(&quot;100&quot; + 100 + 11);	//10010011
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Java中的数据类型&lt;/h2&gt;
&lt;p&gt;分为基本数值类型和引用数据类型&lt;/p&gt;
&lt;h3&gt;基本数值类型&lt;/h3&gt;
&lt;p&gt;数值型 byte short int long float double&lt;/p&gt;
&lt;p&gt;字符型 char 占两个字节（因为有中文等的存在需要更多的空间存储）&lt;/p&gt;
&lt;p&gt;布尔型 boolean&lt;/p&gt;
&lt;h3&gt;引用数据类型&lt;/h3&gt;
&lt;p&gt;类   class&lt;/p&gt;
&lt;p&gt;接口 interface&lt;/p&gt;
&lt;p&gt;数组 [ ]&lt;/p&gt;
&lt;h2&gt;整数类型&lt;/h2&gt;
&lt;p&gt;在java上整数类型有着固定的范围和字段长度，不受具体的操作系统的影响，保证了可移植性。&lt;/p&gt;
&lt;p&gt;java中整形常量默认为int 型，声明long型需要在数据后加上 L 或者 l （以下为一个具体的例子）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;long b = 127;
System.out.println(b);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;127&lt;/code&gt;是一个&lt;code&gt;int&lt;/code&gt;类型的常量，但由于&lt;code&gt;long&lt;/code&gt;类型的范围比&lt;code&gt;int&lt;/code&gt;类型大，Java会自动将&lt;code&gt;127&lt;/code&gt;转换为&lt;code&gt;long&lt;/code&gt;类型，然后赋值给变量&lt;code&gt;b&lt;/code&gt;。因此，这段代码可以通过编译并正常运行。&lt;/p&gt;
&lt;p&gt;如果你要将一个超出&lt;code&gt;int&lt;/code&gt;范围的常量赋值给&lt;code&gt;long&lt;/code&gt;类型的变量，那么你必须在常量后面加上&lt;code&gt;L&lt;/code&gt;或&lt;code&gt;l&lt;/code&gt;来明确指定这是一个&lt;code&gt;long&lt;/code&gt;类型的常量。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;long b = 2147483648L;  // 这个值超出了int的范围，必须加上L
System.out.println(b);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这种情况下，如果不加&lt;code&gt;L&lt;/code&gt;，编译器会报错，因为&lt;code&gt;2147483648&lt;/code&gt;超出了&lt;code&gt;int&lt;/code&gt;类型的范围（&lt;code&gt;int&lt;/code&gt;的范围是&lt;code&gt;-2147483648&lt;/code&gt;到&lt;code&gt;2147483647&lt;/code&gt;），而Java不会自动将超出&lt;code&gt;int&lt;/code&gt;范围的常量转换为&lt;code&gt;long&lt;/code&gt;类型。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/40.png&quot; alt=&quot;40&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;浮点类型&lt;/h2&gt;
&lt;p&gt;与整型相同，java中浮点类型有着固定的范围和字段长度，不受操作系统的影响。&lt;/p&gt;
&lt;p&gt;java中浮点类型常量默认为double 型，声明float型需要在数据后加上 f 或者 F&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test{
	
	public static void main(String[] args){
		
		float num1 = 1.1;//错误 浮点数默认存储是double类型
         double num2 = 1.1;//可以，没有类型的转换
		System.out.println(b);	
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;../images/41.png&quot; alt=&quot;41&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;特殊的数值表示&lt;/h2&gt;
&lt;p&gt;.123 表示 0.123&lt;/p&gt;
&lt;p&gt;科学计数法 e大小写都可以&lt;/p&gt;
&lt;p&gt;3.14e2 表示 314.0&lt;/p&gt;
&lt;p&gt;3.14E-1 表示 0.314&lt;/p&gt;
&lt;p&gt;在使用浮点类型推荐使用double类型&lt;/p&gt;
&lt;p&gt;在判断两个浮点数是否相等时往往取二者的差值是否小于一定的范围，而非直接 == 判断&lt;/p&gt;
&lt;h2&gt;字符类型&lt;/h2&gt;
&lt;p&gt;char型，两个字节，可以存放汉字&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test{
	
	public static void main(String[] args){
		
		char num1 = &apos;李&apos;; 		//汉字
		char num2 = &apos;\n&apos;; 		//转义字符
		char num3 = &apos;a&apos;;  		//字母
		char num4 = 20013;  	//中的Unicode编码为20013
		System.out.println(num1);
		System.out.println(num2);
		System.out.println(num3);
		System.out.println(num4);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;字符类型的单个字符运用的 Unicode 进行编码，char 类型也可以参与运算，取其 Unicode编码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;System.out.println(&apos;a&apos; + 1);	//结果为98 a 的ASCII编码为 97
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;ASCII&lt;/h3&gt;
&lt;p&gt;American Standard Code for Information Interchange，美国信息交换标准代码&lt;/p&gt;
&lt;p&gt;是最早的字符编码标准之一。它使用 7 位二进制数（即 1 个字节中的低 7 位）来表示字符，总共可以表示 128 个字符，注意在这里只用了 128 个字符，实际加上 8 位可以表示 256 个字符&lt;/p&gt;
&lt;p&gt;Unicode 是一个国际化的字符编码标准，旨在为世界上所有的字符提供一个唯一的编号（称为 &lt;strong&gt;码点&lt;/strong&gt;，Code Point）。&lt;/p&gt;
&lt;h3&gt;Unicode&lt;/h3&gt;
&lt;p&gt;使用 &lt;strong&gt;16 位或更多位&lt;/strong&gt; 来表示字符，理论上可以表示超过 100 万个字符。&lt;/p&gt;
&lt;p&gt;Unicode 完全兼容 ASCII，即 ASCII 字符的 Unicode 码点与 ASCII 码相同。&lt;/p&gt;
&lt;p&gt;还有一些其他常用的编码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/43.png&quot; alt=&quot;43&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;UTF-8&lt;/h4&gt;
&lt;p&gt;是在互联网中使用最广的一种Unicode实现方式，也是对Unicode编码的一种改进&lt;/p&gt;
&lt;p&gt;它是一种变长的编码方式，支持使用 1 到 6 个字节表示一个符号，根据不同的符号来变化字节长度&lt;/p&gt;
&lt;h2&gt;布尔类型&lt;/h2&gt;
&lt;p&gt;boolean 类型 只允许取置 true 与 false&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test{
	
	public static void main(String[] args){
		
		boolean isPass = true;
		if(isPass == true) {
			System.out.println(&quot;pass&quot;);
		} else {
			System.out.println(&quot;No pass&quot;);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 java 中不允许用 0 和 非 0 来代替 true 与 false&lt;/p&gt;
&lt;h2&gt;基本数据类型转换&lt;/h2&gt;
&lt;p&gt;从左到右可以自动类型转换&lt;/p&gt;
&lt;p&gt;char  int  long  float  double&lt;/p&gt;
&lt;p&gt;byte  short  int  long  float  double&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
public class Test{
	
	public static void main(String[] args){
	
			int a = &apos;a&apos;;	//char 转 int
			char b = a;		//int 转 char 不可实现
			double c = 12;	//int 转 double
			float d = 10; 	//int 转 float 
			float e = 10.0; //double 转 float 不可实现
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;数据类型转换重点&lt;/h3&gt;
&lt;p&gt;1.有多种类型的混合运算时，将所有的类型转化为数据类型精度最大的后在进行运算&lt;/p&gt;
&lt;p&gt;2.byte short 与 char 类型间不可以发生自动的精度转换&lt;/p&gt;
&lt;p&gt;3.boolean 类型不参与类型自动转换&lt;/p&gt;
&lt;p&gt;4.byte short char 三者可以计算，先将三者转化为 int 类型 再参与运算&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test{
	
	public static void main(String[] args){
	
			char a = &apos;a&apos;;
			short b = 2;
			byte c = 1;
			int c = a + b + c; //三者参与运算时转为 int 类型
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public class Test{
	
	public static void main(String[] args){
			byte a = 1;
			byte b = 1;
			byte c = a + b; //三者参与运算时转为 int 不可转为byte 编译错误
	}
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.自动提升原则：表达式结果的类型自动提升为操作数中最大的类型&lt;/p&gt;
&lt;h2&gt;强制类型转换&lt;/h2&gt;
&lt;p&gt;自动类型转换的逆过程，将精度大的转为小的，使用强制类型转换符（） ，会造成精度的降低或溢出&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
public class Test{
	
	public static void main(String[] args){
			int num1 = (int)1.9;
			System.out.println(num1);	//发生截断 结果为 1
			int num2 = 2000;
			byte flag = (byte)num2;
			System.out.println(flag);	//发生溢出 结果为 -48
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;基本数据类型和 String 类型的转换&lt;/h2&gt;
&lt;p&gt;将基本数据类型转化为 String 类型&lt;/p&gt;
&lt;p&gt;加上 &quot; &quot; 即可实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
public class Test{
	
	public static void main(String[] args){
			int num1 = 100;
			float num2 = 2.1f;
			double num3 = 3.1;
			boolean num4 = true;
			String s1 = num1 + &quot;&quot;;
			String s2 = num2 + &quot;&quot;;
			String s3 = num3 + &quot;&quot;;
			String s4 = num4 + &quot;&quot;;
        	System.out.println(s1 + s2 + s3 + s4);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将String 类型转化为 基本数据类型&lt;/p&gt;
&lt;p&gt;通过 parse 方法实现转换&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
public class Test{
	
	public static void main(String[] args){
			
			String s1 = &quot;100&quot;;
			String s2 = &quot;23.2&quot;;
			String s3 = &quot;23.1&quot;;
			String s4 = &quot;true&quot;;
			
			int n1 = Integer.parseInt(s1);
			double n2 = Double.parseDouble(s2);
			float n3 = Float.parseFloat(s3);
			boolean n4 = Boolean.parseBoolean(s4);
			char n5 = s4.charAt(0);	//得到字符串的第一个字符
			
			System.out.println(n1);
			System.out.println(n2);
			System.out.println(n3);
			System.out.println(n4);
			System.out.println(n5);
	}
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;把字符串转为字符指的是将字符串中第一个字符取出转化为 char 类型&lt;/p&gt;
&lt;p&gt;假设将 hello 字符串转化为 int 类型则会发生解析错误，在这里编译的时候不会发生错误，但是运行的时候会报错&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
public class Test{
	public static void main(String[] args) {	
			String s1 = &quot;true&quot;;
			int n1 = Integer.parseInt(s1);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;../images/44.png&quot; alt=&quot;44&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;Java API 文档&lt;/h2&gt;
&lt;p&gt;Application Programming Interface&lt;/p&gt;
&lt;p&gt;提供了大量的基础类，官方给了相应的API文档，用于告诉开发者如何使用相关类以及方法&lt;/p&gt;
&lt;p&gt;在这里提供一个java8 中文文档&lt;/p&gt;
&lt;p&gt;https://www.matools.com/api/java8&lt;/p&gt;
&lt;h2&gt;Java类 的组织形式&lt;/h2&gt;
&lt;p&gt;java 中类以包的形式包装，JDK 中有很多的包，包下面有很多的接口，类，异常&lt;/p&gt;
&lt;p&gt;类下面有字段，（构造器）构造方法，（成员方法）方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/42.png&quot; alt=&quot;42&quot; /&gt;&lt;/p&gt;
&lt;p&gt;通过文档可以方便的查找需要的 API&lt;/p&gt;
&lt;h2&gt;Java 中的算数运算符&lt;/h2&gt;
&lt;p&gt;/ 号在处理 int 数据时会发生截断&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
public class Test{
	
	public static void main(String[] args){
			double n1 = 10 / 4;    
			System.out.println(n1);//结果是2.0 将int 2 转为 2.0
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;取模公式 a % b = a - a / b * b&lt;/p&gt;
&lt;p&gt;java中面试题&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int i = 1;
i = i++; // 1.temp = i;  2. i = i + 1;  3.i = temp;
System.out.println(i) //i = 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;int i = 1;
i = ++i; // 1.i = i + 1;  2. temp = i;  3.i = temp;
System.out.println(i) //i = 2;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Java中的逻辑运算符&lt;/h2&gt;
&lt;p&gt;&amp;amp;&amp;amp; 短路与 &amp;amp; 与&lt;/p&gt;
&lt;p&gt;|| 短路或 | 或&lt;/p&gt;
&lt;p&gt;! 取反&lt;/p&gt;
&lt;p&gt;a ^ b 逻辑异或 a与b不同时为 true ，相同时为 true&lt;/p&gt;
&lt;h2&gt;赋值运算符&lt;/h2&gt;
&lt;p&gt;注意在使用赋值运算符计算byte char short 类型的时候会发生类型的转换，计算得到的 int 类型 会转化为 byte类型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
public class Test{
	
	public static void main(String[] args){
			byte b = 3;
			b += 2;	//等价于 b = (byte)(b + 2);
			b++;	//等价于 b = (byte)(b + 1);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;运算符优先级大致分类&lt;/h2&gt;
&lt;p&gt;1.（）{}&lt;/p&gt;
&lt;p&gt;2.单目运算符++ --&lt;/p&gt;
&lt;p&gt;3.算术运算符 + - % /&lt;/p&gt;
&lt;p&gt;4.位移运算符 &amp;gt;&amp;gt;&amp;gt;&lt;/p&gt;
&lt;p&gt;5.比较运算符 &amp;gt; ==&lt;/p&gt;
&lt;p&gt;6.逻辑运算符 || &amp;amp;&amp;amp; ^&lt;/p&gt;
&lt;p&gt;7.三元运算符 ？ ：&lt;/p&gt;
&lt;p&gt;8.赋值运算符 =&lt;/p&gt;
&lt;h2&gt;Java中的标识符&lt;/h2&gt;
&lt;h3&gt;标识符的命名规则&lt;/h3&gt;
&lt;p&gt;1.由26个英文字母大小写，0—9，_ ，$ 组成&lt;/p&gt;
&lt;p&gt;2.不可以以数字开头如 int 2ab = 1;&lt;/p&gt;
&lt;p&gt;3.不可以使用关键字或者保留字，但是可以包含关键字和保留字&lt;/p&gt;
&lt;p&gt;4.java 中严格区分大小写，在长度上无限制&lt;/p&gt;
&lt;p&gt;5.标识符不含空格 如 int a b = 1;&lt;/p&gt;
&lt;h3&gt;标识符的命名规范&lt;/h3&gt;
&lt;p&gt;可以使得代码的编写更加专业&lt;/p&gt;
&lt;p&gt;1.包名：多单词组成时，所有字母小写&lt;/p&gt;
&lt;p&gt;2.类名与接口名：多单词组成时，所有首字母大写，如 StudentClass（大驼峰法）&lt;/p&gt;
&lt;p&gt;3.变量名与方法名：多单词组成时，第一个单词首字母小写，其余的单词首字母大写，如 studentName（小驼峰法）&lt;/p&gt;
&lt;p&gt;4.常量命名：所有字母大写，再多单词组成时之间用 _ 链接，STUDENT_NAME_CLASS&lt;/p&gt;
&lt;h2&gt;Java中的键盘输入&lt;/h2&gt;
&lt;p&gt;再 java 编程中需要接收用户输入数据时需要键盘输入语句类获取内容时&lt;/p&gt;
&lt;p&gt;我们需要使用到 java.util.*包中的扫描器 Scanner&lt;/p&gt;
&lt;p&gt;使用步骤：&lt;/p&gt;
&lt;p&gt;1.导入类所在包&lt;/p&gt;
&lt;p&gt;2.创建类的对象&lt;/p&gt;
&lt;p&gt;3.调用类方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Scanner; 							//1.导入类所在包

public class Input{
	public static void main(String[] args){
		Scanner myScanner = new Scanner(System.in);	 //2.创建类的对象
		System.out.println(&quot;请输入名字：&quot;);
		String name = myScanner.next();				//3.调用类方法
		System.out.println(&quot;请输入年龄：&quot;);
		int ages = myScanner.nextInt();				//3.调用类方法
		System.out.println(&quot;请输入成绩：&quot;);
		double grades = myScanner.nextDouble();		 //3.调用类方法
		System.out.println(&quot;信息如下：&quot; + name + ages + grades);
	}
}

&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Java笔记</title><link>https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E9%87%8D%E8%A6%81%E7%89%B9%E7%82%B9%E6%B3%A8%E9%87%8A%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E9%87%8D%E8%A6%81%E7%89%B9%E7%82%B9%E6%B3%A8%E9%87%8A%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/</guid><description>重要特点，注释，编程规范</description><pubDate>Sat, 01 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;听课笔记&lt;/h1&gt;
&lt;p&gt;目前在听韩顺平老师的java课程，准备以此来巩固自己的java基础，以下是一些我听课程时候所记录的笔记&lt;/p&gt;
&lt;h2&gt;Java技术体系平台&lt;/h2&gt;
&lt;p&gt;1.java SE标准版&lt;/p&gt;
&lt;p&gt;2.java EE企业版&lt;/p&gt;
&lt;p&gt;3.java ME小型版&lt;/p&gt;
&lt;h2&gt;Java的重要特点&lt;/h2&gt;
&lt;p&gt;1.面向对象&lt;/p&gt;
&lt;p&gt;2.java的健壮性，java强类型机制，异常处理，垃圾自动收集保证了java的健壮性&lt;/p&gt;
&lt;p&gt;3.java的跨平台性质的&lt;/p&gt;
&lt;p&gt;可以通过.java文件生成.class文件&lt;/p&gt;
&lt;p&gt;class可以在Windows又可以在Linux上运行，并不需要再重新编译.java文件(利用了JVM虚拟机可以在三大操作系统上执行）&lt;/p&gt;
&lt;p&gt;4.java语言是解释性语言，解释性语言在编译之后需要解释器来进行执行，编译性语言（二进制）可以被机器直接执行。&lt;/p&gt;
&lt;p&gt;Win+s可以直接打开windows的搜索栏，ctrl + l 可以快速清除命令行中的内容,再命令行中用Tab键补全&lt;/p&gt;
&lt;h2&gt;java虚拟机 JVM包含于jdk&lt;/h2&gt;
&lt;p&gt;全称java virtual machine&lt;/p&gt;
&lt;p&gt;是一个虚拟的计算机，具有指令集并使用不同的存储区域，负责的执行指令管理数据内存寄存器都包含在jdk中&lt;/p&gt;
&lt;p&gt;Test.java -编译javac（需要用到java开发工具）-&amp;gt; Test.class -运行java（只需要JRE运行环境）-&amp;gt; JVM of op_system&lt;/p&gt;
&lt;h2&gt;JDK java开发工具包 Java Development Kit&lt;/h2&gt;
&lt;p&gt;JDK = JRE + java开发工具&lt;/p&gt;
&lt;h2&gt;JRE (运行.class必要的环境)&lt;/h2&gt;
&lt;p&gt;java运行环境 Java Runtime Environment&lt;/p&gt;
&lt;p&gt;JRE = JVM + Java核心类库 Java SE标准类库&lt;/p&gt;
&lt;h2&gt;运行第一个Java程序&lt;/h2&gt;
&lt;p&gt;注意中文编码问题需要使用 javac -encoding UTF-8 Test.java&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//表示Hello类的开始与结束
public class Test{
	
	//编写一个主方法，即程序的入口
	public static void main(String[] args){
		System.out.println(&quot;Hello world!!&quot;);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;.java文件   源文件&lt;/p&gt;
&lt;p&gt;.class文件 字节码文件&lt;/p&gt;
&lt;p&gt;执行的本质是将.class文件装载到jvm机器执行，所以修改后的源文件需要通过重新编译生成新的.class文件才可以输出正确的预期结果&lt;/p&gt;
&lt;h2&gt;java开发注意事项以及细节说明&lt;/h2&gt;
&lt;p&gt;1.java应用程序执行入口是main（）方法，有着固定的书写格式：public static void main(String[] args)&lt;/p&gt;
&lt;p&gt;2.一个源文件中最多只有一个public类， 其他的类个数不做限制&lt;/p&gt;
&lt;p&gt;3.如果源文件中包含一个public类，则文件名必须按照该类名进行命名&lt;/p&gt;
&lt;p&gt;4.习惯上因为{}成对出现，所以先写括号再填内容&lt;/p&gt;
&lt;p&gt;5.如果源文件中包含一个public类，则文件名必须按照该类名进行命名，也可以将main方法写在非public，这样入口java执行非public的main方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//java的快速入门，演示开发过程
//表示Hello类的开始与结束
public class Test{
	
	//编写一个主方法，即程序的入口
	public static void main(String[] args){
		System.out.println(&quot;Thrinisty正在学习！！\n&quot;);
	}
}

class Cat{
	public static void main(String[] args){
		System.out.println(&quot;修狗！！\n&quot;);
	}
}

class Dog{public static void main(String[] args){
		System.out.println(&quot;猫猫！！\n&quot;);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在技术学习方法方面，老师有一点说的很好，在之后工作之中学习新技术的时候，先掌握基本原理与基本语法，之后再补充细节上的部分。&lt;/p&gt;
&lt;h2&gt;Java转义字符&lt;/h2&gt;
&lt;p&gt;\t  可以实现对齐功能(字表位)&lt;/p&gt;
&lt;p&gt;\n 可以实现换行功能&lt;/p&gt;
&lt;p&gt;要想输出 \  字符需要使用 \ \ 进行转义&lt;/p&gt;
&lt;p&gt;\r 可以实现回车功能(将光标定在当前行的第一个字符，之后输入的字符将替换后续的内容)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
public class ChangeChar{

	public static void main(String[] args){
		System.out.println(&quot;北京\t上海\t天津\n&quot;);
		
		System.out.println(&quot;C:\\Users\\71460\\Desktop\\Java\\class2&quot;);
		
		System.out.println(&quot;书名 \&quot;北京\&quot;&quot;);
		
		System.out.println(&quot;书名是\r北京&quot;);
        //输出的结果为 北京是
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Java注释&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;//单行注释

//多行注释
/*	测试文字
	测试文字
	测试文字
	测试文字
*/

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意！！Java不支持嵌套多行注释！！&lt;/p&gt;
&lt;h2&gt;注释文档&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;/**
 *@author thrinisty
 *@version 1.0
 */

public class Test{

	public static void main(String[] args){
		System.out.println(&quot;北京\t上海\t天津\n&quot;);
		
	}
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;javadoc -d D:\temp -author -version Test.java 指令生成了对应的文档&lt;/p&gt;
&lt;p&gt;java文档标签示例&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/38.png&quot; alt=&quot;38&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/39.png&quot; alt=&quot;39&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;Java中的代码规范&lt;/h2&gt;
&lt;p&gt;1.类，方法的注释，要以javadoc的方式来写&lt;/p&gt;
&lt;p&gt;2.非java doc的注释用单行注释来进行描述&lt;/p&gt;
&lt;p&gt;3.注意运用Tab来进行代码对齐，提高代码的美观性（运用tab向右移动，shift + tab 向左移动）&lt;/p&gt;
&lt;p&gt;4.运算符与数具之间留有空格 a = b + c 来替代a=b+c&lt;/p&gt;
&lt;p&gt;5.源文件使用UTF-8来进行存储&lt;/p&gt;
&lt;p&gt;6.行宽不大于80个字符&lt;/p&gt;
&lt;p&gt;7.代码编写次行风格与行尾风格（都可以使用）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 *行尾风格
 */
 
 public class Test{
	public static void main(String[] args){
		System.out.println(&quot;北京\t上海\t天津\n&quot;);		
	}
}


/**
 *次行风格
 */
 public class Test
 {
	public static void main(String[] args)
	{
		System.out.println(&quot;北京\t上海\t天津\n&quot;);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Dos指令相关内容&lt;/h2&gt;
&lt;p&gt;dir 查看当前目录下有些什么内容。也可以用ls 来进行查看&lt;/p&gt;
&lt;p&gt;cd 改变文件目录，与linux 相关操作同理，在这里不多做叙述，可查看linux相关指令那一篇文&lt;/p&gt;
&lt;p&gt;cls 清除所有显示的内容&lt;/p&gt;
&lt;p&gt;md 创建文件夹 rd删除文件&lt;/p&gt;
&lt;p&gt;copy 拷贝文件 del 删除文件&lt;/p&gt;
&lt;p&gt;echo 输入内容到文件&lt;/p&gt;
&lt;p&gt;move 移动文件&lt;/p&gt;
&lt;p&gt;exit 退出命令行&lt;/p&gt;
</content:encoded></item><item><title>Linux</title><link>https://thrinisty.github.io/posts/linux%E4%B8%AD%E9%87%8D%E8%A6%81%E7%9A%84%E6%8C%87%E4%BB%A4/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/linux%E4%B8%AD%E9%87%8D%E8%A6%81%E7%9A%84%E6%8C%87%E4%BB%A4/</guid><description>linux常见指令，这个部分较为简易，后续或许回补充</description><pubDate>Wed, 19 Feb 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h3&gt;linux中的一些常用指令&lt;/h3&gt;
&lt;h4&gt;cd（change directory）更改目录&lt;/h4&gt;
&lt;p&gt;其中 / 是linux中的根目录， . 代表的是当前的目录， .. 表示上一层目录
大部分的情况下 ./ 可以省略 直接cd + 目录下的文件路径&lt;/p&gt;
&lt;p&gt;cd ||  cd ~进入家目录&lt;/p&gt;
&lt;p&gt;cd - 进入上一次的目录&lt;/p&gt;
&lt;h4&gt;ls（list）显示当前目录的文件&lt;/h4&gt;
&lt;p&gt;-l参数会显示各个类型属性&lt;/p&gt;
&lt;p&gt;-a还会显示额外的文件&lt;/p&gt;
&lt;p&gt;-al综合前两个&lt;/p&gt;
&lt;h4&gt;cp（copy）拷贝文件&lt;/h4&gt;
&lt;p&gt;cp + 拷贝源路径 + 目标路径&lt;/p&gt;
&lt;p&gt;-r 参数 递归地拷贝&lt;/p&gt;
&lt;h4&gt;mv（move to）剪切&lt;/h4&gt;
&lt;p&gt;用法与复制类似&lt;/p&gt;
&lt;p&gt;特殊用法（更改名字）&lt;/p&gt;
&lt;p&gt;mv + 目标原来的文件名 + 现在的文件名&lt;/p&gt;
&lt;h4&gt;chmod （change mode）修改文件权限&lt;/h4&gt;
&lt;p&gt;可以通过chmod 744 文件名 修改&lt;/p&gt;
&lt;p&gt;chmod u+x 文件&lt;/p&gt;
&lt;p&gt;chmod g-r  文件&lt;/p&gt;
&lt;p&gt;chmod o+r 文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/34.png&quot; alt=&quot;34&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;rm（remove）删除文件&lt;/h4&gt;
&lt;p&gt;-rf 强制删除参数&lt;/p&gt;
&lt;h4&gt;touch 创建文件&lt;/h4&gt;
&lt;p&gt;touch a b c&lt;/p&gt;
&lt;h4&gt;mkdir 创建文件夹&lt;/h4&gt;
&lt;h4&gt;tar 压缩&lt;/h4&gt;
&lt;p&gt;tar -zcf 压缩名字 需要压缩的文件文件&lt;/p&gt;
&lt;p&gt;tar -xzf 解压文件&lt;/p&gt;
&lt;p&gt;tar -zcf x.tar.gz a b c&lt;/p&gt;
&lt;h4&gt;find 查找文件&lt;/h4&gt;
&lt;p&gt;find 路径 -name &quot;文件名&quot;&lt;/p&gt;
&lt;h4&gt;grep 查找关键字&lt;/h4&gt;
&lt;p&gt;grep &quot;搜索关键字&quot; 路径 -r (递归)&lt;/p&gt;
</content:encoded></item><item><title>Vim</title><link>https://thrinisty.github.io/posts/vim%E5%85%A5%E9%97%A8/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/vim%E5%85%A5%E9%97%A8/</guid><description>Vim入门，后续可能添加新的内容，或者重构一下</description><pubDate>Tue, 18 Feb 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;VIM&lt;/h2&gt;
&lt;p&gt;vim stdio.h 如果有则进入如果没有则创建文件&lt;/p&gt;
&lt;h4&gt;三种模式&lt;/h4&gt;
&lt;h5&gt;命令模式（默认进入）&lt;/h5&gt;
&lt;p&gt;yy复制一行  10yy复制十行&lt;/p&gt;
&lt;p&gt;p粘贴&lt;/p&gt;
&lt;p&gt;dd剪切&lt;/p&gt;
&lt;p&gt;u撤销&lt;/p&gt;
&lt;p&gt;x删除一个字符&lt;/p&gt;
&lt;p&gt;shift g跳到最后一行&lt;/p&gt;
&lt;p&gt;gg回到第一行&lt;/p&gt;
&lt;p&gt;*用于查找&lt;/p&gt;
&lt;p&gt;shift z&lt;/p&gt;
&lt;h5&gt;插入模式（Insert编辑）&lt;/h5&gt;
&lt;p&gt;通过i或者a按键进入，esc退出并进入命令模式&lt;/p&gt;
&lt;h5&gt;底行模式（通过命令模式下进入）：&lt;/h5&gt;
&lt;p&gt;:w保存 q退出 wq保存退出 wq! 强制保存退出&lt;/p&gt;
&lt;p&gt;:10跳到10行&lt;/p&gt;
&lt;p&gt;：nohl消除高亮&lt;/p&gt;
&lt;p&gt;:set nonu 去除行号&lt;/p&gt;
&lt;p&gt;:set nu 加上行号&lt;/p&gt;
&lt;p&gt;:%s/old/new替换&lt;/p&gt;
&lt;p&gt;/进入底行模式用于查找&lt;/p&gt;
&lt;p&gt;如/main&lt;/p&gt;
</content:encoded></item><item><title>关于 Git</title><link>https://thrinisty.github.io/posts/%E5%85%B3%E4%BA%8Egit/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/%E5%85%B3%E4%BA%8Egit/</guid><description>这一份比较古老了，可以4月份那一篇，稍微详细点</description><pubDate>Wed, 15 Jan 2025 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;git的功能相当于一个游戏的存档功能，可用以代码的管理，正确使用git即可提高编码的效率以及存储安全，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/30.png&quot; alt=&quot;30&quot; /&gt;&lt;/p&gt;
&lt;p&gt;在VScode之中可以通过GUI进行快速的配置与github的git链接，首先用默认的浏览器注册一个GitHub账号，保持账号的登陆状态，按照网络上的教程安装git（详细可参照各大博客上的相关教程）&lt;/p&gt;
&lt;p&gt;再次打开vscode即可在上图的位置看到打开文件夹以及克隆仓库的两个选项，我们选择创建一个文件夹，在文件夹下可以新建一个本地的git仓库，可以自行在仓库中添加一些内容，提交就等价于游戏中保存一个本地存档，而同步相当于提交本地的游戏数据到云端存储，而第一次存储到github中需要按照相关的步骤对本地的环境进行授权操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/31.png&quot; alt=&quot;31&quot; /&gt;&lt;/p&gt;
&lt;p&gt;以上是源代码的管理图，有着代码各个版本的说明以及修改内容介绍，蓝色的代表本地存档，而紫色的代表云存档，二者进度不一定相同，例如提交了本地仓库，但是没有同步至云端。&lt;/p&gt;
&lt;p&gt;在对应的仓库目录下，我们可以在终端使用git log指令查看日志，来检索git提交的版本信息 ，键入q来进行退出&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/32.png&quot; alt=&quot;32&quot; /&gt;&lt;/p&gt;
&lt;p&gt;上述我们通过了在本地的初始化建立git仓库，默认提交到了github中，当然我们也可以在GitHub中先建立仓库，然后再远程建立连接，我们先在源代码管理界面的右侧找到三个点...的选项，选择远程，添加远程库，如果你登陆了github账号的话即可自动查找github中的仓库，选取并在后续选择私有或者公有即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/33.png&quot; alt=&quot;33&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>虚拟机代理</title><link>https://thrinisty.github.io/posts/vmware%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BB%A3%E7%90%86/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/vmware%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BB%A3%E7%90%86/</guid><description>VMware虚拟机代理设置，在安装rust软件包时碰到的问题</description><pubDate>Fri, 15 Nov 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h3&gt;第一份正式的博客内容&lt;/h3&gt;
&lt;p&gt;这算是我写的第一份博客，大学时光已经过半，我也想在有限的时间里面留下点什么，希望这一篇推文可以帮助到你:happy:&lt;/p&gt;
&lt;h4&gt;序言&lt;/h4&gt;
&lt;p&gt;和大多数人一样，我在linux安装各种软件包的时候，想到的第一个方法应该是换源，换一个学术的源平台去下载各种各样的包或者软件之类的，但是有的时候镜像资源难免会出现一些缺漏，导致了没有办法正确的找到依赖，而通过代理的方式可以在linux虚拟机下安装各式各样的软件一劳永逸，接下来是我从网络上找寻到的一种方式&lt;/p&gt;
&lt;h4&gt;解决方式（需要主机拥有代理软件）&lt;/h4&gt;
&lt;h5&gt;第一种解决方式：用图形化界面手动设置&lt;/h5&gt;
&lt;p&gt;第一：设置虚拟机（我这里运用的是VMware虚拟机，Ubuntu版本为22.04）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/7.png&quot; alt=&quot;7&quot; /&gt;&lt;/p&gt;
&lt;p&gt;如图我们将其中的网络适配器网络连接方式更改成为NAT桥接模式，使虚拟机与宿主机共享同样的的IP地址&lt;/p&gt;
&lt;p&gt;第二：记录主机的IP地址&lt;/p&gt;
&lt;p&gt;在主机上打开终端，键入  ipconfig 查看，其中会打印出很多的网络配置信息，我们重点聚焦于主机的IP地址
&lt;img src=&quot;../images/4.png&quot; alt=&quot;4&quot; /&gt;&lt;/p&gt;
&lt;p&gt;其中以太网适配器中的IPv4是我们所需的，将其记录下来：192.168.9.1&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/6.png&quot; alt=&quot;6&quot; /&gt;&lt;/p&gt;
&lt;p&gt;第三：开启代理软件获取其端口号（以clash举例，多的我也没有）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/5.png&quot; alt=&quot;5&quot; /&gt;&lt;/p&gt;
&lt;p&gt;其中7890就是我们所需要的内容，将其记录下来&lt;/p&gt;
&lt;p&gt;第四：启动linux虚拟机设置并开启网络代理&lt;/p&gt;
&lt;p&gt;在网络代理设置中点击手动（默认为已禁用），此时不更改网络代理的数据的时候是无法正常上网的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/8.png&quot; alt=&quot;8&quot; /&gt;&lt;/p&gt;
&lt;p&gt;下一步为设置两个代理，以及Socks主机&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/9.png&quot; alt=&quot;9&quot; /&gt;&lt;/p&gt;
&lt;p&gt;其中前一个为IP地址：填入主机IP，后一个端口号填入代理端口，保存即可完成虚拟机共享主机代理的设置&lt;/p&gt;
&lt;p&gt;第五：验证代理是否成功&lt;/p&gt;
&lt;p&gt;发现可以正常访问学术网站，linux虚拟机代理成功，同时也可以解决rustc软件包安装失效的问题&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/10.png&quot; alt=&quot;10&quot; /&gt;&lt;/p&gt;
&lt;h5&gt;第二种解决方式：通过命令行配置代理&lt;/h5&gt;
&lt;p&gt;第一：配置代理&lt;/p&gt;
&lt;p&gt;在终端中输入以下指令（ip地址为你自己的，端口号为代理软件的，同第一种解决方式中的一样）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export https_proxy=http://192.168.9.1:7890
export http_proxy=http://192.168.9.1:7890
export ftp_proxy=http://192.168.9.1:7890
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二：配置生效&lt;/p&gt;
&lt;p&gt;安装完成后，我们可以重新打开一个终端来让之前设置的环境变量生效。&lt;/p&gt;
&lt;p&gt;我们也可以手动将环境变量设置应用到当前终端（非永久生效，仅限于当前终端），输入以下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;source $HOME/.cargo/env
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;结语&lt;/h4&gt;
&lt;p&gt;真诚地希望你的问题在这里得到解决，以上是我写的有关linux虚拟机代理的解决方法&lt;/p&gt;
</content:encoded></item><item><title>My First Post</title><link>https://thrinisty.github.io/posts/thrinisty/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/thrinisty/</guid><description>欢迎来到我的博客网站！！这里会记录学习Java后端的一些笔记</description><pubDate>Fri, 15 Nov 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h4&gt;关于Thrinisty&lt;/h4&gt;
&lt;h5&gt;欢迎:happy:&lt;/h5&gt;
&lt;p&gt;欢迎来到我的博客网页，在这里我会不定期的更新一些实验中的思路，遇到的问题以及解决方案&lt;/p&gt;
&lt;h5&gt;关于名字&lt;/h5&gt;
&lt;p&gt;为什么要取thrinisty这样的名字，其实这个名字源自于我母亲大人的LOL账号名，又受制于自己起名水平:cry:，故直接将这个称号照搬作为了我的博客名称。&lt;/p&gt;
&lt;h5&gt;尾声&lt;/h5&gt;
&lt;p&gt;总而言之，还是欢迎你来到我的博客，希望你在这里可以找到你想要的东西！！:happy:&lt;/p&gt;
</content:encoded></item><item><title>Markdown Extended Features</title><link>https://thrinisty.github.io/posts/markdown-extended/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/markdown-extended/</guid><description>Read more about Markdown features in Fuwari</description><pubDate>Wed, 01 May 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;GitHub Repository Cards&lt;/h2&gt;
&lt;p&gt;You can add dynamic cards that link to GitHub repositories, on page load, the repository information is pulled from the GitHub API.&lt;/p&gt;
&lt;p&gt;::github{repo=&quot;Fabrizz/MMM-OnSpotify&quot;}&lt;/p&gt;
&lt;p&gt;Create a GitHub repository card with the code &lt;code&gt;::github{repo=&quot;&amp;lt;owner&amp;gt;/&amp;lt;repo&amp;gt;&quot;}&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;::github{repo=&quot;saicaca/fuwari&quot;}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Admonitions&lt;/h2&gt;
&lt;p&gt;Following types of admonitions are supported: &lt;code&gt;note&lt;/code&gt; &lt;code&gt;tip&lt;/code&gt; &lt;code&gt;important&lt;/code&gt; &lt;code&gt;warning&lt;/code&gt; &lt;code&gt;caution&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;:::note
Highlights information that users should take into account, even when skimming.
:::&lt;/p&gt;
&lt;p&gt;:::tip
Optional information to help a user be more successful.
:::&lt;/p&gt;
&lt;p&gt;:::important
Crucial information necessary for users to succeed.
:::&lt;/p&gt;
&lt;p&gt;:::warning
Critical content demanding immediate user attention due to potential risks.
:::&lt;/p&gt;
&lt;p&gt;:::caution
Negative potential consequences of an action.
:::&lt;/p&gt;
&lt;h3&gt;Basic Syntax&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;:::note
Highlights information that users should take into account, even when skimming.
:::

:::tip
Optional information to help a user be more successful.
:::
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Custom Titles&lt;/h3&gt;
&lt;p&gt;The title of the admonition can be customized.&lt;/p&gt;
&lt;p&gt;:::note[MY CUSTOM TITLE]
This is a note with a custom title.
:::&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::note[MY CUSTOM TITLE]
This is a note with a custom title.
:::
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;GitHub Syntax&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;[!TIP]
&lt;a href=&quot;https://github.com/orgs/community/discussions/16925&quot;&gt;The GitHub syntax&lt;/a&gt; is also supported.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; [!NOTE]
&amp;gt; The GitHub syntax is also supported.

&amp;gt; [!TIP]
&amp;gt; The GitHub syntax is also supported.
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Simple Guides for Fuwari</title><link>https://thrinisty.github.io/posts/guide/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/guide/</guid><description>How to use this blog template.</description><pubDate>Mon, 01 Apr 2024 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;Cover image source: &lt;a href=&quot;https://image.civitai.com/xG1nkqKTMzGDvpLrqFT7WA/208fc754-890d-4adb-9753-2c963332675d/width=2048/01651-1456859105-(colour_1.5),girl,_Blue,yellow,green,cyan,purple,red,pink,_best,8k,UHD,masterpiece,male%20focus,%201boy,gloves,%20ponytail,%20long%20hair,.jpeg&quot;&gt;Source&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This blog template is built with &lt;a href=&quot;https://astro.build/&quot;&gt;Astro&lt;/a&gt;. For the things that are not mentioned in this guide, you may find the answers in the &lt;a href=&quot;https://docs.astro.build/&quot;&gt;Astro Docs&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Front-matter of Posts&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;---
title: My First Blog Post
published: 2023-09-09
description: This is the first post of my new Astro blog.
image: ./cover.jpg
tags: [Foo, Bar]
category: Front-end
draft: false
---
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Attribute&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;title&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;The title of the post.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;published&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;The date the post was published.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;description&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;A short description of the post. Displayed on index page.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;image&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;The cover image path of the post.&amp;lt;br/&amp;gt;1. Start with &lt;code&gt;http://&lt;/code&gt; or &lt;code&gt;https://&lt;/code&gt;: Use web image&amp;lt;br/&amp;gt;2. Start with &lt;code&gt;/&lt;/code&gt;: For image in &lt;code&gt;public&lt;/code&gt; dir&amp;lt;br/&amp;gt;3. With none of the prefixes: Relative to the markdown file&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;tags&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;The tags of the post.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;category&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;The category of the post.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;draft&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;If this post is still a draft, which won&apos;t be displayed.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Where to Place the Post Files&lt;/h2&gt;
&lt;p&gt;Your post files should be placed in &lt;code&gt;src/content/posts/&lt;/code&gt; directory. You can also create sub-directories to better organize your posts and assets.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;src/content/posts/
├── post-1.md
└── post-2/
    ├── cover.png
    └── index.md
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Markdown Example</title><link>https://thrinisty.github.io/posts/markdown/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/markdown/</guid><description>A simple example of a Markdown blog post.</description><pubDate>Sun, 01 Oct 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;An h1 header&lt;/h1&gt;
&lt;p&gt;Paragraphs are separated by a blank line.&lt;/p&gt;
&lt;p&gt;2nd paragraph. &lt;em&gt;Italic&lt;/em&gt;, &lt;strong&gt;bold&lt;/strong&gt;, and &lt;code&gt;monospace&lt;/code&gt;. Itemized lists
look like:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;this one&lt;/li&gt;
&lt;li&gt;that one&lt;/li&gt;
&lt;li&gt;the other one&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Note that --- not considering the asterisk --- the actual text
content starts at 4-columns in.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Block quotes are
written like so.&lt;/p&gt;
&lt;p&gt;They can span multiple paragraphs,
if you like.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Use 3 dashes for an em-dash. Use 2 dashes for ranges (ex., &quot;it&apos;s all
in chapters 12--14&quot;). Three dots ... will be converted to an ellipsis.
Unicode is supported. ☺&lt;/p&gt;
&lt;h2&gt;An h2 header&lt;/h2&gt;
&lt;p&gt;Here&apos;s a numbered list:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;first item&lt;/li&gt;
&lt;li&gt;second item&lt;/li&gt;
&lt;li&gt;third item&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Note again how the actual text starts at 4 columns in (4 characters
from the left side). Here&apos;s a code sample:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Let me re-iterate ...
for i in 1 .. 10 { do-something(i) }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you probably guessed, indented 4 spaces. By the way, instead of
indenting the block, you can use delimited blocks, if you like:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;define foobar() {
    print &quot;Welcome to flavor country!&quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(which makes copying &amp;amp; pasting easier). You can optionally mark the
delimited block for Pandoc to syntax highlight it:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import time
# Quick, count to ten!
for i in range(10):
    # (but not *too* quick)
    time.sleep(0.5)
    print i
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;An h3 header&lt;/h3&gt;
&lt;p&gt;Now a nested list:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;First, get these ingredients:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;carrots&lt;/li&gt;
&lt;li&gt;celery&lt;/li&gt;
&lt;li&gt;lentils&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Boil some water.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Dump everything in the pot and follow
this algorithm:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; find wooden spoon
 uncover pot
 stir
 cover pot
 balance wooden spoon precariously on pot handle
 wait 10 minutes
 goto first step (or shut off burner when done)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Do not bump wooden spoon or it will fall.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Notice again how text always lines up on 4-space indents (including
that last line which continues item 3 above).&lt;/p&gt;
&lt;p&gt;Here&apos;s a link to &lt;a href=&quot;http://foo.bar&quot;&gt;a website&lt;/a&gt;, to a &lt;a href=&quot;local-doc.html&quot;&gt;local
doc&lt;/a&gt;, and to a &lt;a href=&quot;#an-h2-header&quot;&gt;section heading in the current
doc&lt;/a&gt;. Here&apos;s a footnote [^1].&lt;/p&gt;
&lt;p&gt;[^1]: Footnote text goes here.&lt;/p&gt;
&lt;p&gt;Tables can look like this:&lt;/p&gt;
&lt;p&gt;size material color&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;9 leather brown
10 hemp canvas natural
11 glass transparent&lt;/p&gt;
&lt;p&gt;Table: Shoes, their sizes, and what they&apos;re made of&lt;/p&gt;
&lt;p&gt;(The above is the caption for the table.) Pandoc also supports
multi-line tables:&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;keyword text&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;red Sunsets, apples, and
other red or reddish
things.&lt;/p&gt;
&lt;p&gt;green Leaves, grass, frogs
and other things it&apos;s
not easy being.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;A horizontal rule follows.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Here&apos;s a definition list:&lt;/p&gt;
&lt;p&gt;apples
: Good for making applesauce.
oranges
: Citrus!
tomatoes
: There&apos;s no &quot;e&quot; in tomatoe.&lt;/p&gt;
&lt;p&gt;Again, text is indented 4 spaces. (Put a blank line between each
term/definition pair to spread things out more.)&lt;/p&gt;
&lt;p&gt;Here&apos;s a &quot;line block&quot;:&lt;/p&gt;
&lt;p&gt;| Line one
| Line too
| Line tree&lt;/p&gt;
&lt;p&gt;and images can be specified like so:&lt;/p&gt;
&lt;p&gt;[//]: # &quot;![example image](./demo-banner.png &quot;An exemplary image&quot;)&quot;&lt;/p&gt;
&lt;p&gt;Inline math equations go in like so: $\omega = d\phi / dt$. Display
math should get its own line and be put in in double-dollarsigns:&lt;/p&gt;
&lt;p&gt;$$I = \int \rho R^{2} dV$$&lt;/p&gt;
&lt;p&gt;$$
\begin{equation*}
\pi
=3.1415926535
;8979323846;2643383279;5028841971;6939937510;5820974944
;5923078164;0628620899;8628034825;3421170679;\ldots
\end{equation*}
$$&lt;/p&gt;
&lt;p&gt;And note that you can backslash-escape any punctuation characters
which you wish to be displayed literally, ex.: `foo`, *bar*, etc.&lt;/p&gt;
</content:encoded></item><item><title>Include Video in the Posts</title><link>https://thrinisty.github.io/posts/video/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/video/</guid><description>This post demonstrates how to include embedded video in a blog post.</description><pubDate>Tue, 01 Aug 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Just copy the embed code from YouTube or other platforms, and paste it in the markdown file.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;---
title: Include Video in the Post
published: 2023-10-19
// ...
---

&amp;lt;iframe width=&quot;100%&quot; height=&quot;468&quot; src=&quot;https://www.youtube.com/embed/5gIf0_xpFPI?si=N1WTorLKL0uwLsU_&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allowfullscreen&amp;gt;&amp;lt;/iframe&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;YouTube&lt;/h2&gt;
&lt;p&gt;&amp;lt;iframe width=&quot;100%&quot; height=&quot;468&quot; src=&quot;https://www.youtube.com/embed/5gIf0_xpFPI?si=N1WTorLKL0uwLsU_&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share&quot; allowfullscreen&amp;gt;&amp;lt;/iframe&amp;gt;&lt;/p&gt;
&lt;h2&gt;Bilibili&lt;/h2&gt;
&lt;p&gt;&amp;lt;iframe width=&quot;100%&quot; height=&quot;468&quot; src=&quot;//player.bilibili.com/player.html?bvid=BV1fK4y1s7Qf&amp;amp;p=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&amp;gt; &amp;lt;/iframe&amp;gt;&lt;/p&gt;
</content:encoded></item></channel></rss>